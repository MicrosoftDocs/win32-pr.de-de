---
description: Die benutzermodusplanung (ums) ist ein schlanker Mechanismus, mit dem Anwendungen ihre eigenen Threads planen können.
ms.assetid: f9dd92fe-6d7a-452c-893e-e6df1757e377
title: User-Mode Planung
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: f3ceea3c4d4e40d73f48414d074bcb5b4f6e911d
ms.sourcegitcommit: 831e8f3db78ab820e1710cede244553c70e50500
ms.translationtype: MT
ms.contentlocale: de-DE
ms.lasthandoff: 01/08/2021
ms.locfileid: "106367992"
---
# <a name="user-mode-scheduling"></a><span data-ttu-id="98ed8-103">User-Mode Planung</span><span class="sxs-lookup"><span data-stu-id="98ed8-103">User-Mode Scheduling</span></span>

<span data-ttu-id="98ed8-104">Die benutzermodusplanung (ums) ist ein schlanker Mechanismus, mit dem Anwendungen ihre eigenen Threads planen können.</span><span class="sxs-lookup"><span data-stu-id="98ed8-104">User-mode scheduling (UMS) is a lightweight mechanism that applications can use to schedule their own threads.</span></span> <span data-ttu-id="98ed8-105">Eine Anwendung kann im Benutzermodus zwischen den Verarbeitungsthreads wechseln, ohne den [Systemplaner](scheduling.md) einzubeziehen, und die Steuerung des Prozessors wiederherzustellen, wenn ein ums-Thread im Kernel blockiert wird.</span><span class="sxs-lookup"><span data-stu-id="98ed8-105">An application can switch between UMS threads in user mode without involving the [system scheduler](scheduling.md) and regain control of the processor if a UMS thread blocks in the kernel.</span></span> <span data-ttu-id="98ed8-106">UMS-Threads unterscheiden sich von [Fibers](fibers.md) darin, dass jeder ums-Thread über einen eigenen Thread Kontext verfügt, anstatt den Thread Kontext eines einzelnen Threads gemeinsam zu nutzen.</span><span class="sxs-lookup"><span data-stu-id="98ed8-106">UMS threads differ from [fibers](fibers.md) in that each UMS thread has its own thread context instead of sharing the thread context of a single thread.</span></span> <span data-ttu-id="98ed8-107">Durch die Möglichkeit, zwischen Threads im Benutzermodus zu wechseln, werden die ums effizienter als [Thread Pools](thread-pools.md) für die Verwaltung einer großen Anzahl von Arbeitsaufgaben mit kurzer Laufzeit, für die nur wenige Systemaufrufe erforderlich sind.</span><span class="sxs-lookup"><span data-stu-id="98ed8-107">The ability to switch between threads in user mode makes UMS more efficient than [thread pools](thread-pools.md) for managing large numbers of short-duration work items that require few system calls.</span></span>

<span data-ttu-id="98ed8-108">UMS werden für Anwendungen mit hohen Leistungsanforderungen empfohlen, die viele Threads gleichzeitig auf Multiprozessor-oder Multikernsystemen ausführen müssen.</span><span class="sxs-lookup"><span data-stu-id="98ed8-108">UMS is recommended for applications with high performance requirements that need to efficiently run many threads concurrently on multiprocessor or multicore systems.</span></span> <span data-ttu-id="98ed8-109">Um von den Vorteilen zu profitieren, muss eine Anwendung eine Scheduler-Komponente implementieren, die die UMS-Threads der Anwendung verwaltet und festlegt, wann Sie ausgeführt werden sollen.</span><span class="sxs-lookup"><span data-stu-id="98ed8-109">To take advantage of UMS, an application must implement a scheduler component that manages the application's UMS threads and determines when they should run.</span></span> <span data-ttu-id="98ed8-110">Entwickler sollten berücksichtigen, ob Ihre Anwendungs Leistungsanforderungen die Arbeit bei der Entwicklung einer solchen Komponente rechtfertigen.</span><span class="sxs-lookup"><span data-stu-id="98ed8-110">Developers should consider whether their application performance requirements justify the work involved in developing such a component.</span></span> <span data-ttu-id="98ed8-111">Anwendungen mit mittleren Leistungsanforderungen werden möglicherweise besser bedient, indem der Systemplaner die Planung Ihrer Threads ermöglicht.</span><span class="sxs-lookup"><span data-stu-id="98ed8-111">Applications with moderate performance requirements might be better served by allowing the system scheduler to schedule their threads.</span></span>

<span data-ttu-id="98ed8-112">UMS steht für 64-Bit-Anwendungen zur Verfügung, die auf 64-Bit-Versionen von Windows 7 und Windows Server 2008 R2 oder neueren 64-Bit-Versionen von Windows ausgeführt werden.</span><span class="sxs-lookup"><span data-stu-id="98ed8-112">UMS is available for 64-bit applications running on 64-bit versions of Windows 7 and Windows Server 2008 R2 or later 64-bit versions of Windows.</span></span> <span data-ttu-id="98ed8-113">Diese Funktion ist in 32-Bit-Versionen von Windows nicht verfügbar.</span><span class="sxs-lookup"><span data-stu-id="98ed8-113">This feature is not available on 32-bit versions of Windows.</span></span>

<span data-ttu-id="98ed8-114">Weitere Informationen finden Sie in den folgenden Abschnitten:</span><span class="sxs-lookup"><span data-stu-id="98ed8-114">For details, see the following sections:</span></span>

-   [<span data-ttu-id="98ed8-115">UMS-Scheduler</span><span class="sxs-lookup"><span data-stu-id="98ed8-115">UMS Scheduler</span></span>](#ums-scheduler)
-   [<span data-ttu-id="98ed8-116">UMS-Scheduler-Thread</span><span class="sxs-lookup"><span data-stu-id="98ed8-116">UMS Scheduler Thread</span></span>](#ums-scheduler-thread)
-   [<span data-ttu-id="98ed8-117">UMS-Arbeitsthreads, Thread Kontexte und Vervollständigungs Listen</span><span class="sxs-lookup"><span data-stu-id="98ed8-117">UMS Worker Threads, Thread Contexts, and Completion Lists</span></span>](#ums-worker-threads-thread-contexts-and-completion-lists)
-   [<span data-ttu-id="98ed8-118">UMS Scheduler-Einstiegspunkt Funktion</span><span class="sxs-lookup"><span data-stu-id="98ed8-118">UMS Scheduler Entry Point Function</span></span>](#ums-scheduler-entry-point-function)
-   [<span data-ttu-id="98ed8-119">UMS-Thread-Ausführung</span><span class="sxs-lookup"><span data-stu-id="98ed8-119">UMS Thread Execution</span></span>](#ums-thread-execution)
-   [<span data-ttu-id="98ed8-120">Bewährte Methoden für ums</span><span class="sxs-lookup"><span data-stu-id="98ed8-120">UMS Best Practices</span></span>](#ums-best-practices)

## <a name="ums-scheduler"></a><span data-ttu-id="98ed8-121">UMS-Scheduler</span><span class="sxs-lookup"><span data-stu-id="98ed8-121">UMS Scheduler</span></span>

<span data-ttu-id="98ed8-122">Der ums-Scheduler einer Anwendung ist für das Erstellen, verwalten und Löschen von UMS-Threads und das Ermitteln des auszuführenden UMS-Threads verantwortlich.</span><span class="sxs-lookup"><span data-stu-id="98ed8-122">An application's UMS scheduler is responsible for creating, managing, and deleting UMS threads and determining which UMS thread to run.</span></span> <span data-ttu-id="98ed8-123">Der Scheduler einer Anwendung führt die folgenden Aufgaben aus:</span><span class="sxs-lookup"><span data-stu-id="98ed8-123">An application's scheduler performs the following tasks:</span></span>

-   <span data-ttu-id="98ed8-124">Erstellt einen ums-schedulerthread für jeden Prozessor, auf dem die Anwendung ums Workerthreads ausgeführt wird.</span><span class="sxs-lookup"><span data-stu-id="98ed8-124">Creates one UMS scheduler thread for each processor on which the application will run UMS worker threads.</span></span>
-   <span data-ttu-id="98ed8-125">Erstellt ums-Arbeitsthreads, um die Arbeit der Anwendung auszuführen.</span><span class="sxs-lookup"><span data-stu-id="98ed8-125">Creates UMS worker threads to perform the work of the application.</span></span>
-   <span data-ttu-id="98ed8-126">Verwaltet eine eigene Warteschlange für Arbeitsthreads von Arbeitsthreads, die zur Ausführung bereit sind, und wählt Threads aus, die basierend auf den Planungsrichtlinien der Anwendung ausgeführt werden.</span><span class="sxs-lookup"><span data-stu-id="98ed8-126">Maintains its own ready-thread queue of worker threads that are ready to run, and selects threads to run based on the application's scheduling policies.</span></span>
-   <span data-ttu-id="98ed8-127">Erstellt und überwacht eine oder mehrere Vervollständigungs Listen, in denen das System Threads in die Warteschlange eingereiht, nachdem die Verarbeitung im Kernel abgeschlossen ist</span><span class="sxs-lookup"><span data-stu-id="98ed8-127">Creates and monitors one or more completion lists where the system queues threads after they finish processing in the kernel.</span></span> <span data-ttu-id="98ed8-128">Dies schließt neu erstellte Arbeitsthreads und Threads ein, die zuvor bei einem System aufruter blockiert wurden, die blockiert werden.</span><span class="sxs-lookup"><span data-stu-id="98ed8-128">These include newly created worker threads and threads previously blocked on a system call that become unblocked.</span></span>
-   <span data-ttu-id="98ed8-129">Stellt eine Einstiegspunkt Funktion für den Scheduler bereit, um Benachrichtigungen vom System zu verarbeiten.</span><span class="sxs-lookup"><span data-stu-id="98ed8-129">Provides a scheduler entry point function to handles notifications from the system.</span></span> <span data-ttu-id="98ed8-130">Das System ruft die Einstiegspunkt Funktion auf, wenn ein Scheduler-Thread erstellt wird, wenn ein Arbeits Thread bei einem Systemaufruf blockiert oder wenn ein Arbeits Thread die Steuerung explizit übergibt.</span><span class="sxs-lookup"><span data-stu-id="98ed8-130">The system calls the entry point function when a scheduler thread is created, when a worker thread blocks on a system call, or when a worker thread explicitly yields control.</span></span>
-   <span data-ttu-id="98ed8-131">Führt Cleanuptasks für Arbeitsthreads aus, deren Ausführung abgeschlossen ist.</span><span class="sxs-lookup"><span data-stu-id="98ed8-131">Performs cleanup tasks for worker threads that have finished running.</span></span>
-   <span data-ttu-id="98ed8-132">Führt ein ordnungsgemäßes Herunterfahren des Schedulers aus, wenn er von der Anwendung angefordert wird.</span><span class="sxs-lookup"><span data-stu-id="98ed8-132">Performs an orderly shutdown of the scheduler when requested by the application.</span></span>

## <a name="ums-scheduler-thread"></a><span data-ttu-id="98ed8-133">UMS-Scheduler-Thread</span><span class="sxs-lookup"><span data-stu-id="98ed8-133">UMS Scheduler Thread</span></span>

<span data-ttu-id="98ed8-134">Ein ums-Scheduler-Thread ist ein gewöhnlicher Thread, der sich durch Aufrufen der Funktion " [**enterumsschedulingmode**](/windows/desktop/api/WinBase/nf-winbase-enterumsschedulingmode) " in "ums" konvertiert hat.</span><span class="sxs-lookup"><span data-stu-id="98ed8-134">A UMS scheduler thread is an ordinary thread that has converted itself to UMS by calling the [**EnterUmsSchedulingMode**](/windows/desktop/api/WinBase/nf-winbase-enterumsschedulingmode) function.</span></span> <span data-ttu-id="98ed8-135">Der Systemplaner bestimmt, wann der ums-Scheduler-Thread basierend auf seiner Priorität in Bezug auf andere bereite Threads ausgeführt wird.</span><span class="sxs-lookup"><span data-stu-id="98ed8-135">The system scheduler determines when the UMS scheduler thread runs based on its priority relative to other ready threads.</span></span> <span data-ttu-id="98ed8-136">Der Prozessor, auf dem der Scheduler-Thread ausgeführt wird, wird durch die Thread Affinität beeinflusst, wie bei nicht-UMS-Threads.</span><span class="sxs-lookup"><span data-stu-id="98ed8-136">The processor on which the scheduler thread runs is influenced by the thread's affinity, same as for non-UMS threads.</span></span>

<span data-ttu-id="98ed8-137">Der Aufrufer von [**enterumsschedulingmode**](/windows/desktop/api/WinBase/nf-winbase-enterumsschedulingmode) gibt eine Vervollständigungsliste und eine [*umsschedulerproc*](/windows/desktop/api/WinNT/nc-winnt-rtl_ums_scheduler_entry_point) -Einstiegspunkt Funktion an, die dem ums-planerthread zugeordnet werden soll.</span><span class="sxs-lookup"><span data-stu-id="98ed8-137">The caller of [**EnterUmsSchedulingMode**](/windows/desktop/api/WinBase/nf-winbase-enterumsschedulingmode) specifies a completion list and a [*UmsSchedulerProc*](/windows/desktop/api/WinNT/nc-winnt-rtl_ums_scheduler_entry_point) entry point function to associate with the UMS scheduler thread.</span></span> <span data-ttu-id="98ed8-138">Das System ruft die angegebene Einstiegspunkt Funktion auf, wenn die Umstellung des aufrufenden Threads in ums abgeschlossen ist.</span><span class="sxs-lookup"><span data-stu-id="98ed8-138">The system calls the specified entry point function when it is finished converting the calling thread to UMS.</span></span> <span data-ttu-id="98ed8-139">Die Einstiegspunkt Funktion des Schedulers ist dafür verantwortlich, die geeignete nächste Aktion für den angegebenen Thread festzulegen.</span><span class="sxs-lookup"><span data-stu-id="98ed8-139">The scheduler entry point function is responsible for determining the appropriate next action for the specified thread.</span></span> <span data-ttu-id="98ed8-140">Weitere Informationen finden Sie weiter unten in diesem Thema unter " [ums Scheduler-Einstiegspunkt Funktion](#ums-scheduler-entry-point-function) ".</span><span class="sxs-lookup"><span data-stu-id="98ed8-140">For more information, see [UMS Scheduler Entry Point Function](#ums-scheduler-entry-point-function) later in this topic.</span></span>

<span data-ttu-id="98ed8-141">Eine Anwendung kann einen ums-Scheduler-Thread für jeden Prozessor erstellen, der zum Ausführen von UMS-Threads verwendet wird.</span><span class="sxs-lookup"><span data-stu-id="98ed8-141">An application might create one UMS scheduler thread for each processor that will be used to run UMS threads.</span></span> <span data-ttu-id="98ed8-142">Die Anwendung kann auch die Affinität jedes ums-planerthreads für einen bestimmten logischen Prozessor festlegen, der in der Regel nicht verknüpfte Threads von der Ausführung auf diesem Prozessor ausschließt und Sie für diesen Zeit Planungs Thread reserviert.</span><span class="sxs-lookup"><span data-stu-id="98ed8-142">The application might also set the affinity of each UMS scheduler thread for a specific logical processor, which tends to exclude unrelated threads from running on that processor, effectively reserving it for that scheduler thread.</span></span> <span data-ttu-id="98ed8-143">Beachten Sie, dass das Festlegen der Thread Affinität auf diese Weise die Gesamtsystemleistung beeinträchtigt, indem andere Prozesse, die möglicherweise auf dem System ausgeführt werden, verhungert werden.</span><span class="sxs-lookup"><span data-stu-id="98ed8-143">Be aware that setting thread affinity in this way can affect overall system performance by starving other processes that may be running on the system.</span></span> <span data-ttu-id="98ed8-144">Weitere Informationen zur Thread Affinität finden Sie unter [mehrere Prozessoren](multiple-processors.md).</span><span class="sxs-lookup"><span data-stu-id="98ed8-144">For more information about thread affinity, see [Multiple Processors](multiple-processors.md).</span></span>

## <a name="ums-worker-threads-thread-contexts-and-completion-lists"></a><span data-ttu-id="98ed8-145">UMS-Arbeitsthreads, Thread Kontexte und Vervollständigungs Listen</span><span class="sxs-lookup"><span data-stu-id="98ed8-145">UMS Worker Threads, Thread Contexts, and Completion Lists</span></span>

<span data-ttu-id="98ed8-146">Ein ums-Arbeits Thread wird erstellt, indem [**createremotethreadex**](/windows/win32/api/processthreadsapi/nf-processthreadsapi-createremotethreadex) mit dem "proc \_ Thread \_ Attribute \_ ums" \_ -Thread Attribut aufgerufen und ein ums-Thread Kontext und eine Vervollständigungsliste angegeben werden.</span><span class="sxs-lookup"><span data-stu-id="98ed8-146">A UMS worker thread is created by calling [**CreateRemoteThreadEx**](/windows/win32/api/processthreadsapi/nf-processthreadsapi-createremotethreadex) with the PROC\_THREAD\_ATTRIBUTE\_UMS\_THREAD attribute and specifying a UMS thread context and a completion list.</span></span>

<span data-ttu-id="98ed8-147">Ein ums-Thread Kontext stellt den ums-Thread Zustand eines Arbeitsthreads dar und wird verwendet, um den Arbeits Thread in ums-Funktionsaufrufen zu identifizieren.</span><span class="sxs-lookup"><span data-stu-id="98ed8-147">A UMS thread context represents the UMS thread state of a worker thread and is used to identify the worker thread in UMS function calls.</span></span> <span data-ttu-id="98ed8-148">Sie wird erstellt, indem [**createumsthlecontext**](/windows/desktop/api/WinBase/nf-winbase-createumsthreadcontext)aufgerufen wird.</span><span class="sxs-lookup"><span data-stu-id="98ed8-148">It is created by calling [**CreateUmsThreadContext**](/windows/desktop/api/WinBase/nf-winbase-createumsthreadcontext).</span></span>

<span data-ttu-id="98ed8-149">Eine Vervollständigungsliste wird durch Aufrufen der [**createumscompletionlist**](/windows/desktop/api/WinBase/nf-winbase-createumscompletionlist) -Funktion erstellt.</span><span class="sxs-lookup"><span data-stu-id="98ed8-149">A completion list is created by calling the [**CreateUmsCompletionList**](/windows/desktop/api/WinBase/nf-winbase-createumscompletionlist) function.</span></span> <span data-ttu-id="98ed8-150">Eine Vervollständigungsliste empfängt ums-Worker-Threads, deren Ausführung im Kernel abgeschlossen ist und die für die Ausführung im Benutzermodus bereit sind.</span><span class="sxs-lookup"><span data-stu-id="98ed8-150">A completion list receives UMS worker threads that have completed execution in the kernel and are ready to run in user mode.</span></span> <span data-ttu-id="98ed8-151">Nur das System kann Arbeitsthreads in eine Vervollständigungsliste in eine Warteschlange stellen.</span><span class="sxs-lookup"><span data-stu-id="98ed8-151">Only the system can queue worker threads to a completion list.</span></span> <span data-ttu-id="98ed8-152">Neue ums-Arbeitsthreads werden automatisch in die Warteschlange eingereiht, wenn die Threads erstellt wurden.</span><span class="sxs-lookup"><span data-stu-id="98ed8-152">New UMS worker threads are automatically queued to the completion list specified when the threads were created.</span></span> <span data-ttu-id="98ed8-153">Zuvor blockierte Arbeitsthreads werden auch in der Vervollständigungsliste in die Warteschlange eingereiht, wenn Sie nicht mehr blockiert werden.</span><span class="sxs-lookup"><span data-stu-id="98ed8-153">Previously blocked worker threads are also queued to the completion list when they are no longer blocked.</span></span>

<span data-ttu-id="98ed8-154">Jedem ums-schedulerthread ist eine einzelne Vervollständigungsliste zugeordnet.</span><span class="sxs-lookup"><span data-stu-id="98ed8-154">Each UMS scheduler thread is associated with a single completion list.</span></span> <span data-ttu-id="98ed8-155">Allerdings kann die gleiche Vervollständigungsliste mit einer beliebigen Anzahl von ums-planerthreads verknüpft werden, und ein Scheduler-Thread kann die ums-Kontexte aus jeder Vervollständigungsliste abrufen, für die er einen Zeiger hat.</span><span class="sxs-lookup"><span data-stu-id="98ed8-155">However, the same completion list can be associated with any number of UMS scheduler threads, and a scheduler thread can retrieve UMS contexts from any completion list for which it has a pointer.</span></span>

<span data-ttu-id="98ed8-156">Jede Vervollständigungsliste verfügt über ein zugeordnetes Ereignis, das vom System signalisiert wird, wenn ein oder mehrere Arbeitsthreads in eine leere Liste eingereiht werden.</span><span class="sxs-lookup"><span data-stu-id="98ed8-156">Each completion list has an associated event that is signaled by the system when it queues one or more worker threads to an empty list.</span></span> <span data-ttu-id="98ed8-157">Die [**getumscompletionlistevent**](/windows/desktop/api/WinBase/nf-winbase-getumscompletionlistevent) -Funktion Ruft ein Handle für das-Ereignis für eine angegebene Vervollständigungsliste ab.</span><span class="sxs-lookup"><span data-stu-id="98ed8-157">The [**GetUmsCompletionListEvent**](/windows/desktop/api/WinBase/nf-winbase-getumscompletionlistevent) function retrieves a handle to the event for a specified completion list.</span></span> <span data-ttu-id="98ed8-158">Eine Anwendung kann mit anderen Ereignissen, die für die Anwendung sinnvoll sind, auf mehr als ein Vervollständigungs Listen Ereignis warten.</span><span class="sxs-lookup"><span data-stu-id="98ed8-158">An application can wait on more than one completion list event along with other events that make sense for the application.</span></span>

## <a name="ums-scheduler-entry-point-function"></a><span data-ttu-id="98ed8-159">UMS Scheduler-Einstiegspunkt Funktion</span><span class="sxs-lookup"><span data-stu-id="98ed8-159">UMS Scheduler Entry Point Function</span></span>

<span data-ttu-id="98ed8-160">Die Einstiegspunkt Funktion einer Anwendung ist als " [*umsschedulerproc*](/windows/desktop/api/WinNT/nc-winnt-rtl_ums_scheduler_entry_point) "-Funktion implementiert.</span><span class="sxs-lookup"><span data-stu-id="98ed8-160">An application's scheduler entry point function is implemented as a [*UmsSchedulerProc*](/windows/desktop/api/WinNT/nc-winnt-rtl_ums_scheduler_entry_point) function.</span></span> <span data-ttu-id="98ed8-161">Das System ruft die Scheduler-Einstiegspunkt Funktion der Anwendung zu den folgenden Zeiten auf:</span><span class="sxs-lookup"><span data-stu-id="98ed8-161">The system calls the application's scheduler entry point function at the following times:</span></span>

-   <span data-ttu-id="98ed8-162">Wenn ein nicht-ums-Thread durch Aufrufen von " [**enterumsschedulingmode**](/windows/desktop/api/WinBase/nf-winbase-enterumsschedulingmode)" in einen ums-planerthread konvertiert wird.</span><span class="sxs-lookup"><span data-stu-id="98ed8-162">When a non-UMS thread is converted to a UMS scheduler thread by calling [**EnterUmsSchedulingMode**](/windows/desktop/api/WinBase/nf-winbase-enterumsschedulingmode).</span></span>
-   <span data-ttu-id="98ed8-163">Wenn ein ums-Workerthread [**umsthumyield**](/windows/desktop/api/WinBase/nf-winbase-umsthreadyield)aufruft.</span><span class="sxs-lookup"><span data-stu-id="98ed8-163">When a UMS worker thread calls [**UmsThreadYield**](/windows/desktop/api/WinBase/nf-winbase-umsthreadyield).</span></span>
-   <span data-ttu-id="98ed8-164">Wenn ein ums-Arbeitsthreads in einem Systemdienst blockiert, z. b. ein System-oder Seiten Fehler.</span><span class="sxs-lookup"><span data-stu-id="98ed8-164">When a UMS worker thread blocks on a system service such as a system call or a page fault.</span></span>

<span data-ttu-id="98ed8-165">Der *reason* -Parameter der [*umsschedulerproc*](/windows/desktop/api/WinNT/nc-winnt-rtl_ums_scheduler_entry_point) -Funktion gibt den Grund an, warum die Einstiegspunkt Funktion aufgerufen wurde.</span><span class="sxs-lookup"><span data-stu-id="98ed8-165">The *Reason* parameter of the [*UmsSchedulerProc*](/windows/desktop/api/WinNT/nc-winnt-rtl_ums_scheduler_entry_point) function specifies the reason that the entry point function was called.</span></span> <span data-ttu-id="98ed8-166">Wenn die Einstiegspunkt Funktion aufgerufen wurde, weil ein neuer ums-Scheduler-Thread erstellt wurde, enthält der *schedulerparam* -Parameterdaten, die vom Aufrufer von [**enterumsschedulingmode**](/windows/desktop/api/WinBase/nf-winbase-enterumsschedulingmode)angegeben werden.</span><span class="sxs-lookup"><span data-stu-id="98ed8-166">If the entry point function was called because a new UMS scheduler thread was created, the *SchedulerParam* parameter contains data specified by the caller of [**EnterUmsSchedulingMode**](/windows/desktop/api/WinBase/nf-winbase-enterumsschedulingmode).</span></span> <span data-ttu-id="98ed8-167">Wenn die Einstiegspunkt Funktion aufgerufen wurde, weil ein ums-Arbeits Thread zurückgegeben wurde, enthält der *schedulerparam* -Parameterdaten, die vom Aufrufer von [**umsthlesyield**](/windows/desktop/api/WinBase/nf-winbase-umsthreadyield)angegeben werden.</span><span class="sxs-lookup"><span data-stu-id="98ed8-167">If the entry point function was called because a UMS worker thread yielded, the *SchedulerParam* parameter contains data specified by the caller of [**UmsThreadYield**](/windows/desktop/api/WinBase/nf-winbase-umsthreadyield).</span></span> <span data-ttu-id="98ed8-168">Wenn die Einstiegspunkt Funktion aufgerufen wurde, weil ein ums-Arbeitsthreads im Kernel blockiert wurde, ist der *schedulerparam* -Parameter NULL.</span><span class="sxs-lookup"><span data-stu-id="98ed8-168">If the entry point function was called because a UMS worker thread blocked in the kernel, the *SchedulerParam* parameter is NULL.</span></span>

<span data-ttu-id="98ed8-169">Die Einstiegspunkt Funktion des Schedulers ist dafür verantwortlich, die geeignete nächste Aktion für den angegebenen Thread festzulegen.</span><span class="sxs-lookup"><span data-stu-id="98ed8-169">The scheduler entry point function is responsible for determining the appropriate next action for the specified thread.</span></span> <span data-ttu-id="98ed8-170">Wenn z. b. ein Arbeits Thread blockiert ist, kann die Scheduler-Einstiegspunkt Funktion den nächsten verfügbaren Arbeits Thread ausführen.</span><span class="sxs-lookup"><span data-stu-id="98ed8-170">For example, if a worker thread is blocked, the scheduler entry point function might run the next available ready UMS worker thread.</span></span>

<span data-ttu-id="98ed8-171">Wenn die Scheduler-Einstiegspunkt Funktion aufgerufen wird, sollte der Scheduler der Anwendung versuchen, alle Elemente in der zugehörigen Vervollständigungsliste abzurufen, indem die Funktion [**dequeueumscompletionlistitems**](/windows/desktop/api/WinBase/nf-winbase-dequeueumscompletionlistitems) aufgerufen wird.</span><span class="sxs-lookup"><span data-stu-id="98ed8-171">When the scheduler entry point function is called, the application's scheduler should attempt to retrieve all of the items in its associated completion list by calling the [**DequeueUmsCompletionListItems**](/windows/desktop/api/WinBase/nf-winbase-dequeueumscompletionlistitems) function.</span></span> <span data-ttu-id="98ed8-172">Diese Funktion Ruft eine Liste der ums-Thread Kontexte ab, die die Verarbeitung im Kernel abgeschlossen haben und zur Laufzeit im Benutzermodus bereit sind.</span><span class="sxs-lookup"><span data-stu-id="98ed8-172">This function retrieves a list of UMS thread contexts that have finished processing in the kernel and are ready to run in user mode.</span></span> <span data-ttu-id="98ed8-173">Der Scheduler der Anwendung sollte keine UMS-Threads direkt aus dieser Liste ausführen, da dies zu unvorhersehbarem Verhalten in der Anwendung führen kann.</span><span class="sxs-lookup"><span data-stu-id="98ed8-173">The application's scheduler should not run UMS threads directly from this list because this can cause unpredictable behavior in the application.</span></span> <span data-ttu-id="98ed8-174">Stattdessen sollte der Planer alle ums-Thread Kontexte abrufen, indem er die [**getnextumslistitem**](/windows/desktop/api/WinBase/nf-winbase-getnextumslistitem) -Funktion für jeden Kontext einmal aufrufen, die ums-Thread Kontexte in die bereite Thread Warteschlange des Planers einfügt und nur UMS-Threads aus der Warteschlange für den bereiten Thread ausführt.</span><span class="sxs-lookup"><span data-stu-id="98ed8-174">Instead, the scheduler should retrieve all UMS thread contexts by calling the [**GetNextUmsListItem**](/windows/desktop/api/WinBase/nf-winbase-getnextumslistitem) function once for each context, insert the UMS thread contexts in the scheduler’s ready thread queue, and only then run UMS threads from the ready thread queue.</span></span>

<span data-ttu-id="98ed8-175">Wenn der Planer nicht auf mehrere Ereignisse warten muss, sollte er [**dequeueumscompletionlistitems**](/windows/desktop/api/WinBase/nf-winbase-dequeueumscompletionlistitems) mit einem Timeout Parameter ungleich NULL aufrufen, damit die Funktion vor der Rückgabe auf das Abschluss Listen Ereignis wartet.</span><span class="sxs-lookup"><span data-stu-id="98ed8-175">If the scheduler does not need to wait on multiple events, it should call [**DequeueUmsCompletionListItems**](/windows/desktop/api/WinBase/nf-winbase-dequeueumscompletionlistitems) with a nonzero timeout parameter so the function waits on the completion list event before returning.</span></span> <span data-ttu-id="98ed8-176">Wenn der Scheduler auf mehrere Ereignisse der Vervollständigungsliste warten muss, sollte er **dequeueumscompletionlistitems** mit einem Timeout Parameter von 0 aufrufen, sodass die Funktion sofort zurückgibt, auch wenn die Vervollständigungsliste leer ist.</span><span class="sxs-lookup"><span data-stu-id="98ed8-176">If the scheduler does need to wait on multiple completion list events, it should call **DequeueUmsCompletionListItems** with a timeout parameter of zero so the function returns immediately, even if the completion list is empty.</span></span> <span data-ttu-id="98ed8-177">In diesem Fall kann der Planer explizit auf Vervollständigungs Listenereignisse warten, z. b. mit [**WaitForMultipleObjects**](/windows/win32/api/synchapi/nf-synchapi-waitformultipleobjects).</span><span class="sxs-lookup"><span data-stu-id="98ed8-177">In this case, the scheduler can wait explicitly on completion list events, for example, by using [**WaitForMultipleObjects**](/windows/win32/api/synchapi/nf-synchapi-waitformultipleobjects).</span></span>

## <a name="ums-thread-execution"></a><span data-ttu-id="98ed8-178">UMS-Thread-Ausführung</span><span class="sxs-lookup"><span data-stu-id="98ed8-178">UMS Thread Execution</span></span>

<span data-ttu-id="98ed8-179">Ein neu erstellter ums-Arbeits Thread wird in die angegebene Vervollständigungsliste eingereiht und wird erst ausgeführt, wenn der es-Zeitplaner der Anwendung die Ausführung auswählt.</span><span class="sxs-lookup"><span data-stu-id="98ed8-179">A newly created UMS worker thread is queued to the specified completion list and does not begin running until the application's UMS scheduler selects it to run.</span></span> <span data-ttu-id="98ed8-180">Dies unterscheidet sich von nicht-UMS-Threads, die der Systemplaner automatisch plant, auszuführen, es sei denn, der Aufrufer erstellt explizit den Thread angehalten.</span><span class="sxs-lookup"><span data-stu-id="98ed8-180">This differs from non-UMS threads, which the system scheduler automatically schedules to run unless the caller explicitly creates the thread suspended.</span></span>

<span data-ttu-id="98ed8-181">Der Scheduler führt einen Arbeits Thread durch Aufrufen von [**executeessthread**](/windows/desktop/api/WinBase/nf-winbase-executeumsthread) mit dem ums-Kontext des Arbeitsthreads aus.</span><span class="sxs-lookup"><span data-stu-id="98ed8-181">The scheduler runs a worker thread by calling [**ExecuteUmsThread**](/windows/desktop/api/WinBase/nf-winbase-executeumsthread) with the worker thread's UMS context.</span></span> <span data-ttu-id="98ed8-182">Ein ums-Arbeits Thread wird ausgeführt, bis er durch Aufrufen der [**umsthleyield**](/windows/desktop/api/WinBase/nf-winbase-umsthreadyield) -Funktion oder-Blöcke ausgeführt wird.</span><span class="sxs-lookup"><span data-stu-id="98ed8-182">A UMS worker thread runs until it yields by calling the [**UmsThreadYield**](/windows/desktop/api/WinBase/nf-winbase-umsthreadyield) function, blocks, or terminates.</span></span>

## <a name="ums-best-practices"></a><span data-ttu-id="98ed8-183">Bewährte Methoden für ums</span><span class="sxs-lookup"><span data-stu-id="98ed8-183">UMS Best Practices</span></span>

<span data-ttu-id="98ed8-184">Anwendungen, die ums implementieren, sollten die folgenden bewährten Methoden befolgen:</span><span class="sxs-lookup"><span data-stu-id="98ed8-184">Applications that implement UMS should follow these best practices:</span></span>

-   <span data-ttu-id="98ed8-185">Die zugrunde liegenden Strukturen für ums-Thread Kontexte werden vom System verwaltet und sollten nicht direkt geändert werden.</span><span class="sxs-lookup"><span data-stu-id="98ed8-185">The underlying structures for UMS thread contexts are managed by the system and should not be modified directly.</span></span> <span data-ttu-id="98ed8-186">Verwenden Sie stattdessen [**queryumsthinfoinformation**](/windows/desktop/api/WinBase/nf-winbase-queryumsthreadinformation) und [**setumsthinfoinformation**](/windows/desktop/api/WinBase/nf-winbase-setumsthreadinformation) , um Informationen über einen ums-Arbeitsthreads abzurufen und festzulegen.</span><span class="sxs-lookup"><span data-stu-id="98ed8-186">Instead, use [**QueryUmsThreadInformation**](/windows/desktop/api/WinBase/nf-winbase-queryumsthreadinformation) and [**SetUmsThreadInformation**](/windows/desktop/api/WinBase/nf-winbase-setumsthreadinformation) to retrieve and set information about a UMS worker thread.</span></span>
-   <span data-ttu-id="98ed8-187">Um Deadlocks zu verhindern, sollte der ums-Scheduler-Thread keine Sperren mit ums-Arbeitsthreads freigeben.</span><span class="sxs-lookup"><span data-stu-id="98ed8-187">To help prevent deadlocks, the UMS scheduler thread should not share locks with UMS worker threads.</span></span> <span data-ttu-id="98ed8-188">Dies schließt sowohl von der Anwendung erstellte Sperren als auch System Sperren ein, die indirekt durch Vorgänge wie das zuordnen aus dem Heap oder das Laden von DLLs erworben werden.</span><span class="sxs-lookup"><span data-stu-id="98ed8-188">This includes both application-created locks and system locks that are acquired indirectly by operations such as allocating from the heap or loading DLLs.</span></span> <span data-ttu-id="98ed8-189">Nehmen Sie beispielsweise an, der Planer führt einen ums-Workerthread aus, der eine DLL lädt.</span><span class="sxs-lookup"><span data-stu-id="98ed8-189">For example, suppose the scheduler runs a UMS worker thread that loads a DLL.</span></span> <span data-ttu-id="98ed8-190">Der Arbeits Thread erhält die Loadersperre und-Blöcke.</span><span class="sxs-lookup"><span data-stu-id="98ed8-190">The worker thread acquires the loader lock and blocks.</span></span> <span data-ttu-id="98ed8-191">Das System ruft die Scheduler-Einstiegspunkt Funktion auf, die dann eine DLL lädt.</span><span class="sxs-lookup"><span data-stu-id="98ed8-191">The system calls the scheduler entry point function, which then loads a DLL.</span></span> <span data-ttu-id="98ed8-192">Dies führt zu einem Deadlock, da die Loadersperre bereits aufrechterhalten wurde und nicht freigegeben werden kann, bis der erste Thread die Blockierung aufgehoben.</span><span class="sxs-lookup"><span data-stu-id="98ed8-192">This causes a deadlock, because the loader lock is already held and cannot be released until the first thread unblocks.</span></span> <span data-ttu-id="98ed8-193">Um dieses Problem zu vermeiden, delegieren Sie die Arbeit, die möglicherweise Sperren mit ums-Arbeitsthreads gemeinsam verwendet, an einen dedizierten ums-Arbeits Thread oder einen nicht-ums-Thread.</span><span class="sxs-lookup"><span data-stu-id="98ed8-193">To help avoid this problem, delegate work that might share locks with UMS worker threads to a dedicated UMS worker thread or a non-UMS thread.</span></span>
-   <span data-ttu-id="98ed8-194">UMS ist am effizientesten, wenn die meisten Verarbeitungsvorgänge im Benutzermodus ausgeführt werden.</span><span class="sxs-lookup"><span data-stu-id="98ed8-194">UMS is most efficient when most processing is done in user mode.</span></span> <span data-ttu-id="98ed8-195">Vermeiden Sie, wenn möglich, Systemaufrufe in ums-Arbeitsthreads.</span><span class="sxs-lookup"><span data-stu-id="98ed8-195">Whenever possible, avoid making system calls in UMS worker threads.</span></span>
-   <span data-ttu-id="98ed8-196">UMS-Arbeitsthreads sollten nicht davon ausgehen, dass der Systemplaner verwendet wird.</span><span class="sxs-lookup"><span data-stu-id="98ed8-196">UMS worker threads should not assume the system scheduler is being used.</span></span> <span data-ttu-id="98ed8-197">Diese Annahme kann feine Auswirkungen haben. Wenn ein Thread im unbekannten Code z. b. eine Thread Priorität oder-Affinität festlegt, kann der ums-Scheduler ihn trotzdem überschreiben.</span><span class="sxs-lookup"><span data-stu-id="98ed8-197">This assumption can have subtle effects; for example, if a thread in the unknown code sets a thread priority or affinity, the UMS scheduler might still override it.</span></span> <span data-ttu-id="98ed8-198">Code, der annimmt, dass der Systemplaner verwendet wird, verhält sich möglicherweise nicht erwartungsgemäß und kann beim Aufrufen durch einen ums-Thread unterbrechen.</span><span class="sxs-lookup"><span data-stu-id="98ed8-198">Code that assumes the system scheduler is being used may not behave as expected and may break when called by a UMS thread.</span></span>
-   <span data-ttu-id="98ed8-199">Möglicherweise muss das System den Thread Kontext eines ums-Arbeitsthreads sperren.</span><span class="sxs-lookup"><span data-stu-id="98ed8-199">The system may need to lock the thread context of a UMS worker thread.</span></span> <span data-ttu-id="98ed8-200">Beispielsweise kann ein asynchroner Prozedur Aufrufe (APC) im Kernel Modus den Kontext des UMS-Threads ändern, sodass der Thread Kontext gesperrt werden muss.</span><span class="sxs-lookup"><span data-stu-id="98ed8-200">For example, a kernel-mode asynchronous procedure call (APC) might change the context of the UMS thread, so the thread context must be locked.</span></span> <span data-ttu-id="98ed8-201">Wenn der Scheduler versucht, den ums-Thread Kontext auszuführen, während er gesperrt ist, tritt ein Fehler auf.</span><span class="sxs-lookup"><span data-stu-id="98ed8-201">If the scheduler tries to execute the UMS thread context while it is locked, the call will fail.</span></span> <span data-ttu-id="98ed8-202">Dieses Verhalten ist Entwurfs bedingt, und der Scheduler sollte so entworfen werden, dass der Zugriff auf den ums-Thread Kontext wiederholt wird.</span><span class="sxs-lookup"><span data-stu-id="98ed8-202">This behavior is by design, and the scheduler should be designed to retry access to the UMS thread context.</span></span>

 

 
