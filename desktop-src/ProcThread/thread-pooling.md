---
description: Es gibt viele Anwendungen, mit denen Threads erstellt werden, die sehr viel Zeit für den Ruhezustand aufwenden, der auf das Eintreten eines Ereignisses wartet.
ms.assetid: a5e52080-35d4-47f5-9050-90889e3bf2f8
title: Pooling von Threads
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: bcf3565401dc57b077e333043861d42b683e810c
ms.sourcegitcommit: 831e8f3db78ab820e1710cede244553c70e50500
ms.translationtype: MT
ms.contentlocale: de-DE
ms.lasthandoff: 01/07/2021
ms.locfileid: "103865048"
---
# <a name="thread-pooling"></a><span data-ttu-id="71e22-103">Pooling von Threads</span><span class="sxs-lookup"><span data-stu-id="71e22-103">Thread Pooling</span></span>

<span data-ttu-id="71e22-104">Es gibt viele Anwendungen, mit denen Threads erstellt werden, die sehr viel Zeit für den Ruhezustand aufwenden, der auf das Eintreten eines Ereignisses wartet.</span><span class="sxs-lookup"><span data-stu-id="71e22-104">There are many applications that create threads that spend a great deal of time in the sleeping state waiting for an event to occur.</span></span> <span data-ttu-id="71e22-105">Andere Threads können nur dann in den Ruhezustand versetzt werden, dass Sie regelmäßig zum Abrufen von Änderungs-oder Update Statusinformationen aktiviert werden.</span><span class="sxs-lookup"><span data-stu-id="71e22-105">Other threads may enter a sleeping state only to be awakened periodically to poll for a change or update status information.</span></span> <span data-ttu-id="71e22-106">*Thread Pooling* ermöglicht es Ihnen, Threads effizienter zu verwenden, indem Sie der Anwendung einen Pool von Arbeitsthreads bereitstellen, die vom System verwaltet werden.</span><span class="sxs-lookup"><span data-stu-id="71e22-106">*Thread pooling* enables you to use threads more efficiently by providing your application with a pool of worker threads that are managed by the system.</span></span> <span data-ttu-id="71e22-107">Mindestens ein Thread überwacht den Status aller warte Vorgänge, die in die Warteschlange des Thread Pools eingereiht wurden.</span><span class="sxs-lookup"><span data-stu-id="71e22-107">At least one thread monitors the status of all wait operations queued to the thread pool.</span></span> <span data-ttu-id="71e22-108">Wenn ein warte Vorgang abgeschlossen ist, führt ein Arbeits Thread aus dem Thread Pool die entsprechende Rückruffunktion aus.</span><span class="sxs-lookup"><span data-stu-id="71e22-108">When a wait operation has completed, a worker thread from the thread pool executes the corresponding callback function.</span></span>

<span data-ttu-id="71e22-109">In diesem Thema wird die ursprüngliche Thread Pool-API beschrieben.</span><span class="sxs-lookup"><span data-stu-id="71e22-109">This topic describes the original thread pool API.</span></span> <span data-ttu-id="71e22-110">Die in Windows Vista eingeführte Thread Pool-API ist einfacher und zuverlässiger, bietet eine bessere Leistung und bietet Entwicklern mehr Flexibilität.</span><span class="sxs-lookup"><span data-stu-id="71e22-110">The thread pool API introduced in Windows Vista is simpler, more reliable, has better performance, and provides more flexibility for developers.</span></span> <span data-ttu-id="71e22-111">Informationen zur aktuellen Thread Pool-API finden Sie unter [Thread Pools](thread-pools.md).</span><span class="sxs-lookup"><span data-stu-id="71e22-111">For information on the current thread pool API, see [Thread Pools](thread-pools.md).</span></span>

<span data-ttu-id="71e22-112">Sie können auch Arbeitselemente in die Warteschlange stellen, die nicht mit einem warte Vorgang im Thread Pool verknüpft sind.</span><span class="sxs-lookup"><span data-stu-id="71e22-112">You can also queue work items that are not related to a wait operation to the thread pool.</span></span> <span data-ttu-id="71e22-113">Um anzufordern, dass ein Arbeits Element von einem Thread im Thread Pool behandelt werden soll, müssen Sie die [**QueueUserWorkItem**](/windows/win32/api/threadpoollegacyapiset/nf-threadpoollegacyapiset-queueuserworkitem) -Funktion aufzurufen.</span><span class="sxs-lookup"><span data-stu-id="71e22-113">To request that a work item be handled by a thread in the thread pool, call the [**QueueUserWorkItem**](/windows/win32/api/threadpoollegacyapiset/nf-threadpoollegacyapiset-queueuserworkitem) function.</span></span> <span data-ttu-id="71e22-114">Diese Funktion nimmt einen Parameter für die Funktion an, die von dem aus dem Thread Pool ausgewählten Thread aufgerufen wird.</span><span class="sxs-lookup"><span data-stu-id="71e22-114">This function takes a parameter to the function that will be called by the thread selected from the thread pool.</span></span> <span data-ttu-id="71e22-115">Es gibt keine Möglichkeit, ein Arbeits Element abzubrechen, nachdem es in die Warteschlange eingereiht wurde.</span><span class="sxs-lookup"><span data-stu-id="71e22-115">There is no way to cancel a work item after it has been queued.</span></span>

<span data-ttu-id="71e22-116">[Timer-Queue-Timer](../sync/timer-queues.md) und [registrierte warte Vorgänge](../sync/wait-functions.md) verwenden ebenfalls den Thread Pool.</span><span class="sxs-lookup"><span data-stu-id="71e22-116">[Timer-queue timers](../sync/timer-queues.md) and [registered wait operations](../sync/wait-functions.md) also use the thread pool.</span></span> <span data-ttu-id="71e22-117">Die Rückruf Funktionen werden in die Warteschlange des Thread Pools eingereiht.</span><span class="sxs-lookup"><span data-stu-id="71e22-117">Their callback functions are queued to the thread pool.</span></span> <span data-ttu-id="71e22-118">Sie können auch die [**bindiocompletioncallback**](/windows/desktop/api/WinBase/nf-winbase-bindiocompletioncallback) -Funktion verwenden, um asynchrone e/a-Vorgänge zu veröffentlichen.</span><span class="sxs-lookup"><span data-stu-id="71e22-118">You can also use the [**BindIoCompletionCallback**](/windows/desktop/api/WinBase/nf-winbase-bindiocompletioncallback) function to post asynchronous I/O operations.</span></span> <span data-ttu-id="71e22-119">Nach Abschluss des e/a-Vorgängen wird der Rückruf von einem Thread Pool Thread ausgeführt.</span><span class="sxs-lookup"><span data-stu-id="71e22-119">On completion of the I/O , the callback is executed by a thread pool thread.</span></span>

<span data-ttu-id="71e22-120">Der Thread Pool wird beim ersten Aufruf von [**QueueUserWorkItem**](/windows/win32/api/threadpoollegacyapiset/nf-threadpoollegacyapiset-queueuserworkitem) oder [**bindiocompletioncallback**](/windows/desktop/api/WinBase/nf-winbase-bindiocompletioncallback)erstellt, oder wenn eine Rückruffunktion von einem Timer oder einem registrierten Warteschlangen-Timer in eine Warteschlange eingereiht wird.</span><span class="sxs-lookup"><span data-stu-id="71e22-120">The thread pool is created the first time you call [**QueueUserWorkItem**](/windows/win32/api/threadpoollegacyapiset/nf-threadpoollegacyapiset-queueuserworkitem) or [**BindIoCompletionCallback**](/windows/desktop/api/WinBase/nf-winbase-bindiocompletioncallback), or when a timer-queue timer or registered wait operation queues a callback function.</span></span> <span data-ttu-id="71e22-121">Standardmäßig beträgt die Anzahl der Threads, die im Thread Pool erstellt werden können, ungefähr 500.</span><span class="sxs-lookup"><span data-stu-id="71e22-121">By default, the number of threads that can be created in the thread pool is about 500.</span></span> <span data-ttu-id="71e22-122">Jeder Thread verwendet die Standard Stapelgröße und wird mit der Standardpriorität ausgeführt.</span><span class="sxs-lookup"><span data-stu-id="71e22-122">Each thread uses the default stack size and runs at the default priority.</span></span>

<span data-ttu-id="71e22-123">Der Thread Pool enthält zwei Arten von Arbeitsthreads: e/a-Vorgänge und nicht-e/a-Vorgänge.</span><span class="sxs-lookup"><span data-stu-id="71e22-123">There are two types of worker threads in the thread pool: I/O and non-I/O.</span></span> <span data-ttu-id="71e22-124">Ein e */a-Arbeits Thread* ist ein Thread, der in einem wartewarnbaren Wartestatus wartet.</span><span class="sxs-lookup"><span data-stu-id="71e22-124">An *I/O worker thread* is a thread that waits in an alertable wait state.</span></span> <span data-ttu-id="71e22-125">Arbeitselemente werden in e/a-Arbeitsthreads als asynchrone Prozedur Aufrufe (APC) in die Warteschlange eingereiht.</span><span class="sxs-lookup"><span data-stu-id="71e22-125">Work items are queued to I/O worker threads as asynchronous procedure calls (APC).</span></span> <span data-ttu-id="71e22-126">Sie sollten eine Arbeitsaufgabe in die Warteschlange eines e/a-Arbeits Thread einreihen, wenn Sie in einem Thread ausgeführt werden soll, der auf einen Warn baren Zustand wartet.</span><span class="sxs-lookup"><span data-stu-id="71e22-126">You should queue a work item to an I/O worker thread if it should be executed in a thread that waits in an alertable state.</span></span>

<span data-ttu-id="71e22-127">Ein *nicht-e/a-Arbeits Thread* wartet auf e/a-Abschlussports.</span><span class="sxs-lookup"><span data-stu-id="71e22-127">A *non-I/O worker thread* waits on I/O completion ports.</span></span> <span data-ttu-id="71e22-128">Die Verwendung von nicht-e/a-Arbeitsthreads ist effizienter als die Verwendung von e/a-Arbeitsthreads.</span><span class="sxs-lookup"><span data-stu-id="71e22-128">Using non-I/O worker threads is more efficient than using I/O worker threads.</span></span> <span data-ttu-id="71e22-129">Daher sollten Sie, wenn möglich, nicht-e/a-Arbeitsthreads verwenden.</span><span class="sxs-lookup"><span data-stu-id="71e22-129">Therefore, you should use non-I/O worker threads whenever possible.</span></span> <span data-ttu-id="71e22-130">Sowohl e/a-als auch nicht-e/a-Arbeitsthreads werden nicht beendet, wenn ausstehende asynchrone e/a-Anforderungen vorliegen.</span><span class="sxs-lookup"><span data-stu-id="71e22-130">Both I/O and non-I/O worker threads do not exit if there are pending asynchronous I/O requests.</span></span> <span data-ttu-id="71e22-131">Beide Arten von Threads können von Arbeits Elementen verwendet werden, die asynchrone e/a-Abschluss Anforderungen initiieren.</span><span class="sxs-lookup"><span data-stu-id="71e22-131">Both types of threads can be used by work items that initiate asynchronous I/O completion requests.</span></span> <span data-ttu-id="71e22-132">Vermeiden Sie jedoch das Veröffentlichen von asynchronen e/a-Abschluss Anforderungen in nicht-e/a-Arbeitsthreads, wenn die Ausführung lange dauern könnte.</span><span class="sxs-lookup"><span data-stu-id="71e22-132">However, avoid posting asynchronous I/O completion requests in non-I/O worker threads if they could take a long time to complete.</span></span>

<span data-ttu-id="71e22-133">Um das Thread Pooling verwenden zu können, müssen die Arbeitselemente und alle Funktionen, die Sie aufzurufen, Thread Pool sicher sein.</span><span class="sxs-lookup"><span data-stu-id="71e22-133">To use thread pooling, the work items and all the functions they call must be thread-pool safe.</span></span> <span data-ttu-id="71e22-134">Eine sichere Funktion geht davon aus, dass es sich bei dem ausgeführten Thread um einen dedizierten oder persistenten Thread handelt.</span><span class="sxs-lookup"><span data-stu-id="71e22-134">A safe function does not assume that the thread executing it is a dedicated or persistent thread.</span></span> <span data-ttu-id="71e22-135">Im Allgemeinen sollten Sie die Verwendung von [Thread lokalem Speicher](thread-local-storage.md) oder das Ausführen eines asynchronen Aufrufes vermeiden, der einen persistenten Thread benötigt, z. b. die [**RegNotifyChangeKeyValue**](/windows/win32/api/winreg/nf-winreg-regnotifychangekeyvalue) -Funktion.</span><span class="sxs-lookup"><span data-stu-id="71e22-135">In general, you should avoid using [thread local storage](thread-local-storage.md) or making an asynchronous call that requires a persistent thread, such as the [**RegNotifyChangeKeyValue**](/windows/win32/api/winreg/nf-winreg-regnotifychangekeyvalue) function.</span></span> <span data-ttu-id="71e22-136">Diese Funktionen können jedoch in einem dedizierten (von der Anwendung erstellten) Thread oder in eine Warteschlange für einen persistenten Arbeits Thread (mithilfe von [**QueueUserWorkItem**](/windows/win32/api/threadpoollegacyapiset/nf-threadpoollegacyapiset-queueuserworkitem) mit der WT \_ executeinpersistentthread-Option) aufgerufen werden.</span><span class="sxs-lookup"><span data-stu-id="71e22-136">However, such functions can be called on a dedicated thread (created by the application) or queued to a persistent worker thread (using [**QueueUserWorkItem**](/windows/win32/api/threadpoollegacyapiset/nf-threadpoollegacyapiset-queueuserworkitem) with the WT\_EXECUTEINPERSISTENTTHREAD option).</span></span>

## <a name="related-topics"></a><span data-ttu-id="71e22-137">Zugehörige Themen</span><span class="sxs-lookup"><span data-stu-id="71e22-137">Related topics</span></span>

<dl> <dt>

[<span data-ttu-id="71e22-138">Warn Bare e/a</span><span class="sxs-lookup"><span data-stu-id="71e22-138">Alertable I/O</span></span>](../fileio/alertable-i-o.md)
</dt> <dt>

[<span data-ttu-id="71e22-139">Asynchrone Prozedur Aufrufe</span><span class="sxs-lookup"><span data-stu-id="71e22-139">Asynchronous Procedure Calls</span></span>](../sync/asynchronous-procedure-calls.md)
</dt> <dt>

[<span data-ttu-id="71e22-140">E/a-Abschlussports</span><span class="sxs-lookup"><span data-stu-id="71e22-140">I/O Completion Ports</span></span>](../fileio/i-o-completion-ports.md)
</dt> <dt>

[<span data-ttu-id="71e22-141">Thread Pools</span><span class="sxs-lookup"><span data-stu-id="71e22-141">Thread Pools</span></span>](thread-pools.md)
</dt> </dl>

 

 
