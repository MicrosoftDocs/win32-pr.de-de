---
description: Ein Thread Pool ist eine Sammlung von Arbeitsthreads, die im Auftrag der Anwendung asynchrone Rückrufe effizient ausführen.
ms.assetid: abe0798a-0b60-4bdb-a61e-45393f1e958d
title: Threadpools
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: 690aa3eb6fd3ce7a99d71e0f57118529ef79113f
ms.sourcegitcommit: 831e8f3db78ab820e1710cede244553c70e50500
ms.translationtype: MT
ms.contentlocale: de-DE
ms.lasthandoff: 01/08/2021
ms.locfileid: "106356212"
---
# <a name="thread-pools"></a><span data-ttu-id="a7255-103">Threadpools</span><span class="sxs-lookup"><span data-stu-id="a7255-103">Thread Pools</span></span>

<span data-ttu-id="a7255-104">Ein *Thread Pool* ist eine Sammlung von Arbeitsthreads, die im Auftrag der Anwendung asynchrone Rückrufe effizient ausführen.</span><span class="sxs-lookup"><span data-stu-id="a7255-104">A *thread pool* is a collection of worker threads that efficiently execute asynchronous callbacks on behalf of the application.</span></span> <span data-ttu-id="a7255-105">Der Thread Pool wird hauptsächlich verwendet, um die Anzahl der Anwendungsthreads zu verringern und die Verwaltung der Arbeitsthreads zu ermöglichen.</span><span class="sxs-lookup"><span data-stu-id="a7255-105">The thread pool is primarily used to reduce the number of application threads and provide management of the worker threads.</span></span> <span data-ttu-id="a7255-106">Anwendungen können Arbeitselemente in die Warteschlange stellen, Arbeitsaufgaben zuordnen, abnutzbare Handles zuordnen, automatisch basierend auf einem Timer in die Warteschlange eingereiht und mit e/a</span><span class="sxs-lookup"><span data-stu-id="a7255-106">Applications can queue work items, associate work with waitable handles, automatically queue based on a timer, and bind with I/O.</span></span>

## <a name="thread-pool-architecture"></a><span data-ttu-id="a7255-107">Thread Pool Architektur</span><span class="sxs-lookup"><span data-stu-id="a7255-107">Thread Pool Architecture</span></span>

<span data-ttu-id="a7255-108">Die folgenden Anwendungen können von einem Thread Pool profitieren:</span><span class="sxs-lookup"><span data-stu-id="a7255-108">The following applications can benefit from using a thread pool:</span></span>

-   <span data-ttu-id="a7255-109">Eine Anwendung, die sehr parallel ist und eine große Anzahl kleiner Arbeitselemente asynchron (z. b. die Suche nach verteiltem Index oder Netzwerk-e/a) versendet.</span><span class="sxs-lookup"><span data-stu-id="a7255-109">An application that is highly parallel and can dispatch a large number of small work items asynchronously (such as distributed index search or network I/O).</span></span>
-   <span data-ttu-id="a7255-110">Eine Anwendung, die eine große Anzahl von Threads erstellt und zerstört, die jeweils für einen kurzen Zeitraum ausgeführt werden.</span><span class="sxs-lookup"><span data-stu-id="a7255-110">An application that creates and destroys a large number of threads that each run for a short time.</span></span> <span data-ttu-id="a7255-111">Durch die Verwendung des Thread Pools können die Komplexität der Thread Verwaltung und der Aufwand bei der Thread Erstellung und-Zerstörung reduziert werden.</span><span class="sxs-lookup"><span data-stu-id="a7255-111">Using the thread pool can reduce the complexity of thread management and the overhead involved in thread creation and destruction.</span></span>
-   <span data-ttu-id="a7255-112">Eine Anwendung, die unabhängige Arbeitselemente im Hintergrund und parallel verarbeitet (z. b. das Laden mehrerer Registerkarten).</span><span class="sxs-lookup"><span data-stu-id="a7255-112">An application that processes independent work items in the background and in parallel (such as loading multiple tabs).</span></span>
-   <span data-ttu-id="a7255-113">Eine Anwendung, die einen exklusiven warte Vorgang auf Kernel Objekte oder einen Block für eingehende Ereignisse eines Objekts ausführen muss.</span><span class="sxs-lookup"><span data-stu-id="a7255-113">An application that must perform an exclusive wait on kernel objects or block on incoming events on an object.</span></span> <span data-ttu-id="a7255-114">Durch die Verwendung des Thread Pools kann die Komplexität der Thread Verwaltung reduziert und die Leistung gesteigert werden, indem die Anzahl von Kontext Schaltern reduziert wird.</span><span class="sxs-lookup"><span data-stu-id="a7255-114">Using the thread pool can reduce the complexity of thread management and increase performance by reducing the number of context switches.</span></span>
-   <span data-ttu-id="a7255-115">Eine Anwendung, die benutzerdefinierte kellnerthreads erstellt, um auf Ereignisse zu warten.</span><span class="sxs-lookup"><span data-stu-id="a7255-115">An application that creates custom waiter threads to wait on events.</span></span>

<span data-ttu-id="a7255-116">Der ursprüngliche Thread Pool wurde in Windows Vista vollständig neu entworfen.</span><span class="sxs-lookup"><span data-stu-id="a7255-116">The original thread pool has been completely rearchitected in Windows Vista.</span></span> <span data-ttu-id="a7255-117">Der neue Thread Pool wird verbessert, da er einen einzelnen Arbeitsthreads bereitstellt (sowohl e/a-Vorgänge als auch nicht-e/a unterstützt), keinen Zeit Geber Thread verwendet, eine einzelne Zeit Geber Warteschlange bereitstellt und einen dedizierten permanenten Thread bereitstellt.</span><span class="sxs-lookup"><span data-stu-id="a7255-117">The new thread pool is improved because it provides a single worker thread type (supports both I/O and non-I/O), does not use a timer thread, provides a single timer queue, and provides a dedicated persistent thread.</span></span> <span data-ttu-id="a7255-118">Außerdem werden Bereinigungs Gruppen, eine höhere Leistung, mehrere Pools pro Prozess, die unabhängig geplant werden, und eine neue Thread Pool-API bereitstellt.</span><span class="sxs-lookup"><span data-stu-id="a7255-118">It also provides clean-up groups, higher performance, multiple pools per process that are scheduled independently, and a new thread pool API.</span></span>

<span data-ttu-id="a7255-119">Die Thread Pool Architektur besteht aus den folgenden Elementen:</span><span class="sxs-lookup"><span data-stu-id="a7255-119">The thread pool architecture consists of the following:</span></span>

-   <span data-ttu-id="a7255-120">Arbeitsthreads, die die Rückruf Funktionen ausführen</span><span class="sxs-lookup"><span data-stu-id="a7255-120">Worker threads that execute the callback functions</span></span>
-   <span data-ttu-id="a7255-121">Kellnerthreads, die auf mehrere Wait-Handles warten</span><span class="sxs-lookup"><span data-stu-id="a7255-121">Waiter threads that wait on multiple wait handles</span></span>
-   <span data-ttu-id="a7255-122">Eine Arbeits Warteschlange</span><span class="sxs-lookup"><span data-stu-id="a7255-122">A work queue</span></span>
-   <span data-ttu-id="a7255-123">Ein Standard Thread Pool für jeden Prozess</span><span class="sxs-lookup"><span data-stu-id="a7255-123">A default thread pool for each process</span></span>
-   <span data-ttu-id="a7255-124">Eine workerfactory, die die Arbeitsthreads verwaltet.</span><span class="sxs-lookup"><span data-stu-id="a7255-124">A worker factory that manages the worker threads</span></span>

## <a name="best-practices"></a><span data-ttu-id="a7255-125">Bewährte Methoden</span><span class="sxs-lookup"><span data-stu-id="a7255-125">Best Practices</span></span>

<span data-ttu-id="a7255-126">Die neue [Thread Pool-API](thread-pool-api.md) bietet mehr Flexibilität und Kontrolle als die [ursprüngliche Thread Pool-API](thread-pooling.md).</span><span class="sxs-lookup"><span data-stu-id="a7255-126">The new [thread pool API](thread-pool-api.md) provides more flexibility and control than the [original thread pool API](thread-pooling.md).</span></span> <span data-ttu-id="a7255-127">Allerdings gibt es einige feine, aber wichtige Unterschiede.</span><span class="sxs-lookup"><span data-stu-id="a7255-127">However, there are a few subtle but important differences.</span></span> <span data-ttu-id="a7255-128">In der ursprünglichen API wurde die Wartezeit automatisch zurückgesetzt. in der neuen API muss der Warte Vorgang jedes Mal explizit zurückgesetzt werden.</span><span class="sxs-lookup"><span data-stu-id="a7255-128">In the original API, the wait reset was automatic; in the new API, the wait must be explicitly reset each time.</span></span> <span data-ttu-id="a7255-129">Die ursprüngliche API hat den Identitätswechsel automatisch verarbeitet und den Sicherheitskontext des aufrufenden Prozesses an den Thread übertragen.</span><span class="sxs-lookup"><span data-stu-id="a7255-129">The original API handled impersonation automatically, transferring the security context of the calling process to the thread.</span></span> <span data-ttu-id="a7255-130">Mit der neuen API muss die Anwendung den Sicherheitskontext explizit festlegen.</span><span class="sxs-lookup"><span data-stu-id="a7255-130">With the new API, the application must explicitly set the security context.</span></span>

<span data-ttu-id="a7255-131">Im folgenden finden Sie bewährte Methoden bei der Verwendung eines Thread Pools:</span><span class="sxs-lookup"><span data-stu-id="a7255-131">The following are best practices when using a thread pool:</span></span>

-   <span data-ttu-id="a7255-132">Die Threads eines Prozesses verwenden den Thread Pool gemeinsam.</span><span class="sxs-lookup"><span data-stu-id="a7255-132">The threads of a process share the thread pool.</span></span> <span data-ttu-id="a7255-133">Ein einzelner Arbeits Thread kann mehrere Rückruf Funktionen nacheinander ausführen.</span><span class="sxs-lookup"><span data-stu-id="a7255-133">A single worker thread can execute multiple callback functions, one at a time.</span></span> <span data-ttu-id="a7255-134">Diese Arbeitsthreads werden vom Thread Pool verwaltet.</span><span class="sxs-lookup"><span data-stu-id="a7255-134">These worker threads are managed by the thread pool.</span></span> <span data-ttu-id="a7255-135">Beenden Sie daher einen Thread aus dem Thread Pool nicht, indem Sie [**TerminateThread**](/windows/win32/api/processthreadsapi/nf-processthreadsapi-terminatethread) im Thread aufrufen oder [**ExitThread**](/windows/win32/api/processthreadsapi/nf-processthreadsapi-exitthread) über eine Rückruffunktion aufrufen.</span><span class="sxs-lookup"><span data-stu-id="a7255-135">Therefore, do not terminate a thread from the thread pool by calling [**TerminateThread**](/windows/win32/api/processthreadsapi/nf-processthreadsapi-terminatethread) on the thread or by calling [**ExitThread**](/windows/win32/api/processthreadsapi/nf-processthreadsapi-exitthread) from a callback function.</span></span>
-   <span data-ttu-id="a7255-136">Eine e/a-Anforderung kann in jedem Thread im Thread Pool ausgeführt werden.</span><span class="sxs-lookup"><span data-stu-id="a7255-136">An I/O request can run on any thread in the thread pool.</span></span> <span data-ttu-id="a7255-137">Für das Abbrechen von e/a-Vorgängen in einem Thread Pool Thread ist eine Synchronisierung erforderlich, da die Cancel-Funktion möglicherweise in einem anderen Thread ausgeführt wird als der, der die e/a-Anforderung verarbeitet. Dies kann zu einem Abbruch eines unbekannten Vorgangs führen.</span><span class="sxs-lookup"><span data-stu-id="a7255-137">Canceling I/O on a thread pool thread requires synchronization because the cancel function might run on a different thread than the one that is handling the I/O request, which can result in cancellation of an unknown operation.</span></span> <span data-ttu-id="a7255-138">Um dies zu vermeiden, geben Sie immer die [**über**](/windows/win32/api/minwinbase/ns-minwinbase-overlapped) Lapp Ende Struktur an, mit der eine e/a-Anforderung initiiert wurde, als [**CancelIoEx**](/windows/win32/api/ioapiset/nf-ioapiset-cancelioex) für asynchrone e/a aufgerufen wurde, oder verwenden Sie Ihre eigene Synchronisierung, um sicherzustellen, dass keine andere e/a-Vorgänge im Zielthread gestartet werden können, bevor Sie die Funktion [**CancelSynchronousIo**](/windows/win32/api/ioapiset/nf-ioapiset-cancelsynchronousio) oder **CancelIoEx**</span><span class="sxs-lookup"><span data-stu-id="a7255-138">To avoid this, always provide the [**OVERLAPPED**](/windows/win32/api/minwinbase/ns-minwinbase-overlapped) structure with which an I/O request was initiated when calling [**CancelIoEx**](/windows/win32/api/ioapiset/nf-ioapiset-cancelioex) for asynchronous I/O, or use your own synchronization to ensure that no other I/O can be started on the target thread before calling either the [**CancelSynchronousIo**](/windows/win32/api/ioapiset/nf-ioapiset-cancelsynchronousio) or **CancelIoEx** function.</span></span>
-   <span data-ttu-id="a7255-139">Bereinigen Sie alle in der Rückruffunktion erstellten Ressourcen, bevor Sie von der Funktion zurückgegeben werden.</span><span class="sxs-lookup"><span data-stu-id="a7255-139">Clean up all resources created in the callback function before returning from the function.</span></span> <span data-ttu-id="a7255-140">Dazu zählen TLS, Sicherheits Kontexte, Thread Priorität und com-Registrierung.</span><span class="sxs-lookup"><span data-stu-id="a7255-140">These include TLS, security contexts, thread priority, and COM registration.</span></span> <span data-ttu-id="a7255-141">Rückruf Funktionen müssen auch den Thread Zustand wiederherstellen, bevor Sie zurückkehren.</span><span class="sxs-lookup"><span data-stu-id="a7255-141">Callback functions must also restore the thread state before returning.</span></span>
-   <span data-ttu-id="a7255-142">Behalten Sie Wait-Handles und die zugeordneten Objekte bei, bis der Thread Pool signalisiert hat, dass er mit dem Handle fertig ist.</span><span class="sxs-lookup"><span data-stu-id="a7255-142">Keep wait handles and their associated objects alive until the thread pool has signaled that it is finished with the handle.</span></span>
-   <span data-ttu-id="a7255-143">Markieren Sie alle Threads, die auf lange Vorgänge warten (z. b. e/a-Leerungen oder Ressourcen Bereinigung), damit der Thread Pool neue Threads zuordnen kann, anstatt auf diesen zu warten.</span><span class="sxs-lookup"><span data-stu-id="a7255-143">Mark all threads that are waiting on lengthy operations (such as I/O flushes or resource cleanup) so that the thread pool can allocate new threads instead of waiting for this one.</span></span>
-   <span data-ttu-id="a7255-144">Bevor Sie eine DLL entladen, die den Thread Pool verwendet, brechen Sie alle Arbeitsaufgaben, e/a-Vorgänge, warte Vorgänge und Timer ab, und warten Sie, bis die Ausführung der Rückrufe beendet ist.</span><span class="sxs-lookup"><span data-stu-id="a7255-144">Before unloading a DLL that uses the thread pool, cancel all work items, I/O, wait operations, and timers, and wait for executing callbacks to complete.</span></span>
-   <span data-ttu-id="a7255-145">Vermeiden Sie Deadlocks, indem Sie Abhängigkeiten zwischen Arbeits Elementen und zwischen Rückrufen vermeiden, indem Sie sicherstellen, dass ein Rückruf nicht auf den Abschluss des Vorgangs wartet, und indem Sie die Thread Priorität beibehalten.</span><span class="sxs-lookup"><span data-stu-id="a7255-145">Avoid deadlocks by eliminating dependencies between work items and between callbacks, by ensuring a callback is not waiting for itself to complete, and by preserving the thread priority.</span></span>
-   <span data-ttu-id="a7255-146">Stellen Sie zu viele Elemente in einem Prozess mit anderen Komponenten, die den Standard Thread Pool verwenden, nicht zu schnell in die Warteschlange.</span><span class="sxs-lookup"><span data-stu-id="a7255-146">Do not queue too many items too quickly in a process with other components using the default thread pool.</span></span> <span data-ttu-id="a7255-147">Es gibt einen Standard Thread Pool pro Prozess, einschließlich Svchost.exe.</span><span class="sxs-lookup"><span data-stu-id="a7255-147">There is one default thread pool per process, including Svchost.exe.</span></span> <span data-ttu-id="a7255-148">Standardmäßig verfügt jeder Thread Pool über maximal 500 Arbeitsthreads.</span><span class="sxs-lookup"><span data-stu-id="a7255-148">By default, each thread pool has a maximum of 500 worker threads.</span></span> <span data-ttu-id="a7255-149">Der Thread Pool versucht, mehr Arbeitsthreads zu erstellen, wenn die Anzahl der Arbeitsthreads im Zustand "bereit/wird" kleiner als die Anzahl der Prozessoren sein muss.</span><span class="sxs-lookup"><span data-stu-id="a7255-149">The thread pool attempts to create more worker threads when the number of worker threads in the ready/running state must be less than the number of processors.</span></span>
-   <span data-ttu-id="a7255-150">Vermeiden Sie das com-Single Thread-Apartment Modell, da es nicht mit dem Thread Pool kompatibel ist.</span><span class="sxs-lookup"><span data-stu-id="a7255-150">Avoid the COM single-threaded apartment model, as it is incompatible with the thread pool.</span></span> <span data-ttu-id="a7255-151">STA erstellt einen Thread Zustand, der sich auf das nächste Arbeits Element für den Thread auswirken kann.</span><span class="sxs-lookup"><span data-stu-id="a7255-151">STA creates thread state which can affect the next work item for the thread.</span></span> <span data-ttu-id="a7255-152">STA ist im allgemeinen langlebig und verfügt über Thread Affinität, die das Gegenteil des Thread Pools ist.</span><span class="sxs-lookup"><span data-stu-id="a7255-152">STA is generally long-lived and has thread affinity, which is the opposite of the thread pool.</span></span>
-   <span data-ttu-id="a7255-153">Erstellen Sie einen neuen Thread Pool zum Steuern der Thread Priorität und-Isolation, zum Erstellen benutzerdefinierter Eigenschaften und zur Verbesserung der Reaktionsfähigkeit.</span><span class="sxs-lookup"><span data-stu-id="a7255-153">Create a new thread pool to control thread priority and isolation, create custom characteristics, and possibly improve responsiveness.</span></span> <span data-ttu-id="a7255-154">Zusätzliche Thread Pools erfordern jedoch mehr Systemressourcen (Threads, Kernel Arbeitsspeicher).</span><span class="sxs-lookup"><span data-stu-id="a7255-154">However, additional thread pools require more system resources (threads, kernel memory).</span></span> <span data-ttu-id="a7255-155">Zu viele Pools erhöhen das Potenzial für CPU-Konflikte.</span><span class="sxs-lookup"><span data-stu-id="a7255-155">Too many pools increases the potential for CPU contention.</span></span>
-   <span data-ttu-id="a7255-156">Verwenden Sie nach Möglichkeit ein wabbares Objekt anstelle eines APC-basierten Mechanismus, um einen Thread Pool Thread zu signalisieren.</span><span class="sxs-lookup"><span data-stu-id="a7255-156">If possible, use a waitable object instead of an APC-based mechanism to signal a thread pool thread.</span></span> <span data-ttu-id="a7255-157">APCs funktionieren nicht ebenso wie andere Signalmechanismen mit Thread Pool-Threads, da die Lebensdauer von Thread Pool-Threads vom System gesteuert wird. Daher ist es möglich, dass ein Thread beendet wird, bevor die Benachrichtigung übermittelt wird.</span><span class="sxs-lookup"><span data-stu-id="a7255-157">APCs do not work as well with thread pool threads as other signaling mechanisms because the system controls the lifetime of thread pool threads, so it is possible for a thread to be terminated before the notification is delivered.</span></span>
-   <span data-ttu-id="a7255-158">Verwenden Sie die Debugger-Erweiterung für den Thread Pool,! TP.</span><span class="sxs-lookup"><span data-stu-id="a7255-158">Use the thread pool debugger extension, !tp.</span></span> <span data-ttu-id="a7255-159">Dieser Befehl weist die folgende Syntax auf:</span><span class="sxs-lookup"><span data-stu-id="a7255-159">This command has the following usage:</span></span>

    -   <span data-ttu-id="a7255-160">*pooladressflags* </span><span class="sxs-lookup"><span data-stu-id="a7255-160">pool *address* *flags*</span></span>
    -   <span data-ttu-id="a7255-161">obj- *adressflags* </span><span class="sxs-lookup"><span data-stu-id="a7255-161">obj *address* *flags*</span></span>
    -   <span data-ttu-id="a7255-162">TDie- *adressflags* </span><span class="sxs-lookup"><span data-stu-id="a7255-162">tqueue *address* *flags*</span></span>
    -   <span data-ttu-id="a7255-163">*kellneradresse*</span><span class="sxs-lookup"><span data-stu-id="a7255-163">waiter *address*</span></span>
    -   <span data-ttu-id="a7255-164">Worker- *Adresse*</span><span class="sxs-lookup"><span data-stu-id="a7255-164">worker *address*</span></span>

    <span data-ttu-id="a7255-165">Für den Pool, den Kellner und den Worker, wenn die Adresse 0 (null) ist, werden mit dem Befehl alle Objekte Abbilder.</span><span class="sxs-lookup"><span data-stu-id="a7255-165">For pool, waiter, and worker, if the address is zero, the command dumps all objects.</span></span> <span data-ttu-id="a7255-166">Für den Kellner und den Worker wird durch Weglassen der Adresse der aktuelle Thread Abbilder.</span><span class="sxs-lookup"><span data-stu-id="a7255-166">For waiter and worker, omitting the address dumps the current thread.</span></span> <span data-ttu-id="a7255-167">Die folgenden Flags sind definiert: 0x1 (einzeilige Ausgabe), 0x2 (dumpmember) und 0x4 (Arbeits Warteschlange für dumppools).</span><span class="sxs-lookup"><span data-stu-id="a7255-167">The following flags are defined: 0x1 (single-line output), 0x2 (dump members), and 0x4 (dump pool work queue).</span></span>

## <a name="related-topics"></a><span data-ttu-id="a7255-168">Zugehörige Themen</span><span class="sxs-lookup"><span data-stu-id="a7255-168">Related topics</span></span>

<dl> <dt>

[<span data-ttu-id="a7255-169">Thread Pool-API</span><span class="sxs-lookup"><span data-stu-id="a7255-169">Thread Pool API</span></span>](thread-pool-api.md)
</dt> <dt>

[<span data-ttu-id="a7255-170">Verwenden der Thread Pool Funktionen</span><span class="sxs-lookup"><span data-stu-id="a7255-170">Using the Thread Pool Functions</span></span>](using-the-thread-pool-functions.md)
</dt> </dl>

 

 
