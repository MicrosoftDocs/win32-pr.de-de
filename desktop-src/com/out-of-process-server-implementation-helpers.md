---
title: Hilfshilfsprogramme für die Out-of-Process-Server Implementierung
description: Hilfshilfsprogramme für die Out-of-Process-Server Implementierung
ms.assetid: 18641a84-56f8-4d27-9ddb-fa64011ac8ba
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: 264d3f26b179b3ecb659ef93785c8c223b6c524e
ms.sourcegitcommit: 5f33645661bf8c825a7a2e73950b1f4ea0f1cd82
ms.translationtype: MT
ms.contentlocale: de-DE
ms.lasthandoff: 08/21/2020
ms.locfileid: "104391072"
---
# <a name="out-of-process-server-implementation-helpers"></a><span data-ttu-id="34891-103">Hilfshilfsprogramme für die Out-of-Process-Server Implementierung</span><span class="sxs-lookup"><span data-stu-id="34891-103">Out-of-Process Server Implementation Helpers</span></span>

<span data-ttu-id="34891-104">Vier Hilfsfunktionen, die von Out-of-Process-Servern aufgerufen werden können, sind verfügbar, um das Schreiben von Servercode zu vereinfachen.</span><span class="sxs-lookup"><span data-stu-id="34891-104">Four helper functions that can be called by out-of-process servers are available to simplify the job of writing server code.</span></span> <span data-ttu-id="34891-105">Com-Clients und com-in-Process-Server werden Sie in der Regel nicht aufzurufen.</span><span class="sxs-lookup"><span data-stu-id="34891-105">COM clients and COM in-process servers typically would not call them.</span></span> <span data-ttu-id="34891-106">Diese Funktionen sind so konzipiert, dass Racebedingungen bei der Server Aktivierung vermieden werden, wenn die Server über mehrere oder mehrere Klassen Objekte verfügen.</span><span class="sxs-lookup"><span data-stu-id="34891-106">These functions are designed to help prevent race conditions in server activation when the servers have multiple apartments or multiple class objects.</span></span> <span data-ttu-id="34891-107">Sie können jedoch auch für Single Thread-und Single Class-Objekt Server verwendet werden.</span><span class="sxs-lookup"><span data-stu-id="34891-107">They can also, however, as easily be used for single-threaded and single class object servers.</span></span> <span data-ttu-id="34891-108">Die Funktionen lauten wie folgt:</span><span class="sxs-lookup"><span data-stu-id="34891-108">The functions are as follows:</span></span>

-   [<span data-ttu-id="34891-109">**Coadref Server Process**</span><span class="sxs-lookup"><span data-stu-id="34891-109">**CoAddRefServerProcess**</span></span>](/windows/desktop/api/combaseapi/nf-combaseapi-coaddrefserverprocess)
-   [<span data-ttu-id="34891-110">**Coreleaseserverprocess**</span><span class="sxs-lookup"><span data-stu-id="34891-110">**CoReleaseServerProcess**</span></span>](/windows/desktop/api/combaseapi/nf-combaseapi-coreleaseserverprocess)
-   [<span data-ttu-id="34891-111">**Cosuspendclassobjects**</span><span class="sxs-lookup"><span data-stu-id="34891-111">**CoSuspendClassObjects**</span></span>](/windows/desktop/api/combaseapi/nf-combaseapi-cosuspendclassobjects)
-   [<span data-ttu-id="34891-112">**CoResumeClassObjects**</span><span class="sxs-lookup"><span data-stu-id="34891-112">**CoResumeClassObjects**</span></span>](/windows/desktop/api/combaseapi/nf-combaseapi-coresumeclassobjects)

<span data-ttu-id="34891-113">Um ordnungsgemäß herunterzufahren, muss ein com-Server nachverfolgen, wie viele Objektinstanzen er instanziiert hat und wie oft die [**IClassFactory:: LockServer**](/windows/win32/api/unknwn/nf-unknwn-iclassfactory-lockserver) -Methode aufgerufen wurde.</span><span class="sxs-lookup"><span data-stu-id="34891-113">To shut down properly, a COM server must keep track of how many object instances it has instantiated and how many times its [**IClassFactory::LockServer**](/windows/win32/api/unknwn/nf-unknwn-iclassfactory-lockserver) method has been called.</span></span> <span data-ttu-id="34891-114">Nur wenn die beiden Zahlen Null erreichen, kann ein Server heruntergefahren werden.</span><span class="sxs-lookup"><span data-stu-id="34891-114">Only when both of these counts reach zero can a server shut down.</span></span> <span data-ttu-id="34891-115">Bei Single Thread-com-Servern wurde die Entscheidung für das Herunterfahren mit eingehenden Aktivierungs Anforderungen koordiniert, die von der Nachrichten Warteschlange serialisiert wurden.</span><span class="sxs-lookup"><span data-stu-id="34891-115">In single-threaded COM servers, the decision to shut down was coordinated with incoming activation requests, which were serialized by the message queue.</span></span> <span data-ttu-id="34891-116">Der Server würde nach dem Empfang einer Freigabe auf der endgültigen Objektinstanz und der Entscheidung, dass er heruntergefahren wird, seine Klassen Objekte widerrufen, bevor weitere Aktivierungs Anforderungen gesendet werden.</span><span class="sxs-lookup"><span data-stu-id="34891-116">The server, upon receiving a release on its final object instance and deciding to shut down, would revoke its class objects before any more activation requests were dispatched.</span></span> <span data-ttu-id="34891-117">Wenn nach diesem Punkt eine Aktivierungs Anforderung aufgetreten ist, erkennt com, dass die Klassen Objekte widerrufen wurden, und gibt einen Fehler an den Dienststeuerungs-Manager (SCM) zurück, der dann eine neue Instanz des lokalen Server Prozesses ausführen würde.</span><span class="sxs-lookup"><span data-stu-id="34891-117">If an activation request did come in after this point, COM would recognize that the class objects were revoked and would return an error to the Service Control Manager (SCM), which would then cause a new instance of the local server process to be run.</span></span>

<span data-ttu-id="34891-118">Bei einem Apartment Modell Server, bei dem unterschiedliche Klassen Objekte in unterschiedlichen Apartments registriert sind, und bei allen frei Thread Servern, muss diese Entscheidung für das Herunterfahren mit Aktivierungs Anforderungen über mehrere Threads koordiniert werden, damit ein Thread des Servers nicht heruntergefahren wird, während ein anderer Thread des Servers mit der Ausgabe von Klassen Objekten oder Objektinstanzen beschäftigt ist.</span><span class="sxs-lookup"><span data-stu-id="34891-118">However, in an apartment model server, in which different class objects are registered on different apartments, and in all free-threaded servers, this decision to shut down must be coordinated with activation requests across multiple threads so that one thread of the server does not decide to shut down while another thread of the server is busy handing out class objects or object instances.</span></span> <span data-ttu-id="34891-119">Ein klassischer, aber mühsamer Ansatz zur Lösung dieses Problems besteht darin, dass der Server, nachdem er seine Klassen Objekte widerrufen hat, seine Instanzanzahl erneut überprüft und aktiv bleibt, bis alle Instanzen freigegeben wurden.</span><span class="sxs-lookup"><span data-stu-id="34891-119">One classical but cumbersome approach to solving this is to have the server, after it has revoked its class objects, recheck its instance count and stay alive until all instances have been released.</span></span>

<span data-ttu-id="34891-120">Um es den Server Entwicklern zu erleichtern, diese Arten von Racebedingungen zu verarbeiten, bietet com zwei Verweis Zähl Funktionen:</span><span class="sxs-lookup"><span data-stu-id="34891-120">To make it easier for server writers to handle these types of race conditions, COM provides two reference counting functions:</span></span>

-   <span data-ttu-id="34891-121">" [**Coadresssserver Process**](/windows/desktop/api/combaseapi/nf-combaseapi-coaddrefserverprocess) " erhöht einen globalen Verweis Zähler pro Prozess.</span><span class="sxs-lookup"><span data-stu-id="34891-121">[**CoAddRefServerProcess**](/windows/desktop/api/combaseapi/nf-combaseapi-coaddrefserverprocess) increments a global per-process reference count.</span></span>
-   <span data-ttu-id="34891-122">[**Coreleaseserverprocess**](/windows/desktop/api/combaseapi/nf-combaseapi-coreleaseserverprocess) Dekremente den globalen Verweis Zähler pro Prozess.</span><span class="sxs-lookup"><span data-stu-id="34891-122">[**CoReleaseServerProcess**](/windows/desktop/api/combaseapi/nf-combaseapi-coreleaseserverprocess) decrements the global per-process reference count.</span></span>

<span data-ttu-id="34891-123">Wenn der globale Verweis Zähler pro Prozess den Wert Null erreicht, ruft com automatisch [**cosuspendclassobjects**](/windows/desktop/api/combaseapi/nf-combaseapi-cosuspendclassobjects)auf, wodurch verhindert wird, dass neue Aktivierungs Anforderungen eingehen.</span><span class="sxs-lookup"><span data-stu-id="34891-123">When the global per-process reference count reaches zero, COM automatically calls [**CoSuspendClassObjects**](/windows/desktop/api/combaseapi/nf-combaseapi-cosuspendclassobjects), which prevents any new activation requests from coming in.</span></span> <span data-ttu-id="34891-124">Der Server kann dann seine verschiedenen Klassen Objekte aus den verschiedenen Threads in der Freizeit aufheben, ohne dass eine andere Aktivierungs Anforderung eingehen kann.</span><span class="sxs-lookup"><span data-stu-id="34891-124">The server can then deregister its various class objects from its various threads at leisure without worry that another activation request may come in.</span></span> <span data-ttu-id="34891-125">Alle neuen Aktivierungs Anforderungen werden von dem SCM verarbeitet, der eine neue Instanz des lokalen Server Prozesses startet.</span><span class="sxs-lookup"><span data-stu-id="34891-125">All new activation requests are henceforth handled by the SCM launching a new instance of the local server process.</span></span>

<span data-ttu-id="34891-126">Die einfachste Möglichkeit für eine lokale Serveranwendung, diese Funktionen zu nutzen, besteht darin, im Konstruktor für die einzelnen Instanzobjekte und in jeder der [**IClassFactory:: LockServer**](/windows/win32/api/unknwn/nf-unknwn-iclassfactory-lockserver) -Methoden " [**coadressfserverprocess**](/windows/desktop/api/combaseapi/nf-combaseapi-coaddrefserverprocess) " aufzurufen, wenn der " *fLock* "-Parameter " **true**" ist.</span><span class="sxs-lookup"><span data-stu-id="34891-126">The simplest way for a local server application to make use of these functions is to call [**CoAddRefServerProcess**](/windows/desktop/api/combaseapi/nf-combaseapi-coaddrefserverprocess) in the constructor for each of its instance objects and in each of its [**IClassFactory::LockServer**](/windows/win32/api/unknwn/nf-unknwn-iclassfactory-lockserver) methods when the *fLock* parameter is **TRUE**.</span></span> <span data-ttu-id="34891-127">Die Serveranwendung sollte auch [**coreleaseserverprocess**](/windows/desktop/api/combaseapi/nf-combaseapi-coreleaseserverprocess) im debugtor der einzelnen Instanzobjekte und in jeder ihrer IClassFactory::**LockServer** -Methoden aufrufen, wenn der *fLock* -Parameter **false** ist.</span><span class="sxs-lookup"><span data-stu-id="34891-127">The server application should also call [**CoReleaseServerProcess**](/windows/desktop/api/combaseapi/nf-combaseapi-coreleaseserverprocess) in the destructor of each of its instance objects and in each of its IClassFactory::**LockServer** methods when the *fLock* parameter is **FALSE**.</span></span>

<span data-ttu-id="34891-128">Schließlich sollte die Serveranwendung auf den Rückgabecode von [**coreleaseserverprocess**](/windows/desktop/api/combaseapi/nf-combaseapi-coreleaseserverprocess)achten. Wenn Sie 0 zurückgibt, sollte die Serveranwendung die Bereinigung initiieren, die für einen Server mit mehreren Threads in der Regel bedeutet, dass Sie die verschiedenen Threads zum Beenden Ihrer Nachrichten Schleifen signalisieren und [**coadressfserverprocess**](/windows/desktop/api/combaseapi/nf-combaseapi-coaddrefserverprocess) und [**coreleaseserverprocess**](/windows/desktop/api/combaseapi/nf-combaseapi-coreleaseserverprocess)aufruft.</span><span class="sxs-lookup"><span data-stu-id="34891-128">Finally, the server application should pay attention to the return code from [**CoReleaseServerProcess**](/windows/desktop/api/combaseapi/nf-combaseapi-coreleaseserverprocess), and if it returns 0, the server application should initiate its cleanup, which, for a server with multiple threads, typically means that it should signal its various threads to exit their message loops and call [**CoAddRefServerProcess**](/windows/desktop/api/combaseapi/nf-combaseapi-coaddrefserverprocess) and [**CoReleaseServerProcess**](/windows/desktop/api/combaseapi/nf-combaseapi-coreleaseserverprocess).</span></span> <span data-ttu-id="34891-129">Wenn die Verwaltungsfunktionen für die Server Prozess Lebensdauer verwendet werden, müssen Sie in den Objektinstanzen und in der [**Lock Server**](/windows/win32/api/unknwn/nf-unknwn-iclassfactory-lockserver) -Methode verwendet werden. Andernfalls wird die Serveranwendung möglicherweise vorzeitig heruntergefahren.</span><span class="sxs-lookup"><span data-stu-id="34891-129">If the server process lifetime management functions are used, they must be used in both the object instances and the [**LockServer**](/windows/win32/api/unknwn/nf-unknwn-iclassfactory-lockserver) method; otherwise, the server application may be shut down prematurely.</span></span>

<span data-ttu-id="34891-130">Wenn eine [**CoGetClassObject**](/windows/desktop/api/combaseapi/nf-combaseapi-cogetclassobject) -Anforderung erfolgt, kontaktiert com den Server, marshüßt die [**IClassFactory**](/windows/win32/api/unknwn/nn-unknwn-iclassfactory) -Schnittstelle des Class-Objekts, kehrt zum Client Prozess zurück, entmarshunkt die **IClassFactory** -Schnittstelle und gibt Sie an den Client zurück.</span><span class="sxs-lookup"><span data-stu-id="34891-130">When a [**CoGetClassObject**](/windows/desktop/api/combaseapi/nf-combaseapi-cogetclassobject) request is made, COM contacts the server, marshals the [**IClassFactory**](/windows/win32/api/unknwn/nn-unknwn-iclassfactory) interface of the class object, returns to the client process, unmarshals the **IClassFactory** interface, and returns this to the client.</span></span> <span data-ttu-id="34891-131">An diesem Punkt wird [**Lock Server**](/windows/win32/api/unknwn/nf-unknwn-iclassfactory-lockserver) in der Regel mit " **true** " aufgerufen, um zu verhindern, dass der Server Prozess heruntergefahren wird.</span><span class="sxs-lookup"><span data-stu-id="34891-131">At this point, clients typically call [**LockServer**](/windows/win32/api/unknwn/nf-unknwn-iclassfactory-lockserver) with **TRUE** to prevent the server process from shutting down.</span></span> <span data-ttu-id="34891-132">Es gibt jedoch ein Zeitfenster zwischen dem Marshalling des Klassen Objekts und dem Aufruf von **Lock Server** , bei dem ein anderer Client eine Verbindung mit dem gleichen Server herstellen kann, eine Instanz erhält und diese Instanz freigibt. auf diese Weise wird der Server heruntergefahren, und der erste Client kann mit einem getrennten **IClassFactory** -Zeiger hoch und trocken gelassen werden.</span><span class="sxs-lookup"><span data-stu-id="34891-132">However, there is a window of time between when the class object is marshaled and when the client calls **LockServer** in which another client could connect to the same server, get an instance, and release that instance, thus causing the server to shut down and leaving the first client high and dry with a disconnected **IClassFactory** pointer.</span></span> <span data-ttu-id="34891-133">Um diese Racebedingung zu vermeiden, fügt com einen impliziten **aufruflockserver** mit **true** dem Klassenobjekt hinzu, wenn es die **IClassFactory** -Schnittstelle Marshalls und einen impliziten Rückruf von **Lock Server** mit **false** hinzufügt, wenn der Client die **IClassFactory** -Schnittstelle freigibt.</span><span class="sxs-lookup"><span data-stu-id="34891-133">To prevent this race condition, COM adds an implicit call to **LockServer** with **TRUE** to the class object when it marshals the **IClassFactory** interface and an implicit call to **LockServer** with **FALSE** when the client releases the **IClassFactory** interface.</span></span> <span data-ttu-id="34891-134">Aus diesem Grund ist es nicht notwendig, die Remote Aufrufe von **Lock Server** an den Server zurückzusetzen, und der Proxy für **LockServer** gibt einfach OK zurück, \_ ohne den Aufruf tatsächlich zu entfernen.</span><span class="sxs-lookup"><span data-stu-id="34891-134">Therefore, it is not necessary to remote **LockServer** calls back to the server, and the proxy for **LockServer** simply returns S\_OK without actually remoting the call.</span></span>

<span data-ttu-id="34891-135">Während der Initialisierung eines Prozess internen Server Prozesses gibt es eine weitere Aktivierungs bezogene Racebedingung.</span><span class="sxs-lookup"><span data-stu-id="34891-135">There is another activation-related race condition during initialization of an out-of-process server process.</span></span> <span data-ttu-id="34891-136">Ein com-Server, der mehrere Klassen registriert, ruft in der Regel [**CoRegisterClassObject**](/windows/desktop/api/combaseapi/nf-combaseapi-coregisterclassobject) mit dem lokalen REGCLS- \_ \_ Server für jede unterstützte CLSID auf.</span><span class="sxs-lookup"><span data-stu-id="34891-136">A COM server that registers multiple classes typically calls [**CoRegisterClassObject**](/windows/desktop/api/combaseapi/nf-combaseapi-coregisterclassobject) with REGCLS\_LOCAL\_SERVER for each CLSID it supports.</span></span> <span data-ttu-id="34891-137">Nachdem dies für alle Klassen abgeschlossen ist, wechselt der Server in seine Nachrichten Schleife.</span><span class="sxs-lookup"><span data-stu-id="34891-137">After it has done this for all classes, the server enters its message loop.</span></span> <span data-ttu-id="34891-138">Bei einem Single Thread-com-Server werden alle Aktivierungs Anforderungen blockiert, bis der Server in die Nachrichten Schleife eintritt.</span><span class="sxs-lookup"><span data-stu-id="34891-138">For a single-threaded COM server, all activation requests are blocked until the server enters the message loop.</span></span> <span data-ttu-id="34891-139">Bei einem Apartment Modell Server, der verschiedene Klassen Objekte in unterschiedlichen Apartments und für alle frei Thread Server registriert, können Aktivierungs Anforderungen jedoch früher eintreffen.</span><span class="sxs-lookup"><span data-stu-id="34891-139">However, for an apartment model server that registers different class objects in different apartments and for all free-threaded servers, activation requests can arrive earlier than this.</span></span> <span data-ttu-id="34891-140">Im Fall von Apartment Modell Servern können Aktivierungs Anforderungen eintreffen, sobald ein Thread eine Nachrichten Schleife eingegeben hat.</span><span class="sxs-lookup"><span data-stu-id="34891-140">In the case of apartment model servers, activation requests could arrive as soon as any one thread has entered its message loop.</span></span> <span data-ttu-id="34891-141">Im Fall von kostenlosen Thread Servern kann eine Aktivierungs Anforderung eintreffen, sobald das erste Klassenobjekt registriert ist.</span><span class="sxs-lookup"><span data-stu-id="34891-141">In the case of free-threaded servers, an activation request could arrive as soon as the first class object is registered.</span></span> <span data-ttu-id="34891-142">Da eine Aktivierung zu einem frühen Zeitpunkt durchgeführt werden kann, ist es auch möglich, dass das endgültige Release stattfindet (und daher das Herunterfahren des Servers bewirken sollte), bevor der Rest des Servers die Initialisierung abschließen konnte.</span><span class="sxs-lookup"><span data-stu-id="34891-142">Since an activation can happen this early, it is also possible for the final release to occur (and therefore cause the server to begin shutting down) before the rest of the server has had a chance to finish initializing.</span></span>

<span data-ttu-id="34891-143">Um diese Racebedingungen auszuschließen und die Aufgabe des serverwriters zu vereinfachen, sollte jeder Server, der mehrere Klassen Objekte mit com registrieren möchte, [**CoRegisterClassObject**](/windows/desktop/api/combaseapi/nf-combaseapi-coregisterclassobject) mit REGCLS \_ local \_ Server \| REGCLS aufrufen, \_ die für jede andere vom Server unterstützte CLSID angehalten werden.</span><span class="sxs-lookup"><span data-stu-id="34891-143">To eliminate these race conditions and simplify the job of the server writer, any server that wants to register multiple class objects with COM should call [**CoRegisterClassObject**](/windows/desktop/api/combaseapi/nf-combaseapi-coregisterclassobject) with REGCLS\_LOCAL\_SERVER \| REGCLS\_SUSPENDED for each different CLSID the server supports.</span></span> <span data-ttu-id="34891-144">Nachdem alle Klassen registriert wurden und der Server Prozess bereit ist, eingehende Aktivierungs Anforderungen zu akzeptieren, sollte der Server einen [**CoResumeClassObjects**](/windows/desktop/api/combaseapi/nf-combaseapi-coresumeclassobjects)-Befehl erstellen.</span><span class="sxs-lookup"><span data-stu-id="34891-144">After all classes have been registered and the server process is ready to accept incoming activation requests, the server should make one call to [**CoResumeClassObjects**](/windows/desktop/api/combaseapi/nf-combaseapi-coresumeclassobjects).</span></span> <span data-ttu-id="34891-145">Diese Funktion teilt com mit, den SCM über alle registrierten Klassen zu informieren, und beginnt damit, Aktivierungs Anforderungen an den Server Prozess zu übermitteln.</span><span class="sxs-lookup"><span data-stu-id="34891-145">This function tells COM to inform the SCM about all the registered classes, and it begins letting activation requests into the server process.</span></span> <span data-ttu-id="34891-146">Die Verwendung dieser Funktionen bietet die folgenden Vorteile:</span><span class="sxs-lookup"><span data-stu-id="34891-146">Using these functions provides the following advantages:</span></span>

-   <span data-ttu-id="34891-147">Nur ein Aufruf wird an den SCM gerichtet, unabhängig davon, wie viele CLSIDs registriert sind. Dadurch wird die Gesamt Registrierungs Zeit (und damit auch die Startzeit der Serveranwendung) verringert.</span><span class="sxs-lookup"><span data-stu-id="34891-147">Only one call is made to the SCM, regardless of how many CLSIDs are registered, thus reducing the overall registration time (and hence startup time of the server application).</span></span>
-   <span data-ttu-id="34891-148">Wenn der Server über mehrere Apartments verfügt und verschiedene CLSIDs in unterschiedlichen Apartments registriert sind, oder wenn es sich bei dem Server um einen frei Thread Server handelt, treten keine Aktivierungs Anforderungen ein, bis der Server [**CoResumeClassObjects**](/windows/desktop/api/combaseapi/nf-combaseapi-coresumeclassobjects)aufruft. Dadurch erhält der Server die Möglichkeit, alle seine CLSIDs zu registrieren und ordnungsgemäß einzurichten, bevor Sie Aktivierungs Anforderungen und mögliche Herunterfahren benötigen</span><span class="sxs-lookup"><span data-stu-id="34891-148">If the server has multiple apartments and different CLSIDs are registered in different apartments, or if the server is a free-threaded server, no activation requests will come in until the server calls [**CoResumeClassObjects**](/windows/desktop/api/combaseapi/nf-combaseapi-coresumeclassobjects), giving the server a chance to register all of its CLSIDs and get properly set up before having to deal with activation requests and possible shut down requests.</span></span>

## <a name="related-topics"></a><span data-ttu-id="34891-149">Zugehörige Themen</span><span class="sxs-lookup"><span data-stu-id="34891-149">Related topics</span></span>

<dl> <dt>

[<span data-ttu-id="34891-150">Zuständigkeiten von com-Servern</span><span class="sxs-lookup"><span data-stu-id="34891-150">COM Server Responsibilities</span></span>](com-server-responsibilities.md)
</dt> </dl>

 

 