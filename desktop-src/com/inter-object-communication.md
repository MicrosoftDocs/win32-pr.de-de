---
title: Inter-Object Kommunikation
description: COM ist so konzipiert, dass Clients transparent mit Objekten kommunizieren können, unabhängig davon, wo diese Objekte im gleichen Prozess, auf demselben Computer oder auf einem anderen Computer ausgeführt werden.
ms.assetid: dd4adafb-a7e4-44ba-ae4a-80585875ecb6
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: 9356ba2bcb9dd3a6a56ac16c354f3abcb752d717
ms.sourcegitcommit: 5f33645661bf8c825a7a2e73950b1f4ea0f1cd82
ms.translationtype: MT
ms.contentlocale: de-DE
ms.lasthandoff: 08/21/2020
ms.locfileid: "104102386"
---
# <a name="inter-object-communication"></a><span data-ttu-id="80afb-103">Inter-Object Kommunikation</span><span class="sxs-lookup"><span data-stu-id="80afb-103">Inter-Object Communication</span></span>

<span data-ttu-id="80afb-104">COM ist so konzipiert, dass Clients transparent mit Objekten kommunizieren können, unabhängig davon, wo diese Objekte in demselben Prozess, auf demselben Computer oder auf einem anderen Computer durchlaufen werden.</span><span class="sxs-lookup"><span data-stu-id="80afb-104">COM is designed to allow clients to communicate transparently with objects, regardless of where those objects are runningâ€”in the same process, on the same computer, or on a different computer.</span></span> <span data-ttu-id="80afb-105">Dadurch wird ein einzelnes Programmiermodell für alle Objekttypen und für Objekt Clients und Objekt Server bereitstellt.</span><span class="sxs-lookup"><span data-stu-id="80afb-105">This provides a single programming model for all types of objects, and for both object clients and object servers.</span></span>

<span data-ttu-id="80afb-106">Aus Sicht eines Clients erfolgt der Zugriff auf alle Objekte über Schnittstellen Zeiger.</span><span class="sxs-lookup"><span data-stu-id="80afb-106">From a client's point of view, all objects are accessed through interface pointers.</span></span> <span data-ttu-id="80afb-107">Ein Zeiger muss in Verarbeitung sein.</span><span class="sxs-lookup"><span data-stu-id="80afb-107">A pointer must be in-process.</span></span> <span data-ttu-id="80afb-108">Tatsächlich erreicht jeder Aufrufe einer Schnittstellenfunktion immer zuerst ein Teil des in-Process-Codes.</span><span class="sxs-lookup"><span data-stu-id="80afb-108">In fact, any call to an interface function always reaches some piece of in-process code first.</span></span> <span data-ttu-id="80afb-109">Wenn das Objekt in Bearbeitung ist, erreicht der-Befehl es direkt und ohne dazwischenliegenden Systeminfrastruktur Code.</span><span class="sxs-lookup"><span data-stu-id="80afb-109">If the object is in-process, the call reaches it directly, with no intervening system-infrastructure code.</span></span> <span data-ttu-id="80afb-110">Wenn das Objekt außerhalb des Prozesses ist, erreicht der Aufruf zuerst das, was als "Proxy"-Objekt bezeichnet wird, das entweder durch com oder durch das-Objekt bereitgestellt wird (wenn der Implementierungs Vorgang wünscht).</span><span class="sxs-lookup"><span data-stu-id="80afb-110">If the object is out-of-process, the call first reaches what is called a "proxy" object provided either by COM or by the object (if the implementor wishes).</span></span> <span data-ttu-id="80afb-111">Die Proxy Pakete rufen Parameter (einschließlich der Schnittstellen Zeiger) auf und generieren den entsprechenden Remote Prozedur Aufrufe (oder einen anderen Kommunikationsmechanismus im Fall von benutzerdefinierten Proxys) für den anderen Prozess oder den anderen Computer, auf dem sich die Objekt Implementierung befindet.</span><span class="sxs-lookup"><span data-stu-id="80afb-111">The proxy packages call parameters (including any interface pointers) and generate the appropriate remote procedure call (or other communication mechanism in the case of custom generated proxies) to the other process or the other computer where the object implementation is located.</span></span> <span data-ttu-id="80afb-112">Dieser Prozess zum Packen von Zeigern für die Übertragung über Prozess Grenzen hinweg *wird als* Marshalling bezeichnet.</span><span class="sxs-lookup"><span data-stu-id="80afb-112">This process of packaging pointers for transmission across process boundaries is called *marshaling*.</span></span>

<span data-ttu-id="80afb-113">Aus Sicht eines Servers werden alle Aufrufe der Schnittstellen Funktionen eines Objekts über einen Zeiger auf diese Schnittstelle durchgeführt.</span><span class="sxs-lookup"><span data-stu-id="80afb-113">From a server's point of view, all calls to an object's interface functions are made through a pointer to that interface.</span></span> <span data-ttu-id="80afb-114">Auch hier hat ein Zeiger nur Kontext in einem einzelnen Prozess, und der Aufrufer muss immer ein Teil des in-Process-Codes sein.</span><span class="sxs-lookup"><span data-stu-id="80afb-114">Again, a pointer has context only in a single process, and the caller must always be some piece of in-process code.</span></span> <span data-ttu-id="80afb-115">Wenn das Objekt in Bearbeitung ist, ist der Aufrufer der Client selbst.</span><span class="sxs-lookup"><span data-stu-id="80afb-115">If the object is in-process, the caller is the client itself.</span></span> <span data-ttu-id="80afb-116">Andernfalls ist der Aufrufer ein "Stub"-Objekt, das entweder durch com oder das Objekt selbst bereitgestellt wird.</span><span class="sxs-lookup"><span data-stu-id="80afb-116">Otherwise, the caller is a "stub" object provided either by COM or by the object itself.</span></span> <span data-ttu-id="80afb-117">Der Stub empfängt den Remote Prozedur Aufruf (oder einen anderen Kommunikationsmechanismus im Fall von benutzerdefinierten generierten Proxys) vom "Proxy" im Client Prozess, entmarsheitet die Parameter und ruft die entsprechende Schnittstelle für das Server Objekt auf.</span><span class="sxs-lookup"><span data-stu-id="80afb-117">The stub receives the remote procedure call (or other communication mechanism in the case of custom generated proxies) from the "proxy" in the client process, unmarshals the parameters, and calls the appropriate interface on the server object.</span></span> <span data-ttu-id="80afb-118">Aus Sicht der Sicht von Clients und Servern kommunizieren Sie immer direkt mit einem anderen Prozess internen Code.</span><span class="sxs-lookup"><span data-stu-id="80afb-118">From the points of view of both clients and servers, they always communicate directly with some other in-process code.</span></span>

<span data-ttu-id="80afb-119">COM stellt eine Marshalling-Implementierung dar, die als *Standardmarshalling* bezeichnet wird.</span><span class="sxs-lookup"><span data-stu-id="80afb-119">COM provides an implementation of marshaling, referred to as *standard marshaling*.</span></span> <span data-ttu-id="80afb-120">Diese Implementierung funktioniert sehr gut für die meisten Objekte und reduziert die Programmier Anforderungen erheblich, sodass der Marshallingprozess effektiv transparent wird.</span><span class="sxs-lookup"><span data-stu-id="80afb-120">This implementation works very well for most objects and greatly reduces programming requirements, making the marshaling process effectively transparent.</span></span>

<span data-ttu-id="80afb-121">Die klare Trennung der-Schnittstelle von der Implementierung der Prozesstransparenz von com kann jedoch in einigen Situationen sinnvoll sein.</span><span class="sxs-lookup"><span data-stu-id="80afb-121">The clear separation of interface from implementation of COM's process transparency can, however, get in the way in some situations.</span></span> <span data-ttu-id="80afb-122">Der Entwurf einer Schnittstelle, die sich auf die Funktion aus der Sicht des Clients konzentriert, kann manchmal zu Entwurfsentscheidungen führen, die mit einer effizienten Implementierung dieser Schnittstelle in einem Netzwerk in Konflikt stehen.</span><span class="sxs-lookup"><span data-stu-id="80afb-122">The design of an interface that focuses on its function from the client's point of view can sometimes lead to design decisions that conflict with efficient implementation of that interface across a network.</span></span> <span data-ttu-id="80afb-123">In solchen Fällen ist es erforderlich, dass es sich nicht um reine Prozesstransparenz, sondern um die Prozesstransparenz handelt, es sei denn, Sie müssen sich kümmern.</span><span class="sxs-lookup"><span data-stu-id="80afb-123">In cases like this, what is needed is not pure process transparency but "process transparency, unless you need to care."</span></span> <span data-ttu-id="80afb-124">COM bietet diese Funktion, indem es einem Objekt Implementierer ermöglicht, ein *benutzerdefiniertes* Marshalling (auch als " [**IMarshal**](/windows/win32/api/objidlbase/nn-objidlbase-imarshal) Marshalling" bezeichnet) zu unterstützen.</span><span class="sxs-lookup"><span data-stu-id="80afb-124">COM provides this capability by allowing an object implementor to support *custom marshaling* (also called [**IMarshal**](/windows/win32/api/objidlbase/nn-objidlbase-imarshal) marshaling).</span></span> <span data-ttu-id="80afb-125">Standard mäßiges Marshalling ist tatsächlich eine Instanz von benutzerdefiniertem Marshalling; Dies ist die Standard Implementierung, die verwendet wird, wenn für ein Objekt kein benutzerdefiniertes Marshalling erforderlich ist.</span><span class="sxs-lookup"><span data-stu-id="80afb-125">Standard marshaling is, in fact, an instance of custom marshaling; it is the default implementation used when an object does not require custom marshaling.</span></span>

<span data-ttu-id="80afb-126">Sie können das benutzerdefinierte Marshalling implementieren, damit ein Objekt verschiedene Aktionen durchführen kann, wenn es in einem Netzwerk verwendet wird, das in einem Netzwerk verwendet wird, und es für den Client vollständig transparent ist.</span><span class="sxs-lookup"><span data-stu-id="80afb-126">You can implement custom marshaling to allow an object to take different actions when used from across a network than it takes under local access and it is completely transparent to the client.</span></span> <span data-ttu-id="80afb-127">Diese Architektur ermöglicht das Entwerfen von Client-/Objekt-Schnittstellen ohne Berücksichtigung von Netzwerk Leistungsproblemen und später, um Netzwerk Leistungsprobleme zu beheben, ohne den eingerichteten Entwurf zu unterbrechen.</span><span class="sxs-lookup"><span data-stu-id="80afb-127">This architecture makes it possible to design client/object interfaces without regard to network performance issues and then later to address network performance issues without disrupting the established design.</span></span>

<span data-ttu-id="80afb-128">COM gibt nicht an, wie Komponenten strukturiert werden. Gibt an, wie Sie interagieren.</span><span class="sxs-lookup"><span data-stu-id="80afb-128">COM does not specify how components are structured; it specifies how they interact.</span></span> <span data-ttu-id="80afb-129">COM unterscheidet sich von der internen Struktur einer Komponente für Programmiersprachen und Entwicklungsumgebungen.</span><span class="sxs-lookup"><span data-stu-id="80afb-129">COM leaves the concern about the internal structure of a component to programming languages and development environments.</span></span> <span data-ttu-id="80afb-130">Im Gegensatz dazu haben Programmierumgebungen keine festgelegten Standards zum Arbeiten mit Objekten außerhalb der unmittelbaren Anwendung.</span><span class="sxs-lookup"><span data-stu-id="80afb-130">Conversely, programming environments have no set standards for working with objects outside of the immediate application.</span></span> <span data-ttu-id="80afb-131">Microsoft Visual C++ z. b. sehr gut für die Bearbeitung von Objekten in einer Anwendung, aber keine Unterstützung für das Arbeiten mit Objekten außerhalb der Anwendung.</span><span class="sxs-lookup"><span data-stu-id="80afb-131">Microsoft Visual C++, for example, works extremely well for manipulating objects inside an application but has no support for working with objects outside the application.</span></span> <span data-ttu-id="80afb-132">Im Allgemeinen sind alle anderen Programmiersprachen in dieser Hinsicht identisch.</span><span class="sxs-lookup"><span data-stu-id="80afb-132">Generally, all other programming languages are the same in this regard.</span></span> <span data-ttu-id="80afb-133">Daher wird für die Bereitstellung von networkwide Interoperabilität, com, über sprachunabhängige Schnittstellen ausgewählt, wo die Programmiersprachen verlassen werden.</span><span class="sxs-lookup"><span data-stu-id="80afb-133">Therefore, to provide networkwide interoperability, COM, through language-independent interfaces, picks up where programming languages leave off.</span></span>

<span data-ttu-id="80afb-134">Die doppelte Dereferenzierung der VTBL-Struktur bedeutet, dass die Zeiger in der Tabelle der Funktionszeiger nicht direkt auf die tatsächliche Implementierung im echten-Objekt verweisen müssen.</span><span class="sxs-lookup"><span data-stu-id="80afb-134">The double indirection of the vtbl structure means that the pointers in the table of function pointers do not need to point directly to the real implementation in the real object.</span></span> <span data-ttu-id="80afb-135">Dies ist das Herzstück der Prozesstransparenz.</span><span class="sxs-lookup"><span data-stu-id="80afb-135">This is the heart of process transparency.</span></span>

<span data-ttu-id="80afb-136">Bei Prozess internen Servern, bei denen das Objekt direkt in den Client Prozess geladen wird, werden die Funktionszeiger in der Tabelle direkt auf die tatsächliche Implementierung festgelegt.</span><span class="sxs-lookup"><span data-stu-id="80afb-136">For in-process servers, where the object is loaded directly into the client process, the function pointers in the table point directly to the actual implementation.</span></span> <span data-ttu-id="80afb-137">In diesem Fall überträgt ein Funktionsaufrufe vom Client an eine Schnittstellen Methode direkt die Ausführungs Steuerung an die-Methode.</span><span class="sxs-lookup"><span data-stu-id="80afb-137">In this case, a function call from the client to an interface method directly transfers execution control to the method.</span></span> <span data-ttu-id="80afb-138">Dies funktioniert jedoch nicht für lokale, nicht-Remote Objekte, da Zeiger auf den Arbeitsspeicher nicht von Prozessen gemeinsam verwendet werden können.</span><span class="sxs-lookup"><span data-stu-id="80afb-138">However, this cannot work for local, let alone remote, objects because pointers to memory cannot be shared between processes.</span></span> <span data-ttu-id="80afb-139">Dennoch muss der Client in der Lage sein, Schnittstellen Methoden aufzurufen, als ob er die tatsächliche Implementierung aufruft.</span><span class="sxs-lookup"><span data-stu-id="80afb-139">Nevertheless, the client must be able to call interface methods as if it were calling the actual implementation.</span></span> <span data-ttu-id="80afb-140">Folglich überträgt der Client die Steuerung gleichmäßig an eine Methode in einem Objekt, indem er den-Befehl aufruft.</span><span class="sxs-lookup"><span data-stu-id="80afb-140">Thus, the client uniformly transfers control to a method in some object by making the call.</span></span>

<span data-ttu-id="80afb-141">Ein Client ruft immer Schnittstellen Methoden in einem in-Process-Objekt auf.</span><span class="sxs-lookup"><span data-stu-id="80afb-141">A client always calls interface methods in some in-process object.</span></span> <span data-ttu-id="80afb-142">Wenn das eigentliche Objekt lokal oder Remote ist, wird der-Vorgang an ein Proxy Objekt gerichtet, das dann einen Remote Prozedur Aufrufvorgang an das tatsächliche-Objekt sendet.</span><span class="sxs-lookup"><span data-stu-id="80afb-142">If the actual object is local or remote, the call is made to a proxy object, which then makes a remote procedure call to the actual object.</span></span>

<span data-ttu-id="80afb-143">Welche Methode wird tatsächlich ausgeführt?</span><span class="sxs-lookup"><span data-stu-id="80afb-143">So what method is actually executed?</span></span> <span data-ttu-id="80afb-144">Die Antwort besteht darin, dass jede Schnittstellen Methode bei einem Aufruf einer Out-of-Process-Schnittstelle von einem Proxy Objekt implementiert wird.</span><span class="sxs-lookup"><span data-stu-id="80afb-144">The answer is that whenever there is a call to an out-of-process interface, each interface method is implemented by a proxy object.</span></span> <span data-ttu-id="80afb-145">Das Proxy Objekt ist immer ein Prozess interner Objekt, das im Namen des aufgerufenen Objekts fungiert.</span><span class="sxs-lookup"><span data-stu-id="80afb-145">The proxy object is always an in-process object that acts on behalf of the object being called.</span></span> <span data-ttu-id="80afb-146">Dieses Proxy Objekt weiß, dass das tatsächliche-Objekt auf einem lokalen Server oder Remote Server ausgeführt wird.</span><span class="sxs-lookup"><span data-stu-id="80afb-146">This proxy object knows that the actual object is running in a local or remote server.</span></span>

<span data-ttu-id="80afb-147">Das Proxy Objekt verpackt die Funktionsparameter in einigen Datenpaketen und generiert einen RPC-Aufruf an das lokale oder Remote Objekt.</span><span class="sxs-lookup"><span data-stu-id="80afb-147">The proxy object packages up the function parameters in some data packets and generates an RPC call to the local or remote object.</span></span> <span data-ttu-id="80afb-148">Dieses Paket wird von einem Stub-Objekt im Server Prozess auf dem lokalen Computer oder einem Remote Computer übernommen, der die Parameter entpackt und die tatsächliche Implementierung der Methode aufruft.</span><span class="sxs-lookup"><span data-stu-id="80afb-148">That packet is picked up by a stub object in the server's process on the local or a remote computer, which unpacks the parameters and makes the call to the real implementation of the method.</span></span> <span data-ttu-id="80afb-149">Wenn diese Funktion zurückgibt, verpackt der Stub alle out-Parameter und den Rückgabewert und sendet Sie zurück an den Proxy, der Sie entpackt und an den ursprünglichen Client zurückgibt.</span><span class="sxs-lookup"><span data-stu-id="80afb-149">When that function returns, the stub packages up any out-parameters and the return value and sends it back to the proxy, which unpacks them and returns them to the original client.</span></span>

<span data-ttu-id="80afb-150">Daher kommunizieren Client und Server immer miteinander, als ob alles in Verarbeitung wäre.</span><span class="sxs-lookup"><span data-stu-id="80afb-150">Thus, client and server always talk to each other as if everything was in-process.</span></span> <span data-ttu-id="80afb-151">Alle Aufrufe vom Client und alle Aufrufe an den Server werden zu einem bestimmten Zeitpunkt in den Prozess verarbeitet.</span><span class="sxs-lookup"><span data-stu-id="80afb-151">All calls from the client and all calls to the server are, at some point, in-process.</span></span> <span data-ttu-id="80afb-152">Da die VTBL-Struktur es jedoch ermöglicht, dass ein Agent (z. b. com) alle Funktionsaufrufe abfängt und alle Rückgabe Vorgänge von Funktionen durchführt, kann dieser Agent diese Aufrufe nach Bedarf an einen RPC-Aufruf umleiten.</span><span class="sxs-lookup"><span data-stu-id="80afb-152">But because the vtbl structure allows some agent, like COM, to intercept all function calls and all returns from functions, that agent can redirect those calls to an RPC call as necessary.</span></span> <span data-ttu-id="80afb-153">Obwohl Prozess interne Aufrufe schneller als prozessübergreifende Aufrufe sind, sind die Prozess Unterschiede für Client und Server vollständig transparent.</span><span class="sxs-lookup"><span data-stu-id="80afb-153">Although in-process calls are faster than out-of-process calls, the process differences are completely transparent to the client and server.</span></span>

<span data-ttu-id="80afb-154">Weitere Informationen finden Sie unter den folgenden Themen:</span><span class="sxs-lookup"><span data-stu-id="80afb-154">For more information, see the following topics:</span></span>

-   [<span data-ttu-id="80afb-155">Marshalling von Details</span><span class="sxs-lookup"><span data-stu-id="80afb-155">Marshaling Details</span></span>](marshaling-details.md)
-   [<span data-ttu-id="80afb-156">Proxy</span><span class="sxs-lookup"><span data-stu-id="80afb-156">Proxy</span></span>](proxy.md)
-   [<span data-ttu-id="80afb-157">Stub</span><span class="sxs-lookup"><span data-stu-id="80afb-157">Stub</span></span>](stub.md)
-   [<span data-ttu-id="80afb-158">Kanal</span><span class="sxs-lookup"><span data-stu-id="80afb-158">Channel</span></span>](channel.md)
-   [<span data-ttu-id="80afb-159">Microsoft RPC</span><span class="sxs-lookup"><span data-stu-id="80afb-159">Microsoft RPC</span></span>](microsoft-rpc.md)

## <a name="related-topics"></a><span data-ttu-id="80afb-160">Zugehörige Themen</span><span class="sxs-lookup"><span data-stu-id="80afb-160">Related topics</span></span>

<dl> <dt>

[<span data-ttu-id="80afb-161">COM-Clients und-Server</span><span class="sxs-lookup"><span data-stu-id="80afb-161">COM Clients and Servers</span></span>](com-clients-and-servers.md)
</dt> <dt>

[<span data-ttu-id="80afb-162">Schnittstellenmarshalling</span><span class="sxs-lookup"><span data-stu-id="80afb-162">Interface Marshaling</span></span>](interface-marshaling.md)
</dt> </dl>

 

 