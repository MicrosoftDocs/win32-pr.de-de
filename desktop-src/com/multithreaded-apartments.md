---
title: Multithread-Apartments
description: Multithread-Apartments
ms.assetid: d3e6acd9-cd5c-4a2c-8526-4f43db3b606b
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: dc2594f9341fc662b068fb7e007e538282a31273
ms.sourcegitcommit: 5f33645661bf8c825a7a2e73950b1f4ea0f1cd82
ms.translationtype: MT
ms.contentlocale: de-DE
ms.lasthandoff: 08/21/2020
ms.locfileid: "106337471"
---
# <a name="multithreaded-apartments"></a><span data-ttu-id="1950f-103">Multithread-Apartments</span><span class="sxs-lookup"><span data-stu-id="1950f-103">Multithreaded Apartments</span></span>

<span data-ttu-id="1950f-104">In einem Multithread-Apartment Modell befinden sich alle Threads im Prozess, die als "freigegeben" initialisiert wurden, in einem einzigen Apartment.</span><span class="sxs-lookup"><span data-stu-id="1950f-104">In a multithreaded apartment model, all the threads in the process that have been initialized as free-threaded reside in a single apartment.</span></span> <span data-ttu-id="1950f-105">Daher ist es nicht erforderlich, zwischen Threads zu Mars Hallen.</span><span class="sxs-lookup"><span data-stu-id="1950f-105">Therefore, there is no need to marshal between threads.</span></span> <span data-ttu-id="1950f-106">Die Threads müssen keine Nachrichten abrufen und verteilen, weil com in diesem Modell keine Fenster Meldungen verwendet.</span><span class="sxs-lookup"><span data-stu-id="1950f-106">The threads need not retrieve and dispatch messages because COM does not use window messages in this model.</span></span>

<span data-ttu-id="1950f-107">Aufrufe von-Methoden von Objekten im Multithreadapartment können in jedem beliebigen Thread im Apartment ausgeführt werden.</span><span class="sxs-lookup"><span data-stu-id="1950f-107">Calls to methods of objects in the multithreaded apartment can be run on any thread in the apartment.</span></span> <span data-ttu-id="1950f-108">Es ist keine Serialisierung von Aufrufen vorhanden. viele Aufrufe können gleichzeitig an dieselbe Methode oder an dasselbe Objekt erfolgen.</span><span class="sxs-lookup"><span data-stu-id="1950f-108">There is no serialization of calls; many calls may occur to the same method or to the same object simultaneously.</span></span> <span data-ttu-id="1950f-109">Objekte, die im Multithreadapartment erstellt werden, müssen jederzeit Aufrufe ihrer Methoden aus anderen Threads verarbeiten können.</span><span class="sxs-lookup"><span data-stu-id="1950f-109">Objects created in the multithreaded apartment must be able to handle calls on their methods from other threads at any time.</span></span>

<span data-ttu-id="1950f-110">Da Aufrufe von Objekten in keiner Weise serialisiert werden, bietet die Parallelität von multithreadobjekten die höchste Leistung und nutzt die Vorteile der Multiprozessorhardware für Thread übergreifende, prozessübergreifende und Computer übergreifende Aufrufe.</span><span class="sxs-lookup"><span data-stu-id="1950f-110">Because calls to objects are not serialized in any way, multithreaded object concurrency offers the highest performance and takes the best advantage of multiprocessor hardware for cross-thread, cross-process, and cross-machine calling.</span></span> <span data-ttu-id="1950f-111">Dies bedeutet jedoch, dass der Code für-Objekte in den Schnittstellen Implementierungen synchronisiert werden muss, in der Regel durch die Verwendung von Synchronisierungs primitiven, z. b. Ereignis Objekten, kritischen Abschnitten, Mutexen oder Semaphoren, die weiter unten in diesem Abschnitt beschrieben werden.</span><span class="sxs-lookup"><span data-stu-id="1950f-111">This means, however, that the code for objects must provide synchronization in their interface implementations, typically through the use of synchronization primitives such as event objects, critical sections, mutexes, or semaphores, which are described later in this section.</span></span> <span data-ttu-id="1950f-112">Da das-Objekt die Lebensdauer der Threads, die darauf zugreifen, nicht steuert, kann außerdem kein Thread spezifischer Zustand im-Objekt (im lokalen Thread Speicher) gespeichert werden.</span><span class="sxs-lookup"><span data-stu-id="1950f-112">In addition, because the object doesn't control the lifetime of the threads that are accessing it, no thread-specific state may be stored in the object (in thread local storage).</span></span>

<span data-ttu-id="1950f-113">Im folgenden finden Sie einige wichtige Überlegungen bezüglich der Synchronisierung für Multithread-Apartments:</span><span class="sxs-lookup"><span data-stu-id="1950f-113">Following are some important considerations regarding synchronization for multithreaded apartments:</span></span>

-   <span data-ttu-id="1950f-114">COM bietet nur eine Synchronisierung für Single Thread-Apartments.</span><span class="sxs-lookup"><span data-stu-id="1950f-114">COM provides call synchronization for single-threaded apartments only.</span></span>
-   <span data-ttu-id="1950f-115">Multithread-Apartments empfangen keine Aufrufe, während Aufrufe (auf demselben Thread) aufgerufen werden.</span><span class="sxs-lookup"><span data-stu-id="1950f-115">Multithreaded apartments do not receive calls while making calls (on the same thread).</span></span>
-   <span data-ttu-id="1950f-116">Multithread-Apartments können keine Eingabe synchronisierten Aufrufe durchführen.</span><span class="sxs-lookup"><span data-stu-id="1950f-116">Multithreaded apartments cannot make input-synchronized calls.</span></span>
-   <span data-ttu-id="1950f-117">Asynchrone Aufrufe werden in Multithread-Apartments in synchrone Aufrufe konvertiert.</span><span class="sxs-lookup"><span data-stu-id="1950f-117">Asynchronous calls are converted to synchronous calls in multithreaded apartments.</span></span>
-   <span data-ttu-id="1950f-118">Der Nachrichtenfilter wird nicht für einen Thread in einem Multithread-Apartment aufgerufen.</span><span class="sxs-lookup"><span data-stu-id="1950f-118">The message filter is not called for any thread in a multithreaded apartment.</span></span>

<span data-ttu-id="1950f-119">Um einen Thread als frei Thread zu initialisieren, können Sie [**CoInitializeEx**](/windows/desktop/api/combaseapi/nf-combaseapi-coinitializeex)aufrufen, indem Sie coinit \_ Multithreaded angeben.</span><span class="sxs-lookup"><span data-stu-id="1950f-119">To initialize a thread as free-threaded, call [**CoInitializeEx**](/windows/desktop/api/combaseapi/nf-combaseapi-coinitializeex), specifying COINIT\_MULTITHREADED.</span></span> <span data-ttu-id="1950f-120">Informationen zum Threading in-Process-Server finden Sie unter [Prozess interne Server Threading Probleme](in-process-server-threading-issues.md).</span><span class="sxs-lookup"><span data-stu-id="1950f-120">For information on in-process server threading, see [In-Process Server Threading Issues](in-process-server-threading-issues.md).</span></span>

<span data-ttu-id="1950f-121">Mehrere Clients können gleichzeitig von unterschiedlichen Threads aus auf ein Objekt, das das kostenlose Threading unterstützt, abrufen.</span><span class="sxs-lookup"><span data-stu-id="1950f-121">Multiple clients can simultaneously call, from different threads, an object that supports free-threading.</span></span> <span data-ttu-id="1950f-122">In frei Thread-Prozess externen Servern erstellt com über das RPC-Subsystem einen Thread Pool im Server Prozess, und ein Client Aufruf (oder mehrere Client Aufrufe) kann von jedem dieser Threads jederzeit übermittelt werden.</span><span class="sxs-lookup"><span data-stu-id="1950f-122">In free-threaded out-of-process servers, COM, through the RPC subsystem, creates a pool of threads in the server process and a client call (or multiple client calls) can be delivered by any of these threads at any time.</span></span> <span data-ttu-id="1950f-123">Außerdem muss ein Prozess interner Server die Synchronisierung in seiner Klassenfactory implementieren.</span><span class="sxs-lookup"><span data-stu-id="1950f-123">An out-of-process server must also implement synchronization in its class factory.</span></span> <span data-ttu-id="1950f-124">Frei Thread interne Objekte können direkte Aufrufe von mehreren Threads des Clients empfangen.</span><span class="sxs-lookup"><span data-stu-id="1950f-124">Free-threaded, in-process objects can receive direct calls from multiple threads of the client.</span></span>

<span data-ttu-id="1950f-125">Der Client kann com in mehreren Threads verwenden.</span><span class="sxs-lookup"><span data-stu-id="1950f-125">The client can do COM work in multiple threads.</span></span> <span data-ttu-id="1950f-126">Alle Threads gehören zum selben Multithreadapartment.</span><span class="sxs-lookup"><span data-stu-id="1950f-126">All threads belong to the same multithreaded apartment.</span></span> <span data-ttu-id="1950f-127">Schnittstellen Zeiger werden direkt von einem Thread an einen Thread in einem Multithread-Apartment übermittelt, sodass Schnittstellen Zeiger nicht zwischen ihren Threads gemarshallt werden.</span><span class="sxs-lookup"><span data-stu-id="1950f-127">Interface pointers are passed directly from thread to thread within a multithreaded apartment, so interface pointers are not marshaled between its threads.</span></span> <span data-ttu-id="1950f-128">Nachrichtenfilter (Implementierungen von [**IMessageFilter**](/windows/desktop/api/ObjIdl/nn-objidl-imessagefilter)) werden in Multithread-Apartments nicht verwendet.</span><span class="sxs-lookup"><span data-stu-id="1950f-128">Message filters (implementations of [**IMessageFilter**](/windows/desktop/api/ObjIdl/nn-objidl-imessagefilter)) are not used in multithreaded apartments.</span></span> <span data-ttu-id="1950f-129">Der Client Thread wird angehalten, wenn er out-of-Apartment-Objekte aufruft und fortgesetzt wird, wenn der-Rückruf zurückgegeben wird.</span><span class="sxs-lookup"><span data-stu-id="1950f-129">The client thread will suspend when it makes a COM call to out-of-apartment objects and will resume when the call returns.</span></span> <span data-ttu-id="1950f-130">Aufrufe zwischen Prozessen werden weiterhin von RPC verarbeitet.</span><span class="sxs-lookup"><span data-stu-id="1950f-130">Calls between processes are still handled by RPC.</span></span>

<span data-ttu-id="1950f-131">Mit dem frei Hand Thread Modell initialisierte Threads müssen eine eigene Synchronisierung implementieren.</span><span class="sxs-lookup"><span data-stu-id="1950f-131">Threads initialized with the free-threaded model must implement their own synchronization.</span></span> <span data-ttu-id="1950f-132">Wie bereits weiter oben in diesem Abschnitt erwähnt, aktiviert Windows diese Implementierung durch die folgenden Synchronisierungs primitiven:</span><span class="sxs-lookup"><span data-stu-id="1950f-132">As mentioned earlier in this section, Windows enables this implementation through the following synchronization primitives:</span></span>

-   <span data-ttu-id="1950f-133">Ereignis Objekte bieten eine Möglichkeit, einen oder mehrere Threads zu signalisieren, dass ein Ereignis aufgetreten ist.</span><span class="sxs-lookup"><span data-stu-id="1950f-133">Event objects provide a way of signaling one or more threads that an event has occurred.</span></span> <span data-ttu-id="1950f-134">Jeder Thread in einem Prozess kann ein Ereignis Objekt erstellen.</span><span class="sxs-lookup"><span data-stu-id="1950f-134">Any thread within a process can create an event object.</span></span> <span data-ttu-id="1950f-135">Ein Handle für das-Ereignis wird von der Ereignis Erstellungsfunktion (" [**kreateevent**](/windows/desktop/api/synchapi/nf-synchapi-createeventa)") zurückgegeben.</span><span class="sxs-lookup"><span data-stu-id="1950f-135">A handle to the event is returned by the event-creating function, [**CreateEvent**](/windows/desktop/api/synchapi/nf-synchapi-createeventa).</span></span> <span data-ttu-id="1950f-136">Nachdem ein Ereignis Objekt erstellt wurde, können Threads mit einem Handle für das Objekt darauf warten, bevor die Ausführung fortgesetzt wird.</span><span class="sxs-lookup"><span data-stu-id="1950f-136">Once an event object has been created, threads with a handle to the object can wait on it before continuing execution.</span></span>
-   <span data-ttu-id="1950f-137">Kritische Abschnitte werden für einen Code Abschnitt verwendet, der exklusiven Zugriff auf einen Satz frei gegebener Daten erfordert, bevor er ausgeführt werden kann und der nur von den Threads innerhalb eines einzelnen Prozesses verwendet wird.</span><span class="sxs-lookup"><span data-stu-id="1950f-137">Critical sections are used for a section of code that requires exclusive access to some set of shared data before it can be executed and that is used only by the threads within a single process.</span></span> <span data-ttu-id="1950f-138">Ein kritischer Abschnitt entspricht einem einzigen Thread, über den nur ein Thread zu einem Zeitpunkt ausgeführt werden kann, der wie folgt funktioniert:</span><span class="sxs-lookup"><span data-stu-id="1950f-138">A critical section is like a turnstile through which only one thread at a time may pass, working as follows:</span></span>
    -   <span data-ttu-id="1950f-139">Um sicherzustellen, dass nicht mehr als ein Thread gleichzeitig auf freigegebene Daten zugreift, ordnet der primäre Thread eines Prozesses eine globale kritische \_ Abschnitts Datenstruktur zu und initialisiert seine Member.</span><span class="sxs-lookup"><span data-stu-id="1950f-139">To ensure that no more than one thread at a time accesses shared data, a process's primary thread allocates a global CRITICAL\_SECTION data structure and initializes its members.</span></span> <span data-ttu-id="1950f-140">Ein Thread, der einen kritischen Abschnitt eingibt, ruft die Funktion " [**EnterCriticalSection**](/windows/desktop/api/synchapi/nf-synchapi-entercriticalsection) " auf und ändert die Elemente der Datenstruktur.</span><span class="sxs-lookup"><span data-stu-id="1950f-140">A thread entering a critical section calls the [**EnterCriticalSection**](/windows/desktop/api/synchapi/nf-synchapi-entercriticalsection) function and modifies the data structure's members.</span></span>
    -   <span data-ttu-id="1950f-141">Ein Thread, der versucht, einen kritischen Abschnitt einzugeben, Ruft den [**EnterCriticalSection**](/windows/desktop/api/synchapi/nf-synchapi-entercriticalsection) auf, der überprüft, ob die \_ Datenstruktur des kritischen Abschnitts geändert wurde.</span><span class="sxs-lookup"><span data-stu-id="1950f-141">A thread attempting to enter a critical section calls [**EnterCriticalSection**](/windows/desktop/api/synchapi/nf-synchapi-entercriticalsection) which checks to see whether the CRITICAL\_SECTION data structure has been modified.</span></span> <span data-ttu-id="1950f-142">Wenn dies der Fall ist, befindet sich derzeit ein anderer Thread im kritischen Abschnitt und der nachfolgende Thread wird in den Standbymodus versetzt.</span><span class="sxs-lookup"><span data-stu-id="1950f-142">If so, another thread is currently in the critical section and the subsequent thread is put to sleep.</span></span> <span data-ttu-id="1950f-143">Ein Thread, der einen kritischen Abschnitt verlässt, Ruft den [**LeaveCriticalSection**](/windows/desktop/api/synchapi/nf-synchapi-leavecriticalsection)auf, der die Datenstruktur zurücksetzt.</span><span class="sxs-lookup"><span data-stu-id="1950f-143">A thread leaving a critical section calls [**LeaveCriticalSection**](/windows/desktop/api/synchapi/nf-synchapi-leavecriticalsection), which resets the data structure.</span></span> <span data-ttu-id="1950f-144">Wenn ein Thread einen kritischen Abschnitt verlässt, aktiviert das System einen der inaktiven Threads, der dann in den kritischen Abschnitt gelangt.</span><span class="sxs-lookup"><span data-stu-id="1950f-144">When a thread leaves a critical section, the system wakes one of the sleeping threads, which then enters the critical section.</span></span>
-   <span data-ttu-id="1950f-145">Mutexes führt die gleiche Funktion wie ein kritischer Abschnitt aus, mit dem Unterschied, dass der Mutex für Threads zugänglich ist, die in verschiedenen Prozessen ausgeführt werden.</span><span class="sxs-lookup"><span data-stu-id="1950f-145">Mutexes performs the same function as a critical section, except that the mutex is accessible to threads running in different processes.</span></span> <span data-ttu-id="1950f-146">Das Besitz eines Mutex-Objekts ist wie der Fußboden in einer Debatte.</span><span class="sxs-lookup"><span data-stu-id="1950f-146">Owning a mutex object is like having the floor in a debate.</span></span> <span data-ttu-id="1950f-147">Ein Prozess erstellt ein Mutex-Objekt durch Aufrufen der [**CreateMutex**](/windows/desktop/api/synchapi/nf-synchapi-createmutexa) -Funktion, die ein Handle zurückgibt.</span><span class="sxs-lookup"><span data-stu-id="1950f-147">A process creates a mutex object by calling the [**CreateMutex**](/windows/desktop/api/synchapi/nf-synchapi-createmutexa) function, which returns a handle.</span></span> <span data-ttu-id="1950f-148">Der erste Thread, der ein Mutex-Objekt anfordert, erhält den Besitz.</span><span class="sxs-lookup"><span data-stu-id="1950f-148">The first thread requesting a mutex object obtains ownership of it.</span></span> <span data-ttu-id="1950f-149">Wenn der Thread mit dem Mutex fertig ist, übergibt der Besitz an andere Threads auf der Grundlage von First-Come, first-served.</span><span class="sxs-lookup"><span data-stu-id="1950f-149">When the thread has finished with the mutex, ownership passes to other threads on a first-come, first-served basis.</span></span>
-   <span data-ttu-id="1950f-150">Semaphoren werden verwendet, um einen Verweis Zähler für eine verfügbare Ressource beizubehalten.</span><span class="sxs-lookup"><span data-stu-id="1950f-150">Semaphores are used to maintain a reference count on some available resource.</span></span> <span data-ttu-id="1950f-151">Ein Thread erstellt eine Semaphor für eine Ressource, indem er die Funktion [**CreateSemaphore**](/windows/desktop/api/winbase/nf-winbase-createsemaphorea) anfordert und einen Zeiger auf die Ressource, eine anfängliche Ressourcen Anzahl und die maximale Ressourcen Anzahl übergibt.</span><span class="sxs-lookup"><span data-stu-id="1950f-151">A thread creates a semaphore for a resource by calling the [**CreateSemaphore**](/windows/desktop/api/winbase/nf-winbase-createsemaphorea) function and passing a pointer to the resource, an initial resource count, and the maximum resource count.</span></span> <span data-ttu-id="1950f-152">Diese Funktion gibt ein Handle zurück.</span><span class="sxs-lookup"><span data-stu-id="1950f-152">This function returns a handle.</span></span> <span data-ttu-id="1950f-153">Ein Thread, der eine Ressource anfordert, übergibt seinen Semaphor-Handle in einem Rückruf der [**WaitForSingleObject**](/windows/desktop/api/synchapi/nf-synchapi-waitforsingleobject) -Funktion.</span><span class="sxs-lookup"><span data-stu-id="1950f-153">A thread requesting a resource passes its semaphore handle in a call to the [**WaitForSingleObject**](/windows/desktop/api/synchapi/nf-synchapi-waitforsingleobject) function.</span></span> <span data-ttu-id="1950f-154">Das Semaphor-Objekt fragt die Ressource ab, um zu bestimmen, ob Sie verfügbar ist.</span><span class="sxs-lookup"><span data-stu-id="1950f-154">The semaphore object polls the resource to determine whether it is available.</span></span> <span data-ttu-id="1950f-155">Wenn dies der Fall ist, verringert das Semaphor die Ressourcen Anzahl und aktiviert den wartenden Thread.</span><span class="sxs-lookup"><span data-stu-id="1950f-155">If so, the semaphore decrements the resource count and wakes the waiting thread.</span></span> <span data-ttu-id="1950f-156">Wenn die Anzahl 0 (null) ist, bleibt der Thread in den Standbymodus, bis ein anderer Thread eine Ressource freigibt, wodurch die Anzahl der Semaphor um 1 erhöht wird.</span><span class="sxs-lookup"><span data-stu-id="1950f-156">If the count is zero, the thread remains asleep until another thread releases a resource, causing the semaphore to increment the count to one.</span></span>

## <a name="related-topics"></a><span data-ttu-id="1950f-157">Zugehörige Themen</span><span class="sxs-lookup"><span data-stu-id="1950f-157">Related topics</span></span>

<dl> <dt>

[<span data-ttu-id="1950f-158">Zugreifen auf Schnittstellen über mehrere Apartments</span><span class="sxs-lookup"><span data-stu-id="1950f-158">Accessing Interfaces Across Apartments</span></span>](accessing-interfaces-across-apartments.md)
</dt> <dt>

[<span data-ttu-id="1950f-159">Auswählen des Threading Modells</span><span class="sxs-lookup"><span data-stu-id="1950f-159">Choosing the Threading Model</span></span>](choosing-the-threading-model.md)
</dt> <dt>

[<span data-ttu-id="1950f-160">Threading Probleme im Prozess internen Server</span><span class="sxs-lookup"><span data-stu-id="1950f-160">In-Process Server Threading Issues</span></span>](in-process-server-threading-issues.md)
</dt> <dt>

[<span data-ttu-id="1950f-161">Prozesse, Threads und Apartments</span><span class="sxs-lookup"><span data-stu-id="1950f-161">Processes, Threads, and Apartments</span></span>](processes--threads--and-apartments.md)
</dt> <dt>

[<span data-ttu-id="1950f-162">Single Thread-und Multithread-Kommunikation</span><span class="sxs-lookup"><span data-stu-id="1950f-162">Single-Threaded and Multithreaded Communication</span></span>](single-threaded-and-multithreaded-communication.md)
</dt> <dt>

[<span data-ttu-id="1950f-163">Single Thread-Apartments</span><span class="sxs-lookup"><span data-stu-id="1950f-163">Single-Threaded Apartments</span></span>](single-threaded-apartments.md)
</dt> </dl>

 

 