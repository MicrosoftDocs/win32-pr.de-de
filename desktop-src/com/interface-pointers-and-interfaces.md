---
title: Interface Pointers and Interfaces (Schnittstellenzeiger und Schnittstellen)
description: Interface Pointers and Interfaces (Schnittstellenzeiger und Schnittstellen)
ms.assetid: 8a8671fe-f0b2-4698-8c98-89753fffce0b
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: aa23d53f529c43fa7529d657108cc75cb6a23b15
ms.sourcegitcommit: d482e4276cc06515e9fade2f253a257ffc418ce5
ms.translationtype: MT
ms.contentlocale: de-DE
ms.lasthandoff: 08/24/2019
ms.locfileid: "106337545"
---
# <a name="interface-pointers-and-interfaces"></a><span data-ttu-id="fa2c3-103">Interface Pointers and Interfaces (Schnittstellenzeiger und Schnittstellen)</span><span class="sxs-lookup"><span data-stu-id="fa2c3-103">Interface Pointers and Interfaces</span></span>

<span data-ttu-id="fa2c3-104">Eine Instanz einer Schnittstellen Implementierung ist tatsächlich ein Zeiger auf ein Array von Zeigern auf Methoden, d. h. eine Funktions Tabelle, die auf eine Implementierung aller Methoden verweist, die in der-Schnittstelle angegeben sind.</span><span class="sxs-lookup"><span data-stu-id="fa2c3-104">An instance of an interface implementation is actually a pointer to an array of pointers to methods - that is, a function table that refers to an implementation of all of the methods specified in the interface.</span></span> <span data-ttu-id="fa2c3-105">Objekte mit mehreren Schnittstellen können Zeiger auf mehr als eine Funktions Tabelle bereitstellen.</span><span class="sxs-lookup"><span data-stu-id="fa2c3-105">Objects with multiple interfaces can provide pointers to more than one function table.</span></span> <span data-ttu-id="fa2c3-106">Jeder Code, der über einen Zeiger verfügt, über den er auf das Array zugreifen kann, kann die Methoden in dieser Schnittstelle aufrufen.</span><span class="sxs-lookup"><span data-stu-id="fa2c3-106">Any code that has a pointer through which it can access the array can call the methods in that interface.</span></span>

<span data-ttu-id="fa2c3-107">Genau diese mehrfache Dereferenzierung ist unpraktisch, daher wird der Zeiger auf die Schnittstellen Funktions Tabelle, die ein anderes Objekt zum Aufrufen seiner Methoden benötigen muss, einfach als *Schnittstellen Zeiger* bezeichnet.</span><span class="sxs-lookup"><span data-stu-id="fa2c3-107">Speaking precisely about this multiple indirection is inconvenient, so instead, the pointer to the interface function table that another object must have to call its methods is called simply an *interface pointer*.</span></span> <span data-ttu-id="fa2c3-108">Sie können Funktionstabellen in einer C-Anwendung oder fast automatisch mithilfe von Visual C++ (oder anderen objektorientierten Sprachen, die com unterstützen) manuell erstellen.</span><span class="sxs-lookup"><span data-stu-id="fa2c3-108">You can manually create function tables in a C application or almost automatically by using Visual C++ (or other object-oriented languages that support COM).</span></span>

<span data-ttu-id="fa2c3-109">Mit der entsprechenden Compilerunterstützung (die in C und C++ verankert ist) kann ein Client eine Schnittstellen Methode über den Namen, nicht die Position im Array, abrufen.</span><span class="sxs-lookup"><span data-stu-id="fa2c3-109">With appropriate compiler support (which is inherent in C and C++), a client can call an interface method through its name, not its position in the array.</span></span> <span data-ttu-id="fa2c3-110">Da es sich bei einer Schnittstelle um einen-Typ handelt, kann der Compiler die Typen von Parametern und Rückgabewerte für die einzelnen Schnittstellen Methodenaufrufe überprüfen.</span><span class="sxs-lookup"><span data-stu-id="fa2c3-110">Because an interface is a type, the compiler, given the names of methods, can check the types of parameters and return values of each interface method call.</span></span> <span data-ttu-id="fa2c3-111">Wenn ein Client dagegen ein Positions basiertes Aufruf Schema verwendet, ist diese Typüberprüfung auch in C oder C++ nicht verfügbar.</span><span class="sxs-lookup"><span data-stu-id="fa2c3-111">In contrast, if a client uses a position-based calling scheme, such type-checking is not available, even in C or C++.</span></span>

<span data-ttu-id="fa2c3-112">Jede Schnittstelle ist ein unveränderlicher Vertrag einer funktionalen Gruppe von Methoden.</span><span class="sxs-lookup"><span data-stu-id="fa2c3-112">Each interface is an immutable contract of a functional group of methods.</span></span> <span data-ttu-id="fa2c3-113">Sie verweisen zur Laufzeit auf eine Schnittstelle mit einer global eindeutigen Schnittstellen-ID (IID).</span><span class="sxs-lookup"><span data-stu-id="fa2c3-113">You reference an interface at run time with a globally unique interface identifier (IID).</span></span> <span data-ttu-id="fa2c3-114">Diese IID, bei der es sich um eine bestimmte Instanz einer von com unterstützten Globally Unique Identifier (GUID) handelt, ermöglicht einem Client, ein Objekt genau anzufordern, unabhängig davon, ob es die Semantik der Schnittstelle unterstützt, ohne unnötige Aufwand und ohne die Verwirrung, die in einem System aufgrund der Verwendung mehrerer Versionen derselben Schnittstelle mit dem gleichen Namen auftreten könnte.</span><span class="sxs-lookup"><span data-stu-id="fa2c3-114">This IID, which is a specific instance of a globally unique identifier (GUID) supported by COM, allows a client to ask an object precisely whether it supports the semantics of the interface, without unnecessary overhead and without the confusion that could arise in a system from having multiple versions of the same interface with the same name.</span></span>

<span data-ttu-id="fa2c3-115">Zusammenfassend ist es wichtig, zu verstehen, was eine COM-Schnittstelle ist, und ist nicht:</span><span class="sxs-lookup"><span data-stu-id="fa2c3-115">To summarize, it is important to understand what a COM interface is, and is not:</span></span>

-   <span data-ttu-id="fa2c3-116">Eine COM-Schnittstelle ist nicht mit einer C++-Klasse identisch.</span><span class="sxs-lookup"><span data-stu-id="fa2c3-116">A COM interface is not the same as a C++ class.</span></span> <span data-ttu-id="fa2c3-117">Die rein virtuelle Definition enthält keine Implementierung.</span><span class="sxs-lookup"><span data-stu-id="fa2c3-117">The pure virtual definition carries no implementation.</span></span> <span data-ttu-id="fa2c3-118">Wenn Sie ein C++-Programmierer sind, können Sie die Implementierung einer Schnittstelle als Klasse definieren. Dies liegt jedoch unter der Überschrift der Implementierungsdetails, die com nicht angibt.</span><span class="sxs-lookup"><span data-stu-id="fa2c3-118">If you are a C++ programmer, you can define your implementation of an interface as a class, but this falls under the heading of implementation details, which COM does not specify.</span></span> <span data-ttu-id="fa2c3-119">Eine Instanz eines Objekts, das eine Schnittstelle implementiert, muss erstellt werden, damit die Schnittstelle tatsächlich vorhanden ist.</span><span class="sxs-lookup"><span data-stu-id="fa2c3-119">An instance of an object that implements an interface must be created for the interface actually to exist.</span></span> <span data-ttu-id="fa2c3-120">Darüber hinaus können unterschiedliche Objektklassen eine Schnittstelle anders implementieren, aber Sie können in Binär Form austauschbar verwendet werden, solange das Verhalten der Schnittstellen Definition entspricht.</span><span class="sxs-lookup"><span data-stu-id="fa2c3-120">Furthermore, different object classes may implement an interface differently yet be used interchangeably in binary form, as long as the behavior conforms to the interface definition.</span></span>
-   <span data-ttu-id="fa2c3-121">Eine COM-Schnittstelle ist kein Objekt.</span><span class="sxs-lookup"><span data-stu-id="fa2c3-121">A COM interface is not an object.</span></span> <span data-ttu-id="fa2c3-122">Es handelt sich einfach um eine verwandte Gruppe von Funktionen und ist der binäre Standard, über den Clients und Objekte kommunizieren.</span><span class="sxs-lookup"><span data-stu-id="fa2c3-122">It is simply a related group of functions and is the binary standard through which clients and objects communicate.</span></span> <span data-ttu-id="fa2c3-123">Solange Sie Zeiger auf Schnittstellen Methoden bereitstellen kann, kann das Objekt in jeder beliebigen Sprache mit einer beliebigen internen Zustands Darstellung implementiert werden.</span><span class="sxs-lookup"><span data-stu-id="fa2c3-123">As long as it can provide pointers to interface methods, the object can be implemented in any language with any internal state representation.</span></span>
-   <span data-ttu-id="fa2c3-124">COM-Schnittstellen sind stark typisiert.</span><span class="sxs-lookup"><span data-stu-id="fa2c3-124">COM interfaces are strongly typed.</span></span> <span data-ttu-id="fa2c3-125">Jede Schnittstelle verfügt über eine eigene Schnittstellen-ID (eine GUID), die die Möglichkeit der Duplizierung überflüssig macht, die mit einem anderen Benennungs Schema auftreten könnte.</span><span class="sxs-lookup"><span data-stu-id="fa2c3-125">Every interface has its own interface identifier (a GUID), which eliminates the possibility of duplication that could occur with any other naming scheme.</span></span>
-   <span data-ttu-id="fa2c3-126">COM-Schnittstellen sind unveränderlich.</span><span class="sxs-lookup"><span data-stu-id="fa2c3-126">COM interfaces are immutable.</span></span> <span data-ttu-id="fa2c3-127">Sie können keine neue Version einer alten Schnittstelle definieren und Ihr denselben Bezeichner zuordnen.</span><span class="sxs-lookup"><span data-stu-id="fa2c3-127">You cannot define a new version of an old interface and give it the same identifier.</span></span> <span data-ttu-id="fa2c3-128">Durch das Hinzufügen oder Entfernen von Methoden einer Schnittstelle oder das Ändern der Semantik wird eine neue Schnittstelle erstellt, nicht die neue Version einer alten Schnittstelle.</span><span class="sxs-lookup"><span data-stu-id="fa2c3-128">Adding or removing methods of an interface or changing semantics creates a new interface, not a new version of an old interface.</span></span> <span data-ttu-id="fa2c3-129">Daher kann eine neue Schnittstelle nicht mit einer alten Schnittstelle in Konflikt stehen.</span><span class="sxs-lookup"><span data-stu-id="fa2c3-129">Therefore, a new interface cannot conflict with an old interface.</span></span> <span data-ttu-id="fa2c3-130">Allerdings können-Objekte mehrere Schnittstellen gleichzeitig unterstützen und Schnittstellen verfügbar machen, die aufeinander folgende Revisionen einer Schnittstelle mit unterschiedlichen bezeichlern sind.</span><span class="sxs-lookup"><span data-stu-id="fa2c3-130">However, objects can support multiple interfaces simultaneously and can expose interfaces that are successive revisions of an interface, with different identifiers.</span></span> <span data-ttu-id="fa2c3-131">Folglich ist jede Schnittstelle ein separater Vertrag, und systemweite Objekte müssen nicht darauf achten, ob die Version der Schnittstelle, die Sie aufrufen, die erwartete Version der Schnittstelle ist.</span><span class="sxs-lookup"><span data-stu-id="fa2c3-131">Thus, each interface is a separate contract, and systemwide objects need not be concerned about whether the version of the interface they are calling is the one they expect.</span></span> <span data-ttu-id="fa2c3-132">Die Schnittstellen-ID (IID) definiert den Schnittstellen Vertrag explizit und eindeutig.</span><span class="sxs-lookup"><span data-stu-id="fa2c3-132">The interface ID (IID) defines the interface contract explicitly and uniquely.</span></span>

## <a name="related-topics"></a><span data-ttu-id="fa2c3-133">Zugehörige Themen</span><span class="sxs-lookup"><span data-stu-id="fa2c3-133">Related topics</span></span>

<dl> <dt>

[<span data-ttu-id="fa2c3-134">COM-Objekte und-Schnittstellen</span><span class="sxs-lookup"><span data-stu-id="fa2c3-134">COM Objects and Interfaces</span></span>](com-objects-and-interfaces.md)
</dt> </dl>

 

 




