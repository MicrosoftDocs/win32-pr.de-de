---
title: Verwalten von Objekt Lebensdauern durch Verweis Zählung
description: Verwalten von Objekt Lebensdauern durch Verweis Zählung
ms.assetid: 7f9da5a9-0435-431c-8f90-56e2e489c431
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: 7aac184baea9198721e6cdf9c0444a8c6431db08
ms.sourcegitcommit: f0ca63c18dc52c357d3398af7be766d2bdd40be7
ms.translationtype: MT
ms.contentlocale: de-DE
ms.lasthandoff: 06/17/2020
ms.locfileid: "106338248"
---
# <a name="managing-object-lifetimes-through-reference-counting"></a><span data-ttu-id="3db00-103">Verwalten von Objekt Lebensdauern durch Verweis Zählung</span><span class="sxs-lookup"><span data-stu-id="3db00-103">Managing Object Lifetimes Through Reference Counting</span></span>

<span data-ttu-id="3db00-104">In herkömmlichen Objekt Systemen wird der Lebenszyklus von Objekten – d. h. die Probleme im Zusammenhang mit der Erstellung und Löschung von Objekten – implizit von der Sprache (oder der Sprachlaufzeit) oder explizit von Anwendungs Programmierern behandelt.</span><span class="sxs-lookup"><span data-stu-id="3db00-104">In traditional object systems, the life cycle of objects—that is, the issues surrounding the creation and deletion of objects—is handled implicitly by the language (or the language run time) or explicitly by application programmers.</span></span>

<span data-ttu-id="3db00-105">In einem weiter entwickelten, dezentral konstruierten System, das aus wiederverwendeten Komponenten besteht, ist es nicht mehr wahr, dass ein Client oder sogar ein Programmierer immer "weiß", wie die Lebensdauer einer Komponente behandelt werden soll.</span><span class="sxs-lookup"><span data-stu-id="3db00-105">In an evolving, decentrally constructed system made up of reused components, it is no longer true that any client, or even any programmer, always "knows" how to deal with a component's lifetime.</span></span> <span data-ttu-id="3db00-106">Für einen Client mit den richtigen Sicherheits Berechtigungen ist es immer noch relativ einfach, Objekte über eine einfache Anforderung zu erstellen. das Löschen von Objekten ist jedoch eine andere Sache.</span><span class="sxs-lookup"><span data-stu-id="3db00-106">For a client with the right security privileges, it is still relatively easy to create objects through a simple request, but object deletion is another matter entirely.</span></span> <span data-ttu-id="3db00-107">Es ist nicht unbedingt klar, wenn ein Objekt nicht mehr benötigt wird und gelöscht werden soll.</span><span class="sxs-lookup"><span data-stu-id="3db00-107">It is not necessarily clear when an object is no longer needed and should be deleted.</span></span> <span data-ttu-id="3db00-108">(Leser, die mit der Garbage Collection vertraut sind, wie z. b. Java, unterliegen möglicherweise nicht, aber Java-Objekte umfassen keine Computer-oder sogar Prozess Grenzen, und daher ist die Garbage Collection auf Objekte beschränkt, die innerhalb eines einzelnen Prozess Raums Leben.</span><span class="sxs-lookup"><span data-stu-id="3db00-108">(Readers familiar with garbage-collected programming environments, such as Java, may disagree; however, Java objects do not span machine or even process boundaries, and therefore the garbage collection is restricted to objects living within a single-process space.</span></span> <span data-ttu-id="3db00-109">Außerdem erzwingt Java die Verwendung einer einzelnen Programmiersprache.) Auch wenn der ursprüngliche Client mit dem-Objekt ausgeführt wird, kann das Objekt nicht einfach heruntergefahren werden, da einige andere Clients oder Clients möglicherweise noch einen Verweis darauf haben.</span><span class="sxs-lookup"><span data-stu-id="3db00-109">In addition, Java forces the use of a single programming language.) Even when the original client is done with the object, it cannot simply shut the object down, because some other client or clients might still have a reference to it.</span></span>

<span data-ttu-id="3db00-110">Eine Möglichkeit, um sicherzustellen, dass ein Objekt nicht mehr benötigt wird, besteht darin, vollständig von einem zugrunde liegenden Kommunikationskanal zu abhängen, um das System zu informieren, wenn alle Verbindungen zu einem prozessübergreifenden oder kanalübergreifenden Objekt verschwunden sind.</span><span class="sxs-lookup"><span data-stu-id="3db00-110">One way to ensure that an object is no longer needed is to depend entirely on an underlying communication channel to inform the system when all connections to a cross-process or cross-channel object have disappeared.</span></span> <span data-ttu-id="3db00-111">Allerdings sind Schemas, die diese Methode verwenden, aus verschiedenen Gründen nicht zulässig.</span><span class="sxs-lookup"><span data-stu-id="3db00-111">However, schemes that use this method are unacceptable for several reasons.</span></span> <span data-ttu-id="3db00-112">Ein Problem besteht darin, dass es einen wesentlichen Unterschied zwischen dem prozessübergreifenden/Netzwerk übergreifenden Programmiermodell und dem Programmiermodell mit einem einzelnen Prozess erfordern könnte.</span><span class="sxs-lookup"><span data-stu-id="3db00-112">One problem is that it could require a major difference between the cross-process/cross-network programming model and the single-process programming model.</span></span> <span data-ttu-id="3db00-113">Im prozessübergreifenden/Netzwerk übergreifenden Programmiermodell stellt das Kommunikationssystem die für die Verwaltung der Objekt Lebensdauer erforderlichen Hooks bereit, während die Objekte im Einzel Prozess-Programmiermodell direkt ohne einen Beteiligten Kommunikationskanal verbunden sind.</span><span class="sxs-lookup"><span data-stu-id="3db00-113">In the cross-process/cross-network programming model, the communication system would provide the hooks necessary for object lifetime management, while in the single-process programming model, objects are directly connected without any intervening communications channel.</span></span> <span data-ttu-id="3db00-114">Ein weiteres Problem besteht darin, dass dieses Schema auch zu einer Ebene der vom System bereitgestellten Software führen könnte, die die Komponenten Leistung in der Prozess internen Groß-/Kleinschreibung beeinträchtigt.</span><span class="sxs-lookup"><span data-stu-id="3db00-114">Another problem is that this scheme could also result in a layer of system-provided software that would interfere with component performance in the in-process case.</span></span> <span data-ttu-id="3db00-115">Außerdem würde ein Mechanismus, der auf der expliziten Überwachung basiert, tendenziell nicht in Bezug auf Tausende oder Millionen von Objekten skaliert werden.</span><span class="sxs-lookup"><span data-stu-id="3db00-115">Furthermore, a mechanism based on explicit monitoring would not tend to scale toward many thousands or millions of objects.</span></span>

<span data-ttu-id="3db00-116">COM bietet einen skalierbaren und verteilten Ansatz zu diesem Satz von Problemen.</span><span class="sxs-lookup"><span data-stu-id="3db00-116">COM offers a scalable and distributed approach to this set of problems.</span></span> <span data-ttu-id="3db00-117">Clients weisen ein Objekt an, wenn es verwendet wird, und wenn es abgeschlossen ist, und Objekte löschen sich selbst, wenn Sie nicht mehr benötigt werden.</span><span class="sxs-lookup"><span data-stu-id="3db00-117">Clients tell an object when they are using it and when they are done, and objects delete themselves when they are no longer needed.</span></span> <span data-ttu-id="3db00-118">Dieser Ansatz gibt an, dass alle Objekte auf sich selbst verweisen.</span><span class="sxs-lookup"><span data-stu-id="3db00-118">This approach mandates that all objects count references to themselves.</span></span> <span data-ttu-id="3db00-119">Programmiersprachen, wie z. b. Java, die von Natur aus über eigene Lebensdauer Verwaltungs Schemas verfügen, wie z. b. Garbage Collection, können COM-Objekte verwenden, um COM-Objekte intern zu implementieren und zu verwenden, sodass der Programmierer keinen Umgang mit diesem</span><span class="sxs-lookup"><span data-stu-id="3db00-119">Programming languages such as Java, which inherently have their own lifetime management schemes, such as garbage collection, can use COM's reference counting to implement and use COM objects internally, allowing the programmer to avoid dealing with it.</span></span>

<span data-ttu-id="3db00-120">Ebenso wie eine Anwendung Arbeitsspeicher freigeben muss, nachdem der Arbeitsspeicher nicht mehr verwendet wird, ist der Client eines Objekts dafür verantwortlich, seine Verweise auf das Objekt freizugeben, wenn das Objekt nicht mehr benötigt wird.</span><span class="sxs-lookup"><span data-stu-id="3db00-120">Just as an application must free memory it has allocated once that memory is no longer in use, a client of an object is responsible for freeing its references to the object when that object is no longer needed.</span></span> <span data-ttu-id="3db00-121">In einem objektorientierten System kann der Client dies nur durchführen, indem er dem Objekt eine Anweisung zum Freigeben von sich selbst erteilt.</span><span class="sxs-lookup"><span data-stu-id="3db00-121">In an object-oriented system, the client can do this only by giving the object an instruction to free itself.</span></span>

<span data-ttu-id="3db00-122">Es ist wichtig, dass die Zuordnung eines Objekts aufgehoben wird, wenn es nicht mehr verwendet wird.</span><span class="sxs-lookup"><span data-stu-id="3db00-122">It is important that an object be deallocated when it is no longer being used.</span></span> <span data-ttu-id="3db00-123">Die Schwierigkeit besteht darin, zu bestimmen, wann das Zuweisen eines Objekts angebracht ist.</span><span class="sxs-lookup"><span data-stu-id="3db00-123">The difficulty lies in determining when it is appropriate to deallocate an object.</span></span> <span data-ttu-id="3db00-124">Dies ist mit automatischen Variablen (auf dem Stapel zugeordnete Variablen) leicht – Sie können nicht außerhalb des Blocks verwendet werden, in dem Sie deklariert sind, sodass der Compiler Sie zuordnet, wenn das Ende des Blocks erreicht ist.</span><span class="sxs-lookup"><span data-stu-id="3db00-124">This is easy with automatic variables (those allocated on the stack)—they cannot be used outside the block in which they're declared, so the compiler deallocates them when the end of the block is reached.</span></span> <span data-ttu-id="3db00-125">Bei COM-Objekten, die dynamisch zugeordnet werden, müssen die Clients eines Objekts entscheiden, wann das Objekt nicht mehr verwendet werden muss – insbesondere lokale oder Remote Objekte, die möglicherweise gleichzeitig von mehreren Clients verwendet werden.</span><span class="sxs-lookup"><span data-stu-id="3db00-125">For COM objects, which are dynamically allocated, it is up to the clients of an object to decide when they no longer need to use the object—especially local or remote objects that might be in use by multiple clients at the same time.</span></span> <span data-ttu-id="3db00-126">Das Objekt muss warten, bis alle Clients damit fertig sind, bevor es freigegeben wird.</span><span class="sxs-lookup"><span data-stu-id="3db00-126">The object must wait until all clients are finished with it before freeing itself.</span></span> <span data-ttu-id="3db00-127">Da com-Objekte über Schnittstellen Zeiger manipuliert werden und von Objekten in verschiedenen Prozessen oder anderen Computern verwendet werden können, kann das System die Clients eines Objekts nicht nachverfolgen.</span><span class="sxs-lookup"><span data-stu-id="3db00-127">Because COM objects are manipulated through interface pointers and can be used by objects in different processes or on other machines, the system cannot keep track of an object's clients.</span></span>

<span data-ttu-id="3db00-128">Die com-Methode, um zu bestimmen, wann es angemessen ist, das Zuordnen eines Objekts zu übernehmen, ist die manuelle Verweis Zählung</span><span class="sxs-lookup"><span data-stu-id="3db00-128">COM's method of determining when it is appropriate to deallocate an object is manual reference counting.</span></span> <span data-ttu-id="3db00-129">Jedes Objekt verwaltet einen Verweis Zähler, der nachverfolgt, wie viele Clients mit dem Objekt verbunden sind, d. h., wie viele Zeiger auf eine beliebige Schnittstelle in einem beliebigen Client vorhanden sind.</span><span class="sxs-lookup"><span data-stu-id="3db00-129">Each object maintains a reference count that tracks how many clients are connected to it - that is, how many pointers exist to any of its interfaces in any client.</span></span>

<span data-ttu-id="3db00-130">Weitere Informationen finden Sie unter den folgenden Themen:</span><span class="sxs-lookup"><span data-stu-id="3db00-130">For more information, see the following topics:</span></span>

-   [<span data-ttu-id="3db00-131">Implementieren der Verweis Zählung</span><span class="sxs-lookup"><span data-stu-id="3db00-131">Implementing Reference Counting</span></span>](implementing-reference-counting.md)
-   [<span data-ttu-id="3db00-132">Regeln für die Verwaltung von Verweis Zählungen</span><span class="sxs-lookup"><span data-stu-id="3db00-132">Rules for Managing Reference Counts</span></span>](rules-for-managing-reference-counts.md)

## <a name="related-topics"></a><span data-ttu-id="3db00-133">Zugehörige Themen</span><span class="sxs-lookup"><span data-stu-id="3db00-133">Related topics</span></span>

<dl> <dt>

[<span data-ttu-id="3db00-134">Verwenden und Implementieren von IUnknown</span><span class="sxs-lookup"><span data-stu-id="3db00-134">Using and Implementing IUnknown</span></span>](using-and-implementing-iunknown.md)
</dt> </dl>

 

 




