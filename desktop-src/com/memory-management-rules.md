---
title: Speicher Verwaltungsregeln
description: Speicher Verwaltungsregeln
ms.assetid: 769127a1-1a14-4ed4-9d38-7cf3e571b661
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: 56e7ad2483b794ec5c2e9c325bca8e469ff4ae0b
ms.sourcegitcommit: 5f33645661bf8c825a7a2e73950b1f4ea0f1cd82
ms.translationtype: MT
ms.contentlocale: de-DE
ms.lasthandoff: 08/21/2020
ms.locfileid: "104102439"
---
# <a name="memory-management-rules"></a><span data-ttu-id="11765-103">Speicher Verwaltungsregeln</span><span class="sxs-lookup"><span data-stu-id="11765-103">Memory Management Rules</span></span>

<span data-ttu-id="11765-104">Die Lebensdauer von Zeigern auf Schnittstellen wird immer über die [**adressf**](/windows/win32/api/unknwn/nf-unknwn-iunknown-addref) -und [**releasemethoden**](/windows/win32/api/unknwn/nf-unknwn-iunknown-release) für jede com-Schnittstelle verwaltet.</span><span class="sxs-lookup"><span data-stu-id="11765-104">The lifetime of pointers to interfaces is always managed through the [**AddRef**](/windows/win32/api/unknwn/nf-unknwn-iunknown-addref) and [**Release**](/windows/win32/api/unknwn/nf-unknwn-iunknown-release) methods on every COM interface.</span></span> <span data-ttu-id="11765-105">Weitere Informationen finden Sie unter [Regeln zum Verwalten von Verweis Zählungen](rules-for-managing-reference-counts.md).</span><span class="sxs-lookup"><span data-stu-id="11765-105">For more information, see [Rules for Managing Reference Counts](rules-for-managing-reference-counts.md).</span></span>

<span data-ttu-id="11765-106">Bei allen anderen Parametern ist es wichtig, bestimmte Regeln für die Verwaltung des Arbeitsspeichers einzuhalten.</span><span class="sxs-lookup"><span data-stu-id="11765-106">For all other parameters, it is important to adhere to certain rules for managing memory.</span></span> <span data-ttu-id="11765-107">Die folgenden Regeln gelten für alle Parameter von Schnittstellen methods\"einschließlich des Rückgabewerts", die nicht als Wert übermittelt werden:</span><span class="sxs-lookup"><span data-stu-id="11765-107">The following rules apply to all parameters of interface methodsâ€”including the return valueâ€”that are not passed by value:</span></span>

-   <span data-ttu-id="11765-108">In-Parameter müssen vom Aufrufer zugeordnet und freigegeben werden.</span><span class="sxs-lookup"><span data-stu-id="11765-108">In-parameters must be allocated and freed by the caller.</span></span>
-   <span data-ttu-id="11765-109">Out-Parameter müssen von dem mit dem Namen zugeordnet werden. Sie werden vom Aufrufer mithilfe der standardmäßigen com-Task Speicherzuweisung freigegeben.</span><span class="sxs-lookup"><span data-stu-id="11765-109">Out-parameters must be allocated by the one called; they are freed by the caller using the standard COM task memory allocator.</span></span> <span data-ttu-id="11765-110">Weitere Informationen finden Sie [unter OLE-Speicherzuweisung](the-ole-memory-allocator.md) .</span><span class="sxs-lookup"><span data-stu-id="11765-110">See [The OLE Memory Allocator](the-ole-memory-allocator.md) for more information.</span></span>
-   <span data-ttu-id="11765-111">In/out-Parameter werden anfänglich vom Aufrufer zugeordnet und dann, sofern erforderlich, von dem Aufrufer freigegeben und neu zugeordnet.</span><span class="sxs-lookup"><span data-stu-id="11765-111">In/out-parameters are initially allocated by the caller, and then freed and reallocated by the one called, if necessary.</span></span> <span data-ttu-id="11765-112">Wie bei Out-Parametern ist der Aufrufer für die Freigabe des endgültigen zurückgegebenen Werts verantwortlich.</span><span class="sxs-lookup"><span data-stu-id="11765-112">As is true for out parameters, the caller is responsible for freeing the final returned value.</span></span> <span data-ttu-id="11765-113">Die standardmäßige com-Speicherzuweisung muss verwendet werden.</span><span class="sxs-lookup"><span data-stu-id="11765-113">The standard COM memory allocator must be used.</span></span>

<span data-ttu-id="11765-114">In den letzten beiden Fällen, in denen ein Code Abschnitt den Arbeitsspeicher zuordnet und ein anderer Code diesen freigibt, stellt die Verwendung der com-Zuweisung sicher, dass die beiden Code Elemente dieselben Zuordnungs Methoden verwenden.</span><span class="sxs-lookup"><span data-stu-id="11765-114">In the latter two cases, where one piece of code allocates the memory and a different piece of code frees it, using the COM allocator ensures that the two pieces of code are using the same allocation methods.</span></span>

<span data-ttu-id="11765-115">Ein weiterer Bereich, der besondere Aufmerksamkeit erfordert, ist die Behandlung von out-und in-out-Parametern in Fehlerbedingungen.</span><span class="sxs-lookup"><span data-stu-id="11765-115">Another area that needs special attention is the treatment of out and in-out parameters in failure conditions.</span></span> <span data-ttu-id="11765-116">Wenn eine Funktion einen Fehlercode zurückgibt, hat der Aufrufer in der Regel keine Möglichkeit, die Out-oder in-out-Parameter zu bereinigen.</span><span class="sxs-lookup"><span data-stu-id="11765-116">If a function returns a failure code, the caller typically has no way to clean up the out or in-out parameters.</span></span> <span data-ttu-id="11765-117">Dies führt zu den folgenden zusätzlichen Regeln:</span><span class="sxs-lookup"><span data-stu-id="11765-117">This leads to the following additional rules:</span></span>

-   <span data-ttu-id="11765-118">Bei einer Fehlerbedingung müssen Parameter immer zuverlässig auf einen Wert festgelegt werden, der ohne eine Aktion durch den Aufrufer bereinigt wird.</span><span class="sxs-lookup"><span data-stu-id="11765-118">In case of an error condition, parameters must always be reliably set to a value that will be cleaned up without any action by the caller.</span></span>
-   <span data-ttu-id="11765-119">Alle out-Zeiger Parameter müssen explizit auf **null** festgelegt werden.</span><span class="sxs-lookup"><span data-stu-id="11765-119">All out pointer parameters must explicitly be set to **NULL**.</span></span> <span data-ttu-id="11765-120">Diese werden normalerweise in einem Zeiger auf einen Zeiger übergeben, können aber auch als Member einer Struktur übergeben werden, die der Aufrufer zuweist und der aufgerufene Code füllt.</span><span class="sxs-lookup"><span data-stu-id="11765-120">These are usually passed in a pointer-to-pointer parameter but can also be passed as members of a structure that the caller allocates and the called code fills.</span></span> <span data-ttu-id="11765-121">Der einfachste Weg, um sicherzustellen, dass diese Werte im Funktions Eintrag auf **null** festgelegt werden.</span><span class="sxs-lookup"><span data-stu-id="11765-121">The most straightforward way to ensure this is (in part) to set these values to **NULL** on function entry.</span></span> <span data-ttu-id="11765-122">Diese Regel ist wichtig, da Sie eine robustere Anwendungs Interoperabilität fördert.</span><span class="sxs-lookup"><span data-stu-id="11765-122">This rule is important because it promotes more robust application interoperability.</span></span>
-   <span data-ttu-id="11765-123">Unter Fehlerbedingungen müssen alle in-out-Parameter entweder allein von dem aufgerufenen Code (und somit mit dem Wert verbleiben, mit dem Sie vom Aufrufer initialisiert wurden) oder explizit festgelegt werden, wie in der Ausgabe des Out-Parameter Fehlers.</span><span class="sxs-lookup"><span data-stu-id="11765-123">Under error conditions, all in-out parameters must either be left alone by the code called (thus remaining at the value to which they were initialized by the caller) or be explicitly set, as in the out parameter error return case.</span></span>

<span data-ttu-id="11765-124">Beachten Sie, dass diese Speicher Verwaltungs Konventionen für COM-Anwendungen nur über öffentliche Schnittstellen gelten und dass es keine Anforderung gibt, dass die Speicher Belegung, die streng für eine COM-Anwendung streng intern ist, mit diesen Mechanismen durchgeführt werden muss.</span><span class="sxs-lookup"><span data-stu-id="11765-124">Remember that these memory management conventions for COM applications apply only across public interfaces and APIsâ€”there is no requirement at all that memory allocation strictly internal to a COM application need be done using these mechanisms.</span></span>

<span data-ttu-id="11765-125">COM verwendet intern Remote Prozedur Aufrufe (RPC) für die Kommunikation zwischen Clients und Servern.</span><span class="sxs-lookup"><span data-stu-id="11765-125">COM internally uses Remote Procedure Calls (RPC) to communicate between clients and servers.</span></span> <span data-ttu-id="11765-126">Weitere Informationen zum Verwalten von Arbeitsspeicher in RPC-Serverstubs finden Sie im Thema [Server-Stub-Speicherverwaltung](../rpc/server-stub-memory-management.md) .</span><span class="sxs-lookup"><span data-stu-id="11765-126">For more information about managing memory in RPC server stubs, see the [Server-stub Memory Management](../rpc/server-stub-memory-management.md) topic.</span></span>

## <a name="related-topics"></a><span data-ttu-id="11765-127">Zugehörige Themen</span><span class="sxs-lookup"><span data-stu-id="11765-127">Related topics</span></span>

<dl> <dt>

[<span data-ttu-id="11765-128">Verwalten der Speicher Belegung</span><span class="sxs-lookup"><span data-stu-id="11765-128">Managing Memory Allocation</span></span>](managing-memory-allocation.md)
</dt> </dl>

 

 