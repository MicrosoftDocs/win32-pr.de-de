---
title: Regeln für die Verwaltung von Verweis Zählungen
description: Die Verwendung eines Verweis Zählers zum Verwalten der Lebensdauer eines Objekts ermöglicht es mehreren Clients, den Zugriff auf ein einzelnes Objekt zu erhalten und freizugeben, ohne einander bei der Verwaltung der Lebensdauer eines Objekts koordinieren zu müssen.
ms.assetid: bbe7d16c-fcb7-474d-a22d-5a3b33dd800e
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: a9520cbbc88cb73c6e2abbd7908bed3754bb3945
ms.sourcegitcommit: 5f33645661bf8c825a7a2e73950b1f4ea0f1cd82
ms.translationtype: MT
ms.contentlocale: de-DE
ms.lasthandoff: 08/21/2020
ms.locfileid: "104391046"
---
# <a name="rules-for-managing-reference-counts"></a><span data-ttu-id="084eb-103">Regeln für die Verwaltung von Verweis Zählungen</span><span class="sxs-lookup"><span data-stu-id="084eb-103">Rules for Managing Reference Counts</span></span>

<span data-ttu-id="084eb-104">Die Verwendung eines Verweis Zählers zum Verwalten der Lebensdauer eines Objekts ermöglicht es mehreren Clients, den Zugriff auf ein einzelnes Objekt zu erhalten und freizugeben, ohne einander bei der Verwaltung der Lebensdauer eines Objekts koordinieren zu müssen.</span><span class="sxs-lookup"><span data-stu-id="084eb-104">Using a reference count to manage an object's lifetime allows multiple clients to obtain and release access to a single object without having to coordinate with one another in managing the object's lifetime.</span></span> <span data-ttu-id="084eb-105">Solange das Client Objekt bestimmten Verwendungs Regeln entspricht, stellt das-Objekt diese Verwaltung bereit.</span><span class="sxs-lookup"><span data-stu-id="084eb-105">As long as the client object conforms to certain rules of use, the object, in effect, provides this management.</span></span> <span data-ttu-id="084eb-106">Diese Regeln geben an, wie Verweise zwischen Objekten verwaltet werden.</span><span class="sxs-lookup"><span data-stu-id="084eb-106">These rules specify how to manage references between objects.</span></span> <span data-ttu-id="084eb-107">(Com gibt keine internen Implementierungen von Objekten an, obwohl diese Regeln einen angemessenen Ausgangspunkt für eine Richtlinie innerhalb eines Objekts sind.)</span><span class="sxs-lookup"><span data-stu-id="084eb-107">(COM does not specify internal implementations of objects, although these rules are a reasonable starting point for a policy within an object.)</span></span>

<span data-ttu-id="084eb-108">Konzeptionell können Schnittstellen Zeiger als in Zeiger Variablen befindende betrachtet werden, die den gesamten internen Berechnungs Zustand enthalten, der einen Schnittstellen Zeiger enthält.</span><span class="sxs-lookup"><span data-stu-id="084eb-108">Conceptually, interface pointers can be thought of as residing within pointer variables that include all the internal computation state that holds an interface pointer.</span></span> <span data-ttu-id="084eb-109">Dazu zählen Variablen in Speicherpositionen, in internen Prozessor Registern und vom Programmierer generierte und vom Compiler generierte Variablen.</span><span class="sxs-lookup"><span data-stu-id="084eb-109">This would include variables in memory locations, in internal processor registers, and both programmer-generated and compiler-generated variables.</span></span> <span data-ttu-id="084eb-110">Die Zuweisung zu oder Initialisierung einer Zeiger Variablen umfasst das Erstellen einer neuen Kopie eines bereits vorhandenen Zeigers.</span><span class="sxs-lookup"><span data-stu-id="084eb-110">Assignment to or initialization of a pointer variable involves creating a new copy of an already existing pointer.</span></span> <span data-ttu-id="084eb-111">Wenn eine Kopie des Zeigers in einer Variablen vorhanden war (der Wert, der bei der Zuweisung/Initialisierung verwendet wird), gibt es jetzt zwei.</span><span class="sxs-lookup"><span data-stu-id="084eb-111">Where there was one copy of the pointer in some variable (the value used in the assignment/initialization), there are now two.</span></span> <span data-ttu-id="084eb-112">Eine Zuweisung zu einer Zeiger Variablen zerstört die Zeiger Kopie, die aktuell in der Variablen ist, ebenso wie die Zerstörung der Variablen selbst.</span><span class="sxs-lookup"><span data-stu-id="084eb-112">An assignment to a pointer variable destroys the pointer copy presently in the variable, as does the destruction of the variable itself.</span></span> <span data-ttu-id="084eb-113">(Das heißt, der Bereich, in dem die Variable gefunden wird, z. b. der Stapel Rahmen, wird zerstört.)</span><span class="sxs-lookup"><span data-stu-id="084eb-113">(That is, the scope in which the variable is found, such as the stack frame, is destroyed.)</span></span>

<span data-ttu-id="084eb-114">Aus Sicht eines COM-Clients erfolgt die Verweis Zählung immer für jede Schnittstelle.</span><span class="sxs-lookup"><span data-stu-id="084eb-114">From a COM client's perspective, reference counting is always done for each interface.</span></span> <span data-ttu-id="084eb-115">Clients sollten niemals davon ausgehen, dass ein Objekt den gleichen Gegenstand für alle Schnittstellen verwendet.</span><span class="sxs-lookup"><span data-stu-id="084eb-115">Clients should never assume that an object uses the same counter for all interfaces.</span></span>

<span data-ttu-id="084eb-116">Der Standardfall ist, dass [**adressf**](/windows/win32/api/unknwn/nf-unknwn-iunknown-addref) für jede neue Kopie eines Schnittstellen Zeigers aufgerufen werden muss und dass die [**Freigabe**](/windows/win32/api/unknwn/nf-unknwn-iunknown-release) für jede Zerstörung eines Schnittstellen Zeigers aufgerufen werden muss, außer wenn die folgenden Regeln andernfalls zulässig sind:</span><span class="sxs-lookup"><span data-stu-id="084eb-116">The default case is that [**AddRef**](/windows/win32/api/unknwn/nf-unknwn-iunknown-addref) must be called for every new copy of an interface pointer and [**Release**](/windows/win32/api/unknwn/nf-unknwn-iunknown-release) must be called for every destruction of an interface pointer, except where the following rules permit otherwise:</span></span>

-   <span data-ttu-id="084eb-117">**In-out-Parameter für Funktionen.**</span><span class="sxs-lookup"><span data-stu-id="084eb-117">**In-out parameters to functions.**</span></span> <span data-ttu-id="084eb-118">Der Aufrufer muss die [**adressf**](/windows/win32/api/unknwn/nf-unknwn-iunknown-addref) für den Parameter aufrufen, da er (mit einem Aufruf von [**Release**](/windows/win32/api/unknwn/nf-unknwn-iunknown-release)) im implementierenden Code freigegeben wird, wenn der Out-Wert darauf gespeichert wird.</span><span class="sxs-lookup"><span data-stu-id="084eb-118">The caller must call [**AddRef**](/windows/win32/api/unknwn/nf-unknwn-iunknown-addref) on the parameter because it will be released (with a call to [**Release**](/windows/win32/api/unknwn/nf-unknwn-iunknown-release)) in the implementing code when the out value is stored on top of it.</span></span>
-   <span data-ttu-id="084eb-119">**Eine globale Variable wird abgerufen.**</span><span class="sxs-lookup"><span data-stu-id="084eb-119">**Fetching a global variable.**</span></span> <span data-ttu-id="084eb-120">Wenn Sie eine lokale Kopie eines Schnittstellen Zeigers aus einer vorhandenen Kopie des Zeigers in einer globalen Variablen erstellen, müssen Sie die [**adressf**](/windows/win32/api/unknwn/nf-unknwn-iunknown-addref) für die lokale Kopie abrufen, da eine andere Funktion die Kopie in der globalen Variablen zerstören kann, während die lokale Kopie noch gültig ist.</span><span class="sxs-lookup"><span data-stu-id="084eb-120">When creating a local copy of an interface pointer from an existing copy of the pointer in a global variable, you must call [**AddRef**](/windows/win32/api/unknwn/nf-unknwn-iunknown-addref) on the local copy because another function might destroy the copy in the global variable while the local copy is still valid.</span></span>
-   <span data-ttu-id="084eb-121">**Neue Zeiger, die aus "Thin Air" synthetisiert werden.**</span><span class="sxs-lookup"><span data-stu-id="084eb-121">**New pointers synthesized out of "thin air."**</span></span> <span data-ttu-id="084eb-122">Eine Funktion, die einen Schnittstellen Zeiger mithilfe von besonderen internen Kenntnissen synthetisiert, anstatt ihn aus einer anderen Quelle abzurufen, muss zunächst die [**adressf**](/windows/win32/api/unknwn/nf-unknwn-iunknown-addref) auf dem neu synthetisierten Zeiger aufrufen.</span><span class="sxs-lookup"><span data-stu-id="084eb-122">A function that synthesizes an interface pointer using special internal knowledge rather than obtaining it from some other source must call [**AddRef**](/windows/win32/api/unknwn/nf-unknwn-iunknown-addref) initially on the newly synthesized pointer.</span></span> <span data-ttu-id="084eb-123">Wichtige Beispiele für derartige Routinen sind Instanzen Erstellungs Routinen, Implementierungen von [**QueryInterface**](/windows/desktop/api/Unknwn/nf-unknwn-iunknown-queryinterface(q))usw.</span><span class="sxs-lookup"><span data-stu-id="084eb-123">Important examples of such routines include instance creation routines, implementations of [**QueryInterface**](/windows/desktop/api/Unknwn/nf-unknwn-iunknown-queryinterface(q)), and so on.</span></span>
-   <span data-ttu-id="084eb-124">**Abrufen einer Kopie eines intern gespeicherten Zeigers.**</span><span class="sxs-lookup"><span data-stu-id="084eb-124">**Retrieving a copy of an internally stored pointer.**</span></span> <span data-ttu-id="084eb-125">Wenn eine Funktion eine Kopie eines Zeigers abruft, die intern vom Objekt mit dem Namen gespeichert wird, muss der Code dieses Objekts vor der Rückgabe der Funktion [**adressf**](/windows/win32/api/unknwn/nf-unknwn-iunknown-addref) für den Zeiger aufrufen.</span><span class="sxs-lookup"><span data-stu-id="084eb-125">When a function retrieves a copy of a pointer that is stored internally by the object called, that object's code must call [**AddRef**](/windows/win32/api/unknwn/nf-unknwn-iunknown-addref) on the pointer before the function returns.</span></span> <span data-ttu-id="084eb-126">Nachdem der Zeiger abgerufen wurde, bietet das Ursprungs Objekt keine andere Möglichkeit, zu bestimmen, wie seine Lebensdauer mit der der intern gespeicherten Kopie des Zeigers zusammenhängt.</span><span class="sxs-lookup"><span data-stu-id="084eb-126">Once the pointer has been retrieved, the originating object has no other way of determining how its lifetime relates to that of the internally stored copy of the pointer.</span></span>

<span data-ttu-id="084eb-127">Die einzige Ausnahme für den Standardfall ist, dass der Verwaltungs Code die Beziehungen zwischen den Lebens dauern von mindestens zwei Kopien eines Zeigers auf die gleiche Schnittstelle in einem Objekt kennt und einfach sicherstellt, dass das Objekt nicht zerstört wird, indem der Verweis Zähler auf 0 (null) zurückgesetzt wird.</span><span class="sxs-lookup"><span data-stu-id="084eb-127">The only exceptions to the default case require that the managing code know the relationships of the lifetimes of two or more copies of a pointer to the same interface on an object and simply ensure that the object is not destroyed by allowing its reference count to go to zero.</span></span> <span data-ttu-id="084eb-128">Im Allgemeinen gibt es zwei Fälle:</span><span class="sxs-lookup"><span data-stu-id="084eb-128">There are generally two cases, as follows:</span></span>

-   <span data-ttu-id="084eb-129">Wenn eine Kopie eines Zeigers bereits vorhanden ist und anschließend eine zweite Kopie erstellt und dann zerstört wird, während die erste Kopie noch vorhanden ist, können Aufrufe von [**adressf**](/windows/win32/api/unknwn/nf-unknwn-iunknown-addref) und [**Release**](/windows/win32/api/unknwn/nf-unknwn-iunknown-release)für die zweite Kopie ausgelassen werden.</span><span class="sxs-lookup"><span data-stu-id="084eb-129">When one copy of a pointer already exists and a second is created subsequently and then is destroyed while the first copy still exists, calls to [**AddRef**](/windows/win32/api/unknwn/nf-unknwn-iunknown-addref) and [**Release**](/windows/win32/api/unknwn/nf-unknwn-iunknown-release)for the second copy can be omitted.</span></span>
-   <span data-ttu-id="084eb-130">Wenn eine Kopie eines Zeigers vorhanden ist und ein zweiter erstellt wird und der erste Vorgang vor dem zweiten zerstört wird, können die Aufrufe von [**adressf**](/windows/win32/api/unknwn/nf-unknwn-iunknown-addref)für die zweite Kopie und die [**Freigabe**](/windows/win32/api/unknwn/nf-unknwn-iunknown-release) für die erste Kopie ausgelassen werden.</span><span class="sxs-lookup"><span data-stu-id="084eb-130">When one copy of a pointer exists and a second is created and then the first is destroyed before the second, the calls to [**AddRef**](/windows/win32/api/unknwn/nf-unknwn-iunknown-addref)for the second copy and to [**Release**](/windows/win32/api/unknwn/nf-unknwn-iunknown-release) for the first copy can be omitted.</span></span>

<span data-ttu-id="084eb-131">Im folgenden finden Sie spezifische Beispiele für diese Situationen: die ersten beiden sind besonders häufig.</span><span class="sxs-lookup"><span data-stu-id="084eb-131">The following are specific examples of these situations, the first two being especially common:</span></span>

-   <span data-ttu-id="084eb-132">**In den Parametern für Funktionen.**</span><span class="sxs-lookup"><span data-stu-id="084eb-132">**In parameters to functions.**</span></span> <span data-ttu-id="084eb-133">Die Lebensdauer der Kopie eines Schnittstellen Zeigers, der als Parameter an eine Funktion übergeben wird, wird in der des Zeigers, der zum Initialisieren des Werts verwendet wird, eingefügt, sodass für den Parameter kein separater Verweis Zähler erforderlich ist.</span><span class="sxs-lookup"><span data-stu-id="084eb-133">The lifetime of the copy of an interface pointer passed as a parameter to a function is nested in that of the pointer used to initialize the value, so there is no need for a separate reference count on the parameter.</span></span>
-   <span data-ttu-id="084eb-134">**Out-Parameter aus Funktionen, einschließlich der Rückgabewerte.**</span><span class="sxs-lookup"><span data-stu-id="084eb-134">**Out parameters from functions, including return values.**</span></span> <span data-ttu-id="084eb-135">Um den out-Parameter festzulegen, muss die Funktion über eine stabile Kopie des Schnittstellen Zeigers verfügen.</span><span class="sxs-lookup"><span data-stu-id="084eb-135">To set the out parameter, the function must have a stable copy of the interface pointer.</span></span> <span data-ttu-id="084eb-136">Bei der Rückgabe ist der Aufrufer für die Freigabe des Zeigers verantwortlich.</span><span class="sxs-lookup"><span data-stu-id="084eb-136">On return, the caller is responsible for releasing the pointer.</span></span> <span data-ttu-id="084eb-137">Der Out-Parameter benötigt daher keinen separaten Verweis Zähler.</span><span class="sxs-lookup"><span data-stu-id="084eb-137">Therefore, the out parameter does not need a separate reference count.</span></span>
-   <span data-ttu-id="084eb-138">**Lokale Variablen.**</span><span class="sxs-lookup"><span data-stu-id="084eb-138">**Local variables.**</span></span> <span data-ttu-id="084eb-139">Eine Methoden Implementierung hat die Kontrolle über die Lebensdauer der einzelnen Zeiger Variablen, die im Stapel Rahmen zugeordnet sind, und kann dies verwenden, um zu bestimmen, wie redundante [**adressf**](/windows/win32/api/unknwn/nf-unknwn-iunknown-addref)- / [**releasepaare**](/windows/win32/api/unknwn/nf-unknwn-iunknown-release) ausgelassen werden.</span><span class="sxs-lookup"><span data-stu-id="084eb-139">A method implementation has control of the lifetimes of each of the pointer variables allocated on the stack frame and can use this to determine how to omit redundant [**AddRef**](/windows/win32/api/unknwn/nf-unknwn-iunknown-addref)/[**Release**](/windows/win32/api/unknwn/nf-unknwn-iunknown-release) pairs.</span></span>
-   <span data-ttu-id="084eb-140">**Backpointer.**</span><span class="sxs-lookup"><span data-stu-id="084eb-140">**Backpointers.**</span></span> <span data-ttu-id="084eb-141">Einige Datenstrukturen enthalten zwei-Objekte, von denen jeder einen Zeiger auf den anderen hat.</span><span class="sxs-lookup"><span data-stu-id="084eb-141">Some data structures contain two objects, each with a pointer to the other.</span></span> <span data-ttu-id="084eb-142">Wenn die Lebensdauer des ersten Objekts bekannt ist, dass die Lebensdauer des zweiten Objekts enthalten ist, ist es nicht erforderlich, einen Verweis Zähler für den Zeiger des zweiten Objekts auf das erste Objekt zu haben.</span><span class="sxs-lookup"><span data-stu-id="084eb-142">If the lifetime of the first object is known to contain the lifetime of the second, it is not necessary to have a reference count on the second object's pointer to the first object.</span></span> <span data-ttu-id="084eb-143">Häufig ist es wichtig, diesen Schleifen zu vermeiden, wenn das entsprechende Verhalten beim Aufheben der Zuordnung beibehalten wird.</span><span class="sxs-lookup"><span data-stu-id="084eb-143">Often, avoiding this cycle is important in maintaining the appropriate deallocation behavior.</span></span> <span data-ttu-id="084eb-144">Nicht abgezählte Zeiger sollten jedoch mit äußerster Vorsicht verwendet werden, da der Teil des Betriebssystems, der die Remote Verarbeitung verarbeitet, keine Möglichkeit hat, über diese Beziehung zu informieren.</span><span class="sxs-lookup"><span data-stu-id="084eb-144">However, uncounted pointers should be used with extreme caution because the portion of the operating system that handles remote processing has no way of knowing about this relationship.</span></span> <span data-ttu-id="084eb-145">Daher ist in fast allen Fällen, dass der Rück Zeiger ein zweites, "Friend"-Objekt des ersten Zeigers (wodurch die Zirkularität vermieden wird) die bevorzugte Lösung.</span><span class="sxs-lookup"><span data-stu-id="084eb-145">Therefore, in almost all cases, having the backpointer see a second, "friend" object of the first pointer (thus avoiding the circularity) is the preferred solution.</span></span> <span data-ttu-id="084eb-146">Beispielsweise verwendet die Verbindungs fähigen Objects-Architektur von com diese Vorgehensweise.</span><span class="sxs-lookup"><span data-stu-id="084eb-146">COM's connectable objects architecture, for example, uses this approach.</span></span>

<span data-ttu-id="084eb-147">Beim implementieren oder Verwenden von Objekten mit Verweis Zählung kann es hilfreich sein, *künstliche Verweis Zähler* anzuwenden, die die Objekt Stabilität während der Verarbeitung einer Funktion garantieren.</span><span class="sxs-lookup"><span data-stu-id="084eb-147">When implementing or using reference-counted objects, it may be useful to apply *artificial reference counts*, which guarantee object stability during processing of a function.</span></span> <span data-ttu-id="084eb-148">Beim Implementieren einer Methode einer Schnittstelle können Sie Funktionen aufzurufen, die die Möglichkeit haben, den Verweis Zähler auf ein Objekt zu dekrementieren, wodurch eine Vorzeitige Freigabe des Objekts und ein Fehler der Implementierung verursacht wird.</span><span class="sxs-lookup"><span data-stu-id="084eb-148">In implementing a method of an interface, you might call functions that have a chance of decrementing your reference count to an object, causing a premature release of the object and failure of the implementation.</span></span> <span data-ttu-id="084eb-149">Ein robuster Weg, dies zu vermeiden, besteht darin, am Anfang der Methoden Implementierung einen [**callf-Adressaten**](/windows/win32/api/unknwn/nf-unknwn-iunknown-addref) einzufügen und ihn mit einem [**Freigabe Freigabe**](/windows/win32/api/unknwn/nf-unknwn-iunknown-release) paar kurz vor der Rückgabe der Methode zu koppeln.</span><span class="sxs-lookup"><span data-stu-id="084eb-149">A robust way to avoid this is to insert a call to [**AddRef**](/windows/win32/api/unknwn/nf-unknwn-iunknown-addref) at the beginning of the method implementation and pair it with a call to [**Release**](/windows/win32/api/unknwn/nf-unknwn-iunknown-release) just before the method returns.</span></span>

<span data-ttu-id="084eb-150">In einigen Situationen sind die Rückgabewerte von [**adressf**](/windows/win32/api/unknwn/nf-unknwn-iunknown-addref) und [**Release**](/windows/win32/api/unknwn/nf-unknwn-iunknown-release) möglicherweise instabil und sollten nicht darauf basieren. Sie sollten nur zu Debuggingzwecken oder zu Diagnose Zwecken verwendet werden.</span><span class="sxs-lookup"><span data-stu-id="084eb-150">In some situations, the return values of [**AddRef**](/windows/win32/api/unknwn/nf-unknwn-iunknown-addref) and [**Release**](/windows/win32/api/unknwn/nf-unknwn-iunknown-release) may be unstable and should not be relied upon; they should be used only for debugging or diagnostic purposes.</span></span>

## <a name="related-topics"></a><span data-ttu-id="084eb-151">Zugehörige Themen</span><span class="sxs-lookup"><span data-stu-id="084eb-151">Related topics</span></span>

<dl> <dt>

[<span data-ttu-id="084eb-152">Verwalten von Objekt Lebensdauern durch Verweis Zählung</span><span class="sxs-lookup"><span data-stu-id="084eb-152">Managing Object Lifetimes Through Reference Counting</span></span>](managing-object-lifetimes-through-reference-counting.md)
</dt> </dl>

 

 