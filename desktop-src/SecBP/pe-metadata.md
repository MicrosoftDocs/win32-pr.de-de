---
description: Dieser Artikel enthält weitere Details zu den Ablauf Steuerungs Schutz-Metadaten in PE-Images.
title: PE-Metadaten
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: 52eb54ac953be4ac09461dbc92bb39d8afc5d332
ms.sourcegitcommit: 831e8f3db78ab820e1710cede244553c70e50500
ms.translationtype: MT
ms.contentlocale: de-DE
ms.lasthandoff: 01/08/2021
ms.locfileid: "106351143"
---
# <a name="pe-metadata"></a><span data-ttu-id="d603a-103">PE-Metadaten</span><span class="sxs-lookup"><span data-stu-id="d603a-103">PE metadata</span></span>

<span data-ttu-id="d603a-104">Dieser Artikel enthält zusätzliche Details zu den Metadaten des Control Flow Guard (CFG) in PE-Images.</span><span class="sxs-lookup"><span data-stu-id="d603a-104">This article provides additional details for Control Flow Guard (CFG) metadata in PE images.</span></span> <span data-ttu-id="d603a-105">Es wird davon ausgegangen, dass die Struktur von CFG-Metadaten in PE-Images Vertrautheit ist.</span><span class="sxs-lookup"><span data-stu-id="d603a-105">Familiarity with the structure for CFG metadata in PE images is assumed.</span></span> <span data-ttu-id="d603a-106">Im Thema [PE-Format](../debug/pe-format.md) finden Sie eine ausführliche Dokumentation für cfg-Metadaten in PE-Images.</span><span class="sxs-lookup"><span data-stu-id="d603a-106">See the [PE Format](../debug/pe-format.md) topic for high-level documentation for CFG metadata in PE images.</span></span>

- <span data-ttu-id="d603a-107">Funktionen, die gültige indirekte callziele sind, werden in der " **guardcffunctiontable** " aufgelistet, die an das Konfigurationsverzeichnis "Load" angefügt ist, was manchmal auch als **gmeds** -Tabelle bezeichnet wird.</span><span class="sxs-lookup"><span data-stu-id="d603a-107">Functions that are valid indirect call targets are listed in the **GuardCFFunctionTable** attached to the load configuration directory, sometimes termed the **GFIDS** table for brevity.</span></span> <span data-ttu-id="d603a-108">Dies ist eine sortierte Liste von relativen virtuellen Adressen (RVA), die Informationen zu gültigen cfg-callzielen enthalten.</span><span class="sxs-lookup"><span data-stu-id="d603a-108">This is a sorted list of relative virtual addresses (RVA) that contain information about valid CFG call targets.</span></span> <span data-ttu-id="d603a-109">Dabei handelt es sich im Allgemeinen um Funktions Symbole, die von der Adresse übernommen werden</span><span class="sxs-lookup"><span data-stu-id="d603a-109">These are, generally speaking, address taken function symbols.</span></span> <span data-ttu-id="d603a-110">Ein Bild, das die cfg-Erzwingung erfordert, muss alle in der zugehörigen **GFI** -Tabelle ausgeführten Funktions Symbole auflisten.</span><span class="sxs-lookup"><span data-stu-id="d603a-110">An image that wants CFG enforcement must enumerate all address taken function symbols in its **GFIDS** table.</span></span> <span data-ttu-id="d603a-111">Die RVA-Liste in der **GFI DS** -Tabelle muss ordnungsgemäß sortiert werden, oder das Image wird nicht geladen.</span><span class="sxs-lookup"><span data-stu-id="d603a-111">The RVA list in the **GFIDS** table must be sorted properly or the image will not be loaded.</span></span> <span data-ttu-id="d603a-112">Die **gmeds** -Tabelle ist ein Array von 4 + *n* bytes, wobei *n* von (("guardflags & IMAGE_GUARD_CF_FUNCTION_TABLE_SIZE_MASK)  >> IMAGE_GUARD_CF_FUNCTION_TABLE_SIZE_SHIFT)" angegeben wird.</span><span class="sxs-lookup"><span data-stu-id="d603a-112">The **GFIDS** table is an array of 4 + *n* bytes, where *n* is given by ((GuardFlags & IMAGE_GUARD_CF_FUNCTION_TABLE_SIZE_MASK) >> IMAGE_GUARD_CF_FUNCTION_TABLE_SIZE_SHIFT).</span></span> <span data-ttu-id="d603a-113">"Guardflags" ist das Feld "guardflags" des Konfigurations Verzeichnisses "Load".</span><span class="sxs-lookup"><span data-stu-id="d603a-113">“GuardFlags” is the GuardFlags field of the load configuration directory.</span></span> <span data-ttu-id="d603a-114">Dadurch können zusätzliche Metadaten in Zukunft an cfg-callziele angefügt werden.</span><span class="sxs-lookup"><span data-stu-id="d603a-114">This allows for extra metadata to be attached to CFG call targets in the future.</span></span> <span data-ttu-id="d603a-115">Die einzigen aktuell definierten Metadaten sind ein optionales 1-Byte-extra-Flags-Feld ("gmeds-Flags"), das an jeden **GFI** -Eintrag angefügt wird, wenn beliebige callziele über Metadaten verfügen.</span><span class="sxs-lookup"><span data-stu-id="d603a-115">The only currently defined metadata is an optional 1-byte extra flags field (“GFIDS flags”) that is attached to each **GFIDS** entry if any call targets have metadata.</span></span> <span data-ttu-id="d603a-116">Zwei **GFI DS** -Flags sind definiert:</span><span class="sxs-lookup"><span data-stu-id="d603a-116">There are two **GFIDS** flags defined:</span></span>
  
  | &nbsp; | &nbsp; |
  | ---- |:---- |
  | <span data-ttu-id="d603a-117">IMAGE_GUARD_FLAG_FID_SUPPRESSED/0x1</span><span class="sxs-lookup"><span data-stu-id="d603a-117">IMAGE_GUARD_FLAG_FID_SUPPRESSED/0x1</span></span> | <span data-ttu-id="d603a-118">Das Aufrufziel wird explizit unterdrückt (behandeln Sie es für cfg nicht als gültig).</span><span class="sxs-lookup"><span data-stu-id="d603a-118">Call target is explicitly suppressed (do not treat it as valid for purposes of CFG)</span></span> |
  | <span data-ttu-id="d603a-119">IMAGE_GUARD_FLAG_EXPORT_SUPPRESSED/0x2</span><span class="sxs-lookup"><span data-stu-id="d603a-119">IMAGE_GUARD_FLAG_EXPORT_SUPPRESSED/0x2</span></span> | <span data-ttu-id="d603a-120">Der Export des callziels wird unterdrückt.</span><span class="sxs-lookup"><span data-stu-id="d603a-120">Call target is export suppressed.</span></span> <span data-ttu-id="d603a-121">Weitere Informationen finden Sie unter [Export Unterdrückung](#export-suppression) .</span><span class="sxs-lookup"><span data-stu-id="d603a-121">See [Export suppression](#export-suppression) for more details</span></span> |
  
  <span data-ttu-id="d603a-122">Um die Kompatibilität zu erhöhen, sollten die Tools keine **gatds** -Flags festlegen, die noch nicht definiert wurden, und keine zusätzlichen **gmeds** zusätzlichen metadatenbytes enthalten, die über das aktuell definierte 1-Byte hinausgehen, da die Bedeutung für andere Flags oder zusätzliche Metadaten noch nicht zugewiesen ist.</span><span class="sxs-lookup"><span data-stu-id="d603a-122">For future compatibility, tools should not set **GFIDS** flags that have not yet been defined and should not include additional **GFIDS** extra metadata bytes beyond the 1-byte currently defined since the meanings for other flags or additional metadata are not yet assigned.</span></span> <span data-ttu-id="d603a-123">Sie finden Beispiele für Images, die zusätzliche metadatenbytes enthalten, indem Sie die **gmeds** -Tabelle der Binärdateien, z. b. Ntdll.dll, auf einer modernen Windows 10-Betriebssystemversion sichern.</span><span class="sxs-lookup"><span data-stu-id="d603a-123">You can find examples of images that include extra metadata bytes by dumping the **GFIDS** table of binaries such as Ntdll.dll on a modern Windows 10 OS version.</span></span>

  <span data-ttu-id="d603a-124">Tools sollten Funktions Symbole nur als gültige callziele deklarieren, was möglicherweise zusätzliche Überlegungen zu Assemblycode verdient, bei dem Bezeichnungen möglicherweise adressiert werden.</span><span class="sxs-lookup"><span data-stu-id="d603a-124">Tools should only declare function symbols as valid call targets which may merit additional consideration for assembler code where labels might be address taken.</span></span> <span data-ttu-id="d603a-125">Aus historischen Gründen kann der Assemblycode von anderen Code Bezeichnungen als proc oder. altentry abhängen, die nicht in cfg-callziele durch den Linker konvertiert werden.</span><span class="sxs-lookup"><span data-stu-id="d603a-125">For historical reasons, assembler code may rely on code labels other than PROC or .altentry as not being converted into CFG call targets by the linker.</span></span>

  <span data-ttu-id="d603a-126">Aus historischen Gründen kann Code absichtlich Code als Daten deklarieren, um die Einbindung in die **GFI DS** -Tabelle zu vermeiden.</span><span class="sxs-lookup"><span data-stu-id="d603a-126">Also for historical reasons, code may deliberately declare code as data to avoid inclusion in the **GFIDS** table.</span></span> <span data-ttu-id="d603a-127">Beispielsweise kann eine Objektdatei ein Symbol als Code implementieren, während ein anderes das Symbol als Daten deklarieren kann, um die Adresse des Symbols zu übernehmen, ohne einen gültigen cfg-Zieldatensatz zu erstellen.</span><span class="sxs-lookup"><span data-stu-id="d603a-127">For example, one object file may implement a symbol as code while another may declare it as data in order to take the address of the symbol without generating a valid CFG target record.</span></span> <span data-ttu-id="d603a-128">Aus Kompatibilitätsgründen wird empfohlen, dass Toolsets diese Vorgehensweise unterstützen.</span><span class="sxs-lookup"><span data-stu-id="d603a-128">For compatibility, it is recommended that toolsets support this practice.</span></span>

- <span data-ttu-id="d603a-129">Images, die cfg unterstützen und cfg-Überprüfungen durchführen möchten, sollten die IMAGE_GUARD_CF_INSTRUMENTED-und IMAGE_GUARD_CF_FUNCTION_TABLE_PRESENT guardflags-Bits festlegen und das IMAGE_DLLCHARACTERISTICS_GUARD_CF DllCharacteristics-Bit in den Bild Headern festlegen.</span><span class="sxs-lookup"><span data-stu-id="d603a-129">Images that support CFG and that want or perform CFG checks should set the IMAGE_GUARD_CF_INSTRUMENTED and IMAGE_GUARD_CF_FUNCTION_TABLE_PRESENT GuardFlags bits, and should set the IMAGE_DLLCHARACTERISTICS_GUARD_CF DllCharacteristics bit in the image headers.</span></span>

- <span data-ttu-id="d603a-130">Das Lade Konfigurationsverzeichnis weist zwei Funktionszeiger auf: "guardcfcheckfunctionpointer" und "guardcfdispatchfunctionpointer" (Letzteres wird nur für bestimmte Architekturen wie amd64 unterstützt).</span><span class="sxs-lookup"><span data-stu-id="d603a-130">The load configuration directory advertises two function pointers: GuardCFCheckFunctionPointer and GuardCFDispatchFunctionPointer (the latter is only supported for certain architectures such as AMD64).</span></span> <span data-ttu-id="d603a-131">Diese Funktionszeiger sollten auf den schreibgeschützten Speicher verweisen, damit die cfg-Sicherheit wirksam ist. Das dll-Lade Modul des Betriebssystems schützt den Speicher beim Laden des Images beim Laden der Funktionen erneut, um die Funktionszeiger zu speichern.</span><span class="sxs-lookup"><span data-stu-id="d603a-131">These function pointers should point to read only memory for CFG security to be effective; the operating system’s DLL loader will reprotect the memory transiently during image loading to store the function pointers.</span></span> <span data-ttu-id="d603a-132">Die typische Verwendung besteht darin, diese in demselben Abschnitt zusammenzuführen, der die Import Adress Tabelle (IAT) enthält.</span><span class="sxs-lookup"><span data-stu-id="d603a-132">Typical usage might be to merge these into the same section that contains the Import Address Table (IAT).</span></span> <span data-ttu-id="d603a-133">Der "guardcfcheckfunctionpointer" stellt die Adresse eines von einem Betriebssystem bereitgestellten Symbols bereit, das mit einem Funktionszeiger in der ersten ganzzahligen Argument Registrierung (ECX auf x86) aufgerufen werden kann, die bei Erfolg zurückgegeben wird, oder den Prozess Abbrechen, wenn das Aufruf Ziel kein gültiges cfg-Ziel ist.</span><span class="sxs-lookup"><span data-stu-id="d603a-133">The GuardCFCheckFunctionPointer provides the address of an OS-loader provided symbol that can be called with a function pointer in the first integer argument register (ECX on x86) which will return on success or will abort the process if the call target is not a valid CFG target.</span></span> <span data-ttu-id="d603a-134">Der "guardcfdispatchfunctionpointer" stellt die Adresse eines von einem Betriebssystem bereitgestellten Symbols bereit, das ein Aufruf Ziel in Register Rax annimmt und einen kombinierten cfg-Check-und End-Branch-optimierten Aufruf des Aufruf Ziels ausführt (die Register "R10/R11" sind für die Verwendung durch das Ultimate-Aufruf Ziel reserviert).</span><span class="sxs-lookup"><span data-stu-id="d603a-134">The GuardCFDispatchFunctionPointer provides the address of an OS-loader provided symbol that takes a call target in register RAX and performs a combined CFG check and tail branch optimized call to the call target (registers R10/R11 are reserved for use by the GuardCFDispatchFunctionPointer and integer argument registers are reserved for use by the ultimate call target).</span></span> <span data-ttu-id="d603a-135">Die Standardadresse der cfg-Symbole in einem Bild sollte auf eine Funktion verweisen, die nur (guardcfcheckfunctionpointer) zurückgibt, oder die ein vom Wächter unterdrücktes Symbol zurückgibt (oder vorzugsweise im **GFI** -Tabellen Symbol vollständig ausgelassen wird), das eine "jmp Rax"-Anweisung ausführt.</span><span class="sxs-lookup"><span data-stu-id="d603a-135">The default address of the CFG symbols in an image should point to a function that just returns (GuardCFCheckFunctionPointer) or that returns a guard-suppressed symbol (or is preferably entirely omitted from the **GFIDS** table symbol) that executes a “jmp rax” instruction.</span></span> <span data-ttu-id="d603a-136">Wenn für AMD64 guardcfdispatchfunctionpointer ein Bild auf einem cfg-fähigen Betriebssystem geladen und cfg aktiviert ist, installiert das Betriebssystem-dll-Lade Modul geeignete Funktionszeiger, die die Abwärtskompatibilität der Einrichtungen ermöglichen.</span><span class="sxs-lookup"><span data-stu-id="d603a-136">For AMD64 GuardCFDispatchFunctionPointer, when an image is loaded on a CFG-aware operating system, and CFG is enabled, the OS DLL loader will install appropriate function pointers, which facilities backwards compatibility.</span></span> <span data-ttu-id="d603a-137">Ein Bild kann 0 für den "guardcfdispatchfunctionpointer" in der Auslastungs Konfiguration angeben, wenn er die cfg-dispatchfunktion nicht verwenden möchte.</span><span class="sxs-lookup"><span data-stu-id="d603a-137">An image can supply 0 for the GuardCFDispatchFunctionPointer in the load config if it does not intend to use the CFG dispatch facility.</span></span> <span data-ttu-id="d603a-138">Dies sollte für nicht-amd64-Architekturen zur zukünftigen Kompatibilität erfolgen, falls diese Architekturen den cfg-Verteilungsmechanismus in irgendeiner Form unterstützen.</span><span class="sxs-lookup"><span data-stu-id="d603a-138">This should be done for non-AMD64 architectures for future compatibility, in case these architectures eventually support the CFG dispatch mechanism in some form.</span></span> <span data-ttu-id="d603a-139">Beachten Sie, dass Windows 8.1 amd64 die cfg-Verteilung nicht unterstützte und den Standard Funktionszeiger für "guardcfdispatchfunctionpointer" belassen würde.</span><span class="sxs-lookup"><span data-stu-id="d603a-139">Note that Windows 8.1 AMD64 did not support CFG dispatch and would leave the default function pointer in place for GuardCFDispatchFunctionPointer.</span></span> <span data-ttu-id="d603a-140">CFG-Dispatch wird nur unter Windows 10 und höheren Betriebssystemen unterstützt.</span><span class="sxs-lookup"><span data-stu-id="d603a-140">CFG dispatch is only supported on Windows 10 and later operating systems.</span></span>

- <span data-ttu-id="d603a-141">Der Benutzermodus-cfg kann nur für Bilder erzwungen werden, die als "Address Space Layout Anordnung (ASLR)-kompatibel" gekennzeichnet sind (angegeben durch die Option/DynamicBase mit dem Microsoft-Linker).</span><span class="sxs-lookup"><span data-stu-id="d603a-141">User mode CFG might only be enforced for images that are marked as address space layout randomization (ASLR) compatible (specified by the /DYNAMICBASE option with the Microsoft linker).</span></span> <span data-ttu-id="d603a-142">Dies liegt daran, wie das Betriebssystem cfg intern verarbeitet, wo es im Wesentlichen mit der ASLR-Infrastruktur verknüpft ist.</span><span class="sxs-lookup"><span data-stu-id="d603a-142">This is due to how the OS internally handles CFG where it is essentially wired in to the ASLR infrastructure.</span></span> <span data-ttu-id="d603a-143">Im Allgemeinen sollten Benutzer von CFG ASLR als ersten Schritt für Ihre Images aktivieren.</span><span class="sxs-lookup"><span data-stu-id="d603a-143">In general, users of CFG should enable ASLR for their images as a first step.</span></span> <span data-ttu-id="d603a-144">Tools sollten nicht davon ausgehen, dass das Betriebssystem "cfg" immer ohne ASLR-Satz ignoriert, aber in der Regel beide gleichzeitig festgelegt werden sollte.</span><span class="sxs-lookup"><span data-stu-id="d603a-144">Tools should not assume that the OS will always ignore CFG without ASLR set but should generally set both at the same time.</span></span>

## <a name="compiler-directives"></a><span data-ttu-id="d603a-145">Compilerdirektiven</span><span class="sxs-lookup"><span data-stu-id="d603a-145">Compiler directives</span></span>

- <span data-ttu-id="d603a-146">Callziele können mit dem __declspec (Guard (Unterdrückung))-Modifizierer oder mit der/guardsym: symname, S-linkerdirektive (z. b. für ASM-Code) als explizit unterdrückt gekennzeichnet werden.</span><span class="sxs-lookup"><span data-stu-id="d603a-146">Call targets can be marked as explicitly suppressed with the __declspec(guard(suppress)) modifier, or with the /guardsym:symname,S linker directive (for asm code for example).</span></span> <span data-ttu-id="d603a-147">Dies bewirkt, dass das aufrufsziel in der **GFI DS** -Tabelle enthalten ist, aber so gekennzeichnet ist, dass das Betriebssystem das aufrufsziel als ungültig behandelt.</span><span class="sxs-lookup"><span data-stu-id="d603a-147">This causes the call target to be included in the **GFIDS** table but marked in such a way that the OS will treat the call target as not valid.</span></span> <span data-ttu-id="d603a-148">Einige nicht produktive Szenarien, wie z. b. mit einer bestimmten anwendungsverifiziererinstrumentation, die für einige ältere Betriebssysteme aktiviert ist, können unterdrückte calltargets als gültig behandeln, aber im Allgemeinen werden diese Szenarien nicht als Produktions Szenarios erwartet.</span><span class="sxs-lookup"><span data-stu-id="d603a-148">Some non-production scenarios, such as with certain application verifier instrumentation enabled on some older operating systems, may enable suppressed call targets to be treated as valid, but in general these scenarios are not expected to be production scenarios.</span></span> <span data-ttu-id="d603a-149">Diese Direktive ist nützlich, um "gefährliche" Funktionen zu kommentieren, die nicht als gültige callziele angesehen werden sollten, auch wenn Sie in der normalen cfg-Regel enthalten sind.</span><span class="sxs-lookup"><span data-stu-id="d603a-149">This directive is useful for annotating “dangerous” functions that should not be considered as valid call targets, even though the normal CFG rule would include them.</span></span>

- <span data-ttu-id="d603a-150">Code kann angeben, dass cfg-Überprüfungen nicht mit dem __declspec (Guard (nocf))-Modifizierer gewünscht werden.</span><span class="sxs-lookup"><span data-stu-id="d603a-150">Code can indicate CFG checks are not wanted with the __declspec(guard(nocf)) modifier.</span></span> <span data-ttu-id="d603a-151">Dadurch wird der Compiler angewiesen, keine cfg-Überprüfungen für die gesamte Funktion einzufügen.</span><span class="sxs-lookup"><span data-stu-id="d603a-151">This directs the compiler to not insert any CFG checks for the entire function.</span></span> <span data-ttu-id="d603a-152">Der Compiler sollte darauf achten, diese Direktive an jeden von einer Inline Funktion beigetragenen Code weiterzugeben, der als keine Überprüfung der cfg-Überprüfungen gekennzeichnet ist.</span><span class="sxs-lookup"><span data-stu-id="d603a-152">The compiler should take care to propagate this directive to any code contributed by an inlined function that is marked as not wanting CFG checks.</span></span> <span data-ttu-id="d603a-153">Diese Vorgehensweise wird in der Regel nur selten in bestimmten Situationen verwendet, in denen der Programmierer den "cfg-äquivalenten" Schutz manuell eingefügt hat.</span><span class="sxs-lookup"><span data-stu-id="d603a-153">This approach is typically used only sparingly in specific situations where the programmer has manually inserted “CFG-equivalent” protection.</span></span> <span data-ttu-id="d603a-154">Der Programmierer weiß, dass Sie über eine schreibgeschützte Funktions Tabelle aufrufen, deren Adresse durch schreibgeschützte Speicher Verweise abgerufen wird und für die der Index mit dem Grenzwert für die Funktions Tabelle maskiert ist.</span><span class="sxs-lookup"><span data-stu-id="d603a-154">The programmer knows that they are calling through some read only function table whose address is obtained through read only memory references and for which the index is masked to the function table limit.</span></span> <span data-ttu-id="d603a-155">Diese Vorgehensweise kann auch auf kleine Wrapper Funktionen angewendet werden, die nicht Inline sind, und die nichts weiter tun, als einen Funktionszeiger aufzurufen.</span><span class="sxs-lookup"><span data-stu-id="d603a-155">This approach may also be applied to small wrapper functions that are not inlined and that do nothing more than make a call through a function pointer.</span></span> <span data-ttu-id="d603a-156">Da durch eine falsche Verwendung dieser Direktive die Sicherheit von CFG beeinträchtigt werden kann, muss der Programmierer mit der-Direktive sehr vorsichtig sein.</span><span class="sxs-lookup"><span data-stu-id="d603a-156">Since incorrect usage of this directive can compromise the security of CFG, the programmer must be very careful using the directive.</span></span> <span data-ttu-id="d603a-157">In der Regel ist diese Verwendung auf sehr kleine Funktionen beschränkt, die nur eine Funktion aufzurufen.</span><span class="sxs-lookup"><span data-stu-id="d603a-157">Typically, this usage is limited to very small functions that only call one function.</span></span>

## <a name="import-handling"></a><span data-ttu-id="d603a-158">Import Verarbeitung</span><span class="sxs-lookup"><span data-stu-id="d603a-158">Import handling</span></span>

- <span data-ttu-id="d603a-159">Aufrufe über IAT sollten keinen cfg-Schutz verwenden.</span><span class="sxs-lookup"><span data-stu-id="d603a-159">Calls through the IAT should not use CFG protection.</span></span> <span data-ttu-id="d603a-160">Der IAT ist in modernen Images schreibgeschützt (vorausgesetzt, dass der IAT in den PE-Headern deklariert ist, und er muss sich auf seinen eigenen Seiten befinden).</span><span class="sxs-lookup"><span data-stu-id="d603a-160">The IAT is read only in modern images (assuming that the IAT is declared in the PE headers in which case it must be on its own pages).</span></span> <span data-ttu-id="d603a-161">Der IAT kann verwendet werden, um Funktionen zu erreichen, die Schutz unterdrückt werden. Dies ist eine korrekte Anforderung.</span><span class="sxs-lookup"><span data-stu-id="d603a-161">The IAT can be used to reach functions that are guard suppressed, so this is a correctness requirement.</span></span> <span data-ttu-id="d603a-162">Schreib geschützter Speicherschutz durch IAT ersetzt die von cfg, da die Bindungs Ziel Bindung nach der Auflösung der Bild Import-Ausgangsbox unveränderlich ist und die Bindungs Auflösung fein abgeglichen wird.</span><span class="sxs-lookup"><span data-stu-id="d603a-162">Read only memory protection through the IAT supersedes that of CFG since the call target binding is immutable after the image import snaps are resolved, and the binding resolution is fine grained.</span></span>

- <span data-ttu-id="d603a-163">Geschütztes verzögertes Laden: Aufrufe über das Verzögerungs Lade-IAT sollten keinen cfg-Schutz verwenden, aus denselben Gründen wie bei der Standard-IAT.</span><span class="sxs-lookup"><span data-stu-id="d603a-163">Protected delay load: Calls through the delay load IAT should not use CFG protection, for the same reasons as the standard IAT.</span></span> <span data-ttu-id="d603a-164">Der Verzögerungs Lade-IAT sollte sich in einem eigenen Abschnitt befinden, und das Image sollte das IMAGE_GUARD_CF_PROTECT_DELAYLOAD_IAT guardflags-Bit festlegen.</span><span class="sxs-lookup"><span data-stu-id="d603a-164">The delay load IAT should be in its own section and the image should set the IMAGE_GUARD_CF_PROTECT_DELAYLOAD_IAT GuardFlags bit.</span></span> <span data-ttu-id="d603a-165">Dies deutet darauf hin, dass das dll-Lade Tool des Betriebssystems während der Export Auflösung den Schutz für das Verzögerungs Laden von IAT ändern soll, wenn die Verzögerungs Auslastung des Betriebssystems System eigen für Windows 8 und spätere Betriebssysteme verwendet wird.</span><span class="sxs-lookup"><span data-stu-id="d603a-165">This indicates that the operating system’s DLL loader should change protections for the delay load IAT during export resolution if using the operating system’s delay load support native to Windows 8 and later operating systems.</span></span> <span data-ttu-id="d603a-166">Die Synchronisierung dieses Schritts wird vom Betriebssystem-dll-Lade Programm verwaltet, wenn die Unterstützung für das systemeigene verzögerte Laden von Betriebssystemen (z. b. resolvedelta-loadedapi) verwendet wird, sodass keine andere Komponente die Seiten erneut schützen soll, die das deklarierte Verzögerungs Lade Modul umfassen.</span><span class="sxs-lookup"><span data-stu-id="d603a-166">The synchronization of this step is managed by the operating system DLL loader if native operating system delay load support is in use (e.g. ResolveDelayLoadedAPI) so no other component should reprotect the pages spanning the declared delay load IAT.</span></span> <span data-ttu-id="d603a-167">Aus Gründen der Abwärtskompatibilität mit älteren Pre-cfg-Betriebssystemen können Tools die Option zum Verschieben des verzögerten Lade Verfahrens in einen eigenen Abschnitt (kanonisch ". didat"), geschützt als Lese-/Schreibzugriff in den Bild Headern, aktivieren und zusätzlich das IMAGE_GUARD_CF_DELAYLOAD_IAT_IN_ITS_OWN_SECTION-Flag festlegen.</span><span class="sxs-lookup"><span data-stu-id="d603a-167">For backwards compatibility with older pre-CFG operating systems, tools may enable the option to move the delay load IAT into its own section (canonically “.didat”), protected as read/write in the image headers, and additionally set the IMAGE_GUARD_CF_DELAYLOAD_IAT_IN_ITS_OWN_SECTION flag.</span></span> <span data-ttu-id="d603a-168">Diese Einstellung bewirkt, dass cfg-fähige Betriebssystem-dll-Lade Programme den gesamten Abschnitt, der die IMAGE_DIRECTORY_ENTRY_DELAY_IMPORT Tabelle enthält, erneut schützen, um beim Laden des Images schreibgeschützten Speicher zu erhalten.</span><span class="sxs-lookup"><span data-stu-id="d603a-168">This setting will cause CFG-aware operating system DLL loaders to reprotect the entire section containing the IMAGE_DIRECTORY_ENTRY_DELAY_IMPORT table to read only memory during image loading.</span></span> <span data-ttu-id="d603a-169">Die Option zum Platzieren des verzögerten Ladens von IAT in einem eigenen Abschnitt ist möglicherweise nicht erforderlich, wenn Sie kein Abbild auf Betriebssystemen ausführen müssen, die die Unterstützung von CFG als prädate aufweisen, aber die Tools sollten diese Entscheidung basierend auf der minimalen Betriebssystemunterstützung, die ein Image benötigt, treffen.</span><span class="sxs-lookup"><span data-stu-id="d603a-169">The option to place the delay load IAT in its own section may not be required if you do not care about running an image on operating systems that predate CFG support, but tools should make that decision based on the minimum operating system support that an image needs.</span></span>

  <span data-ttu-id="d603a-170">Wenn ein Image nicht die systemeigene Verzögerungs ladeunterstützung des Betriebssystems verwendet, kann es dennoch die geschützten wartenverzögerungs-wartenbits festlegen.</span><span class="sxs-lookup"><span data-stu-id="d603a-170">If an image does not use the operating system’s native delay load support, it can still set the protected delay load related GuardFlags bits.</span></span> <span data-ttu-id="d603a-171">In dieser Konfiguration bietet das Betriebssystem-Lade Modul nur Unterstützung zum Schutz der verzögerten Verzögerungs Last (IAT) zur Laufzeit, wenn dies von der Plattform unterstützt wird. es ist die Verantwortung für die internen Load Resolution-Stub des Abbilds zum Synchronisieren und Verwalten des Schutzes für den verzögerten Ladevorgang.</span><span class="sxs-lookup"><span data-stu-id="d603a-171">In this configuration, the operating system loader will just provide support to protect the delay load IAT as read only at runtime if supported by the platform, and it becomes the responsibility of the image’s internal delay load resolution stubs to synchronize and manage protection of the delay load IAT.</span></span> <span data-ttu-id="d603a-172">Vorausgesetzt, die Auslastungs Konfigurations Tabelle wird im schreibgeschützten Speicher gespeichert (was empfohlen wird), kann das vorhanden sein oder Fehlen des IAT-Bits für die geschützte Verzögerungs Last im Feld "guardflags" des Bilds nützlich sein, um anzugeben, ob das Verzögerungs Lade-IAT geschützt werden soll.</span><span class="sxs-lookup"><span data-stu-id="d603a-172">Provided that the load configuration table is stored in read only memory (which is recommended), the presence or absence of the protected delay load IAT bit in the image’s GuardFlags field might be useful as an internal hint to the image’s internal delay load resolution stubs to indicate whether or not it should protect the delay load IAT.</span></span>

  <span data-ttu-id="d603a-173">Es wird empfohlen, dass geschütztes Verzögerungs laden standardmäßig aktiviert ist, wenn CFG aktiviert ist.</span><span class="sxs-lookup"><span data-stu-id="d603a-173">It is recommended that protected delay load be enabled by default if CFG is enabled.</span></span> <span data-ttu-id="d603a-174">Images, die unter älteren Betriebssystemversionen ausgeführt werden und die systemeigene Unterstützung für verzögertes verzögern des Betriebssystems verwenden, können, wie bereits erwähnt, den verzögerten Ladevorgang IAT in der eigenen Abschnitts Unterstützung für Abwärtskompatibilität verwenden.</span><span class="sxs-lookup"><span data-stu-id="d603a-174">Images that run on older operating system versions and that use the operating system’s native delay load support, as noted, may use the delay load IAT in its own section support for backwards compatibility.</span></span> <span data-ttu-id="d603a-175">Dies steht im Gegensatz zum Markieren der verzögerten verzögerten Last (IAT) als schreibgeschützt und zum Zusammenführen mit einem anderen Abschnitt, der bei älteren Betriebssystemen unterbrechen würde, die keine geschützten Verzögerungs Lasten verstehen und die systemeigene Unterstützung für die verzögerte Lade Auflösung ermöglichen.</span><span class="sxs-lookup"><span data-stu-id="d603a-175">This is opposed to marking the delay load IAT as read only and merging it with another section, which would break on older operating system’s that do not understand protected delay loads and which provide native delay load resolution support.</span></span> <span data-ttu-id="d603a-176">Alle Windows 10-Releases und die ersten Windows 8.1/Windows Server 2012 R2-Builds, die cfg unterstützten (d.h. das Update vom November 2014), führen zu einer Unterstützung für die geschützte Verzögerungs Last im Betriebssystem.</span><span class="sxs-lookup"><span data-stu-id="d603a-176">All Windows 10 releases and the first Windows 8.1/Windows Server 2012 R2 builds that supported CFG (meaning the November 2014 update) introduce support for protected delay load in the operating system.</span></span>

## <a name="function-alignment"></a><span data-ttu-id="d603a-177">Funktions Ausrichtung</span><span class="sxs-lookup"><span data-stu-id="d603a-177">Function alignment</span></span>

- <span data-ttu-id="d603a-178">Funktionen, die adressiert werden und daher in die **GFI DS** -Tabelle eingeschlossen werden, sollten nach Möglichkeit 16-Byte-ausgerichtet werden.</span><span class="sxs-lookup"><span data-stu-id="d603a-178">Functions that are address taken and are therefore included in the **GFIDS** table should be made 16-byte aligned, if possible.</span></span> <span data-ttu-id="d603a-179">Dies ist möglicherweise nicht immer möglich.</span><span class="sxs-lookup"><span data-stu-id="d603a-179">This may not always be possible.</span></span> <span data-ttu-id="d603a-180">Beispielsweise für nicht-COMDAT-Funktionen, die Teil von Objektdateien sind, die von nicht-cfg-fähigen Tools als eine Einheit zusammengestellt werden, die einige Assemblys erzeugen können, muss der Benutzer des Tools, das die Dateien erstellt hat, die Ausrichtung entsprechend festlegen.</span><span class="sxs-lookup"><span data-stu-id="d603a-180">For example, for non-COMDAT functions that are a part of object files assembled together as one unit by non-CFG aware tools, which some assemblers may produce, the user of the tool that produced the files must appropriately set the alignment.</span></span> <span data-ttu-id="d603a-181">Tools können in dieser Situation eine Diagnose Warnung ausgeben, damit der Benutzer geeignete Korrekturmaßnahmen ergreifen kann.</span><span class="sxs-lookup"><span data-stu-id="d603a-181">Tools may elect to issue a diagnostic warning in this situation so that the user can take appropriate corrective action.</span></span> <span data-ttu-id="d603a-182">Der Grund hierfür ist, dass cfg-Markierungen Ziele als gültig oder nicht in 16-Byte-Grenzen für die Effizienz von schnellen cfg-Überprüfungen aufruft.</span><span class="sxs-lookup"><span data-stu-id="d603a-182">The reason for this is that CFG marks call targets as valid or not valid on 16-byte boundaries for efficiency of fast CFG checks.</span></span> <span data-ttu-id="d603a-183">Wenn eine Funktion nicht mit 16 Byte ausgerichtet ist, muss der gesamte 16-Byte-Slot als gültig gekennzeichnet werden, was nicht so sicher ist, da Sie falsch ausgerichtete Code in Code schreiben können, der sich nicht am Anfang einer Funktion befindet.</span><span class="sxs-lookup"><span data-stu-id="d603a-183">If a function is not 16-byte aligned, then the entire 16-byte slot must be marked as valid, which is not as secure since you can call misaligned into code that is not at the very start of a function.</span></span> <span data-ttu-id="d603a-184">Dieses Szenario wird unterstützt, um die Interoperabilität zu vereinfachen, wenn Sie zunächst cfg für ein Projekt einrichten.</span><span class="sxs-lookup"><span data-stu-id="d603a-184">This scenario is supported for ease of interoperability when first bringing CFG up for a project.</span></span> <span data-ttu-id="d603a-185">Nicht cfg-fähige Bilder sind auf ähnliche Weise für jede Ziel Ausrichtung des Anweisungs Ziels als gültig gekennzeichnet.</span><span class="sxs-lookup"><span data-stu-id="d603a-185">Non-CFG aware images are similarly marked as valid for any call target alignment for compatibility.</span></span> <span data-ttu-id="d603a-186">Wie zuvor reduziert die Verwendung von falsch ausgerichteten calltargets die Sicherheitsvorteile von cfg, sodass die Tools automatisch an einer 16-Byte-Grenze für alle Elemente in der **GFI** -Tabelle ausgerichtet werden, wenn CFG für ein Abbild gewünscht wird.</span><span class="sxs-lookup"><span data-stu-id="d603a-186">As before, having misaligned call targets reduces the security benefits of CFG, so tools should automatically align to a 16-byte boundary for anything in the **GFIDS** table when CFG is desired for an image.</span></span> <span data-ttu-id="d603a-187">Symbole, die nicht in der **GFI DS** -Tabelle enthalten sind, benötigen keine bestimmten Ausrichtungen für cfg.</span><span class="sxs-lookup"><span data-stu-id="d603a-187">Symbols that are not in the **GFIDS** table do not need to have particular alignments for CFG.</span></span>

## <a name="export-suppression"></a><span data-ttu-id="d603a-188">Export Unterdrückung</span><span class="sxs-lookup"><span data-stu-id="d603a-188">Export suppression</span></span>

- <span data-ttu-id="d603a-189">CFG-Export Unterdrückung (CFG es) ist ein optionaler Modus, der es einem Prozess ermöglicht, anzugeben, dass es sich um callziele handelt, die nur gültig waren, weil es sich um dllexport-Symbole handelt und die noch nicht von GetProcAddress dynamisch aufgelöst wurden.</span><span class="sxs-lookup"><span data-stu-id="d603a-189">CFG export suppression (CFG ES) is an optional mode that enables a process to indicate that call targets which were only valid because they were dllexport symbols, and which have not yet been dynamically resolved by GetProcAddress, will be considered as not valid for purposes of CFG.</span></span> <span data-ttu-id="d603a-190">Dadurch wird der Oberflächen Bereich von cfg von System-DLL-Exporten reduziert.</span><span class="sxs-lookup"><span data-stu-id="d603a-190">This reduces the surface area of CFG from system DLL exports.</span></span> <span data-ttu-id="d603a-191">Die Export Unterdrückung umfasst das kommunizieren berechtigter "exporunterdrückter" dllexport-callziele, indem Sie mit den IMAGE_GUARD_FLAG_EXPORT_SUPPRESSED **GFI DS** -Flags gekennzeichnet werden.</span><span class="sxs-lookup"><span data-stu-id="d603a-191">Export suppression involves communicating eligible “export suppressed” dllexport call targets by marking them with the IMAGE_GUARD_FLAG_EXPORT_SUPPRESSED **GFIDS** flags.</span></span> <span data-ttu-id="d603a-192">Dllexport-Symbole und der PE-Abbild Einstiegspunkt sollten implizit als "Address" angesehen werden, die von Tools zum Erstellen der **gmeds** -Tabelle verwendet werden.</span><span class="sxs-lookup"><span data-stu-id="d603a-192">Dllexport symbols and the PE image entry point should be implicitly considered address taken by tools for purposes of generating the **GFIDS** table.</span></span>  <span data-ttu-id="d603a-193">Wenn ein Export Symbol 16-Byte-ausgerichtet ist und die Adresse aus keinem anderen Grund als dllexport entnommen wird, kann es in der Funktions Tabelle mit dem Export unterdrückter **GFI DS** -Flag gekennzeichnet werden.</span><span class="sxs-lookup"><span data-stu-id="d603a-193">If an export symbol is 16-byte aligned and it is address taken for no other reason than being a dllexport, then it can be marked with the export suppressed **GFIDS** flag in the function table.</span></span> <span data-ttu-id="d603a-194">Aufruf Ziele, die nicht mit 16 Byte ausgerichtet sind, **dürfen nicht** mit dem IMAGE_GUARD_FLAG_EXPORT_SUPPRESSED **GFI DS** -Flag gekennzeichnet werden und können nicht auf die dynamische Aktivierung als gültige Aufruf Ziele zur GetProcAddress-Zeit beschränkt werden.</span><span class="sxs-lookup"><span data-stu-id="d603a-194">Call targets that are not 16-byte aligned **must not** be marked with the IMAGE_GUARD_FLAG_EXPORT_SUPPRESSED **GFIDS** flag and cannot be restricted to only being dynamically enabled as valid call targets at GetProcAddress time.</span></span>

  <span data-ttu-id="d603a-195">Ein Bild, das cfg es unterstützt, enthält eine "guardadresssstakeniatentrytable", deren Anzahl von "guardadresssstakeniatentrycount" als Teil des Lade Konfigurations Verzeichnisses bereitgestellt wird.</span><span class="sxs-lookup"><span data-stu-id="d603a-195">An image that supports CFG ES includes a GuardAddressTakenIatEntryTable whose count is provided by the GuardAddressTakenIatEntryCount as part of its load configuration directory.</span></span> <span data-ttu-id="d603a-196">Diese Tabelle ist strukturell formatiert, identisch mit der **gmeds** -Tabelle.</span><span class="sxs-lookup"><span data-stu-id="d603a-196">This table is structurally formatted the same as the **GFIDS** table.</span></span> <span data-ttu-id="d603a-197">Er verwendet denselben guardflags-IMAGE_GUARD_CF_FUNCTION_TABLE_SIZE_MASK Mechanismus zum Codieren zusätzlicher optionaler metadatenbytes in der IAT-Tabelle, in der die IAT-Tabelle verwendet wird. alle metadatenbytes müssen jedoch für die an der IAT-Tabelle ergriffene Adresse 0</span><span class="sxs-lookup"><span data-stu-id="d603a-197">It uses the same GuardFlags IMAGE_GUARD_CF_FUNCTION_TABLE_SIZE_MASK mechanism to encode extra optional metadata bytes in the address taken IAT table, though all metadata bytes must be zero for the address taken IAT table and are reserved.</span></span> <span data-ttu-id="d603a-198">Die IAT Table-Adresse gibt ein sortiertes Array von RVAs von Import-thunken an, für die das als Symbol Adresse importierte "CallTarget" importiert wurde.</span><span class="sxs-lookup"><span data-stu-id="d603a-198">The address taken IAT table indicates a sorted array of RVAs of import thunks which have the imported as a symbol address taken call target.</span></span> <span data-ttu-id="d603a-199">Dieses Konstrukt unterstützt Address-Symbole, die in einem Remote Modul vorhanden sind, und bei denen es sich um dllexports handelt, wobei cfg verwendet werden.</span><span class="sxs-lookup"><span data-stu-id="d603a-199">This construct supports address taken symbols that exist in a remote module, and which are dllexports, with CFG ES in use.</span></span> <span data-ttu-id="d603a-200">Ein Beispiel für ein solches Code Konstrukt wäre:</span><span class="sxs-lookup"><span data-stu-id="d603a-200">An example of such a code construct would be:</span></span>

  ```
  mov rcx, [__imp_DefWindowProc]
  call foo ; where foo takes the actual address of DefWindowProc.
  ```

  <span data-ttu-id="d603a-201">Alle mit dem Import von thunten erstellten Adressen müssen aufgelistet werden, damit das Betriebssystem-Lade Modul Sie finden kann, und die entsprechenden callziele beim Laden eines Bilds und Ausrichten der Importe als gültig festlegen.</span><span class="sxs-lookup"><span data-stu-id="d603a-201">All such address taken import thunks must be enumerated so that the operating system loader can find them and make the appropriate call targets valid when loading an image and snapping its imports.</span></span> <span data-ttu-id="d603a-202">"Table" und "count" können den Wert "0" aufweisen, wenn keine importierten thunten vorhanden sind.</span><span class="sxs-lookup"><span data-stu-id="d603a-202">The table and count can be 0 if there are no import thunks that were address taken.</span></span>

  <span data-ttu-id="d603a-203">Ein Modul legt das IMAGE_GUARD_CF_EXPORT_SUPPRESSION_INFO_PRESENT guardflags-Bit fest, um anzugeben, dass es alle Adressen, die in seiner Adresse als IAT-Tabelle entnommen wurden, aufgezählt haben und dass alle exportierbaren Exporte mit dem IMAGE_GUARD_FLAG_EXPORT_SUPPRESSED **GFI DS** -Flag gekennzeichnet sind.</span><span class="sxs-lookup"><span data-stu-id="d603a-203">A module sets the IMAGE_GUARD_CF_EXPORT_SUPPRESSION_INFO_PRESENT GuardFlags bit to indicate that it has enumerated all address taken thunks in its address taken IAT table and that all exports that are CFG ES eligible are marked with the IMAGE_GUARD_FLAG_EXPORT_SUPPRESSED **GFIDS** flag.</span></span> <span data-ttu-id="d603a-204">Beachten Sie, dass es möglicherweise keine solchen thunchen gibt und dass möglicherweise auch keine solchen dllexport-Symbole vorhanden sind.</span><span class="sxs-lookup"><span data-stu-id="d603a-204">Note that there may be zero such thunks and that there may also be zero such dllexport symbols.</span></span> <span data-ttu-id="d603a-205">Ein Fehler bei der Beibehaltung der IAT-Tabelle kann ein Problem mit der Richtigkeit sein, da einige Aufruf Ziele möglicherweise nicht als gültig festgelegt werden, wenn Sie zur DLL-Ladezeit verwendet werden sollen.</span><span class="sxs-lookup"><span data-stu-id="d603a-205">Failure to maintain the address taken IAT table can be a correctness issue as some call targets might not be made valid when they should be at DLL load time.</span></span>

  <span data-ttu-id="d603a-206">Ein Modul legt das IMAGE_GUARD_CF_ENABLE_EXPORT_SUPPRESSION guardflags-Bit fest, um anzugeben, dass es für den Prozess cfg-Werte aktivieren soll.</span><span class="sxs-lookup"><span data-stu-id="d603a-206">A module sets the IMAGE_GUARD_CF_ENABLE_EXPORT_SUPPRESSION GuardFlags bit to indicate that it wants to enable CFG ES for the process.</span></span> <span data-ttu-id="d603a-207">In der Praxis ist dies nur noch heute von Bedeutung.</span><span class="sxs-lookup"><span data-stu-id="d603a-207">In practice, this is only meaningful for EXEs today.</span></span> <span data-ttu-id="d603a-208">Ein Prozess, der cfg es aktiviert, sollte keine DLLs laden, die nicht mit cfg es erstellt wurden, oder es können Laufzeitfehler auftreten, weil nicht festgelegte Adressen IAT-Symbole entnommen haben</span><span class="sxs-lookup"><span data-stu-id="d603a-208">A process enabling CFG ES should not load DLLs not built with CFG ES or runtime failures may occur because of undesignated address taken IAT symbols.</span></span> <span data-ttu-id="d603a-209">Die Unterstützung für das Aktivieren von CFG es sollte eine separate Option zum Aktivieren von CFG sein.</span><span class="sxs-lookup"><span data-stu-id="d603a-209">Support for enabling CFG ES should be a separate opt-in option from enabling CFG.</span></span> <span data-ttu-id="d603a-210">Das Bereitstellen von CFG es-Metadaten ist sicher und wird standardmäßig mit cfg empfohlen, obwohl Toolsets darauf achten müssen, dass Sie korrekte Metadaten liefern.</span><span class="sxs-lookup"><span data-stu-id="d603a-210">Providing CFG ES metadata is safe and recommended by default with CFG, though toolsets must take care to ensure they produce correct metadata.</span></span> <span data-ttu-id="d603a-211">Andernfalls werden die generierten Images möglicherweise nicht ordnungsgemäß in einem cfg es-Prozess ausgeführt.</span><span class="sxs-lookup"><span data-stu-id="d603a-211">If not, their generated images may not run properly in a CFG ES process.</span></span> <span data-ttu-id="d603a-212">Diese Unterstützung sollte in einem Testprozess gründlich getestet werden, der cfg es erzwingt.</span><span class="sxs-lookup"><span data-stu-id="d603a-212">Such support should be thoroughly tested in a test process that enforces CFG ES.</span></span> <span data-ttu-id="d603a-213">Die integrierten System-DLLs für das Betriebssystem unterstützen cfg es-Metadaten für moderne Windows 10-Betriebssystemversionen, die CFG-Dateien verstehen.</span><span class="sxs-lookup"><span data-stu-id="d603a-213">The operating system built-in system DLLs support CFG ES metadata for modern Windows 10 operating system versions that understand CFG ES.</span></span> <span data-ttu-id="d603a-214">Betriebssystemversionen vor dieser Unterstützung verstehen keine cfg-Elemente und ignorieren alle in der Abbildung bezogenen cfg-bezogenen Direktiven.</span><span class="sxs-lookup"><span data-stu-id="d603a-214">Operating system versions prior to this support do not understand CFG ES at all and will ignore any CFG ES related directives in the image.</span></span> <span data-ttu-id="d603a-215">Diese Images sind nach wie vor abwärts kompatibel mit älteren Betriebssystemversionen.</span><span class="sxs-lookup"><span data-stu-id="d603a-215">Such images are still backwards compatible to older operating system versions.</span></span>

  <span data-ttu-id="d603a-216">Die Unterstützung von CFG es ist aus der Perspektive eines Toolsets optional, aber es wird empfohlen, dass Toolsets zumindest Unterstützung für die Enumeration von ausreichenden Informationen enthalten, damit Bilder in einem Prozess ausgeführt werden können, der CFG-Dateien wünscht.</span><span class="sxs-lookup"><span data-stu-id="d603a-216">CFG ES support is optional from a toolset perspective, but it is recommended that toolsets at least include support to enumerate enough information for images to run in a process that desires CFG ES.</span></span> <span data-ttu-id="d603a-217">Wie bereits erwähnt, ist es wichtig, dass die Unterstützung von Toolsets gründlich getestet wird, um sicherzustellen, dass Sie mit cfg es kompatibel ist, da die meisten Prozesse cfg es noch nicht aktivieren.</span><span class="sxs-lookup"><span data-stu-id="d603a-217">As mentioned, it is critical that toolset support be thoroughly tested to ensure that it is compatible with CFG ES, as most processes don’t yet enable CFG ES.</span></span>

## <a name="exception-handling-and-unwinding"></a><span data-ttu-id="d603a-218">Ausnahmebehandlung und-Entwicklung</span><span class="sxs-lookup"><span data-stu-id="d603a-218">Exception handling and unwinding</span></span>

- <span data-ttu-id="d603a-219">Sprachspezifische Handler wie __C_specific_handler, wie von den ausnahmehandlerinformationen in einer. pdata-Registrierung festgelegt, dürfen nicht als gültige calltargets in der **GFI** -Tabelle gekennzeichnet werden.</span><span class="sxs-lookup"><span data-stu-id="d603a-219">Language specific handlers like __C_specific_handler, as designated by the exception handler information in a .pdata registration, should not be marked as valid call targets in the **GFIDS** table.</span></span> <span data-ttu-id="d603a-220">Sie werden stattdessen durch Durchlaufen des schreibgeschützten Speichers gesucht.</span><span class="sxs-lookup"><span data-stu-id="d603a-220">They are instead looked up by traversing read only memory.</span></span> <span data-ttu-id="d603a-221">Ebenso verwendet der Microsoft C-sprachspezifische Handler schreibgeschützte Speicher Suchvorgänge, um funclets für Ausnahmehandler zu suchen, und deklariert seine funclets daher nicht als gültige calltargets in der **GFI** -Tabelle.</span><span class="sxs-lookup"><span data-stu-id="d603a-221">Similarly, the Microsoft C language specific handler uses read only memory searches to locate funclets for exception handlers and thus does not declare its funclets as valid call targets in the **GFIDS** table.</span></span>

- <span data-ttu-id="d603a-222">Lange Sprung Behandlung (für nicht-x86-Ziele wie amd64): Toolsets, die mit cfg kompiliert werden und setjmp ()/longjmp () unterstützen, sollten Long Jump als "sicherer langer Sprung" implementieren, der mit strukturierter Ausnahmebehandlung (SEH) interagiert.</span><span class="sxs-lookup"><span data-stu-id="d603a-222">Long jump handling (for non-x86 targets like AMD64):  Toolsets compiling with CFG and supporting setjmp()/longjmp() should implement long jump as “safe long jump” that interoperates with structured exception handling (SEH).</span></span> <span data-ttu-id="d603a-223">Dies bedeutet, dass Long Jump als calllunwindex-Befehl implementiert ist, wobei STATUS_LONGJUMP als Status Code im angegebenen Ausnahme Daten Satz und eine Standard _JUMP_BUFFER auf die von ExceptionInformation [0] verwiesen wird.</span><span class="sxs-lookup"><span data-stu-id="d603a-223">This means long jump is implemented as a call to RtlUnwindEx with STATUS_LONGJUMP as the status code in the supplied exception record and a standard _JUMP_BUFFER pointed to by ExceptionInformation[0].</span></span> <span data-ttu-id="d603a-224">Das Sprung Entlade Ziel sollte die TargetIp der Entladung sein.</span><span class="sxs-lookup"><span data-stu-id="d603a-224">The jump unwind target should be the TargetIp of the unwind.</span></span> <span data-ttu-id="d603a-225">Der Sprung Puffer stellt den Registrierungs Kontext dar, der vom Betriebssystem wieder hergestellt wird, nachdem der lange Sprung abgeschlossen wurde.</span><span class="sxs-lookup"><span data-stu-id="d603a-225">The jump buffer represents the register context that is restored by the operating system after the long jump has completed.</span></span> <span data-ttu-id="d603a-226">Rtlunwind (ex) hat bei Aufruf mit STATUS_LONGJUMP besondere Bedeutung, die für cfg eindeutig ist.</span><span class="sxs-lookup"><span data-stu-id="d603a-226">RtlUnwind(Ex) when called with STATUS_LONGJUMP has special significance unique to CFG.</span></span> <span data-ttu-id="d603a-227">Das Long-Sprungziel (_JUMP_BUFFER. RIP oder _JUMP_BUFFER. LR auf ARM64) wird in der Liste geladener Module gesucht, die vom Betriebssystem im schreibgeschützten Speicher verwaltet wird.</span><span class="sxs-lookup"><span data-stu-id="d603a-227">The long jump target (_JUMP_BUFFER.Rip or _JUMP_BUFFER.Lr on ARM64) is looked up in the loaded module list maintained by the operating system in read only memory.</span></span> <span data-ttu-id="d603a-228">Wenn für das enthaltende Modul für das Sprungziel (das Ziel Modul) das IMAGE_GUARD_CF_LONGJUMP_TABLE_PRESENT-Flag im Feld "guardflags" festgelegt ist, hat das Konfigurationsverzeichnis "Laden" eine Element Anzahl, die im Feld "Load Configuration guardlongjumptargetcount" angegeben ist.</span><span class="sxs-lookup"><span data-stu-id="d603a-228">If the containing module for the jump target (the “target module”) has the IMAGE_GUARD_CF_LONGJUMP_TABLE_PRESENT flag set in its GuardFlags field, then the load configuration directory has a GuardLongJumpTargetTable whith an element count specified by the load configuration GuardLongJumpTargetCount field.</span></span> <span data-ttu-id="d603a-229">Diese Tabelle ist strukturell formatiert, identisch mit der **gatds** -Tabelle und verwendet denselben guardflags-IMAGE_GUARD_CF_FUNCTION_TABLE_SIZE_MASK Mechanismus, um optionale zusätzliche metadatenbytes in der Long Jump Table zu codieren.</span><span class="sxs-lookup"><span data-stu-id="d603a-229">This table is structurally formatted the same as the **GFIDS** table and uses the same GuardFlags IMAGE_GUARD_CF_FUNCTION_TABLE_SIZE_MASK mechanism to encode optional extra metadata bytes in the long jump table.</span></span> <span data-ttu-id="d603a-230">Alle metadatenbytes müssen für die Long-Sprung Tabelle 0 (null) sein und sind reserviert.</span><span class="sxs-lookup"><span data-stu-id="d603a-230">All metadata bytes must be zero for the long jump table and are reserved.</span></span>

  <span data-ttu-id="d603a-231">Die lange Sprung Tabelle stellt ein sortiertes Array von RVAs dar, die gültige lange Sprung Ziele sind.</span><span class="sxs-lookup"><span data-stu-id="d603a-231">The long jump table represents a sorted array of RVAs that are valid long jump targets.</span></span> <span data-ttu-id="d603a-232">Wenn ein Modul für den langen Sprung Zielwert IMAGE_GUARD_CF_LONGJUMP_TABLE_PRESENT im Feld "guardflags" festlegt, müssen alle langen Sprung Ziele in "longjumptargeamp;" aufgezählt werden.</span><span class="sxs-lookup"><span data-stu-id="d603a-232">If a long jump target module sets IMAGE_GUARD_CF_LONGJUMP_TABLE_PRESENT in its GuardFlags field, then all long jump targets must be enumerated in the LongJumpTargetTable.</span></span> <span data-ttu-id="d603a-233">Auch wenn ein Modul über keine langen Sprung Ziele verfügt, sollte das IMAGE_GUARD_CF_LONGJUMP_TABLE_PRESENT-Flag weiterhin festgelegt werden, wenn das Toolset eine lange Sprung Härtung für cfg unterstützt.</span><span class="sxs-lookup"><span data-stu-id="d603a-233">Even if a module has zero long jump targets, it should still set the IMAGE_GUARD_CF_LONGJUMP_TABLE_PRESENT flag if the toolset supports long jump hardening for CFG.</span></span> <span data-ttu-id="d603a-234">Dies bedeutet explizit, dass das Image über keine langen Sprung Ziele verfügt und kein altes Image ist, das vom Betriebssystem angenommen werden kann, wenn es über gültige lange Sprung Ziele an nicht markierten Positionen verfügen kann, für die keine Überprüfung des langen Sprung Ziels ausgeführt werden kann.</span><span class="sxs-lookup"><span data-stu-id="d603a-234">This explicitly means that the image has no long jump targets and is not an old image that the operating system must assume could have valid long jump targets at unmarked locations for which it cannot perform long jump target checking.</span></span>

  <span data-ttu-id="d603a-235">Eine lange Sprung Härtung wird empfohlen, wenn CFG unterstützt wird.</span><span class="sxs-lookup"><span data-stu-id="d603a-235">Long jump hardening is recommended to be enabled by default if CFG is supported.</span></span> <span data-ttu-id="d603a-236">Dies ist die Disposition von Microsoft-Compilern.</span><span class="sxs-lookup"><span data-stu-id="d603a-236">This is the disposition of Microsoft compilers.</span></span> <span data-ttu-id="d603a-237">Betriebssysteme, die die lange Sprung Härtung (Pre-Windows 10 oder ältere Windows 10-Versionen) nicht verstehen, führen keine langen Sprung-Härtungs Prüfungen durch, und ignorieren alle langen Aufwärm Härtungs Metadaten, sodass eine lange Sprung Härtung rückwärts mit älteren Betriebssystemversionen kompatibel ist.</span><span class="sxs-lookup"><span data-stu-id="d603a-237">Operating systems that do not understand long jump hardening (pre-Windows 10 or older Windows 10 versions) will not perform long jump hardening checks and ignore any long jump hardening metadata, so long jump hardening is backwards compatible with older operating system releases.</span></span>

  <span data-ttu-id="d603a-238">Bei kernelmodusimages sollte die Guard Long Jump Target-Tabelle nicht in einem verwerfbaren Abschnitt enthalten sein.</span><span class="sxs-lookup"><span data-stu-id="d603a-238">For kernel mode images, the guard long jump target table should not be included in a discardable section.</span></span> <span data-ttu-id="d603a-239">Die Guard Long Jump Target-Tabelle sollte immer im schreibgeschützten Speicher abgelegt werden, damit die Sicherheitseigenschaften wirksam werden.</span><span class="sxs-lookup"><span data-stu-id="d603a-239">The guard long jump target table should always be stored in read only memory for its security properties to be effective.</span></span>

## <a name="coff-information"></a><span data-ttu-id="d603a-240">COFF-Informationen</span><span class="sxs-lookup"><span data-stu-id="d603a-240">COFF information</span></span>

- <span data-ttu-id="d603a-241">Es gibt Objektdatei Markierungen, um zu deklarieren, ob eine Objektdatei mit cfg konform ist.</span><span class="sxs-lookup"><span data-stu-id="d603a-241">There are object file markings to declare whether an object file conforms to CFG or not.</span></span> <span data-ttu-id="d603a-242">Eine Objektdatei, die cfg entspricht, listet die gültigen callziele, die Sie generiert, explizit sowie alle Adressen, die IAT-Metadaten enthalten, auf.</span><span class="sxs-lookup"><span data-stu-id="d603a-242">An object file that conforms to CFG will list the valid call targets that it produces, explicitly, as well as any address taken IAT metadata.</span></span> <span data-ttu-id="d603a-243">Für eine Objektdatei, die nicht mit cfg konform ist, müssen die Rückruf Ziele abgeleitet werden, indem die COFF-Umsetzungen der obj-Datei untersucht werden, um nach Verschiebungen zu suchen, die auf den Anfang eines Funktions Symbols zeigen.</span><span class="sxs-lookup"><span data-stu-id="d603a-243">An object file that does not conform to CFG must have call targets inferred by examining the COFF relocations of the obj file to find relocations that point to the start of a function symbol.</span></span> <span data-ttu-id="d603a-244">Dies kann zu einer Überschreitung gültiger cfg-callziele werden. Daher ist es wünschenswert, dass Tools Ihre OBJ-Dateien markieren, die cfg-fähig sind, und die Metadaten der cfg obj-Datei enthalten, wenn Sie mit cfg kompiliert werden</span><span class="sxs-lookup"><span data-stu-id="d603a-244">This may overapproximate valid CFG call targets so it is desirable that tools mark their obj files that are CFG-aware and include the CFG obj file metadata if compiling with CFG.</span></span>

- <span data-ttu-id="d603a-245">Es gibt Objektdatei Markierungen, um lange Sprung Ziele für cfg-festgeschriebene lange Sprünge zu deklarieren, die für den cfg-Kompilierungs Modus aufgefüllt werden sollen.</span><span class="sxs-lookup"><span data-stu-id="d603a-245">There are object file markings to declare long jump targets for CFG hardened long jump which should be populated for CFG compilation mode.</span></span>
