---
description: Dieser Artikel enthält weitere Details zu den Ablauf Steuerungs Schutz-Metadaten in PE-Images.
title: PE-Metadaten
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: 52eb54ac953be4ac09461dbc92bb39d8afc5d332
ms.sourcegitcommit: 831e8f3db78ab820e1710cede244553c70e50500
ms.translationtype: MT
ms.contentlocale: de-DE
ms.lasthandoff: 01/08/2021
ms.locfileid: "106351143"
---
# <a name="pe-metadata"></a>PE-Metadaten

Dieser Artikel enthält zusätzliche Details zu den Metadaten des Control Flow Guard (CFG) in PE-Images. Es wird davon ausgegangen, dass die Struktur von CFG-Metadaten in PE-Images Vertrautheit ist. Im Thema [PE-Format](../debug/pe-format.md) finden Sie eine ausführliche Dokumentation für cfg-Metadaten in PE-Images.

- Funktionen, die gültige indirekte callziele sind, werden in der " **guardcffunctiontable** " aufgelistet, die an das Konfigurationsverzeichnis "Load" angefügt ist, was manchmal auch als **gmeds** -Tabelle bezeichnet wird. Dies ist eine sortierte Liste von relativen virtuellen Adressen (RVA), die Informationen zu gültigen cfg-callzielen enthalten. Dabei handelt es sich im Allgemeinen um Funktions Symbole, die von der Adresse übernommen werden Ein Bild, das die cfg-Erzwingung erfordert, muss alle in der zugehörigen **GFI** -Tabelle ausgeführten Funktions Symbole auflisten. Die RVA-Liste in der **GFI DS** -Tabelle muss ordnungsgemäß sortiert werden, oder das Image wird nicht geladen. Die **gmeds** -Tabelle ist ein Array von 4 + *n* bytes, wobei *n* von (("guardflags & IMAGE_GUARD_CF_FUNCTION_TABLE_SIZE_MASK)  >> IMAGE_GUARD_CF_FUNCTION_TABLE_SIZE_SHIFT)" angegeben wird. "Guardflags" ist das Feld "guardflags" des Konfigurations Verzeichnisses "Load". Dadurch können zusätzliche Metadaten in Zukunft an cfg-callziele angefügt werden. Die einzigen aktuell definierten Metadaten sind ein optionales 1-Byte-extra-Flags-Feld ("gmeds-Flags"), das an jeden **GFI** -Eintrag angefügt wird, wenn beliebige callziele über Metadaten verfügen. Zwei **GFI DS** -Flags sind definiert:
  
  | &nbsp; | &nbsp; |
  | ---- |:---- |
  | IMAGE_GUARD_FLAG_FID_SUPPRESSED/0x1 | Das Aufrufziel wird explizit unterdrückt (behandeln Sie es für cfg nicht als gültig). |
  | IMAGE_GUARD_FLAG_EXPORT_SUPPRESSED/0x2 | Der Export des callziels wird unterdrückt. Weitere Informationen finden Sie unter [Export Unterdrückung](#export-suppression) . |
  
  Um die Kompatibilität zu erhöhen, sollten die Tools keine **gatds** -Flags festlegen, die noch nicht definiert wurden, und keine zusätzlichen **gmeds** zusätzlichen metadatenbytes enthalten, die über das aktuell definierte 1-Byte hinausgehen, da die Bedeutung für andere Flags oder zusätzliche Metadaten noch nicht zugewiesen ist. Sie finden Beispiele für Images, die zusätzliche metadatenbytes enthalten, indem Sie die **gmeds** -Tabelle der Binärdateien, z. b. Ntdll.dll, auf einer modernen Windows 10-Betriebssystemversion sichern.

  Tools sollten Funktions Symbole nur als gültige callziele deklarieren, was möglicherweise zusätzliche Überlegungen zu Assemblycode verdient, bei dem Bezeichnungen möglicherweise adressiert werden. Aus historischen Gründen kann der Assemblycode von anderen Code Bezeichnungen als proc oder. altentry abhängen, die nicht in cfg-callziele durch den Linker konvertiert werden.

  Aus historischen Gründen kann Code absichtlich Code als Daten deklarieren, um die Einbindung in die **GFI DS** -Tabelle zu vermeiden. Beispielsweise kann eine Objektdatei ein Symbol als Code implementieren, während ein anderes das Symbol als Daten deklarieren kann, um die Adresse des Symbols zu übernehmen, ohne einen gültigen cfg-Zieldatensatz zu erstellen. Aus Kompatibilitätsgründen wird empfohlen, dass Toolsets diese Vorgehensweise unterstützen.

- Images, die cfg unterstützen und cfg-Überprüfungen durchführen möchten, sollten die IMAGE_GUARD_CF_INSTRUMENTED-und IMAGE_GUARD_CF_FUNCTION_TABLE_PRESENT guardflags-Bits festlegen und das IMAGE_DLLCHARACTERISTICS_GUARD_CF DllCharacteristics-Bit in den Bild Headern festlegen.

- Das Lade Konfigurationsverzeichnis weist zwei Funktionszeiger auf: "guardcfcheckfunctionpointer" und "guardcfdispatchfunctionpointer" (Letzteres wird nur für bestimmte Architekturen wie amd64 unterstützt). Diese Funktionszeiger sollten auf den schreibgeschützten Speicher verweisen, damit die cfg-Sicherheit wirksam ist. Das dll-Lade Modul des Betriebssystems schützt den Speicher beim Laden des Images beim Laden der Funktionen erneut, um die Funktionszeiger zu speichern. Die typische Verwendung besteht darin, diese in demselben Abschnitt zusammenzuführen, der die Import Adress Tabelle (IAT) enthält. Der "guardcfcheckfunctionpointer" stellt die Adresse eines von einem Betriebssystem bereitgestellten Symbols bereit, das mit einem Funktionszeiger in der ersten ganzzahligen Argument Registrierung (ECX auf x86) aufgerufen werden kann, die bei Erfolg zurückgegeben wird, oder den Prozess Abbrechen, wenn das Aufruf Ziel kein gültiges cfg-Ziel ist. Der "guardcfdispatchfunctionpointer" stellt die Adresse eines von einem Betriebssystem bereitgestellten Symbols bereit, das ein Aufruf Ziel in Register Rax annimmt und einen kombinierten cfg-Check-und End-Branch-optimierten Aufruf des Aufruf Ziels ausführt (die Register "R10/R11" sind für die Verwendung durch das Ultimate-Aufruf Ziel reserviert). Die Standardadresse der cfg-Symbole in einem Bild sollte auf eine Funktion verweisen, die nur (guardcfcheckfunctionpointer) zurückgibt, oder die ein vom Wächter unterdrücktes Symbol zurückgibt (oder vorzugsweise im **GFI** -Tabellen Symbol vollständig ausgelassen wird), das eine "jmp Rax"-Anweisung ausführt. Wenn für AMD64 guardcfdispatchfunctionpointer ein Bild auf einem cfg-fähigen Betriebssystem geladen und cfg aktiviert ist, installiert das Betriebssystem-dll-Lade Modul geeignete Funktionszeiger, die die Abwärtskompatibilität der Einrichtungen ermöglichen. Ein Bild kann 0 für den "guardcfdispatchfunctionpointer" in der Auslastungs Konfiguration angeben, wenn er die cfg-dispatchfunktion nicht verwenden möchte. Dies sollte für nicht-amd64-Architekturen zur zukünftigen Kompatibilität erfolgen, falls diese Architekturen den cfg-Verteilungsmechanismus in irgendeiner Form unterstützen. Beachten Sie, dass Windows 8.1 amd64 die cfg-Verteilung nicht unterstützte und den Standard Funktionszeiger für "guardcfdispatchfunctionpointer" belassen würde. CFG-Dispatch wird nur unter Windows 10 und höheren Betriebssystemen unterstützt.

- Der Benutzermodus-cfg kann nur für Bilder erzwungen werden, die als "Address Space Layout Anordnung (ASLR)-kompatibel" gekennzeichnet sind (angegeben durch die Option/DynamicBase mit dem Microsoft-Linker). Dies liegt daran, wie das Betriebssystem cfg intern verarbeitet, wo es im Wesentlichen mit der ASLR-Infrastruktur verknüpft ist. Im Allgemeinen sollten Benutzer von CFG ASLR als ersten Schritt für Ihre Images aktivieren. Tools sollten nicht davon ausgehen, dass das Betriebssystem "cfg" immer ohne ASLR-Satz ignoriert, aber in der Regel beide gleichzeitig festgelegt werden sollte.

## <a name="compiler-directives"></a>Compilerdirektiven

- Callziele können mit dem __declspec (Guard (Unterdrückung))-Modifizierer oder mit der/guardsym: symname, S-linkerdirektive (z. b. für ASM-Code) als explizit unterdrückt gekennzeichnet werden. Dies bewirkt, dass das aufrufsziel in der **GFI DS** -Tabelle enthalten ist, aber so gekennzeichnet ist, dass das Betriebssystem das aufrufsziel als ungültig behandelt. Einige nicht produktive Szenarien, wie z. b. mit einer bestimmten anwendungsverifiziererinstrumentation, die für einige ältere Betriebssysteme aktiviert ist, können unterdrückte calltargets als gültig behandeln, aber im Allgemeinen werden diese Szenarien nicht als Produktions Szenarios erwartet. Diese Direktive ist nützlich, um "gefährliche" Funktionen zu kommentieren, die nicht als gültige callziele angesehen werden sollten, auch wenn Sie in der normalen cfg-Regel enthalten sind.

- Code kann angeben, dass cfg-Überprüfungen nicht mit dem __declspec (Guard (nocf))-Modifizierer gewünscht werden. Dadurch wird der Compiler angewiesen, keine cfg-Überprüfungen für die gesamte Funktion einzufügen. Der Compiler sollte darauf achten, diese Direktive an jeden von einer Inline Funktion beigetragenen Code weiterzugeben, der als keine Überprüfung der cfg-Überprüfungen gekennzeichnet ist. Diese Vorgehensweise wird in der Regel nur selten in bestimmten Situationen verwendet, in denen der Programmierer den "cfg-äquivalenten" Schutz manuell eingefügt hat. Der Programmierer weiß, dass Sie über eine schreibgeschützte Funktions Tabelle aufrufen, deren Adresse durch schreibgeschützte Speicher Verweise abgerufen wird und für die der Index mit dem Grenzwert für die Funktions Tabelle maskiert ist. Diese Vorgehensweise kann auch auf kleine Wrapper Funktionen angewendet werden, die nicht Inline sind, und die nichts weiter tun, als einen Funktionszeiger aufzurufen. Da durch eine falsche Verwendung dieser Direktive die Sicherheit von CFG beeinträchtigt werden kann, muss der Programmierer mit der-Direktive sehr vorsichtig sein. In der Regel ist diese Verwendung auf sehr kleine Funktionen beschränkt, die nur eine Funktion aufzurufen.

## <a name="import-handling"></a>Import Verarbeitung

- Aufrufe über IAT sollten keinen cfg-Schutz verwenden. Der IAT ist in modernen Images schreibgeschützt (vorausgesetzt, dass der IAT in den PE-Headern deklariert ist, und er muss sich auf seinen eigenen Seiten befinden). Der IAT kann verwendet werden, um Funktionen zu erreichen, die Schutz unterdrückt werden. Dies ist eine korrekte Anforderung. Schreib geschützter Speicherschutz durch IAT ersetzt die von cfg, da die Bindungs Ziel Bindung nach der Auflösung der Bild Import-Ausgangsbox unveränderlich ist und die Bindungs Auflösung fein abgeglichen wird.

- Geschütztes verzögertes Laden: Aufrufe über das Verzögerungs Lade-IAT sollten keinen cfg-Schutz verwenden, aus denselben Gründen wie bei der Standard-IAT. Der Verzögerungs Lade-IAT sollte sich in einem eigenen Abschnitt befinden, und das Image sollte das IMAGE_GUARD_CF_PROTECT_DELAYLOAD_IAT guardflags-Bit festlegen. Dies deutet darauf hin, dass das dll-Lade Tool des Betriebssystems während der Export Auflösung den Schutz für das Verzögerungs Laden von IAT ändern soll, wenn die Verzögerungs Auslastung des Betriebssystems System eigen für Windows 8 und spätere Betriebssysteme verwendet wird. Die Synchronisierung dieses Schritts wird vom Betriebssystem-dll-Lade Programm verwaltet, wenn die Unterstützung für das systemeigene verzögerte Laden von Betriebssystemen (z. b. resolvedelta-loadedapi) verwendet wird, sodass keine andere Komponente die Seiten erneut schützen soll, die das deklarierte Verzögerungs Lade Modul umfassen. Aus Gründen der Abwärtskompatibilität mit älteren Pre-cfg-Betriebssystemen können Tools die Option zum Verschieben des verzögerten Lade Verfahrens in einen eigenen Abschnitt (kanonisch ". didat"), geschützt als Lese-/Schreibzugriff in den Bild Headern, aktivieren und zusätzlich das IMAGE_GUARD_CF_DELAYLOAD_IAT_IN_ITS_OWN_SECTION-Flag festlegen. Diese Einstellung bewirkt, dass cfg-fähige Betriebssystem-dll-Lade Programme den gesamten Abschnitt, der die IMAGE_DIRECTORY_ENTRY_DELAY_IMPORT Tabelle enthält, erneut schützen, um beim Laden des Images schreibgeschützten Speicher zu erhalten. Die Option zum Platzieren des verzögerten Ladens von IAT in einem eigenen Abschnitt ist möglicherweise nicht erforderlich, wenn Sie kein Abbild auf Betriebssystemen ausführen müssen, die die Unterstützung von CFG als prädate aufweisen, aber die Tools sollten diese Entscheidung basierend auf der minimalen Betriebssystemunterstützung, die ein Image benötigt, treffen.

  Wenn ein Image nicht die systemeigene Verzögerungs ladeunterstützung des Betriebssystems verwendet, kann es dennoch die geschützten wartenverzögerungs-wartenbits festlegen. In dieser Konfiguration bietet das Betriebssystem-Lade Modul nur Unterstützung zum Schutz der verzögerten Verzögerungs Last (IAT) zur Laufzeit, wenn dies von der Plattform unterstützt wird. es ist die Verantwortung für die internen Load Resolution-Stub des Abbilds zum Synchronisieren und Verwalten des Schutzes für den verzögerten Ladevorgang. Vorausgesetzt, die Auslastungs Konfigurations Tabelle wird im schreibgeschützten Speicher gespeichert (was empfohlen wird), kann das vorhanden sein oder Fehlen des IAT-Bits für die geschützte Verzögerungs Last im Feld "guardflags" des Bilds nützlich sein, um anzugeben, ob das Verzögerungs Lade-IAT geschützt werden soll.

  Es wird empfohlen, dass geschütztes Verzögerungs laden standardmäßig aktiviert ist, wenn CFG aktiviert ist. Images, die unter älteren Betriebssystemversionen ausgeführt werden und die systemeigene Unterstützung für verzögertes verzögern des Betriebssystems verwenden, können, wie bereits erwähnt, den verzögerten Ladevorgang IAT in der eigenen Abschnitts Unterstützung für Abwärtskompatibilität verwenden. Dies steht im Gegensatz zum Markieren der verzögerten verzögerten Last (IAT) als schreibgeschützt und zum Zusammenführen mit einem anderen Abschnitt, der bei älteren Betriebssystemen unterbrechen würde, die keine geschützten Verzögerungs Lasten verstehen und die systemeigene Unterstützung für die verzögerte Lade Auflösung ermöglichen. Alle Windows 10-Releases und die ersten Windows 8.1/Windows Server 2012 R2-Builds, die cfg unterstützten (d.h. das Update vom November 2014), führen zu einer Unterstützung für die geschützte Verzögerungs Last im Betriebssystem.

## <a name="function-alignment"></a>Funktions Ausrichtung

- Funktionen, die adressiert werden und daher in die **GFI DS** -Tabelle eingeschlossen werden, sollten nach Möglichkeit 16-Byte-ausgerichtet werden. Dies ist möglicherweise nicht immer möglich. Beispielsweise für nicht-COMDAT-Funktionen, die Teil von Objektdateien sind, die von nicht-cfg-fähigen Tools als eine Einheit zusammengestellt werden, die einige Assemblys erzeugen können, muss der Benutzer des Tools, das die Dateien erstellt hat, die Ausrichtung entsprechend festlegen. Tools können in dieser Situation eine Diagnose Warnung ausgeben, damit der Benutzer geeignete Korrekturmaßnahmen ergreifen kann. Der Grund hierfür ist, dass cfg-Markierungen Ziele als gültig oder nicht in 16-Byte-Grenzen für die Effizienz von schnellen cfg-Überprüfungen aufruft. Wenn eine Funktion nicht mit 16 Byte ausgerichtet ist, muss der gesamte 16-Byte-Slot als gültig gekennzeichnet werden, was nicht so sicher ist, da Sie falsch ausgerichtete Code in Code schreiben können, der sich nicht am Anfang einer Funktion befindet. Dieses Szenario wird unterstützt, um die Interoperabilität zu vereinfachen, wenn Sie zunächst cfg für ein Projekt einrichten. Nicht cfg-fähige Bilder sind auf ähnliche Weise für jede Ziel Ausrichtung des Anweisungs Ziels als gültig gekennzeichnet. Wie zuvor reduziert die Verwendung von falsch ausgerichteten calltargets die Sicherheitsvorteile von cfg, sodass die Tools automatisch an einer 16-Byte-Grenze für alle Elemente in der **GFI** -Tabelle ausgerichtet werden, wenn CFG für ein Abbild gewünscht wird. Symbole, die nicht in der **GFI DS** -Tabelle enthalten sind, benötigen keine bestimmten Ausrichtungen für cfg.

## <a name="export-suppression"></a>Export Unterdrückung

- CFG-Export Unterdrückung (CFG es) ist ein optionaler Modus, der es einem Prozess ermöglicht, anzugeben, dass es sich um callziele handelt, die nur gültig waren, weil es sich um dllexport-Symbole handelt und die noch nicht von GetProcAddress dynamisch aufgelöst wurden. Dadurch wird der Oberflächen Bereich von cfg von System-DLL-Exporten reduziert. Die Export Unterdrückung umfasst das kommunizieren berechtigter "exporunterdrückter" dllexport-callziele, indem Sie mit den IMAGE_GUARD_FLAG_EXPORT_SUPPRESSED **GFI DS** -Flags gekennzeichnet werden. Dllexport-Symbole und der PE-Abbild Einstiegspunkt sollten implizit als "Address" angesehen werden, die von Tools zum Erstellen der **gmeds** -Tabelle verwendet werden.  Wenn ein Export Symbol 16-Byte-ausgerichtet ist und die Adresse aus keinem anderen Grund als dllexport entnommen wird, kann es in der Funktions Tabelle mit dem Export unterdrückter **GFI DS** -Flag gekennzeichnet werden. Aufruf Ziele, die nicht mit 16 Byte ausgerichtet sind, **dürfen nicht** mit dem IMAGE_GUARD_FLAG_EXPORT_SUPPRESSED **GFI DS** -Flag gekennzeichnet werden und können nicht auf die dynamische Aktivierung als gültige Aufruf Ziele zur GetProcAddress-Zeit beschränkt werden.

  Ein Bild, das cfg es unterstützt, enthält eine "guardadresssstakeniatentrytable", deren Anzahl von "guardadresssstakeniatentrycount" als Teil des Lade Konfigurations Verzeichnisses bereitgestellt wird. Diese Tabelle ist strukturell formatiert, identisch mit der **gmeds** -Tabelle. Er verwendet denselben guardflags-IMAGE_GUARD_CF_FUNCTION_TABLE_SIZE_MASK Mechanismus zum Codieren zusätzlicher optionaler metadatenbytes in der IAT-Tabelle, in der die IAT-Tabelle verwendet wird. alle metadatenbytes müssen jedoch für die an der IAT-Tabelle ergriffene Adresse 0 Die IAT Table-Adresse gibt ein sortiertes Array von RVAs von Import-thunken an, für die das als Symbol Adresse importierte "CallTarget" importiert wurde. Dieses Konstrukt unterstützt Address-Symbole, die in einem Remote Modul vorhanden sind, und bei denen es sich um dllexports handelt, wobei cfg verwendet werden. Ein Beispiel für ein solches Code Konstrukt wäre:

  ```
  mov rcx, [__imp_DefWindowProc]
  call foo ; where foo takes the actual address of DefWindowProc.
  ```

  Alle mit dem Import von thunten erstellten Adressen müssen aufgelistet werden, damit das Betriebssystem-Lade Modul Sie finden kann, und die entsprechenden callziele beim Laden eines Bilds und Ausrichten der Importe als gültig festlegen. "Table" und "count" können den Wert "0" aufweisen, wenn keine importierten thunten vorhanden sind.

  Ein Modul legt das IMAGE_GUARD_CF_EXPORT_SUPPRESSION_INFO_PRESENT guardflags-Bit fest, um anzugeben, dass es alle Adressen, die in seiner Adresse als IAT-Tabelle entnommen wurden, aufgezählt haben und dass alle exportierbaren Exporte mit dem IMAGE_GUARD_FLAG_EXPORT_SUPPRESSED **GFI DS** -Flag gekennzeichnet sind. Beachten Sie, dass es möglicherweise keine solchen thunchen gibt und dass möglicherweise auch keine solchen dllexport-Symbole vorhanden sind. Ein Fehler bei der Beibehaltung der IAT-Tabelle kann ein Problem mit der Richtigkeit sein, da einige Aufruf Ziele möglicherweise nicht als gültig festgelegt werden, wenn Sie zur DLL-Ladezeit verwendet werden sollen.

  Ein Modul legt das IMAGE_GUARD_CF_ENABLE_EXPORT_SUPPRESSION guardflags-Bit fest, um anzugeben, dass es für den Prozess cfg-Werte aktivieren soll. In der Praxis ist dies nur noch heute von Bedeutung. Ein Prozess, der cfg es aktiviert, sollte keine DLLs laden, die nicht mit cfg es erstellt wurden, oder es können Laufzeitfehler auftreten, weil nicht festgelegte Adressen IAT-Symbole entnommen haben Die Unterstützung für das Aktivieren von CFG es sollte eine separate Option zum Aktivieren von CFG sein. Das Bereitstellen von CFG es-Metadaten ist sicher und wird standardmäßig mit cfg empfohlen, obwohl Toolsets darauf achten müssen, dass Sie korrekte Metadaten liefern. Andernfalls werden die generierten Images möglicherweise nicht ordnungsgemäß in einem cfg es-Prozess ausgeführt. Diese Unterstützung sollte in einem Testprozess gründlich getestet werden, der cfg es erzwingt. Die integrierten System-DLLs für das Betriebssystem unterstützen cfg es-Metadaten für moderne Windows 10-Betriebssystemversionen, die CFG-Dateien verstehen. Betriebssystemversionen vor dieser Unterstützung verstehen keine cfg-Elemente und ignorieren alle in der Abbildung bezogenen cfg-bezogenen Direktiven. Diese Images sind nach wie vor abwärts kompatibel mit älteren Betriebssystemversionen.

  Die Unterstützung von CFG es ist aus der Perspektive eines Toolsets optional, aber es wird empfohlen, dass Toolsets zumindest Unterstützung für die Enumeration von ausreichenden Informationen enthalten, damit Bilder in einem Prozess ausgeführt werden können, der CFG-Dateien wünscht. Wie bereits erwähnt, ist es wichtig, dass die Unterstützung von Toolsets gründlich getestet wird, um sicherzustellen, dass Sie mit cfg es kompatibel ist, da die meisten Prozesse cfg es noch nicht aktivieren.

## <a name="exception-handling-and-unwinding"></a>Ausnahmebehandlung und-Entwicklung

- Sprachspezifische Handler wie __C_specific_handler, wie von den ausnahmehandlerinformationen in einer. pdata-Registrierung festgelegt, dürfen nicht als gültige calltargets in der **GFI** -Tabelle gekennzeichnet werden. Sie werden stattdessen durch Durchlaufen des schreibgeschützten Speichers gesucht. Ebenso verwendet der Microsoft C-sprachspezifische Handler schreibgeschützte Speicher Suchvorgänge, um funclets für Ausnahmehandler zu suchen, und deklariert seine funclets daher nicht als gültige calltargets in der **GFI** -Tabelle.

- Lange Sprung Behandlung (für nicht-x86-Ziele wie amd64): Toolsets, die mit cfg kompiliert werden und setjmp ()/longjmp () unterstützen, sollten Long Jump als "sicherer langer Sprung" implementieren, der mit strukturierter Ausnahmebehandlung (SEH) interagiert. Dies bedeutet, dass Long Jump als calllunwindex-Befehl implementiert ist, wobei STATUS_LONGJUMP als Status Code im angegebenen Ausnahme Daten Satz und eine Standard _JUMP_BUFFER auf die von ExceptionInformation [0] verwiesen wird. Das Sprung Entlade Ziel sollte die TargetIp der Entladung sein. Der Sprung Puffer stellt den Registrierungs Kontext dar, der vom Betriebssystem wieder hergestellt wird, nachdem der lange Sprung abgeschlossen wurde. Rtlunwind (ex) hat bei Aufruf mit STATUS_LONGJUMP besondere Bedeutung, die für cfg eindeutig ist. Das Long-Sprungziel (_JUMP_BUFFER. RIP oder _JUMP_BUFFER. LR auf ARM64) wird in der Liste geladener Module gesucht, die vom Betriebssystem im schreibgeschützten Speicher verwaltet wird. Wenn für das enthaltende Modul für das Sprungziel (das Ziel Modul) das IMAGE_GUARD_CF_LONGJUMP_TABLE_PRESENT-Flag im Feld "guardflags" festgelegt ist, hat das Konfigurationsverzeichnis "Laden" eine Element Anzahl, die im Feld "Load Configuration guardlongjumptargetcount" angegeben ist. Diese Tabelle ist strukturell formatiert, identisch mit der **gatds** -Tabelle und verwendet denselben guardflags-IMAGE_GUARD_CF_FUNCTION_TABLE_SIZE_MASK Mechanismus, um optionale zusätzliche metadatenbytes in der Long Jump Table zu codieren. Alle metadatenbytes müssen für die Long-Sprung Tabelle 0 (null) sein und sind reserviert.

  Die lange Sprung Tabelle stellt ein sortiertes Array von RVAs dar, die gültige lange Sprung Ziele sind. Wenn ein Modul für den langen Sprung Zielwert IMAGE_GUARD_CF_LONGJUMP_TABLE_PRESENT im Feld "guardflags" festlegt, müssen alle langen Sprung Ziele in "longjumptargeamp;" aufgezählt werden. Auch wenn ein Modul über keine langen Sprung Ziele verfügt, sollte das IMAGE_GUARD_CF_LONGJUMP_TABLE_PRESENT-Flag weiterhin festgelegt werden, wenn das Toolset eine lange Sprung Härtung für cfg unterstützt. Dies bedeutet explizit, dass das Image über keine langen Sprung Ziele verfügt und kein altes Image ist, das vom Betriebssystem angenommen werden kann, wenn es über gültige lange Sprung Ziele an nicht markierten Positionen verfügen kann, für die keine Überprüfung des langen Sprung Ziels ausgeführt werden kann.

  Eine lange Sprung Härtung wird empfohlen, wenn CFG unterstützt wird. Dies ist die Disposition von Microsoft-Compilern. Betriebssysteme, die die lange Sprung Härtung (Pre-Windows 10 oder ältere Windows 10-Versionen) nicht verstehen, führen keine langen Sprung-Härtungs Prüfungen durch, und ignorieren alle langen Aufwärm Härtungs Metadaten, sodass eine lange Sprung Härtung rückwärts mit älteren Betriebssystemversionen kompatibel ist.

  Bei kernelmodusimages sollte die Guard Long Jump Target-Tabelle nicht in einem verwerfbaren Abschnitt enthalten sein. Die Guard Long Jump Target-Tabelle sollte immer im schreibgeschützten Speicher abgelegt werden, damit die Sicherheitseigenschaften wirksam werden.

## <a name="coff-information"></a>COFF-Informationen

- Es gibt Objektdatei Markierungen, um zu deklarieren, ob eine Objektdatei mit cfg konform ist. Eine Objektdatei, die cfg entspricht, listet die gültigen callziele, die Sie generiert, explizit sowie alle Adressen, die IAT-Metadaten enthalten, auf. Für eine Objektdatei, die nicht mit cfg konform ist, müssen die Rückruf Ziele abgeleitet werden, indem die COFF-Umsetzungen der obj-Datei untersucht werden, um nach Verschiebungen zu suchen, die auf den Anfang eines Funktions Symbols zeigen. Dies kann zu einer Überschreitung gültiger cfg-callziele werden. Daher ist es wünschenswert, dass Tools Ihre OBJ-Dateien markieren, die cfg-fähig sind, und die Metadaten der cfg obj-Datei enthalten, wenn Sie mit cfg kompiliert werden

- Es gibt Objektdatei Markierungen, um lange Sprung Ziele für cfg-festgeschriebene lange Sprünge zu deklarieren, die für den cfg-Kompilierungs Modus aufgefüllt werden sollen.
