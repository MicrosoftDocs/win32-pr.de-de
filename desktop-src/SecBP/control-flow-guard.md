---
description: Der Steuerungs Schutz (Control Flow Guard, cfg) ist ein hochoptimiertes Platt Form Sicherheits Feature, das erstellt wurde, um Sicherheitslücken im Speicher zu beheben.
ms.assetid: 116EAD64-7CAE-455C-BA43-9492F78DE873
title: Ablaufsteuerungsschutz
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: 91cf97a648443135e7fee666ea4c259b1c32104e
ms.sourcegitcommit: 831e8f3db78ab820e1710cede244553c70e50500
ms.translationtype: MT
ms.contentlocale: de-DE
ms.lasthandoff: 01/08/2021
ms.locfileid: "104132024"
---
# <a name="control-flow-guard"></a><span data-ttu-id="25360-103">Ablaufsteuerungsschutz</span><span class="sxs-lookup"><span data-stu-id="25360-103">Control Flow Guard</span></span>

## <a name="what-is-control-flow-guard"></a><span data-ttu-id="25360-104">Was ist Ablauf Steuerungs Schutz?</span><span class="sxs-lookup"><span data-stu-id="25360-104">What is Control Flow Guard?</span></span>

<span data-ttu-id="25360-105">Der Steuerungs Schutz (Control Flow Guard, cfg) ist ein hochoptimiertes Platt Form Sicherheits Feature, das erstellt wurde, um Sicherheitslücken im Speicher zu beheben.</span><span class="sxs-lookup"><span data-stu-id="25360-105">Control Flow Guard (CFG) is a highly-optimized platform security feature that was created to combat memory corruption vulnerabilities.</span></span> <span data-ttu-id="25360-106">Durch das Platzieren von strengen Einschränkungen für den Ort, an dem eine Anwendung Code ausführen kann, ist es für Exploits weitaus schwieriger, beliebigen Code durch Sicherheitsrisiken, wie z. b. Pufferüberläufe, auszuführen.</span><span class="sxs-lookup"><span data-stu-id="25360-106">By placing tight restrictions on where an application can execute code from, it makes it much harder for exploits to execute arbitrary code through vulnerabilities such as buffer overflows.</span></span> <span data-ttu-id="25360-107">CFG erweitert frühere Technologien zur exploentschärfung, wie z. b. [/GS](/cpp/build/reference/gs-buffer-security-check?view=vs-2019), [DEP](../memory/data-execution-prevention.md)und [ASLR](/archive/blogs/michael_howard/address-space-layout-randomization-in-windows-vista).</span><span class="sxs-lookup"><span data-stu-id="25360-107">CFG extends previous exploit mitigation technologies such as [/GS](/cpp/build/reference/gs-buffer-security-check?view=vs-2019), [DEP](../memory/data-execution-prevention.md), and [ASLR](/archive/blogs/michael_howard/address-space-layout-randomization-in-windows-vista).</span></span>

<span data-ttu-id="25360-108">Diese Funktion ist in Microsoft Visual Studio 2015 verfügbar und wird unter "cfg-fähige" Versionen von Windows – den x86-und x64-Releases für Desktop und Server von Windows 10 und Windows 8.1 Update (KB3000850) ausgeführt.</span><span class="sxs-lookup"><span data-stu-id="25360-108">This feature is available in Microsoft Visual Studio 2015, and runs on "CFG-Aware" versions of Windows—the x86 and x64 releases for Desktop and Server of Windows 10 and Windows 8.1 Update (KB3000850).</span></span>

<span data-ttu-id="25360-109">Wir empfehlen Entwicklern dringend, cfg für Ihre Anwendungen zu aktivieren.</span><span class="sxs-lookup"><span data-stu-id="25360-109">We strongly encourage developers to enable CFG for their applications.</span></span> <span data-ttu-id="25360-110">Sie müssen CFG nicht für jeden Teil Ihres Codes aktivieren, da eine Mischung aus cfg-aktiviertem und nicht cfg aktiviertem Code problemlos ausgeführt werden kann.</span><span class="sxs-lookup"><span data-stu-id="25360-110">You don't have to enable CFG for every part of your code, as a mixture of CFG enabled and non-CFG enabled code will execute fine.</span></span> <span data-ttu-id="25360-111">Wenn aber cfg nicht für den gesamten Code aktiviert werden kann, können Lücken im Schutz geöffnet werden.</span><span class="sxs-lookup"><span data-stu-id="25360-111">But failing to enable CFG for all code can open gaps in the protection.</span></span> <span data-ttu-id="25360-112">Außerdem funktioniert der cfg-aktivierte Code in den "cfg-nicht-"-Versionen von Windows einwandfrei und ist daher vollständig kompatibel mit diesen.</span><span class="sxs-lookup"><span data-stu-id="25360-112">Furthermore, CFG enabled code works fine on "CFG-Unaware" versions of Windows and is therefore fully compatible with them.</span></span>

## <a name="how-can-i-enable-cfg"></a><span data-ttu-id="25360-113">Wie kann ich cfg Aktivieren?</span><span class="sxs-lookup"><span data-stu-id="25360-113">How Can I Enable CFG?</span></span>

<span data-ttu-id="25360-114">In den meisten Fällen ist es nicht erforderlich, Quellcode zu ändern.</span><span class="sxs-lookup"><span data-stu-id="25360-114">In most cases, there is no need to change source code.</span></span> <span data-ttu-id="25360-115">Sie müssen lediglich eine Option zu Ihrem Visual Studio 2015-Projekt hinzufügen, und der Compiler und Linker aktivieren cfg.</span><span class="sxs-lookup"><span data-stu-id="25360-115">All you have to do is add an option to your Visual Studio 2015 project, and the compiler and linker will enable CFG.</span></span>

<span data-ttu-id="25360-116">Die einfachste Methode besteht darin, zu den **Projekt \| Eigenschaften \| Konfigurations Eigenschaften \| C/C++- \| Code Generierung** zu navigieren und für Ablauf Steuerungs Schutz die Option **Ja (/Guard: CF)** auszuwählen.</span><span class="sxs-lookup"><span data-stu-id="25360-116">The simplest method is to navigate to **Project \| Properties \| Configuration Properties \| C/C++ \| Code Generation** and choose **Yes (/guard:cf)** for Control Flow Guard.</span></span>

![CFG-Eigenschaft in Visual Studio](images/cfg-vs.png)

<span data-ttu-id="25360-118">Alternativ dazu können Sie auch **/Guard: CF** zu den **Projekt \| Eigenschaften \| Konfigurations Eigenschaften \| C/C++ \| Befehlszeile \| zusätzliche Optionen** (für den Compiler) und **/Guard: CF** zu **Projekt \| Eigenschaften \| Konfigurations Eigenschaften \| Weitere Optionen für die Linkerbefehlszeile \| \|** (für den Linker) hinzufügen.</span><span class="sxs-lookup"><span data-stu-id="25360-118">Alternatively, add **/guard:cf** to **Project \| Properties \| Configuration Properties \| C/C++ \| Command Line \| Additional Options** (for the compiler) and **/guard:cf** to **Project \| Properties \| Configuration Properties \| Linker \| Command Line \| Additional Options** (for the linker).</span></span>

![CFG-Eigenschaft für Compiler](images/cfg-compiler.png)![CFG-Eigenschaft für Linker](images/cfg-linker.png)

<span data-ttu-id="25360-121">Weitere Informationen finden Sie unter [/Guard (Ablauf Steuerungs Schutz aktivieren)](/cpp/build/reference/guard-enable-control-flow-guard?view=vs-2019) .</span><span class="sxs-lookup"><span data-stu-id="25360-121">See [/guard (Enable Control Flow Guard)](/cpp/build/reference/guard-enable-control-flow-guard?view=vs-2019) for additional info.</span></span>

<span data-ttu-id="25360-122">Wenn Sie Ihr Projekt von der Befehlszeile aus entwickeln, können Sie dieselben Optionen hinzufügen.</span><span class="sxs-lookup"><span data-stu-id="25360-122">If you are building your project from the command line, you can add the same options.</span></span> <span data-ttu-id="25360-123">Wenn Sie z. b. ein Projekt mit dem Namen "Test. cpp" kompilieren, verwenden Sie **cl/Guard: CF Test. cpp/Link/Guard: CF**.</span><span class="sxs-lookup"><span data-stu-id="25360-123">For example, if you are compiling a project called test.cpp, use **cl /guard:cf test.cpp /link /guard:cf**.</span></span>

<span data-ttu-id="25360-124">Sie haben auch die Möglichkeit, den Satz von icalltarget-Adressen, die von CFG als gültig eingestuft werden, mithilfe von [**setprocessvalidcalltargets**](/windows/desktop/api/memoryapi/nf-memoryapi-setprocessvalidcalltargets) aus der-Speicherverwaltungs-API dynamisch zu steuern.</span><span class="sxs-lookup"><span data-stu-id="25360-124">You also have the option of dynamically controlling the set of icall target addresses that are considered valid by CFG using the [**SetProcessValidCallTargets**](/windows/desktop/api/memoryapi/nf-memoryapi-setprocessvalidcalltargets) from the Memory Management API.</span></span> <span data-ttu-id="25360-125">Dieselbe API kann verwendet werden, um anzugeben, ob Seiten ungültige oder gültige Ziele für cfg sind.</span><span class="sxs-lookup"><span data-stu-id="25360-125">The same API can be used to specify whether pages are invalid or valid targets for CFG.</span></span> <span data-ttu-id="25360-126">Die [**VirtualProtect**](/windows/desktop/api/memoryapi/nf-memoryapi-virtualprotect) -und [**virtualdepc**](/windows/desktop/api/memoryapi/nf-memoryapi-virtualalloc) -Funktionen behandeln standardmäßig einen angegebenen Bereich von ausführbaren und zugeteilten Seiten als gültige indirekte callziele.</span><span class="sxs-lookup"><span data-stu-id="25360-126">The [**VirtualProtect**](/windows/desktop/api/memoryapi/nf-memoryapi-virtualprotect) and [**VirtualAlloc**](/windows/desktop/api/memoryapi/nf-memoryapi-virtualalloc) functions will by default treat a specified region of executable and committed pages as valid indirect call targets.</span></span> <span data-ttu-id="25360-127">Es ist möglich, dieses Verhalten außer Kraft zu setzen, z. b. bei der Implementierung eines Just-in-Time-Compilers  , indem Sie beim Aufrufen von " **VirtualProtect** " die Option " [](/windows/desktop/Memory/memory-protection-constants) **Seiten \_ Ziele \_** " angeben **\_ \_ \_**</span><span class="sxs-lookup"><span data-stu-id="25360-127">It is possible to override this behavior, such as when implementing a Just-in-Time compiler, by specifying **PAGE\_TARGETS\_INVALID** when calling **VirtualAlloc** or **PAGE\_TARGETS\_NO\_UPDATE** when calling **VirtualProtect** as detailed under [**Memory Protection Constants**](/windows/desktop/Memory/memory-protection-constants).</span></span>

## <a name="how-do-i-tell-that-a-binary-is-under-control-flow-guard"></a><span data-ttu-id="25360-128">Wie erkenne ich, dass eine Binärdatei unter Ablauf Steuerungs Schutz ist?</span><span class="sxs-lookup"><span data-stu-id="25360-128">How Do I Tell That a Binary is under Control Flow Guard?</span></span>

<span data-ttu-id="25360-129">Führen Sie das [(dumpbin-Tool](/cpp/build/reference/dumpbin-reference) (das in der Visual Studio 2015-Installation enthalten ist) über die Visual Studio-Eingabeaufforderung mit den Optionen */Headers* und */LOADCONFIG* aus: **(dumpbin/Headers/LOADCONFIG test.exe**.</span><span class="sxs-lookup"><span data-stu-id="25360-129">Run the [dumpbin tool](/cpp/build/reference/dumpbin-reference) (included in the Visual Studio 2015 installation) from the Visual Studio command prompt with the */headers* and */loadconfig* options: **dumpbin /headers /loadconfig test.exe**.</span></span> <span data-ttu-id="25360-130">Die Ausgabe für eine Binärdatei unter cfg sollte anzeigen, dass die Header Werte "Guard" enthalten, und die Werte der Lade Konfiguration enthalten "CF instrumentiert" und "FID Table Present".</span><span class="sxs-lookup"><span data-stu-id="25360-130">The output for a binary under CFG should show that the header values include "Guard", and that the load config values include "CF Instrumented" and "FID table present".</span></span>

![Ausgabe von (dumpbin/Headers](images/cfg-dumpbin-headers.png)

![Ausgabe von (dumpbin/LOADCONFIG](images/cfg-dumpbin-loadconfig.png)

## <a name="how-does-cfg-really-work"></a><span data-ttu-id="25360-133">Wie funktioniert cfg wirklich?</span><span class="sxs-lookup"><span data-stu-id="25360-133">How Does CFG Really Work?</span></span>

<span data-ttu-id="25360-134">Software Sicherheitslücken werden oft ausgenutzt, wenn ein ausgelaufendes Programm unwahrscheinliche, ungewöhnliche oder Extreme Daten bereitstellt.</span><span class="sxs-lookup"><span data-stu-id="25360-134">Software vulnerabilities are often exploited by providing unlikely, unusual, or extreme data to a running program.</span></span> <span data-ttu-id="25360-135">Ein Angreifer kann z. b. ein Pufferüberlauf-Sicherheitsrisiko ausnutzen, indem er mehr Eingaben für ein Programm als erwartet bereitstellt, wodurch der Bereich, der vom Programm reserviert ist, zum Speichern einer Antwort überschritten wird.</span><span class="sxs-lookup"><span data-stu-id="25360-135">For example, an attacker can exploit a buffer overflow vulnerability by providing more input to a program than expected, thereby over-running the area reserved by the program to hold a response.</span></span> <span data-ttu-id="25360-136">Dadurch kann der angrenzende Arbeitsspeicher beschädigt werden, der einen Funktionszeiger enthalten kann.</span><span class="sxs-lookup"><span data-stu-id="25360-136">This could corrupt adjacent memory that may hold a function pointer.</span></span> <span data-ttu-id="25360-137">Wenn das Programm diese Funktion aufruft, springt es möglicherweise zu einem unbeabsichtigten Speicherort, der vom Angreifer festgelegt wurde.</span><span class="sxs-lookup"><span data-stu-id="25360-137">When the program calls through this function it may then jump to an unintended location specified by the attacker.</span></span>

<span data-ttu-id="25360-138">Eine potente Kombination der Kompilierungs-und Laufzeitunterstützung von CFG implementiert jedoch die Ablauf Steuerungs Integrität, die eng einschränkt, wo indirekte Aufruf Anweisungen ausgeführt werden können.</span><span class="sxs-lookup"><span data-stu-id="25360-138">However, a potent combination of compile and run-time support from CFG implements control flow integrity that tightly restricts where indirect call instructions can execute.</span></span>

<span data-ttu-id="25360-139">Der Compiler führt Folgendes aus:</span><span class="sxs-lookup"><span data-stu-id="25360-139">The compiler does the following:</span></span>

1.  <span data-ttu-id="25360-140">Fügt dem kompilierten Code Lightweight-Sicherheitsüberprüfungen hinzu.</span><span class="sxs-lookup"><span data-stu-id="25360-140">Adds lightweight security checks to the compiled code.</span></span>
2.  <span data-ttu-id="25360-141">Identifiziert den Satz von Funktionen in der Anwendung, die gültige Ziele für indirekte Aufrufe sind.</span><span class="sxs-lookup"><span data-stu-id="25360-141">Identifies the set of functions in the application that are valid targets for indirect calls.</span></span>

<span data-ttu-id="25360-142">Die Runtime-Unterstützung, die vom Windows-Kernel bereitgestellt wird:</span><span class="sxs-lookup"><span data-stu-id="25360-142">The runtime support, provided by the Windows kernel:</span></span>

1.  <span data-ttu-id="25360-143">Verwaltet den Zustand, der gültige indirekte Rückruf Ziele identifiziert, effizient.</span><span class="sxs-lookup"><span data-stu-id="25360-143">Efficiently maintains state that identifies valid indirect call targets.</span></span>
2.  <span data-ttu-id="25360-144">Implementiert die Logik, die überprüft, ob ein indirektes aufrufsziel gültig ist.</span><span class="sxs-lookup"><span data-stu-id="25360-144">Implements the logic that verifies that an indirect call target is valid.</span></span>

<span data-ttu-id="25360-145">So veranschaulichen Sie Folgendes:</span><span class="sxs-lookup"><span data-stu-id="25360-145">To illustrate:</span></span>

![CFG-Pseudo Code](images/cfg-pseudocode.jpg)

<span data-ttu-id="25360-147">Wenn bei einer cfg-Überprüfung zur Laufzeit ein Fehler auftritt, beendet Windows das Programm sofort und unterbricht dadurch alle Exploits, die versuchen, indirekt eine ungültige Adresse aufzurufen.</span><span class="sxs-lookup"><span data-stu-id="25360-147">When a CFG check fails at runtime, Windows immediately terminates the program, thus breaking any exploit that attempts to indirectly call an invalid address.</span></span>

 

 
