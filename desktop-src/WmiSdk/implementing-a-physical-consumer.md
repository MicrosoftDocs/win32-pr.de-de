---
description: Ein physischer Consumer ist ein COM-Objekt, das die iwbemunboundobjectsink-Schnittstelle implementiert.
ms.assetid: 497457dc-61ca-4527-89fd-2af0383de5e9
ms.tgt_platform: multiple
title: Implementieren eines physischen Consumers
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: af0a9530ed7a98ce19b3b39f2f5a1fe52f3b0631
ms.sourcegitcommit: 831e8f3db78ab820e1710cede244553c70e50500
ms.translationtype: MT
ms.contentlocale: de-DE
ms.lasthandoff: 01/08/2021
ms.locfileid: "106350356"
---
# <a name="implementing-a-physical-consumer"></a><span data-ttu-id="a7f7e-103">Implementieren eines physischen Consumers</span><span class="sxs-lookup"><span data-stu-id="a7f7e-103">Implementing a Physical Consumer</span></span>

<span data-ttu-id="a7f7e-104">Ein physischer Consumer ist ein COM-Objekt, das die [**iwbemunboundobjectsink**](/windows/desktop/api/Wbemprov/nn-wbemprov-iwbemunboundobjectsink) -Schnittstelle implementiert.</span><span class="sxs-lookup"><span data-stu-id="a7f7e-104">A physical consumer is a COM object that implements the [**IWbemUnboundObjectSink**](/windows/desktop/api/Wbemprov/nn-wbemprov-iwbemunboundobjectsink) interface.</span></span> <span data-ttu-id="a7f7e-105">WMI lädt den physischen Consumer und übergibt Ereignisse als Antwort auf ein oder mehrere Ereignisse, wie vom zugeordneten logischen Consumer definiert, durch **iwbemunboundobjectsink** .</span><span class="sxs-lookup"><span data-stu-id="a7f7e-105">WMI loads your physical consumer and passes events through **IWbemUnboundObjectSink** in response to one or more events, as defined by the associated logical consumer.</span></span> <span data-ttu-id="a7f7e-106">Permanente Verbraucher haben besondere Sicherheitsanforderungen.</span><span class="sxs-lookup"><span data-stu-id="a7f7e-106">Permanent consumers have special security requirements.</span></span> <span data-ttu-id="a7f7e-107">Weitere Informationen finden Sie unter [Sichern von WMI-Ereignissen](securing-wmi-events.md).</span><span class="sxs-lookup"><span data-stu-id="a7f7e-107">For more information, see [Securing WMI Events](securing-wmi-events.md).</span></span>

<span data-ttu-id="a7f7e-108">Im folgenden Verfahren wird beschrieben, wie ein physischer Consumer für einen permanenten Ereignisconsumer implementiert wird.</span><span class="sxs-lookup"><span data-stu-id="a7f7e-108">The following procedure describes how to implement a physical consumer for a permanent event consumer.</span></span>

<span data-ttu-id="a7f7e-109">**So implementieren Sie einen physischen Consumer für einen permanenten Ereignisconsumer**</span><span class="sxs-lookup"><span data-stu-id="a7f7e-109">**To implement a physical consumer for a permanent event consumer**</span></span>

1.  <span data-ttu-id="a7f7e-110">Erstellen Sie ein COM-Objekt.</span><span class="sxs-lookup"><span data-stu-id="a7f7e-110">Create a COM object.</span></span>

    <span data-ttu-id="a7f7e-111">Sie müssen einen physischen Consumer als lokalen Server oder Remote Server mit dem com-Protokoll implementieren.</span><span class="sxs-lookup"><span data-stu-id="a7f7e-111">You must implement a physical consumer as a local or remote server using the COM protocol.</span></span>

2.  <span data-ttu-id="a7f7e-112">Bestimmen Sie, ob eine synchrone oder asynchrone Ereignis Benachrichtigung unterstützt werden soll.</span><span class="sxs-lookup"><span data-stu-id="a7f7e-112">Determine if you want to support synchronous or asynchronous event notification.</span></span>

    <span data-ttu-id="a7f7e-113">Bei der asynchronen Ereignis Benachrichtigung ist der sendende Thread nicht mit dem empfangenden Thread verknüpft.</span><span class="sxs-lookup"><span data-stu-id="a7f7e-113">With asynchronous event notification, the sending thread is unrelated to the receiving thread.</span></span> <span data-ttu-id="a7f7e-114">Daher wird weder WMI noch der Ereignis Anbieter blockiert, während WMI eine Benachrichtigung an jeden Consumer übergibt, der für den Empfang des Ereignisses registriert ist.</span><span class="sxs-lookup"><span data-stu-id="a7f7e-114">Therefore, neither WMI nor the event provider gets blocked while WMI delivers a notification to any consumer registered to receive the event.</span></span> <span data-ttu-id="a7f7e-115">Der Nachteil der asynchronen Übermittlung besteht darin, dass ein Kontextwechsel zwischen dem Zeitpunkt, zu dem der Anbieter das Ereignis erzeugt, und dem Zeitpunkt auftritt, zu dem der Consumer das Ereignis empfängt.</span><span class="sxs-lookup"><span data-stu-id="a7f7e-115">The disadvantage to asynchronous delivery is that a context switch occurs between the time the provider produces the event and the time the consumer receives the event.</span></span> <span data-ttu-id="a7f7e-116">Weitere Informationen zum asynchronen Arbeiten finden Sie im Thema zu den [com-Grundlagen](../com/guide.md) im com-Abschnitt des Microsoft Windows Software Development Kit (SDK).</span><span class="sxs-lookup"><span data-stu-id="a7f7e-116">For more information about working asynchronously, see the [COM Fundamentals](../com/guide.md) topic in the COM section of the Microsoft Windows Software Development Kit (SDK).</span></span> <span data-ttu-id="a7f7e-117">Weitere Informationen zu Kontext wechseln finden Sie im Abschnitt " [Kontext](../procthread/context-switches.md) Wechsel" im Abschnitt DLLs, Prozesse und Threads des Windows SDK.</span><span class="sxs-lookup"><span data-stu-id="a7f7e-117">For more information about context switches, see the [Context Switches](../procthread/context-switches.md) topic in the DLLs, Processes, and Threads section of the Windows SDK.</span></span>

    > [!Note]  
    > <span data-ttu-id="a7f7e-118">Da der Rückruf für die Senke möglicherweise nicht auf derselben Authentifizierungs Ebene wie der Client zurückgegeben wird, wird empfohlen, semisynchrone anstelle der asynchronen Kommunikation zu verwenden.</span><span class="sxs-lookup"><span data-stu-id="a7f7e-118">Because the callback to the sink might not be returned at the same authentication level as the client requires, it is recommended that you use semisynchronous instead of asynchronous communication.</span></span> <span data-ttu-id="a7f7e-119">Weitere Informationen finden Sie unter [Aufrufen einer Methode](calling-a-method.md).</span><span class="sxs-lookup"><span data-stu-id="a7f7e-119">For more information, see [Calling a Method](calling-a-method.md).</span></span>

     

    <span data-ttu-id="a7f7e-120">Bei der synchronen Benachrichtigung übermittelt WMI die Benachrichtigung in demselben Thread, den der Ereignis Anbieter verwendet hat, um das Ereignis an WMI zu übermitteln.</span><span class="sxs-lookup"><span data-stu-id="a7f7e-120">With synchronous notification, WMI delivers the notification on the same thread that the event provider used to deliver the event to WMI.</span></span> <span data-ttu-id="a7f7e-121">Wenn in diesem Fall ein Ereignis Anbieter eine Benachrichtigung sendet, wird der Ereignis Anbieter von WMI blockiert, bis die Benachrichtigung von WMI übermittelt wird.</span><span class="sxs-lookup"><span data-stu-id="a7f7e-121">In this case, when an event provider sends a notification, the event provider is blocked by WMI until WMI delivers the notification.</span></span> <span data-ttu-id="a7f7e-122">Nur wenn Ihr Consumer extrem schnell ist und ein Ereignis in 100 Mikrosekunden oder weniger verarbeiten kann, sollten Sie die Unterstützung synchroner Benachrichtigungen in Erwägung gezogen.</span><span class="sxs-lookup"><span data-stu-id="a7f7e-122">Only if your consumer is extremely fast and can process an event in 100 microseconds or less should you consider supporting synchronous notification.</span></span> <span data-ttu-id="a7f7e-123">Synchrone Consumer, die zu lange dauern, um Ereignisse zu verarbeiten, können die Übermittlung von Ereignissen für alle anderen Consumer erheblich verlangsamen.</span><span class="sxs-lookup"><span data-stu-id="a7f7e-123">Synchronous consumers that take too long to process events can seriously slow the delivery of events to all other consumers.</span></span> <span data-ttu-id="a7f7e-124">Außerdem kann der Anbieter versehentlich blockiert werden.</span><span class="sxs-lookup"><span data-stu-id="a7f7e-124">Furthermore, they can inadvertently block the provider.</span></span> <span data-ttu-id="a7f7e-125">Weitere Informationen finden Sie unter [Binden eines Ereignis Filters mit einem logischen Consumer](binding-an-event-filter-with-a-logical-consumer.md).</span><span class="sxs-lookup"><span data-stu-id="a7f7e-125">For more information, see [Binding an Event Filter with a Logical Consumer](binding-an-event-filter-with-a-logical-consumer.md).</span></span>

3.  <span data-ttu-id="a7f7e-126">Implementieren Sie die [**iwbemunboundobjectsink:: jecetoconsumer**](/windows/desktop/api/Wbemprov/nf-wbemprov-iwbemunboundobjectsink-indicatetoconsumer) -Funktion.</span><span class="sxs-lookup"><span data-stu-id="a7f7e-126">Implement the [**IWbemUnboundObjectSink::IndicateToConsumer**](/windows/desktop/api/Wbemprov/nf-wbemprov-iwbemunboundobjectsink-indicatetoconsumer) function.</span></span>

    <span data-ttu-id="a7f7e-127">WMI verwendet die [**Funktion "**](/windows/desktop/api/Wbemprov/nf-wbemprov-iwbemunboundobjectsink-indicatetoconsumer) -Funktion", um die erforderlichen Zeiger und Ereignisse für die synchrone und asynchrone Kommunikation an den physischen Consumer zu übergeben.</span><span class="sxs-lookup"><span data-stu-id="a7f7e-127">WMI uses the [**IndicateToConsumer**](/windows/desktop/api/Wbemprov/nf-wbemprov-iwbemunboundobjectsink-indicatetoconsumer) function to pass the necessary pointers and events to your physical consumer for both synchronous and asynchronous communications.</span></span> <span data-ttu-id="a7f7e-128">Ihre Implementierung von " **indikatetoconsumer** " muss den gesamten erforderlichen Code enthalten, um auf ein Ereignis zu reagieren.</span><span class="sxs-lookup"><span data-stu-id="a7f7e-128">Your implementation of **IndicateToConsumer** should contain all of the necessary code to respond to an event.</span></span>

    <span data-ttu-id="a7f7e-129">Anders als bei einem temporären Ereignisconsumer müssen Sie die [**IWBEMLocator**](/windows/desktop/api/Wbemcli/nn-wbemcli-iwbemlocator) -Schnittstelle nicht zum Kontaktieren von WMI anrufen.</span><span class="sxs-lookup"><span data-stu-id="a7f7e-129">Unlike a temporary event consumer, you do not need to call the [**IWbemLocator**](/windows/desktop/api/Wbemcli/nn-wbemcli-iwbemlocator) interface to contact WMI.</span></span> <span data-ttu-id="a7f7e-130">Stattdessen wird von WMI über den Ereignisconsumeranbieter ein Zeiger auf den Consumer angezeigt.</span><span class="sxs-lookup"><span data-stu-id="a7f7e-130">Instead, WMI locates a pointer to your consumer through the event consumer provider.</span></span> <span data-ttu-id="a7f7e-131">Weitere Informationen finden Sie unter [Schreiben eines Ereignisconsumeranbieters](writing-an-event-consumer-provider.md).</span><span class="sxs-lookup"><span data-stu-id="a7f7e-131">For more information, see [Writing an Event Consumer Provider](writing-an-event-consumer-provider.md).</span></span>

    <span data-ttu-id="a7f7e-132">Wenn Sie jedoch WMI zurückkehren möchten, verwenden Sie die [**IWBEMLocator**](/windows/desktop/api/Wbemcli/nn-wbemcli-iwbemlocator) -Schnittstelle und die [**IWbemServices**](/windows/desktop/api/WbemCli/nn-wbemcli-iwbemservices) -Schnittstelle.</span><span class="sxs-lookup"><span data-stu-id="a7f7e-132">However, if you wish to call back into WMI, use the [**IWbemLocator**](/windows/desktop/api/Wbemcli/nn-wbemcli-iwbemlocator) and [**IWbemServices**](/windows/desktop/api/WbemCli/nn-wbemcli-iwbemservices) interfaces.</span></span> <span data-ttu-id="a7f7e-133">Die herkömmliche Methode zum Herstellen einer Verbindung mit WMI ist die Initialisierung des COM-Objekts.</span><span class="sxs-lookup"><span data-stu-id="a7f7e-133">The traditional method for connecting to WMI is during the initialization process of your COM object.</span></span> <span data-ttu-id="a7f7e-134">Weitere Informationen finden Sie unter [Erstellen einer WMI-Anwendung oder eines Skripts](creating-a-wmi-application-or-script.md).</span><span class="sxs-lookup"><span data-stu-id="a7f7e-134">For more information, see [Creating a WMI Application or Script](creating-a-wmi-application-or-script.md).</span></span>

    <span data-ttu-id="a7f7e-135">Wenn Sie den physischen Consumer als in-Process-COM-Server implementieren und getrennt vom Initialisierungs Prozess eine Verbindung mit WMI herstellen, müssen Sie für den Zugriff auf die [**IWBEMLocator**](/windows/desktop/api/Wbemcli/nn-wbemcli-iwbemlocator) -Schnittstelle im [**cokreateinstance-Code**](/windows/win32/api/combaseapi/nf-combaseapi-cocreateinstance)die **\_ clbemlocator** -Schnittstelle verwenden.</span><span class="sxs-lookup"><span data-stu-id="a7f7e-135">If you implement your physical consumer as an in-process COM server and connect to WMI separately from the initialization process, you must use the **CLSID\_WbemAdministrativeLocator** class identifier to access the [**IWbemLocator**](/windows/desktop/api/Wbemcli/nn-wbemcli-iwbemlocator) interface in the call to [**CoCreateInstance**](/windows/win32/api/combaseapi/nf-combaseapi-cocreateinstance).</span></span>

    <span data-ttu-id="a7f7e-136">Im folgenden Beispiel wird gezeigt, wie der **CLSID \_ wbemadministrativelocator** -Klassen Bezeichner verwendet wird, um auf die [**IWBEMLocator**](/windows/desktop/api/Wbemcli/nn-wbemcli-iwbemlocator) -Schnittstelle zuzugreifen.</span><span class="sxs-lookup"><span data-stu-id="a7f7e-136">The following example shows how to use the **CLSID\_WbemAdministrativeLocator** class identifier to access the [**IWbemLocator**](/windows/desktop/api/Wbemcli/nn-wbemcli-iwbemlocator) interface.</span></span>

    ```C++
    IWbemLocator *pLoc = 0;

    DWORD dwRes = CoCreateInstance(CLSID_WbemAdministrativeLocator, 0, 
        CLSCTX_INPROC_SERVER, IID_IWbemLocator, (LPVOID *) &pLoc);
    ```

    

    <span data-ttu-id="a7f7e-137">Die [**IWBEMLocator**](/windows/desktop/api/Wbemcli/nn-wbemcli-iwbemlocator) -Schnittstelle erhält den anfänglichen Namespace Zeiger auf WMI auf einem bestimmten Host Computer.</span><span class="sxs-lookup"><span data-stu-id="a7f7e-137">The [**IWbemLocator**](/windows/desktop/api/Wbemcli/nn-wbemcli-iwbemlocator) interface obtains the initial namespace pointer to WMI on a particular host computer.</span></span> <span data-ttu-id="a7f7e-138">Wenn der **CLSID- \_ wbemadministrativelocator** -Bezeichner nicht im [**cokreateinstance**](/windows/win32/api/combaseapi/nf-combaseapi-cocreateinstance) -Befehl verwendet wird, führt dies zu einem Fehler vom Typ "Zugriff verweigert".</span><span class="sxs-lookup"><span data-stu-id="a7f7e-138">Failure to use the **CLSID\_WbemAdministrativeLocator** identifier in the [**CoCreateInstance**](/windows/win32/api/combaseapi/nf-combaseapi-cocreateinstance) call results in an "access denied" error.</span></span>

    <span data-ttu-id="a7f7e-139">Unter normalen Umständen werden von WMI asynchrone Ereignisse nacheinander an den Client übermittelt.</span><span class="sxs-lookup"><span data-stu-id="a7f7e-139">Under usual circumstances, WMI delivers asynchronous events to the client one at a time.</span></span> <span data-ttu-id="a7f7e-140">Wenn ein Client jedoch nicht so schnell, wie die Ereignisse eintreffen, asynchrone Ereignis Benachrichtigungen empfangen kann, startet WMI automatisch eine Batch Verarbeitung von Ereignissen in einem einzelnen-Befehl.</span><span class="sxs-lookup"><span data-stu-id="a7f7e-140">However, if a client cannot receive asynchronous event notifications as fast as the events arrive, WMI starts to automatically batch events into a single call.</span></span> <span data-ttu-id="a7f7e-141">Die automatische Batch Verarbeitung hilft, wenn die Roundtrip-Zeiten ein Problem darstellen, wie es häufig bei Szenarios mit hohem Durchsatz der Fall ist.</span><span class="sxs-lookup"><span data-stu-id="a7f7e-141">Automatic batching helps if the round-trip times are a problem, as is often the case in high-throughput scenarios.</span></span> <span data-ttu-id="a7f7e-142">Die Batch Verarbeitung verbessert jedoch nicht die Systemleistung, wenn der Client oder die Netzwerkbandbreite fehlerhaft ist.</span><span class="sxs-lookup"><span data-stu-id="a7f7e-142">However, batching does not improve system performance if the client or the network bandwidth are at fault.</span></span>

 

 
