---
description: Wenn Sie über eine funktionsfähige Microsoft Direct3D-Anwendung verfügen und die Leistung verbessern möchten, verwenden Sie im Allgemeinen ein offsetprofilerstellungs-Tool oder eine benutzerdefinierte Messtechnik, um die Zeit zu messen, die für die Ausführung eines oder mehrerer API-Aufrufe (Application Programming Interface) benötigt wird. Wenn Sie dies getan haben, aber Zeit Steuerungs Ergebnisse erhalten, die von einer Rendering-Sequenz zu der nächsten reichen, oder wenn Sie Hypothesen treffen, die nicht die tatsächlichen Experiment Ergebnisse enthalten, können Sie anhand der folgenden Informationen verstehen, warum.
ms.assetid: f969be42-d541-4e8d-aec4-eb9508bcc7cf
title: Exakte Profilerstellung für Direct3D-API-Aufrufe (Direct3D 9)
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: cdb6d60fcc1b3ace4112dbf7028d91e2c9c8b345
ms.sourcegitcommit: c7add10d695482e1ceb72d62b8a4ebd84ea050f7
ms.translationtype: MT
ms.contentlocale: de-DE
ms.lasthandoff: 01/07/2021
ms.locfileid: "103748737"
---
# <a name="accurately-profiling-direct3d-api-calls-direct3d-9"></a><span data-ttu-id="e38d9-104">Exakte Profilerstellung für Direct3D-API-Aufrufe (Direct3D 9)</span><span class="sxs-lookup"><span data-stu-id="e38d9-104">Accurately Profiling Direct3D API Calls (Direct3D 9)</span></span>

-   [<span data-ttu-id="e38d9-105">Die genaue Profilerstellung Direct3D ist schwierig.</span><span class="sxs-lookup"><span data-stu-id="e38d9-105">Accurately Profiling Direct3D Is Difficult</span></span>](#accurately-profiling-direct3d-is-difficult)
-   [<span data-ttu-id="e38d9-106">Genaue Profilerstellung für eine Direct3D-Rendering-Sequenz</span><span class="sxs-lookup"><span data-stu-id="e38d9-106">How to Accurately Profile a Direct3D Render Sequence</span></span>](#how-to-accurately-profile-a-direct3d-render-sequence)
-   [<span data-ttu-id="e38d9-107">Profilerstellung Direct3D Zustandsänderungen</span><span class="sxs-lookup"><span data-stu-id="e38d9-107">Profiling Direct3D State Changes</span></span>](#profiling-direct3d-state-changes)
-   [<span data-ttu-id="e38d9-108">Zusammenfassung</span><span class="sxs-lookup"><span data-stu-id="e38d9-108">Summary</span></span>](#summary)
-   [<span data-ttu-id="e38d9-109">Anhang</span><span class="sxs-lookup"><span data-stu-id="e38d9-109">Appendix</span></span>](#appendix)

<span data-ttu-id="e38d9-110">Wenn Sie über eine funktionsfähige Microsoft Direct3D-Anwendung verfügen und die Leistung verbessern möchten, verwenden Sie im Allgemeinen ein offsetprofilerstellungs-Tool oder eine benutzerdefinierte Messtechnik, um die Zeit zu messen, die für die Ausführung eines oder mehrerer API-Aufrufe (Application Programming Interface) benötigt wird.</span><span class="sxs-lookup"><span data-stu-id="e38d9-110">Once you have a functional Microsoft Direct3D application and you want to improve its performance, you generally use an off-the-shelf profiling tool or some custom measurement technique to measure the time it takes to execute one or more application programming interface (API) calls.</span></span> <span data-ttu-id="e38d9-111">Wenn Sie dies getan haben, aber Zeit Steuerungs Ergebnisse erhalten, die von einer Rendering-Sequenz zu der nächsten reichen, oder wenn Sie Hypothesen treffen, die nicht die tatsächlichen Experiment Ergebnisse enthalten, können Sie anhand der folgenden Informationen verstehen, warum.</span><span class="sxs-lookup"><span data-stu-id="e38d9-111">If you have done this but are getting timing results that vary from one render sequence to the next, or you are making hypotheses that do not hold up to actual experiment results, the following information may help you to understand why.</span></span>

<span data-ttu-id="e38d9-112">Die hier bereitgestellten Informationen basieren auf der Annahme, dass Sie über die folgenden Informationen verfügen:</span><span class="sxs-lookup"><span data-stu-id="e38d9-112">The information provided here is based upon the assumption that you have knowledge of and experience with the following:</span></span>

-   <span data-ttu-id="e38d9-113">C/C++-Programmierung</span><span class="sxs-lookup"><span data-stu-id="e38d9-113">C/C++ programming</span></span>
-   <span data-ttu-id="e38d9-114">Direct3D-API-Programmierung</span><span class="sxs-lookup"><span data-stu-id="e38d9-114">Direct3D API programming</span></span>
-   <span data-ttu-id="e38d9-115">Messen der API-Zeit</span><span class="sxs-lookup"><span data-stu-id="e38d9-115">Measuring API timing</span></span>
-   <span data-ttu-id="e38d9-116">Die Grafikkarte und deren Software Treiber</span><span class="sxs-lookup"><span data-stu-id="e38d9-116">The video card and its software driver</span></span>
-   <span data-ttu-id="e38d9-117">Mögliche nicht erklärbare Ergebnisse aus vorheriger Profilerstellung</span><span class="sxs-lookup"><span data-stu-id="e38d9-117">Possible unexplainable results from previous profiling experience</span></span>

## <a name="accurately-profiling-direct3d-is-difficult"></a><span data-ttu-id="e38d9-118">Die genaue Profilerstellung Direct3D ist schwierig.</span><span class="sxs-lookup"><span data-stu-id="e38d9-118">Accurately Profiling Direct3D Is Difficult</span></span>

<span data-ttu-id="e38d9-119">Ein Profiler meldet die Zeitspanne, die für die einzelnen API-Aufrufe aufgewendet wurde.</span><span class="sxs-lookup"><span data-stu-id="e38d9-119">A profiler reports on the amount of time spent in each API call.</span></span> <span data-ttu-id="e38d9-120">Dies wird erreicht, um die Leistung durch Auffinden und Optimieren von Hotspots zu verbessern.</span><span class="sxs-lookup"><span data-stu-id="e38d9-120">This is done to improve performance by finding and tuning away hot spots.</span></span> <span data-ttu-id="e38d9-121">Es gibt verschiedene Arten von Profiler und Profil Erstellungs Techniken.</span><span class="sxs-lookup"><span data-stu-id="e38d9-121">There are different kinds of profilers and profiling techniques.</span></span>

-   <span data-ttu-id="e38d9-122">Ein Samplingprofiler befindet sich in einem gewissen Zeitraum im Leerlauf und erwachte in bestimmten Intervallen, um die ausgeführten Funktionen zu testen (oder aufzuzeichnen).</span><span class="sxs-lookup"><span data-stu-id="e38d9-122">A sampling profiler sits idle much of the time, awakening at specific intervals to sample (or to record) the functions being executed.</span></span> <span data-ttu-id="e38d9-123">Er gibt den Prozentsatz der für jeden Aufruf aufgewendeten Zeit zurück.</span><span class="sxs-lookup"><span data-stu-id="e38d9-123">It returns the percentage of time spent in each call.</span></span> <span data-ttu-id="e38d9-124">Im Allgemeinen ist ein Samplingprofiler für die Anwendung nicht sehr invasiv und wirkt sich nur minimal auf den Aufwand für die Anwendung aus.</span><span class="sxs-lookup"><span data-stu-id="e38d9-124">Generally, a sampling profiler is not very invasive to the application and has minimal impact on the overhead for the application.</span></span>
-   <span data-ttu-id="e38d9-125">Ein instrumentierungsprofiler misst die tatsächliche Zeit, die für das Zurückgeben eines Aufrufes benötigt wird.</span><span class="sxs-lookup"><span data-stu-id="e38d9-125">An instrumenting profiler measures the actual time it takes for a call to return.</span></span> <span data-ttu-id="e38d9-126">Hierfür müssen die Trennzeichen für das Starten und beenden in eine Anwendung kompiliert werden.</span><span class="sxs-lookup"><span data-stu-id="e38d9-126">It requires compiling start and stop delimiters into an application.</span></span> <span data-ttu-id="e38d9-127">Ein instrumentierungsprofiler ist im Gegensatz zu einem Samplingprofiler in einer Anwendung vergleichsweise invasiver.</span><span class="sxs-lookup"><span data-stu-id="e38d9-127">An instrumenting profiler is comparatively more invasive to an application than a sampling profiler.</span></span>
-   <span data-ttu-id="e38d9-128">Es ist auch möglich, eine benutzerdefinierte Profil Erstellungs Methode mit einem Hochleistungs-Timer zu verwenden.</span><span class="sxs-lookup"><span data-stu-id="e38d9-128">It is also possible to use a custom profiling technique with a high-performance timer.</span></span> <span data-ttu-id="e38d9-129">Dies erzeugt Ergebnisse ähnlich wie ein instrumentierungsprofiler.</span><span class="sxs-lookup"><span data-stu-id="e38d9-129">This produces results very much like an instrumenting profiler.</span></span>

<span data-ttu-id="e38d9-130">Der Typ der verwendeten Profiler-oder Profil Erstellungs Methode ist nur ein Teil der Herausforderung, genaue Messungen zu generieren.</span><span class="sxs-lookup"><span data-stu-id="e38d9-130">The type of profiler or profiling technique used is only part of the challenge of generating accurate measurements.</span></span>

<span data-ttu-id="e38d9-131">Mit der Profilerstellung erhalten Sie Antworten, die Ihnen bei der Budget Leistung helfen</span><span class="sxs-lookup"><span data-stu-id="e38d9-131">Profiling gives you answers that help you budget performance.</span></span> <span data-ttu-id="e38d9-132">Angenommen, Sie wissen, dass ein API-Befehl durchschnittlich 1000-Taktzyklen für die Ausführung durchläuft.</span><span class="sxs-lookup"><span data-stu-id="e38d9-132">For instance, suppose you know that an API call averages one thousand clock cycles to execute.</span></span> <span data-ttu-id="e38d9-133">Sie können einige Schlussfolgerungen über die Leistung bestätigen, wie z. b. Folgendes:</span><span class="sxs-lookup"><span data-stu-id="e38d9-133">You can assert some conclusions about performance such as the following:</span></span>

-   <span data-ttu-id="e38d9-134">Eine CPU mit 2 GHz (die 50 Prozent des Zeit Rendering verbringt) ist auf das Aufrufen dieser API 1 Million Mal pro Sekunde beschränkt.</span><span class="sxs-lookup"><span data-stu-id="e38d9-134">A 2 GHz CPU (which spends 50 percent of its time rendering) is limited to calling this API 1 million times a second.</span></span>
-   <span data-ttu-id="e38d9-135">Um 30 Frames pro Sekunde zu erreichen, können Sie diese API nicht mehr als 33.000 Mal pro Frame aufzurufen.</span><span class="sxs-lookup"><span data-stu-id="e38d9-135">To achieve 30 frames per second, you cannot call this API more than 33,000 times per frame.</span></span>
-   <span data-ttu-id="e38d9-136">Sie können nur 3.3 KB-Objekte pro Frame Rendering (bei 10 dieser API-Aufrufe für die Rendering-Sequenz der einzelnen Objekte).</span><span class="sxs-lookup"><span data-stu-id="e38d9-136">You can only render 3.3K objects per frame (assuming 10 of these API calls for each object's render sequence).</span></span>

<span data-ttu-id="e38d9-137">Anders ausgedrückt: Wenn Sie über ausreichend Zeit pro API-Aufruf verfügen, können Sie eine Budgetfrage wie die Anzahl der primitiven, die interaktiv gerendert werden können, beantworten.</span><span class="sxs-lookup"><span data-stu-id="e38d9-137">In other words, if you had sufficient time per API call, you could answer a budgeting question such as the number of primitives that can be rendered interactively.</span></span> <span data-ttu-id="e38d9-138">Die von einem Instrumentierungs Profiler zurückgegebenen Rohdaten beantworten die Fragen zur Budgetierung jedoch nicht genau.</span><span class="sxs-lookup"><span data-stu-id="e38d9-138">But the raw numbers returned by an instrumenting profiler will not accurately answer the budgeting questions.</span></span> <span data-ttu-id="e38d9-139">Dies liegt daran, dass die Grafik Pipeline komplexe Entwurfs Probleme aufweist, wie z. b. die Anzahl der Komponenten, die funktionieren müssen, die Anzahl der Prozessoren, die Steuern, wie der Arbeitsablauf zwischen den Komponenten verläuft, sowie Optimierungsstrategien, die in der Laufzeit und in einem Treiber implementiert werden, der entwickelt wurde, um die Pipeline effizienter zu gestalten.</span><span class="sxs-lookup"><span data-stu-id="e38d9-139">This is because the graphics pipeline has complex design issues such as the number of components that need to do work, the number of processors that control how the work flows between components, and optimization strategies implemented in the runtime and in a driver that are designed to make the pipeline more efficient.</span></span>

### <a name="each-api-call-goes-through-several-components"></a><span data-ttu-id="e38d9-140">Jeder API-Befehl durchläuft mehrere Komponenten.</span><span class="sxs-lookup"><span data-stu-id="e38d9-140">Each API Call Goes through Several Components</span></span>

<span data-ttu-id="e38d9-141">Jeder-Rückruf wird von der Anwendung bis zur Grafikkarte von mehreren Komponenten verarbeitet.</span><span class="sxs-lookup"><span data-stu-id="e38d9-141">Each call is processed by several components on its way from the application to the video card.</span></span> <span data-ttu-id="e38d9-142">Sehen Sie sich zum Beispiel die folgende rendersequenz an, die zwei Aufrufe zum Zeichnen eines einzelnen Dreiecks enthält:</span><span class="sxs-lookup"><span data-stu-id="e38d9-142">For instance, consider the following render sequence containing two calls for drawing a single triangle:</span></span>


```
SetTexture(...);
DrawPrimitive(D3DPT_TRIANGLELIST, 0, 1);
```



<span data-ttu-id="e38d9-143">Das folgende konzeptionelle Diagramm zeigt die verschiedenen Komponenten, über die die Aufrufe bestanden werden müssen.</span><span class="sxs-lookup"><span data-stu-id="e38d9-143">The following conceptual diagram shows the different components through which the calls must pass.</span></span>

![Diagramm der Grafik Komponenten, die API-Aufrufe durchlaufen](images/microbenchmarkinstructionflow2.png)

<span data-ttu-id="e38d9-145">Die Anwendung ruft Direct3D auf, um die Szene zu steuern, Benutzerinteraktionen zu verarbeiten und zu bestimmen, wie das Rendering erfolgt.</span><span class="sxs-lookup"><span data-stu-id="e38d9-145">The application invokes Direct3D which controls the scene, handles user interactions, and determines how rendering is done.</span></span> <span data-ttu-id="e38d9-146">All diese Aufgaben werden in der Rendering-Sequenz angegeben, die mithilfe von Direct3D-API-Aufrufen an die Laufzeit gesendet wird.</span><span class="sxs-lookup"><span data-stu-id="e38d9-146">All of this work is specified in the render sequence, which is sent to the runtime using Direct3D API calls.</span></span> <span data-ttu-id="e38d9-147">Die Rendering-Sequenz ist praktisch Hardware unabhängig (d. h., die API-Aufrufe sind Hardware unabhängig, aber eine Anwendung hat wissen, welche Funktionen von einer Grafikkarte unterstützt werden).</span><span class="sxs-lookup"><span data-stu-id="e38d9-147">The render sequence is virtually hardware independent (that is, the API calls are hardware independent but an application has knowledge of what features a video card supports).</span></span>

<span data-ttu-id="e38d9-148">Die Laufzeit konvertiert diese Aufrufe in ein Geräte unabhängiges Format.</span><span class="sxs-lookup"><span data-stu-id="e38d9-148">The runtime converts these calls into a device-independent format.</span></span> <span data-ttu-id="e38d9-149">Die Laufzeit übernimmt die gesamte Kommunikation zwischen der Anwendung und dem Treiber, sodass eine Anwendung auf mehr als einem kompatiblen Hardware Server ausgeführt werden kann (abhängig von den erforderlichen Features).</span><span class="sxs-lookup"><span data-stu-id="e38d9-149">The runtime handles all the communication between the application and the driver, so that an application will run on more than one compatible piece of hardware (depending on the features required).</span></span> <span data-ttu-id="e38d9-150">Beim Messen eines Funktions Aufrufes misst ein Instrumentierungs Profil die Zeit, die in einer Funktion aufgewendet wurde, sowie die Zeit, die die Funktion zurückgibt.</span><span class="sxs-lookup"><span data-stu-id="e38d9-150">When measuring a function call, an instrumenting profiler measures the time it spent in a function as well as the time for the function to return.</span></span> <span data-ttu-id="e38d9-151">Eine Einschränkung für einen instrumentierungsprofiler besteht darin, dass es möglicherweise nicht die Zeit beinhaltet, mit der ein Treiber die resultierende Arbeit an die Grafikkarte sendet, und nicht die Uhrzeit, zu der die Grafikkarte die Arbeit verarbeitet.</span><span class="sxs-lookup"><span data-stu-id="e38d9-151">One limitation of an instrumenting profiler is that it may not include the time it takes a driver to send the resulting work to the video card nor the time for the video card to process the work.</span></span> <span data-ttu-id="e38d9-152">Anders ausgedrückt: ein offlinerinstrumentierungsprofiler kann nicht alle Arbeit, die den einzelnen Funktions aufruten zugeordnet ist, zuordnen.</span><span class="sxs-lookup"><span data-stu-id="e38d9-152">In other words, an off-the-shelf instrumenting profiler fails to attribute all of the work associated with each function call.</span></span>

<span data-ttu-id="e38d9-153">Der Software Treiber verwendet Hardware spezifische Informationen über die Grafikkarte, um die geräteunabhängigen Befehle in eine Sequenz von Grafikkarten Befehlen zu konvertieren.</span><span class="sxs-lookup"><span data-stu-id="e38d9-153">The software driver uses hardware specific knowledge about the video card to convert the device-independent commands into a sequence of video card commands.</span></span> <span data-ttu-id="e38d9-154">Treiber können auch die Abfolge der Befehle optimieren, die an die Grafikkarte gesendet werden, damit das Rendering auf der Grafikkarte effizient erfolgt.</span><span class="sxs-lookup"><span data-stu-id="e38d9-154">Drivers may also optimize the sequence of commands that are sent to the video card, so that rendering on the video card is done efficiently.</span></span> <span data-ttu-id="e38d9-155">Diese Optimierungen können Profil Erstellungs Probleme verursachen, da die Menge der abgeschlossenen Arbeit nicht so aussieht, wie Sie aussieht (Sie müssen möglicherweise die Optimierungen verstehen, um Sie zu berücksichtigen).</span><span class="sxs-lookup"><span data-stu-id="e38d9-155">These optimizations can cause profiling problems because the amount of work done is not what it appears to be (you may need to understand the optimizations to account for them).</span></span> <span data-ttu-id="e38d9-156">Der Treiber gibt in der Regel die Steuerung an die Laufzeit zurück, bevor die Grafikkarte die Verarbeitung aller Befehle abgeschlossen hat.</span><span class="sxs-lookup"><span data-stu-id="e38d9-156">The driver typically returns control to the runtime before the video card has finished processing all the commands.</span></span>

<span data-ttu-id="e38d9-157">Die Grafikkarte führt den Großteil des Renderings durch Kombinieren von Daten aus dem Scheitelpunkt und Index Puffer, Texturen, renderstatusinformationen und den Grafik Befehlen aus.</span><span class="sxs-lookup"><span data-stu-id="e38d9-157">The video card performs the majority of the rendering by combining data from the vertex and index buffers, textures, render state information, and the graphics commands.</span></span> <span data-ttu-id="e38d9-158">Wenn die Grafikkarte das Rendering abschließt, ist die aus der rendersequenz erstellte Arbeit abgeschlossen.</span><span class="sxs-lookup"><span data-stu-id="e38d9-158">When the video card finishes rendering, the work created from the render sequence is complete.</span></span>

<span data-ttu-id="e38d9-159">Jeder Direct3D-API-Rückruf muss von jeder Komponente (der Laufzeit, dem Treiber und der Grafikkarte) verarbeitet werden, um alles zu Rendering.</span><span class="sxs-lookup"><span data-stu-id="e38d9-159">Each Direct3D API call must be processed by each component (the runtime, the driver, and the video card) to render anything.</span></span>

### <a name="there-is-more-than-one-processor-controlling-the-components"></a><span data-ttu-id="e38d9-160">Es sind mehrere Prozessoren vorhanden, die die Komponenten steuern.</span><span class="sxs-lookup"><span data-stu-id="e38d9-160">There Is More than One Processor Controlling the Components</span></span>

<span data-ttu-id="e38d9-161">Die Beziehung zwischen diesen Komponenten ist noch komplexer, da die Anwendung, die Laufzeit und der Treiber von einem Prozessor gesteuert werden und die Grafikkarte von einem separaten Prozessor gesteuert wird.</span><span class="sxs-lookup"><span data-stu-id="e38d9-161">The relationship between these components is even more complex, because the application, runtime, and the driver are controlled by one processor and the video card is controlled by a separate processor.</span></span> <span data-ttu-id="e38d9-162">Das folgende Diagramm zeigt zwei Arten von Prozessoren: eine zentrale Verarbeitungseinheit (CPU) und eine GPU (Graphics Processing Unit).</span><span class="sxs-lookup"><span data-stu-id="e38d9-162">The following diagram shows two kinds of processors: a central processing unit (CPU) and a graphics processing unit (GPU).</span></span>

![Diagramm für eine CPU und eine GPU und deren Komponenten](images/microbenchmarkprocessors.png)

<span data-ttu-id="e38d9-164">PC-Systeme verfügen über mindestens eine CPU und eine GPU, Sie können jedoch mehr als eine von beiden oder beides aufweisen.</span><span class="sxs-lookup"><span data-stu-id="e38d9-164">PC systems have at least one CPU and one GPU, but can have more than one of either or both.</span></span> <span data-ttu-id="e38d9-165">Die CPUs befinden sich auf der Hauptplatine, und die GPUs befinden sich entweder auf dem Motherboard oder auf der Grafikkarte.</span><span class="sxs-lookup"><span data-stu-id="e38d9-165">The CPUs are located on the motherboard, and the GPUs are located either on the motherboard or on the video card.</span></span> <span data-ttu-id="e38d9-166">Die Geschwindigkeit der CPU wird durch einen Takt Chip auf der Hauptplatine festgelegt, und die Geschwindigkeit der GPU wird durch einen separaten Takt Chip bestimmt.</span><span class="sxs-lookup"><span data-stu-id="e38d9-166">The speed of the CPU is determined by a clock chip on the motherboard, and the speed of the GPU is determined by a separate clock chip.</span></span> <span data-ttu-id="e38d9-167">Die CPU-Uhr steuert die Geschwindigkeit der von der Anwendung, der Laufzeit und des Treibers ausgeführten Arbeit.</span><span class="sxs-lookup"><span data-stu-id="e38d9-167">The CPU clock controls the speed of the work done by the application, the runtime, and the driver.</span></span> <span data-ttu-id="e38d9-168">Die Anwendung sendet Arbeit an die GPU über die Laufzeit und den Treiber.</span><span class="sxs-lookup"><span data-stu-id="e38d9-168">The application sends work to the GPU via the runtime and the driver.</span></span>

<span data-ttu-id="e38d9-169">Die CPU und die GPU werden in der Regel unabhängig voneinander mit unterschiedlichen Geschwindigkeiten ausgeführt.</span><span class="sxs-lookup"><span data-stu-id="e38d9-169">The CPU and the GPU generally run at different speeds, independent of one another.</span></span> <span data-ttu-id="e38d9-170">Die GPU reagiert möglicherweise auf die Arbeit, sobald die Arbeit verfügbar ist (vorausgesetzt, die GPU hat die Verarbeitung vorheriger Aufgaben abgeschlossen).</span><span class="sxs-lookup"><span data-stu-id="e38d9-170">The GPU may respond to the work as soon as the work is available (assuming the GPU has finished processing previous work).</span></span> <span data-ttu-id="e38d9-171">Die GPU-Arbeit erfolgt parallel zur CPU-Arbeit, wie von der gekrümmten Linie in der obigen Abbildung hervorgehoben.</span><span class="sxs-lookup"><span data-stu-id="e38d9-171">The GPU work is done in parallel with the CPU work as highlighted by the curved line in the figure above.</span></span> <span data-ttu-id="e38d9-172">Ein Profiler misst in der Regel die Leistung der CPU, nicht die GPU.</span><span class="sxs-lookup"><span data-stu-id="e38d9-172">A profiler generally measures the performance of the CPU, not the GPU.</span></span> <span data-ttu-id="e38d9-173">Dadurch ist die Profilerstellung schwierig, da die von einem instrumentierungsprofiler erstellten Messungen die CPU-Zeit einschließen, aber nicht die GPU-Zeit einschließen.</span><span class="sxs-lookup"><span data-stu-id="e38d9-173">This makes profiling challenging, because the measurements made by an instrumenting profiler include the CPU time but may not include the GPU time.</span></span>

<span data-ttu-id="e38d9-174">Der Zweck der GPU besteht darin, die Verarbeitung von der CPU auf einen Prozessor zu deaktivieren, der speziell für Grafik Arbeiten konzipiert ist.</span><span class="sxs-lookup"><span data-stu-id="e38d9-174">The purpose of the GPU is to off-load processing from the CPU to a processor specifically designed for graphics work.</span></span> <span data-ttu-id="e38d9-175">Auf modernen Videokarten ersetzt die GPU einen Großteil der Transformations-und Beleuchtungsaufgaben in der Pipeline von der CPU zur GPU.</span><span class="sxs-lookup"><span data-stu-id="e38d9-175">On modern video cards, the GPU replaces much of the transform and lighting work in the pipeline from the CPU to the GPU.</span></span> <span data-ttu-id="e38d9-176">Dadurch wird die CPU-Arbeitsauslastung erheblich reduziert, sodass mehr CPU-Zyklen für die andere Verarbeitung verfügbar sind.</span><span class="sxs-lookup"><span data-stu-id="e38d9-176">This greatly reduces the CPU workload, leaving more CPU cycles available for other processing.</span></span> <span data-ttu-id="e38d9-177">Wenn Sie eine grafische Anwendung für die Spitzenleistung optimieren möchten, müssen Sie die Leistung der CPU und der GPU Messen und die Arbeit zwischen den beiden Arten von Prozessoren ausgleichen.</span><span class="sxs-lookup"><span data-stu-id="e38d9-177">To tune a graphical application for peak performance, you need to measure the performance of both the CPU and the GPU, and balance the work between the two types of processors.</span></span>

<span data-ttu-id="e38d9-178">In diesem Dokument werden keine Themen behandelt, die sich auf das Messen der Leistung der GPU oder den Ausgleich der Arbeitsauslastung zwischen der CPU und der GPU beziehen.</span><span class="sxs-lookup"><span data-stu-id="e38d9-178">This document does not cover topics related to measuring the performance of the GPU or balancing the work between the CPU and the GPU.</span></span> <span data-ttu-id="e38d9-179">Wenn Sie die Leistung einer GPU (oder einer bestimmten Grafikkarte) besser verstehen möchten, besuchen Sie die Website des Anbieters, um nach weiteren Informationen zur GPU-Leistung zu suchen.</span><span class="sxs-lookup"><span data-stu-id="e38d9-179">If you want to better understand the performance of a GPU (or a particular video card), visit the vendor's web site to look for more information about GPU performance.</span></span> <span data-ttu-id="e38d9-180">Stattdessen konzentriert sich dieses Dokument auf die Arbeit, die von der Laufzeit und dem Treiber erledigt wird, indem die GPU-Arbeit auf einen vernachlässigbaren Betrag reduziert wird.</span><span class="sxs-lookup"><span data-stu-id="e38d9-180">Instead, this document focuses on the work done by the runtime and the driver by reducing the GPU work to a negligible amount.</span></span> <span data-ttu-id="e38d9-181">Dies ist teilweise auf der Grundlage der Erfahrung, dass Anwendungen, die Leistungsprobleme aufweisen, in der Regel CPU-beschränkt sind.</span><span class="sxs-lookup"><span data-stu-id="e38d9-181">This is, in part, based on experience that applications experiencing performance problems are generally CPU-limited.</span></span>

### <a name="runtime-and-driver-optimizations-can-mask-api-measurements"></a><span data-ttu-id="e38d9-182">Lauf Zeit-und Treiber Optimierungen können API-Messungen maskieren</span><span class="sxs-lookup"><span data-stu-id="e38d9-182">Runtime and Driver Optimizations Can Mask API Measurements</span></span>

<span data-ttu-id="e38d9-183">Die Laufzeitumgebung verfügt über eine integrierte Leistungsoptimierung, mit der die Messung eines einzelnen Aufrufes überlastet werden kann.</span><span class="sxs-lookup"><span data-stu-id="e38d9-183">The runtime has a performance optimization built into it that can overwhelm the measurement of an individual call.</span></span> <span data-ttu-id="e38d9-184">Im folgenden finden Sie ein Beispielszenario, in dem dieses Problem veranschaulicht wird.</span><span class="sxs-lookup"><span data-stu-id="e38d9-184">Here's an example scenario that demonstrates this problem.</span></span> <span data-ttu-id="e38d9-185">Sehen Sie sich die folgende Rendering-Sequenz an:</span><span class="sxs-lookup"><span data-stu-id="e38d9-185">Consider the following render sequence:</span></span>


```
  BeginScene();
    ...
    SetTexture(...);
    DrawPrimitive(D3DPT_TRIANGLELIST, 0, 1);
    ...
  EndScene();
  Present();
```



<span data-ttu-id="e38d9-186">Beispiel 1: einfache Rendering-Sequenz</span><span class="sxs-lookup"><span data-stu-id="e38d9-186">Example 1: Simple Render Sequence</span></span>

<span data-ttu-id="e38d9-187">Wenn Sie sich die Ergebnisse der beiden Aufrufe in der Rendering-Sequenz ansehen, könnte ein instrumentierungsprofiler ähnliche Ergebnisse wie die folgenden zurückgeben:</span><span class="sxs-lookup"><span data-stu-id="e38d9-187">Looking at the results for the two calls in the render sequence, an instrumenting profiler could return results similar to these:</span></span>


```
Number of cycles for SetTexture       : 100
Number of cycles for DrawPrimitive    : 950,500
```



<span data-ttu-id="e38d9-188">Der Profiler gibt die Anzahl der CPU-Zyklen zurück, die erforderlich sind, um die mit jedem-Rückruf verknüpften Aufgaben zu verarbeiten (Beachten Sie, dass die GPU nicht in diese Zahlen eingeschlossen ist, weil die GPU noch nicht mit diesen Befehlen begonnen hat)</span><span class="sxs-lookup"><span data-stu-id="e38d9-188">The profiler returns the number of CPU cycles required to process the work associated with each call (remember that the GPU isn't included in these numbers because the GPU hasn't started working on these commands yet).</span></span> <span data-ttu-id="e38d9-189">Da [**IDirect3DDevice9::D rawprimitiv**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-drawprimitive) fast eine Million Zyklen für die Verarbeitung erforderte, konnten Sie feststellen, dass es nicht sehr effizient ist.</span><span class="sxs-lookup"><span data-stu-id="e38d9-189">Because [**IDirect3DDevice9::DrawPrimitive**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-drawprimitive) required almost a million cycles to process, you could conclude that it is not very efficient.</span></span> <span data-ttu-id="e38d9-190">Sie werden jedoch bald feststellen, warum diese Schlussfolgerung falsch ist, und wie Sie Ergebnisse generieren können, die für die Budgetplanung verwendet werden können.</span><span class="sxs-lookup"><span data-stu-id="e38d9-190">However, you'll soon see why this conclusion is incorrect and how you can generate results that can be used for budgeting.</span></span>

### <a name="measuring-state-changes-requires-careful-render-sequences"></a><span data-ttu-id="e38d9-191">Das Messen von Zustandsänderungen erfordert sorgfältige Rendering-Sequenzen.</span><span class="sxs-lookup"><span data-stu-id="e38d9-191">Measuring State Changes Requires Careful Render Sequences</span></span>

<span data-ttu-id="e38d9-192">Alle Aufrufe außer [**IDirect3DDevice9::D rawprimitiv**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-drawprimitive), [**drawindexedprimitiv**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-drawindexedprimitive)oder [**Clear**](/windows/desktop/api) (z. b. [**SetTexture**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-settexture), [**setvertexdeclaration**](/windows/desktop/api)und [**setrenderstate**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-setrenderstate)) bewirken eine Zustandsänderung.</span><span class="sxs-lookup"><span data-stu-id="e38d9-192">All calls other than [**IDirect3DDevice9::DrawPrimitive**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-drawprimitive), [**DrawIndexedPrimitive**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-drawindexedprimitive), or [**Clear**](/windows/desktop/api) (such as [**SetTexture**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-settexture), [**SetVertexDeclaration**](/windows/desktop/api), and [**SetRenderState**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-setrenderstate)) produce a state change.</span></span> <span data-ttu-id="e38d9-193">Jede Zustandsänderung legt den Pipeline Status fest, der steuert, wie das Rendering durchgeführt wird.</span><span class="sxs-lookup"><span data-stu-id="e38d9-193">Each state change sets pipeline state that controls how rendering will be done.</span></span>

<span data-ttu-id="e38d9-194">Optimierungen in der Laufzeit und/oder dem Treiber sind so konzipiert, dass das Rendering beschleunigt wird, indem der erforderliche Arbeitsaufwand reduziert wird.</span><span class="sxs-lookup"><span data-stu-id="e38d9-194">Optimizations in the runtime and/or the driver are designed to speed up rendering by reducing the amount of work required.</span></span> <span data-ttu-id="e38d9-195">Im folgenden finden Sie eine Reihe von Optimierungen für die Statusänderung, die Profil-Mittelwerte verschmutzen können:</span><span class="sxs-lookup"><span data-stu-id="e38d9-195">The following are a couple of state change optimizations that may pollute profile averages:</span></span>

-   <span data-ttu-id="e38d9-196">Ein Treiber (oder die Laufzeit) kann eine Zustandsänderung als lokalen Status speichern.</span><span class="sxs-lookup"><span data-stu-id="e38d9-196">A driver (or the runtime) could save a state change as a local state.</span></span> <span data-ttu-id="e38d9-197">Da der Treiber in einem "Lazy"-Algorithmus arbeiten könnte (die Arbeit wird so lange verschoben, bis er unbedingt erforderlich ist), kann die Arbeit mit einigen Zustandsänderungen verzögert werden.</span><span class="sxs-lookup"><span data-stu-id="e38d9-197">Because the driver could operate in a "lazy" algorithm (postponing work until it is absolutely necessary), work associated with some state changes could get delayed.</span></span>
-   <span data-ttu-id="e38d9-198">Die Laufzeit (oder ein Treiber) kann Zustandsänderungen durch Optimieren von entfernen.</span><span class="sxs-lookup"><span data-stu-id="e38d9-198">The runtime (or a driver) may remove state changes by optimizing.</span></span> <span data-ttu-id="e38d9-199">Ein Beispiel hierfür ist das Entfernen einer redundanten Zustandsänderung, die die Beleuchtung deaktiviert, da die Beleuchtung zuvor deaktiviert wurde.</span><span class="sxs-lookup"><span data-stu-id="e38d9-199">An example of this might be to remove a redundant state change that disables lighting because lighting has previously been disabled.</span></span>

<span data-ttu-id="e38d9-200">Es gibt keine Möglichkeit, eine rendersequenz zu überprüfen und zu bestimmen, welche Zustandsänderungen ein geändertes Bit festlegen und die Arbeit verzögern oder einfach durch Optimierung entfernt werden.</span><span class="sxs-lookup"><span data-stu-id="e38d9-200">There is no foolproof way to look at a render sequence and conclude which state changes will set a dirty bit and defer work, or will simply be removed by optimization.</span></span> <span data-ttu-id="e38d9-201">Auch wenn Sie optimierte Zustandsänderungen in der Laufzeit oder im Treiber von heute ermitteln könnten, wird die Laufzeit oder der Treiber von morgen wahrscheinlich aktualisiert.</span><span class="sxs-lookup"><span data-stu-id="e38d9-201">Even if you could identify optimized state changes in today's runtime or driver, tomorrow's runtime or driver is likely to be updated.</span></span> <span data-ttu-id="e38d9-202">Sie wissen auch nicht, was der vorherige Status war, daher ist es schwierig, redundante Zustandsänderungen zu identifizieren.</span><span class="sxs-lookup"><span data-stu-id="e38d9-202">You also don't readily know what the previous state was so it is difficult to identify redundant state changes.</span></span> <span data-ttu-id="e38d9-203">Die einzige Möglichkeit, die Kosten einer Zustandsänderung zu überprüfen, ist das Messen der Rendering-Sequenz, die die Statusänderungen einschließt.</span><span class="sxs-lookup"><span data-stu-id="e38d9-203">The only way to verify the cost of a state change is to measure the render sequence that includes the state changes.</span></span>

<span data-ttu-id="e38d9-204">Wie Sie sehen können, ist die Erstellung der Profilerstellung schwerwiegend, wenn Sie über mehrere Prozessoren, Befehle verfügen, die von mehr als einer Komponente verarbeitet werden, und Optimierungen, die in die Komponenten integriert wurden.</span><span class="sxs-lookup"><span data-stu-id="e38d9-204">As you can see, the complications caused by having multiple processors, commands being processed by more than one component, and optimizations built into the components make profiling difficult to predict.</span></span> <span data-ttu-id="e38d9-205">Im nächsten Abschnitt wird jede dieser Herausforderungen bei der Profilerstellung behandelt.</span><span class="sxs-lookup"><span data-stu-id="e38d9-205">In the next section, each of these profiling challenges will be addressed.</span></span> <span data-ttu-id="e38d9-206">Sample Direct3D-Rendering-Sequenzen werden mit den dazugehörigen Messtechniken angezeigt.</span><span class="sxs-lookup"><span data-stu-id="e38d9-206">Sample Direct3D render sequences will be shown, with the accompanying measurement techniques.</span></span> <span data-ttu-id="e38d9-207">Mit diesem Wissen können Sie exakte, wiederholbare Messergebnisse für einzelne Aufrufe generieren.</span><span class="sxs-lookup"><span data-stu-id="e38d9-207">With this knowledge, you will be able to generate accurate, repeatable measurements on individual calls.</span></span>

## <a name="how-to-accurately-profile-a-direct3d-render-sequence"></a><span data-ttu-id="e38d9-208">Genaue Profilerstellung für eine Direct3D-Rendering-Sequenz</span><span class="sxs-lookup"><span data-stu-id="e38d9-208">How to Accurately Profile a Direct3D Render Sequence</span></span>

<span data-ttu-id="e38d9-209">Nachdem nun einige der Herausforderungen bei der Profilerstellung hervorgehoben wurden, werden in diesem Abschnitt Techniken vorgestellt, mit denen Sie Profilmessungen generieren können, die für die Budgetplanung verwendet werden können.</span><span class="sxs-lookup"><span data-stu-id="e38d9-209">Now that some of the profiling challenges have been highlighted, this section will show you techniques that will help you generate profile measurements that can be used for budgeting.</span></span> <span data-ttu-id="e38d9-210">Genaue, wiederholbare Profil Erstellungs Messungen sind möglich, wenn Sie die Beziehung zwischen den von der CPU kontrollierten Komponenten verstehen und die von der Laufzeit und dem Treiber implementierten Leistungsoptimierungen vermeiden.</span><span class="sxs-lookup"><span data-stu-id="e38d9-210">Accurate, repeatable profiling measurements are possible if you understand the relationship between the components controlled by the CPU, and how to avoid performance optimizations implemented by the runtime and the driver.</span></span>

<span data-ttu-id="e38d9-211">Zunächst müssen Sie in der Lage sein, die Ausführungszeit eines einzelnen API-Aufrufes genau zu messen.</span><span class="sxs-lookup"><span data-stu-id="e38d9-211">To begin, you need to be able to accurately measure the execution time of a single API call.</span></span>

### <a name="pick-an-accurate-measurement-tool-like-queryperformancecounter"></a><span data-ttu-id="e38d9-212">Wählen Sie ein genaues Mess Tool wie QueryPerformanceCounter aus.</span><span class="sxs-lookup"><span data-stu-id="e38d9-212">Pick an Accurate Measurement Tool Like QueryPerformanceCounter</span></span>

<span data-ttu-id="e38d9-213">Das Microsoft Windows-Betriebssystem enthält einen Zeit Geber mit hoher Auflösung, der zum Messen der verstrichenen Zeiten mit hoher Auflösung verwendet werden kann.</span><span class="sxs-lookup"><span data-stu-id="e38d9-213">The Microsoft Windows operating system includes a high-resolution timer that can be used to measure high-resolution elapsed times.</span></span> <span data-ttu-id="e38d9-214">Der aktuelle Wert eines solchen Timers kann mithilfe von " [**QueryPerformanceCounter**](/windows/win32/api/profileapi/nf-profileapi-queryperformancecounter)" zurückgegeben werden.</span><span class="sxs-lookup"><span data-stu-id="e38d9-214">The current value of one such timer can be returned using [**QueryPerformanceCounter**](/windows/win32/api/profileapi/nf-profileapi-queryperformancecounter).</span></span> <span data-ttu-id="e38d9-215">Nachdem Sie **QueryPerformanceCounter** aufgerufen haben, um Start-und Endwerte zurückzugeben, kann der Unterschied zwischen den beiden Werten mithilfe von **QueryPerformanceCounter** in die tatsächlich verstrichene Zeit (in Sekunden) konvertiert werden.</span><span class="sxs-lookup"><span data-stu-id="e38d9-215">After invoking **QueryPerformanceCounter** to return start and stop values, the difference between the two values can be converted to the actual elapsed time (in seconds) using **QueryPerformanceCounter**.</span></span>

<span data-ttu-id="e38d9-216">Die Verwendung von [**QueryPerformanceCounter**](/windows/win32/api/profileapi/nf-profileapi-queryperformancecounter) hat den Vorteil, dass es in Windows verfügbar ist und problemlos verwendet werden kann.</span><span class="sxs-lookup"><span data-stu-id="e38d9-216">The advantages of using [**QueryPerformanceCounter**](/windows/win32/api/profileapi/nf-profileapi-queryperformancecounter) are that it is available in Windows and it is easy to use.</span></span> <span data-ttu-id="e38d9-217">Umschließen Sie die Aufrufe einfach mit einem **QueryPerformanceCounter** -Aufruf, und speichern Sie die Werte für Start und Ende.</span><span class="sxs-lookup"><span data-stu-id="e38d9-217">Simply surround the calls with a **QueryPerformanceCounter** call and save the start and stop values.</span></span> <span data-ttu-id="e38d9-218">Daher wird in diesem Artikel veranschaulicht, wie Sie **QueryPerformanceCounter** verwenden, um die Ausführungszeiten zu Profilen, ähnlich der Art, wie Sie von einem instrumentierungsprofiler gemessen wird.</span><span class="sxs-lookup"><span data-stu-id="e38d9-218">Therefore, this paper will demonstrate how to use **QueryPerformanceCounter** to profile execution times, similar to the way an instrumenting profiler would measure it.</span></span> <span data-ttu-id="e38d9-219">Es folgt ein Beispiel, das zeigt, wie Sie **QueryPerformanceCounter** in Ihren Quellcode einbetten:</span><span class="sxs-lookup"><span data-stu-id="e38d9-219">Here's an example that shows how to embed **QueryPerformanceCounter** in your source code:</span></span>


```
  BeginScene();
    ...
    // Start profiling
    LARGE_INTEGER start, stop, freq;
    QueryPerformanceCounter(&start);

    SetTexture(...);
    DrawPrimitive(D3DPT_TRIANGLELIST, 0, 1); 

    QueryPerformanceCounter(&stop);
    stop.QuadPart -= start.QuadPart;
    QueryPerformanceFrequency(&freq);
    // Stop profiling
    ...
  EndScene();
  Present();
```



<span data-ttu-id="e38d9-220">Beispiel 2: Implementierung benutzerdefinierter Profilerstellung mit QPC</span><span class="sxs-lookup"><span data-stu-id="e38d9-220">Example 2: Custom Profiling Implementation with QPC</span></span>

<span data-ttu-id="e38d9-221">Start und anhalten sind zwei große ganze Zahlen, die die vom Hochleistungs-Timer zurückgegebenen Werte für Start und Ende enthalten.</span><span class="sxs-lookup"><span data-stu-id="e38d9-221">start and stop are two large integers that will hold the start and stop values returned by the high-performance timer.</span></span> <span data-ttu-id="e38d9-222">Beachten Sie, dass QueryPerformanceCounter (&Start) unmittelbar vor dem Aufruf von [**SetTexture**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-settexture) und QueryPerformanceCounter (&Ende) direkt nach [**drawprimitive**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-drawprimitive)aufgerufen wird.</span><span class="sxs-lookup"><span data-stu-id="e38d9-222">Notice that QueryPerformanceCounter(&start) is called just before [**SetTexture**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-settexture) and QueryPerformanceCounter(&stop) is called just after [**DrawPrimitive**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-drawprimitive).</span></span> <span data-ttu-id="e38d9-223">Nach dem Abrufen des Endwerts wird QueryPerformanceFrequency aufgerufen, um freq zurückzugeben. Dies ist die Häufigkeit des hochauflösenden Timers.</span><span class="sxs-lookup"><span data-stu-id="e38d9-223">After getting the stop value, QueryPerformanceFrequency is called to return freq, which is the frequency of the high-resolution timer.</span></span> <span data-ttu-id="e38d9-224">Angenommen, Sie erhalten in diesem hypothetischen Beispiel die folgenden Ergebnisse für "Start", "Start" und "FREQ":</span><span class="sxs-lookup"><span data-stu-id="e38d9-224">In this hypothetical example, suppose you get the following results for start, stop, and freq:</span></span>



| <span data-ttu-id="e38d9-225">Lokale Variable</span><span class="sxs-lookup"><span data-stu-id="e38d9-225">Local Variable</span></span> | <span data-ttu-id="e38d9-226">Anzahl der Ticks</span><span class="sxs-lookup"><span data-stu-id="e38d9-226">Number of Ticks</span></span> |
|----------------|-----------------|
| <span data-ttu-id="e38d9-227">start</span><span class="sxs-lookup"><span data-stu-id="e38d9-227">start</span></span>          | <span data-ttu-id="e38d9-228">1792998845094</span><span class="sxs-lookup"><span data-stu-id="e38d9-228">1792998845094</span></span>   |
| <span data-ttu-id="e38d9-229">stop</span><span class="sxs-lookup"><span data-stu-id="e38d9-229">stop</span></span>           | <span data-ttu-id="e38d9-230">1792998845102</span><span class="sxs-lookup"><span data-stu-id="e38d9-230">1792998845102</span></span>   |
| <span data-ttu-id="e38d9-231">Freq</span><span class="sxs-lookup"><span data-stu-id="e38d9-231">freq</span></span>           | <span data-ttu-id="e38d9-232">3579545</span><span class="sxs-lookup"><span data-stu-id="e38d9-232">3579545</span></span>         |



 

<span data-ttu-id="e38d9-233">Sie können diese Werte in die Anzahl der Zyklen konvertieren, die zum Ausführen der API-Aufrufe wie folgt benötigt werden:</span><span class="sxs-lookup"><span data-stu-id="e38d9-233">You could convert these values to the number of cycles it takes to execute the API calls like this:</span></span>


```
# ticks = (stop - start) = 1792998845102 - 1792998845094 = 8 ticks

# cycles = CPU speed * number of ticks / QPF
# 4568   = 2 GHz      * 8              / 3,579,545
```



<span data-ttu-id="e38d9-234">Das heißt, es werden ungefähr 4568 Taktzyklen benötigt, um [**SetTexture**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-settexture) und [**drawprimitiv**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-drawprimitive) auf diesem Computer mit 2 GHz zu verarbeiten.</span><span class="sxs-lookup"><span data-stu-id="e38d9-234">In other words, it takes about 4568 clock cycles to process [**SetTexture**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-settexture) and [**DrawPrimitive**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-drawprimitive) on this 2 GHz machine.</span></span> <span data-ttu-id="e38d9-235">Sie könnten diese Werte in die tatsächliche Zeit konvertieren, die zum Ausführen aller Aufrufe wie folgt benötigt wird:</span><span class="sxs-lookup"><span data-stu-id="e38d9-235">You could convert these values to the actual time it took to execute all the calls like this:</span></span>


```
(stop - start)/ freq = elapsed time
8 ticks / 3,579,545 = 2.2E-6 seconds or between 2 and 3 microseconds.
```



<span data-ttu-id="e38d9-236">Die Verwendung von QueryPerformanceCounter erfordert, dass Sie Ihrer Rendering-Sequenz Start-und Endmessungen hinzufügen und QueryPerformanceFrequency verwenden, um die Differenz (Anzahl der Ticks) in die Anzahl der CPU-Zyklen oder die tatsächliche Zeit zu konvertieren.</span><span class="sxs-lookup"><span data-stu-id="e38d9-236">Using QueryPerformanceCounter requires that you add start and stop measurements to your render sequence and use QueryPerformanceFrequency to convert the difference (number of ticks) to the number of CPU cycles or to actual time.</span></span> <span data-ttu-id="e38d9-237">Das Identifizieren der Messtechnik ist ein guter Einstieg in die Entwicklung einer benutzerdefinierten Profil Erstellungs Implementierung.</span><span class="sxs-lookup"><span data-stu-id="e38d9-237">Identifying the measurement technique is a good start for developing a custom profiling implementation.</span></span> <span data-ttu-id="e38d9-238">Bevor Sie jedoch mit der Erstellung von Messungen beginnen, müssen Sie wissen, wie Sie mit der Grafikkarte umzugehen sind.</span><span class="sxs-lookup"><span data-stu-id="e38d9-238">But before you jump in and start making measurements, you need to know how to deal with the video card.</span></span>

### <a name="focus-on-cpu-measurements"></a><span data-ttu-id="e38d9-239">Fokus auf CPU-Messungen</span><span class="sxs-lookup"><span data-stu-id="e38d9-239">Focus on CPU Measurements</span></span>

<span data-ttu-id="e38d9-240">Wie bereits erwähnt, funktionieren die CPU und die GPU parallel, um die von den API-aufrufen generierten Aufgaben zu verarbeiten.</span><span class="sxs-lookup"><span data-stu-id="e38d9-240">As stated earlier, the CPU and the GPU work in parallel to process the work generated by the API calls.</span></span> <span data-ttu-id="e38d9-241">Eine reale Anwendung erfordert die Profilerstellung für beide Arten von Prozessoren, um herauszufinden, ob Ihre Anwendung CPU-eingeschränkt oder GPU-begrenzt ist.</span><span class="sxs-lookup"><span data-stu-id="e38d9-241">A real world application requires profiling both types of processors to find out if your application is CPU-limited or GPU-limited.</span></span> <span data-ttu-id="e38d9-242">Da die GPU-Leistung Hersteller spezifisch ist, wäre es sehr schwierig, Ergebnisse in diesem Whitepaper zu liefern, die die verschiedenen verfügbaren Grafikkarten abdecken.</span><span class="sxs-lookup"><span data-stu-id="e38d9-242">Since GPU performance is vendor specific, it would be very challenging to produce results in this paper that cover the variety of video cards available.</span></span>

<span data-ttu-id="e38d9-243">Stattdessen konzentriert sich dieses Whitepaper auf die Profilerstellung für die von der CPU ausgeführten Arbeit, indem eine benutzerdefinierte Technik zum Messen der Laufzeit und der Treiber Arbeit verwendet wird.</span><span class="sxs-lookup"><span data-stu-id="e38d9-243">Instead, this paper will focus only on profiling the work performed by the CPU by using a custom technique for measuring the runtime and driver work.</span></span> <span data-ttu-id="e38d9-244">Die GPU-Arbeit wird auf eine unbedeutende Menge reduziert, sodass die CPU-Ergebnisse besser sichtbar sind.</span><span class="sxs-lookup"><span data-stu-id="e38d9-244">The GPU work will be reduced to an insignificant amount, so that CPU results are more visible.</span></span> <span data-ttu-id="e38d9-245">Ein Vorteil dieses Ansatzes besteht darin, dass diese Technik Ergebnisse in dem Anhang liefert, dass Sie in der Lage sein sollten, mit Ihren Messungen zu korrelieren.</span><span class="sxs-lookup"><span data-stu-id="e38d9-245">One benefit of this approach is that this technique yields results in the Appendix that you should be able to correlate with your measurements.</span></span> <span data-ttu-id="e38d9-246">Um die für die Grafikkarte erforderliche Arbeit auf eine unbedeutende Ebene zu reduzieren, verringern Sie einfach die renderingarbeit auf die geringstmögliche Menge.</span><span class="sxs-lookup"><span data-stu-id="e38d9-246">To reduce the work required by the video card to an insignificant level, simply reduce the rendering work to the least amount possible.</span></span> <span data-ttu-id="e38d9-247">Dies kann erreicht werden, indem zeichnen-Aufrufe zum Rendern eines einzelnen Dreiecks eingeschränkt werden, und Sie können weiter eingeschränkt werden, sodass jedes Dreieck nur ein Pixel enthält.</span><span class="sxs-lookup"><span data-stu-id="e38d9-247">This can be accomplished by limiting draw calls to render a single triangle, and can be further constrained so that each triangle only contains one pixel.</span></span>

<span data-ttu-id="e38d9-248">Die Maßeinheit, die in diesem Artikel zum Messen der CPU-Arbeit verwendet wird, ist die Anzahl der CPU-Taktzyklen anstelle der tatsächlichen Zeit.</span><span class="sxs-lookup"><span data-stu-id="e38d9-248">The unit of measure used in this paper for measuring CPU work will be the number of CPU clock cycles rather than actual time.</span></span> <span data-ttu-id="e38d9-249">CPU-Taktzyklen haben den Vorteil, dass Sie besser portierbar sind (für CPU-eingeschränkte Anwendungen) als die tatsächlich verstrichene Zeit auf Computern mit unterschiedlichen CPU-Geschwindigkeiten.</span><span class="sxs-lookup"><span data-stu-id="e38d9-249">CPU clock cycles has the advantage that it is more portable (for CPU-limited applications) than actual elapsed time across machines with different CPU speeds.</span></span> <span data-ttu-id="e38d9-250">Dies kann bei Bedarf problemlos in die tatsächliche Zeit konvertiert werden.</span><span class="sxs-lookup"><span data-stu-id="e38d9-250">This can easily be converted to actual time if desired.</span></span>

<span data-ttu-id="e38d9-251">Dieses Dokument behandelt keine Themen im Zusammenhang mit dem Lastenausgleich der Arbeitsauslastung zwischen der CPU und der GPU.</span><span class="sxs-lookup"><span data-stu-id="e38d9-251">This document does not cover topics related to balancing the work load between the CPU and the GPU.</span></span> <span data-ttu-id="e38d9-252">Beachten Sie, dass das Ziel dieses Dokuments darin besteht, die Gesamtleistung einer Anwendung nicht zu messen, sondern zu veranschaulichen, wie Sie die Zeit, die die Laufzeit und der Treiber zum Verarbeiten von API-aufrufen benötigt, exakt messen können.</span><span class="sxs-lookup"><span data-stu-id="e38d9-252">Remember, the goal of this paper is not to measure the overall performance of an application, but to show you how to accurately measure the time it takes the runtime and the driver to process API calls.</span></span> <span data-ttu-id="e38d9-253">Mit diesen präzisen Messungen können Sie die Aufgabe der Budgetierung der CPU übernehmen, um bestimmte Leistungs Szenarios zu verstehen.</span><span class="sxs-lookup"><span data-stu-id="e38d9-253">With these accurate measurements, you can take on the task of budgeting the CPU to understand certain performance scenarios.</span></span>

### <a name="controlling-runtime-and-driver-optimizations"></a><span data-ttu-id="e38d9-254">Steuern von Lauf Zeit-und Treiber Optimierungen</span><span class="sxs-lookup"><span data-stu-id="e38d9-254">Controlling Runtime and Driver Optimizations</span></span>

<span data-ttu-id="e38d9-255">Wenn eine Maßeinheit identifiziert ist und eine Strategie zur Reduzierung der GPU-Arbeit vorliegt, besteht der nächste Schritt darin, die Lauf Zeit-und Treiber Optimierungen zu verstehen, die bei der Profilerstellung durchlaufen werden.</span><span class="sxs-lookup"><span data-stu-id="e38d9-255">With a measurement technique identified, and a strategy for reducing GPU work, the next step is to understand the runtime and driver optimizations that get in the way when you are profiling.</span></span>

<span data-ttu-id="e38d9-256">Die CPU-Arbeit kann in drei Bucket unterteilt werden: die Anwendung funktioniert, die Laufzeit funktioniert, und der Treiber funktioniert.</span><span class="sxs-lookup"><span data-stu-id="e38d9-256">The CPU work can be divided into three buckets: the application work, the runtime work, and the driver work.</span></span> <span data-ttu-id="e38d9-257">Ignorieren Sie die Anwendungs Arbeit, da dies der Programmierer-Kontrolle unterliegt.</span><span class="sxs-lookup"><span data-stu-id="e38d9-257">Ignore the application work since this is under programmer control.</span></span> <span data-ttu-id="e38d9-258">Aus Sicht der Anwendung sind die Laufzeit und der Treiber wie schwarze Felder, da die Anwendung nicht steuern kann, was in Ihnen implementiert ist.</span><span class="sxs-lookup"><span data-stu-id="e38d9-258">From the application's standpoint, the runtime and the driver are like black boxes, as the application has no control over what is implemented in them.</span></span> <span data-ttu-id="e38d9-259">Der Schlüssel ist das Verständnis der Optimierungstechniken, die in der Laufzeit und im Treiber implementiert werden können.</span><span class="sxs-lookup"><span data-stu-id="e38d9-259">The key is to understand the optimization techniques that may be implemented in the runtime and the driver.</span></span> <span data-ttu-id="e38d9-260">Wenn Sie diese Optimierungen nicht verstehen, ist es sehr einfach, zur falschen Schlussfolgerung hinsichtlich der Arbeitsauslastung der CPU basierend auf den Profilmessungen zu springen.</span><span class="sxs-lookup"><span data-stu-id="e38d9-260">If you don't understand these optimizations, it is very easy to jump to the wrong conclusion about the amount of work the CPU is doing based on the profile measurements.</span></span> <span data-ttu-id="e38d9-261">Vor allem gibt es zwei Themen, die sich auf einen als Befehls Puffer bezeichneten Artikel beziehen, und auf welche Weise die Profilerstellung verschleiert werden kann.</span><span class="sxs-lookup"><span data-stu-id="e38d9-261">In particular, there are two topics related to something called the command buffer and what it can do to obfuscate profiling.</span></span> <span data-ttu-id="e38d9-262">Diese Themen sind:</span><span class="sxs-lookup"><span data-stu-id="e38d9-262">These topics are:</span></span>

-   <span data-ttu-id="e38d9-263">Lauf Zeitoptimierung mit dem Befehls Puffer.</span><span class="sxs-lookup"><span data-stu-id="e38d9-263">Runtime optimization with the Command Buffer.</span></span> <span data-ttu-id="e38d9-264">Der Befehls Puffer ist eine Lauf Zeitoptimierung, die die Auswirkung eines Modus-Übergangs verringert.</span><span class="sxs-lookup"><span data-stu-id="e38d9-264">The command buffer is a runtime optimization that reduces the impact of a mode transition.</span></span> <span data-ttu-id="e38d9-265">Informationen zum Steuern der zeitliche Steuerung des Modus-Übergangs finden Sie unter [Steuern des Befehls Puffers](#controlling-the-command-buffer).</span><span class="sxs-lookup"><span data-stu-id="e38d9-265">To control the timing of the mode transition, see [Controlling the Command Buffer](#controlling-the-command-buffer).</span></span>
-   <span data-ttu-id="e38d9-266">Neinieren der zeitlichen Auswirkungen des Befehls Puffers.</span><span class="sxs-lookup"><span data-stu-id="e38d9-266">Negating the timing effects of the Command Buffer.</span></span> <span data-ttu-id="e38d9-267">Die verstrichene Zeit eines modusübergangs kann eine große Auswirkung auf die Profil Erstellungs Messungen haben.</span><span class="sxs-lookup"><span data-stu-id="e38d9-267">The elapsed time of a mode transition can have a big impact on profiling measurements.</span></span> <span data-ttu-id="e38d9-268">Die Strategie hierfür besteht darin, [die rendersequenz im Vergleich zum modusübergang groß zu gestalten](#make-the-render-sequence-large-compared-to-the-mode-transition).</span><span class="sxs-lookup"><span data-stu-id="e38d9-268">The strategy for this is to [Make the Render Sequence Large Compared to the Mode Transition](#make-the-render-sequence-large-compared-to-the-mode-transition).</span></span>

### <a name="controlling-the-command-buffer"></a><span data-ttu-id="e38d9-269">Steuern des Befehls Puffers</span><span class="sxs-lookup"><span data-stu-id="e38d9-269">Controlling the Command Buffer</span></span>

<span data-ttu-id="e38d9-270">Wenn eine Anwendung einen API-Befehl ausführt, konvertiert die Laufzeit den API-Aufrufe in ein Geräte unabhängiges Format (das einen Befehl aufruft) und speichert es im Befehls Puffer.</span><span class="sxs-lookup"><span data-stu-id="e38d9-270">When an application makes an API call, the runtime converts the API call to a device-independent format (which we will call a command), and stores it in the command buffer.</span></span> <span data-ttu-id="e38d9-271">Der Befehls Puffer wird dem folgenden Diagramm hinzugefügt.</span><span class="sxs-lookup"><span data-stu-id="e38d9-271">The command buffer is added to the following diagram.</span></span>

![Diagramm der CPU-Komponenten, einschließlich eines Befehls Puffers](images/microbenchmarkcommandbuffer2.png)

<span data-ttu-id="e38d9-273">Jedes Mal, wenn die Anwendung einen weiteren API-Aufruf durchführt, wiederholt die Laufzeit diese Sequenz und fügt dem Befehls Puffer einen weiteren Befehl hinzu.</span><span class="sxs-lookup"><span data-stu-id="e38d9-273">Each time the application makes another API call, the runtime repeats this sequence and adds another command to the command buffer.</span></span> <span data-ttu-id="e38d9-274">Zu einem bestimmten Zeitpunkt leert die Laufzeit den Puffer (sendet die Befehle an den Treiber).</span><span class="sxs-lookup"><span data-stu-id="e38d9-274">At some point, the runtime empties the buffer (sending the commands to the driver).</span></span> <span data-ttu-id="e38d9-275">In Windows XP führt das Leeren des Befehls Puffers zu einem modusübergang, weil das Betriebssystem von der Laufzeit (im Benutzermodus ausgeführt) zum Treiber wechselt (wird im Kernel Modus ausgeführt), wie im folgenden Diagramm dargestellt.</span><span class="sxs-lookup"><span data-stu-id="e38d9-275">In Windows XP, emptying the command buffer causes a mode transition as the operating system switches from the runtime (running in user mode) to the driver (running in kernel mode), as shown in the following diagram.</span></span>

-   <span data-ttu-id="e38d9-276">Benutzermodus: der nicht privilegierte Prozessor Modus, der Anwendungscode ausführt.</span><span class="sxs-lookup"><span data-stu-id="e38d9-276">user mode - The non-privileged processor mode that executes application code.</span></span> <span data-ttu-id="e38d9-277">Benutzermodusanwendungen können mit Ausnahme von System Diensten keinen Zugriff auf Systemdaten erlangen.</span><span class="sxs-lookup"><span data-stu-id="e38d9-277">User-mode applications cannot gain access to system data except through system services.</span></span>
-   <span data-ttu-id="e38d9-278">Kernel Modus: der privilegierte Prozessor Modus, in dem Windows-basierter Executive-Code ausgeführt wird.</span><span class="sxs-lookup"><span data-stu-id="e38d9-278">kernel mode - The privileged processor mode in which Windows-based executive code runs.</span></span> <span data-ttu-id="e38d9-279">Ein Treiber oder Thread, der im Kernel Modus ausgeführt wird, hat Zugriff auf den gesamten System Arbeitsspeicher, den direkten Zugriff auf die Hardware und die CPU-Anweisungen, um e/a-Vorgänge mit der Hardware auszuführen.</span><span class="sxs-lookup"><span data-stu-id="e38d9-279">A driver or thread running in kernel mode has access to all system memory, direct access to hardware, and the CPU instructions to perform I/O with the hardware.</span></span>

![Diagramm der Übergänge zwischen Benutzermodus und Kernel Modus](images/microbenchmarkcommandbuffer3.png)

<span data-ttu-id="e38d9-281">Der Übergang erfolgt immer dann, wenn die CPU vom Benutzer in den Kernel Modus wechselt (und umgekehrt) und die Anzahl der benötigten Zyklen im Vergleich zu einem einzelnen API-Aufruf groß ist.</span><span class="sxs-lookup"><span data-stu-id="e38d9-281">The transition happens each time the CPU switches from user to kernel mode (and vice versa) and the number of cycles it requires is large compared to an individual API call.</span></span> <span data-ttu-id="e38d9-282">Wenn die Laufzeit jeden API-Aufruf an den Treiber gesendet hat, als er aufgerufen wurde, würde jeder API-Aufruf die Kosten für einen modusübergang verursachen.</span><span class="sxs-lookup"><span data-stu-id="e38d9-282">If the runtime sent each API call to the driver when it was invoked, every API call would incur the cost of a mode transition.</span></span>

<span data-ttu-id="e38d9-283">Stattdessen ist der Befehls Puffer eine Lauf Zeitoptimierung, die so konzipiert ist, dass die effektiven Kosten des Modus-Übergangs gesenkt werden.</span><span class="sxs-lookup"><span data-stu-id="e38d9-283">Instead, the command buffer is a runtime optimization designed to reduce the effective cost of the mode transition.</span></span> <span data-ttu-id="e38d9-284">Der Befehls Puffer fügt viele Treiber Befehle in die Warteschlange ein, um einen Übergang im Einzelmodus vorzubereiten.</span><span class="sxs-lookup"><span data-stu-id="e38d9-284">The command buffer queues many driver commands in preparation for a single mode transition.</span></span> <span data-ttu-id="e38d9-285">Wenn die Laufzeit dem Befehls Puffer einen Befehl hinzufügt, wird die Steuerung an die Anwendung zurückgegeben.</span><span class="sxs-lookup"><span data-stu-id="e38d9-285">When the runtime adds a command to the command buffer, control is returned to the application.</span></span> <span data-ttu-id="e38d9-286">Ein Profiler kann nicht wissen, dass die Treiber Befehle wahrscheinlich noch nicht an den Treiber gesendet wurden.</span><span class="sxs-lookup"><span data-stu-id="e38d9-286">A profiler has no way of knowing that the driver commands have probably not even been sent to the driver yet.</span></span> <span data-ttu-id="e38d9-287">Demzufolge sind die von einem Off-The-Shelf instrumentierungsprofiler zurückgegebenen Zahlen irreführend, da Sie die Lauf Zeit Arbeit messen, aber nicht die zugeordnete Treiber Arbeit.</span><span class="sxs-lookup"><span data-stu-id="e38d9-287">As a result, the numbers returned by an off-the-shelf instrumenting profiler are misleading since it measures the runtime work but not the associated driver work.</span></span>

### <a name="profile-results-without-a-mode-transition"></a><span data-ttu-id="e38d9-288">Profil Ergebnisse ohne modusübergang</span><span class="sxs-lookup"><span data-stu-id="e38d9-288">Profile Results without a Mode Transition</span></span>

<span data-ttu-id="e38d9-289">Mithilfe der rendersequenz aus Beispiel 2 sind hier einige typische Zeit Steuerungs Messungen angegeben, die die Größe eines Modus-Übergangs veranschaulichen.</span><span class="sxs-lookup"><span data-stu-id="e38d9-289">Using the render sequence from example 2, here are some typical timing measurements that illustrate the magnitude of a mode transition.</span></span> <span data-ttu-id="e38d9-290">Wenn [**SetTexture**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-settexture) -und [**drawprimitive**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-drawprimitive) -Aufrufe keinen modusübergang verursachen, könnte ein Offsets-instrumentierungsprofiler ähnliche Ergebnisse wie die folgenden zurückgeben:</span><span class="sxs-lookup"><span data-stu-id="e38d9-290">Assuming that [**SetTexture**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-settexture) and [**DrawPrimitive**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-drawprimitive) calls do not cause a mode transition, an off-the-shelf instrumenting profiler could return results similar to these:</span></span>


```
Number of cycles for SetTexture           : 100
Number of cycles for DrawPrimitive        : 900
```



<span data-ttu-id="e38d9-291">Jede dieser Zahlen ist die Zeitspanne, die es dauert, bis die Common Language Runtime diese Aufrufe zum Befehls Puffer hinzufügt.</span><span class="sxs-lookup"><span data-stu-id="e38d9-291">Each of these numbers are the amount of time it takes for the runtime to add these calls to the command buffer.</span></span> <span data-ttu-id="e38d9-292">Da es keinen modusübergang gibt, hat der Treiber noch keine Arbeit erledigt.</span><span class="sxs-lookup"><span data-stu-id="e38d9-292">Since there is no mode transition, the driver has not done any work yet.</span></span> <span data-ttu-id="e38d9-293">Die Profiler-Ergebnisse sind genau, aber Sie messen nicht alle Aufgaben, die von der Rendering-Sequenz letztendlich ausgeführt werden.</span><span class="sxs-lookup"><span data-stu-id="e38d9-293">The profiler results are accurate, but they do not measure all of the work that the render sequence will eventually cause the CPU to perform.</span></span>

### <a name="profile-results-with-a-mode-transition"></a><span data-ttu-id="e38d9-294">Profil Ergebnisse mit einem modusübergang</span><span class="sxs-lookup"><span data-stu-id="e38d9-294">Profile Results with a Mode Transition</span></span>

<span data-ttu-id="e38d9-295">Sehen Sie sich nun an, was für das gleiche Beispiel geschieht, wenn ein modusübergang stattfindet.</span><span class="sxs-lookup"><span data-stu-id="e38d9-295">Now, look at what happens for the same example when a mode transition occurs.</span></span> <span data-ttu-id="e38d9-296">Nehmen Sie diesmal an, dass [**SetTexture**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-settexture) und [**drawprimitive**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-drawprimitive) einen Modus-Übergang verursachen.</span><span class="sxs-lookup"><span data-stu-id="e38d9-296">This time, assume [**SetTexture**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-settexture) and [**DrawPrimitive**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-drawprimitive) cause a mode transition.</span></span> <span data-ttu-id="e38d9-297">Ein Offsets-instrumentierungsprofiler könnte wiederum ähnliche Ergebnisse wie die folgenden zurückgeben:</span><span class="sxs-lookup"><span data-stu-id="e38d9-297">Once again, an off-the-shelf instrumenting profiler could return results similar to these:</span></span>


```
Number of cycles for SetTexture           : 98 
Number of cycles for DrawPrimitive        : 946,900
```



<span data-ttu-id="e38d9-298">Die Zeit, die für [**SetTexture**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-settexture) gemessen wird, ist ungefähr identisch, aber der drastische Anstieg der in [**drawprimitiv**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-drawprimitive) verbrachten Zeit ist auf den modusübergang zurückzuführen.</span><span class="sxs-lookup"><span data-stu-id="e38d9-298">The time measured for [**SetTexture**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-settexture) is about the same, however, the dramatic increase in the amount of time spent in [**DrawPrimitive**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-drawprimitive) is due to the mode transition.</span></span> <span data-ttu-id="e38d9-299">Folgendes geschieht:</span><span class="sxs-lookup"><span data-stu-id="e38d9-299">Here's what is happening:</span></span>

1.  <span data-ttu-id="e38d9-300">Nehmen Sie an, dass der Befehls Puffer Platz für einen Befehl hat, bevor die Rendering-Sequenz gestartet wird.</span><span class="sxs-lookup"><span data-stu-id="e38d9-300">Assume the command buffer has room for one command before our render sequence starts.</span></span>
2.  <span data-ttu-id="e38d9-301">[**SetTexture**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-settexture) wird in ein Geräte unabhängiges Format konvertiert und dem Befehls Puffer hinzugefügt.</span><span class="sxs-lookup"><span data-stu-id="e38d9-301">[**SetTexture**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-settexture) is converted to a device-independent format and added to the command buffer.</span></span> <span data-ttu-id="e38d9-302">In diesem Szenario füllt dieser Befehl den Befehls Puffer aus.</span><span class="sxs-lookup"><span data-stu-id="e38d9-302">In this scenario, this call fills the command buffer.</span></span>
3.  <span data-ttu-id="e38d9-303">Die Laufzeit versucht, [**drawprimitive**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-drawprimitive) dem Befehls Puffer hinzuzufügen, kann jedoch nicht, da Sie voll ist.</span><span class="sxs-lookup"><span data-stu-id="e38d9-303">The runtime tries to add [**DrawPrimitive**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-drawprimitive) to the command buffer but cannot, because it is full.</span></span> <span data-ttu-id="e38d9-304">Stattdessen leert die Laufzeit den Befehls Puffer.</span><span class="sxs-lookup"><span data-stu-id="e38d9-304">Instead, the runtime empties the command buffer.</span></span> <span data-ttu-id="e38d9-305">Dies bewirkt den Kernel Modus-Übergang.</span><span class="sxs-lookup"><span data-stu-id="e38d9-305">This causes the kernel-mode transition.</span></span> <span data-ttu-id="e38d9-306">Nehmen Sie an, dass der Übergang ungefähr 5000 Zyklen erfordert.</span><span class="sxs-lookup"><span data-stu-id="e38d9-306">Assume the transition takes about 5000 cycles.</span></span> <span data-ttu-id="e38d9-307">Diese Zeit trägt zum Zeitaufwand für **drawprimitiv** bei.</span><span class="sxs-lookup"><span data-stu-id="e38d9-307">This time contributes to time spent in **DrawPrimitive**.</span></span>
4.  <span data-ttu-id="e38d9-308">Der Treiber verarbeitet dann die Arbeit, die mit allen Befehlen verknüpft ist, die aus dem Befehls Puffer geleert wurden.</span><span class="sxs-lookup"><span data-stu-id="e38d9-308">The driver then processes the work associated with all the commands that were emptied from the command buffer.</span></span> <span data-ttu-id="e38d9-309">Angenommen, die Treiber Zeit zum Verarbeiten der Befehle, die den Befehls Puffer fast ausgefüllt haben, beträgt ungefähr 935.000 Zyklen.</span><span class="sxs-lookup"><span data-stu-id="e38d9-309">Assume that the driver time to process the commands that nearly filled the command buffer is about 935,000 cycles.</span></span> <span data-ttu-id="e38d9-310">Angenommen, die mit [**SetTexture**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-settexture) verknüpften Treiber arbeiten sind ungefähr 2750 Zyklen.</span><span class="sxs-lookup"><span data-stu-id="e38d9-310">Assume that the driver work associated with [**SetTexture**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-settexture) is about 2750 cycles.</span></span> <span data-ttu-id="e38d9-311">Diese Zeit trägt zum Zeitaufwand für [**drawprimitiv**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-drawprimitive)bei.</span><span class="sxs-lookup"><span data-stu-id="e38d9-311">This time contributes to time spent in [**DrawPrimitive**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-drawprimitive).</span></span>
5.  <span data-ttu-id="e38d9-312">Nachdem der Treiber seine Arbeit beendet hat, gibt der Benutzermodus-Übergang die Steuerung an die Laufzeit zurück.</span><span class="sxs-lookup"><span data-stu-id="e38d9-312">When the driver finishes its work, the user-mode transition returns control to the runtime.</span></span> <span data-ttu-id="e38d9-313">Der Befehls Puffer ist jetzt leer.</span><span class="sxs-lookup"><span data-stu-id="e38d9-313">The command buffer is now empty.</span></span> <span data-ttu-id="e38d9-314">Nehmen Sie an, dass der Übergang ungefähr 5000 Zyklen erfordert.</span><span class="sxs-lookup"><span data-stu-id="e38d9-314">Assume the transition takes about 5000 cycles.</span></span>
6.  <span data-ttu-id="e38d9-315">Die Rendering-Sequenz wird beendet, indem [**drawprimitiv**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-drawprimitive) umgerechnet und dem Befehls Puffer hinzugefügt wird.</span><span class="sxs-lookup"><span data-stu-id="e38d9-315">The render sequence finishes by converting [**DrawPrimitive**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-drawprimitive) and adding it to the command buffer.</span></span> <span data-ttu-id="e38d9-316">Angenommen, dies dauert ungefähr 900 Zyklen.</span><span class="sxs-lookup"><span data-stu-id="e38d9-316">Assume this takes about 900 cycles.</span></span> <span data-ttu-id="e38d9-317">Diese Zeit trägt zum Zeitaufwand für **drawprimitiv** bei.</span><span class="sxs-lookup"><span data-stu-id="e38d9-317">This time contributes to time spent in **DrawPrimitive**.</span></span>

<span data-ttu-id="e38d9-318">Wenn Sie die Ergebnisse zusammenfassen, sehen Sie Folgendes:</span><span class="sxs-lookup"><span data-stu-id="e38d9-318">Summarizing the results, you see:</span></span>


```
DrawPrimitive = kernel-transition + driver work    + user-transition + runtime work
DrawPrimitive = 5000              + 935,000 + 2750 + 5000            + 900
DrawPrimitive = 947,950  
```



<span data-ttu-id="e38d9-319">Genau wie bei der Messung für [**drawprimitive**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-drawprimitive) ohne den modusübergang (900 Zyklen) ist die Messung für **drawprimitive** mit dem modusübergang (947.950 Zyklen) präzise, aber nutzlos in Bezug auf die Arbeitsauslastung der CPU.</span><span class="sxs-lookup"><span data-stu-id="e38d9-319">Just like the measurement for [**DrawPrimitive**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-drawprimitive) without the mode transition (900 cycles), the measurement for **DrawPrimitive** with the mode transition (947,950 cycles) is accurate but useless in terms of budgeting CPU work.</span></span> <span data-ttu-id="e38d9-320">Das Ergebnis enthält die richtige Lauf Zeitfunktion, der Treiber funktioniert für [**SetTexture**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-settexture), der Treiber für alle Befehle, die mit " **SetTexture**" vorangestellt sind, und die zwei-Modus-Übergänge.</span><span class="sxs-lookup"><span data-stu-id="e38d9-320">The result contains the correct runtime work, the driver work for [**SetTexture**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-settexture), the driver work for any commands that preceded **SetTexture**, and two mode transitions.</span></span> <span data-ttu-id="e38d9-321">In der Messung fehlen jedoch die Arbeit des **drawprimitive** -Treibers.</span><span class="sxs-lookup"><span data-stu-id="e38d9-321">However, the measurement is missing the **DrawPrimitive** driver work.</span></span>

<span data-ttu-id="e38d9-322">Ein modusübergang kann als Reaktion auf einen beliebigen-Rückruf auftreten.</span><span class="sxs-lookup"><span data-stu-id="e38d9-322">A mode transition could happen in response to any call.</span></span> <span data-ttu-id="e38d9-323">Dies hängt davon ab, was zuvor im Befehls Puffer war.</span><span class="sxs-lookup"><span data-stu-id="e38d9-323">It depends on what was previously in the command buffer.</span></span> <span data-ttu-id="e38d9-324">Sie müssen den Modus-Übergang steuern, um zu verstehen, wie viel CPU-Arbeit (Laufzeit und Treiber) den einzelnen anrufen zugeordnet ist.</span><span class="sxs-lookup"><span data-stu-id="e38d9-324">You need to control the mode transition to understand how much CPU work (runtime and driver) is associated with each call.</span></span> <span data-ttu-id="e38d9-325">Zu diesem Zweck benötigen Sie einen Mechanismus zum Steuern des Befehls Puffers und die zeitliche Steuerung des Modus-Übergangs.</span><span class="sxs-lookup"><span data-stu-id="e38d9-325">To do that, you need a mechanism for controlling the command buffer and the timing of the mode transition.</span></span>

### <a name="the-query-mechanism"></a><span data-ttu-id="e38d9-326">Der Abfrage Mechanismus</span><span class="sxs-lookup"><span data-stu-id="e38d9-326">The Query Mechanism</span></span>

<span data-ttu-id="e38d9-327">Der Abfrage Mechanismus in Microsoft Direct3D 9 wurde so konzipiert, dass die Common Language Runtime die GPU zum Fortschritt Abfragen und bestimmte Daten von der GPU zurückgeben kann.</span><span class="sxs-lookup"><span data-stu-id="e38d9-327">The query mechanism in Microsoft Direct3D 9 was designed to allow the runtime to query the GPU for progress and return certain data from the GPU.</span></span> <span data-ttu-id="e38d9-328">Wenn bei der Profilerstellung die GPU-Arbeit minimiert wird, sodass Sie eine erhebliche Auswirkung auf die Leistung hat, können Sie den Status von der GPU zurückgeben, um die Treiber Arbeit zu messen.</span><span class="sxs-lookup"><span data-stu-id="e38d9-328">While profiling, if the GPU work is minimized so that it has a negligible impact on performance, you can return status from the GPU to help measure the driver work.</span></span> <span data-ttu-id="e38d9-329">Schließlich ist der Treiber Vorgang vollständig, wenn die GPU die Treiber Befehle gesehen hat.</span><span class="sxs-lookup"><span data-stu-id="e38d9-329">After all, the driver work is complete when the GPU has seen the driver commands.</span></span> <span data-ttu-id="e38d9-330">Außerdem kann der Abfrage Mechanismus mit der Steuerung von zwei Befehls Puffer Merkmalen verknüpft werden, die für die Profilerstellung wichtig sind: Wenn der Befehls Puffer leer ist und wie viel Arbeit im Puffer liegt.</span><span class="sxs-lookup"><span data-stu-id="e38d9-330">Additionally, the query mechanism can be coaxed into controlling two command buffer characteristics that are important to profiling: when the command buffer empties and how much work is in the buffer.</span></span>

<span data-ttu-id="e38d9-331">Hier ist die gleiche Rendering-Sequenz mit dem Abfrage Mechanismus:</span><span class="sxs-lookup"><span data-stu-id="e38d9-331">Here's the same render sequence using the query mechanism:</span></span>


```
// 1. Create an event query from the current device
IDirect3DQuery9* pEvent;
m_pD3DDevice->CreateQuery(D3DQUERYTYPE_EVENT, &pEvent);

// 2. Add an end marker to the command buffer queue.
pEvent->Issue(D3DISSUE_END);

// 3. Empty the command buffer and wait until the GPU is idle.
while(S_FALSE == pEvent->GetData( NULL, 0, D3DGETDATA_FLUSH ))
    ;

// 4. Start profiling
LARGE_INTEGER start, stop;
QueryPerformanceCounter(&start);

// 5. Invoke the API calls to be profiled.
SetTexture(...);
DrawPrimitive(D3DPT_TRIANGLELIST, 0, 1);

// 6. Add an end marker to the command buffer queue.
pEvent->Issue(D3DISSUE_END);

// 7. Force the driver to execute the commands from the command buffer.
// Empty the command buffer and wait until the GPU is idle.
while(S_FALSE == pEvent->GetData( NULL, 0, D3DGETDATA_FLUSH ))
    ;
    
// 8. End profiling
QueryPerformanceCounter(&stop);
```



<span data-ttu-id="e38d9-332">Beispiel 3: Verwenden einer Abfrage zum Steuern des Befehls Puffers</span><span class="sxs-lookup"><span data-stu-id="e38d9-332">Example 3: Using a Query to Control the Command Buffer</span></span>

<span data-ttu-id="e38d9-333">Im folgenden finden Sie eine ausführlichere Erläuterung der einzelnen Codezeilen:</span><span class="sxs-lookup"><span data-stu-id="e38d9-333">Here is a more detailed explanation of each of these lines of code:</span></span>

1.  <span data-ttu-id="e38d9-334">Erstellen Sie eine Ereignis Abfrage, indem Sie ein Abfrageobjekt mit D3DQUERYTYPE- \_ Ereignis erstellen.</span><span class="sxs-lookup"><span data-stu-id="e38d9-334">Create an event query by creating a query object with D3DQUERYTYPE\_EVENT.</span></span>
2.  <span data-ttu-id="e38d9-335">Fügen Sie dem Befehls Puffer einen Abfrage Ereignis Marker hinzu, indem Sie [**Issue**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3dquery9-issue)([**D3DISSUE \_ End**](d3dissue-end.md)) aufrufen.</span><span class="sxs-lookup"><span data-stu-id="e38d9-335">Add a query event marker to the command buffer by calling [**Issue**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3dquery9-issue)([**D3DISSUE\_END**](d3dissue-end.md)).</span></span> <span data-ttu-id="e38d9-336">Dieser Marker weist den Treiber an, zu verfolgen, wann die GPU die Ausführung von Befehlen beendet, die dem Marker vorangestellt sind</span><span class="sxs-lookup"><span data-stu-id="e38d9-336">This marker tells the driver to track when the GPU finishes executing whatever commands preceded the marker.</span></span>
3.  <span data-ttu-id="e38d9-337">Der erste Aufruf leert den Befehls Puffer, da der Aufruf von [**GetData**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3dquery9-getdata) mit [**D3DGETDATA \_ Flush**](d3dgetdata-flush.md) das Leeren des Befehls Puffers erzwingt.</span><span class="sxs-lookup"><span data-stu-id="e38d9-337">The first call empties the command buffer because calling [**GetData**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3dquery9-getdata) with [**D3DGETDATA\_FLUSH**](d3dgetdata-flush.md) forces the command buffer to be emptied.</span></span> <span data-ttu-id="e38d9-338">Jeder nachfolgende-Rückruf überprüft die GPU, um zu sehen, wann die Verarbeitung der gesamten Befehls Puffer Arbeit abgeschlossen ist.</span><span class="sxs-lookup"><span data-stu-id="e38d9-338">Each subsequent call is checking the GPU to see when it finishes processing all the command-buffer work.</span></span> <span data-ttu-id="e38d9-339">Diese Schleife gibt S \_ OK erst zurück, wenn sich die GPU im Leerlauf befindet.</span><span class="sxs-lookup"><span data-stu-id="e38d9-339">This loop does not return S\_OK until the GPU is idle.</span></span>
4.  <span data-ttu-id="e38d9-340">Beispiel für die Startzeit.</span><span class="sxs-lookup"><span data-stu-id="e38d9-340">Sample the start time.</span></span>
5.  <span data-ttu-id="e38d9-341">Aufrufen der API-Aufrufe, für die ein Profil erstellt wird</span><span class="sxs-lookup"><span data-stu-id="e38d9-341">Invoke the API calls being profiled.</span></span>
6.  <span data-ttu-id="e38d9-342">Fügen Sie dem Befehls Puffer einen zweiten Abfrage Ereignis Marker hinzu.</span><span class="sxs-lookup"><span data-stu-id="e38d9-342">Add a second query event marker to the command buffer.</span></span> <span data-ttu-id="e38d9-343">Dieser Marker wird verwendet, um den Abschluss der Aufrufe zu verfolgen.</span><span class="sxs-lookup"><span data-stu-id="e38d9-343">This marker will be used to track the completion of the calls.</span></span>
7.  <span data-ttu-id="e38d9-344">Der erste Aufruf leert den Befehls Puffer, da der Aufruf von [**GetData**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3dquery9-getdata) mit [**D3DGETDATA \_ Flush**](d3dgetdata-flush.md) das Leeren des Befehls Puffers erzwingt.</span><span class="sxs-lookup"><span data-stu-id="e38d9-344">The first call empties the command buffer because calling [**GetData**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3dquery9-getdata) with [**D3DGETDATA\_FLUSH**](d3dgetdata-flush.md) forces the command buffer to be emptied.</span></span> <span data-ttu-id="e38d9-345">Wenn die GPU die Verarbeitung der Befehls Puffer Arbeit abgeschlossen hat, gibt **GetData** S \_ OK zurück, und die Schleife wird beendet, da sich die GPU im Leerlauf befindet.</span><span class="sxs-lookup"><span data-stu-id="e38d9-345">When the GPU finishes processing all the command-buffer work, **GetData** returns S\_OK, and the loop is exited because the GPU is idle.</span></span>
8.  <span data-ttu-id="e38d9-346">Beispiel für die Endzeit.</span><span class="sxs-lookup"><span data-stu-id="e38d9-346">Sample the stop time.</span></span>

<span data-ttu-id="e38d9-347">Dies sind die Ergebnisse, die mit QueryPerformanceCounter und QueryPerformanceFrequency gemessen werden:</span><span class="sxs-lookup"><span data-stu-id="e38d9-347">Here are the results measured with QueryPerformanceCounter and QueryPerformanceFrequency:</span></span>



| <span data-ttu-id="e38d9-348">Lokale Variable</span><span class="sxs-lookup"><span data-stu-id="e38d9-348">Local Variable</span></span> | <span data-ttu-id="e38d9-349">Anzahl der Ticks</span><span class="sxs-lookup"><span data-stu-id="e38d9-349">Number of Ticks</span></span> |
|----------------|-----------------|
| <span data-ttu-id="e38d9-350">start</span><span class="sxs-lookup"><span data-stu-id="e38d9-350">start</span></span>          | <span data-ttu-id="e38d9-351">1792998845060</span><span class="sxs-lookup"><span data-stu-id="e38d9-351">1792998845060</span></span>   |
| <span data-ttu-id="e38d9-352">stop</span><span class="sxs-lookup"><span data-stu-id="e38d9-352">stop</span></span>           | <span data-ttu-id="e38d9-353">1792998845090</span><span class="sxs-lookup"><span data-stu-id="e38d9-353">1792998845090</span></span>   |
| <span data-ttu-id="e38d9-354">Freq</span><span class="sxs-lookup"><span data-stu-id="e38d9-354">freq</span></span>           | <span data-ttu-id="e38d9-355">3579545</span><span class="sxs-lookup"><span data-stu-id="e38d9-355">3579545</span></span>         |



 

<span data-ttu-id="e38d9-356">Erneutes Umrechnen von Ticks in Zyklen (auf einem Computer mit 2 GHz):</span><span class="sxs-lookup"><span data-stu-id="e38d9-356">Converting ticks to cycles once again (on a 2 GHz machine):</span></span>


```
# ticks  = (stop - start) = 1792998845090 - 1792998845060 = 30 ticks
# cycles = CPU speed * number of ticks / QPF
# 16,450 = 2 GHz      * 30             / 3,579,545
```



<span data-ttu-id="e38d9-357">Hier ist die Aufschlüsselung der Anzahl von Zyklen pro-Rückruf:</span><span class="sxs-lookup"><span data-stu-id="e38d9-357">Here is the breakdown of the number of cycles per call:</span></span>


```
Number of cycles for SetTexture           : 100
Number of cycles for DrawPrimitive        : 900
Number of cycles for Issue                : 200
Number of cycles for GetData              : 16,450
```



<span data-ttu-id="e38d9-358">Mit dem Abfrage Mechanismus haben wir die Steuerung der Laufzeit und der zu messenden Treiber Arbeit ermöglicht.</span><span class="sxs-lookup"><span data-stu-id="e38d9-358">The query mechanism has allowed us to control the runtime and the driver work that is being measured.</span></span> <span data-ttu-id="e38d9-359">Um diese Zahlen zu verstehen, geschieht Folgendes als Reaktion auf die einzelnen API-Aufrufe, und zwar zusammen mit den geschätzten Zeitangaben:</span><span class="sxs-lookup"><span data-stu-id="e38d9-359">To understand each of these numbers, here's what is happening in response to each of the API calls, along with the estimated timings:</span></span>

1.  <span data-ttu-id="e38d9-360">Der erste Aufruf leert den Befehls Puffer, indem [**GetData**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3dquery9-getdata) mit [**D3DGETDATA \_ Flush**](d3dgetdata-flush.md)aufgerufen wird.</span><span class="sxs-lookup"><span data-stu-id="e38d9-360">The first call empties the command buffer by calling [**GetData**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3dquery9-getdata) with [**D3DGETDATA\_FLUSH**](d3dgetdata-flush.md).</span></span> <span data-ttu-id="e38d9-361">Wenn die GPU die Verarbeitung der Befehls Puffer Arbeit abgeschlossen hat, gibt **GetData** S \_ OK zurück, und die Schleife wird beendet, da sich die GPU im Leerlauf befindet.</span><span class="sxs-lookup"><span data-stu-id="e38d9-361">When the GPU finishes processing all the command-buffer work, **GetData** returns S\_OK, and the loop is exited because the GPU is idle.</span></span>
2.  <span data-ttu-id="e38d9-362">Die rendersequenz beginnt mit dem Umrechnen von [**SetTexture**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-settexture) in ein Geräte unabhängiges Format und dem Hinzufügen des Befehls Puffers.</span><span class="sxs-lookup"><span data-stu-id="e38d9-362">The render sequence starts by converting [**SetTexture**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-settexture) to a device-independent format and adding it to the command buffer.</span></span> <span data-ttu-id="e38d9-363">Angenommen, dies dauert ungefähr 100 Zyklen.</span><span class="sxs-lookup"><span data-stu-id="e38d9-363">Assume this takes about 100 cycles.</span></span>
3.  <span data-ttu-id="e38d9-364">[**Drawprimitiv**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-drawprimitive) wird konvertiert und dem Befehls Puffer hinzugefügt.</span><span class="sxs-lookup"><span data-stu-id="e38d9-364">[**DrawPrimitive**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-drawprimitive) is converted and added to the command buffer.</span></span> <span data-ttu-id="e38d9-365">Angenommen, dies dauert ungefähr 900 Zyklen.</span><span class="sxs-lookup"><span data-stu-id="e38d9-365">Assume this takes about 900 cycles.</span></span>
4.  <span data-ttu-id="e38d9-366">[**Problem**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3dquery9-issue) fügt dem Befehls Puffer einen Abfrage Marker hinzu.</span><span class="sxs-lookup"><span data-stu-id="e38d9-366">[**Issue**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3dquery9-issue) adds a query marker to the command buffer.</span></span> <span data-ttu-id="e38d9-367">Angenommen, dies dauert ungefähr 200 Zyklen.</span><span class="sxs-lookup"><span data-stu-id="e38d9-367">Assume this takes about 200 cycles.</span></span>
5.  <span data-ttu-id="e38d9-368">[**GetData**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3dquery9-getdata) bewirkt, dass der Befehls Puffer geleert wird, der den Kernel Modus-Übergang erzwingt.</span><span class="sxs-lookup"><span data-stu-id="e38d9-368">[**GetData**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3dquery9-getdata) causes the command buffer to be emptied which forces the kernel-mode transition.</span></span> <span data-ttu-id="e38d9-369">Angenommen, dies dauert ungefähr 5000 Zyklen.</span><span class="sxs-lookup"><span data-stu-id="e38d9-369">Assume this takes about 5000 cycles.</span></span>
6.  <span data-ttu-id="e38d9-370">Der Treiber verarbeitet dann die Arbeit, die mit allen vier aufrufen verknüpft ist.</span><span class="sxs-lookup"><span data-stu-id="e38d9-370">The driver then processes the work associated with all four calls.</span></span> <span data-ttu-id="e38d9-371">Angenommen, die Treiber Zeit zum Verarbeiten von [**SetTexture**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-settexture) beträgt ungefähr 2964 Zyklen, [**drawprimitiv**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-drawprimitive) beträgt ungefähr 3600 Zyklen, das [**Problem**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3dquery9-issue) beträgt ungefähr 200 Zyklen.</span><span class="sxs-lookup"><span data-stu-id="e38d9-371">Assume that the driver time to process [**SetTexture**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-settexture) is about 2964 cycles, [**DrawPrimitive**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-drawprimitive) is about 3600 cycles, [**Issue**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3dquery9-issue) is about 200 cycles.</span></span> <span data-ttu-id="e38d9-372">Die gesamte Treiber Zeit für alle vier Befehle beträgt ungefähr 6450 Zyklen.</span><span class="sxs-lookup"><span data-stu-id="e38d9-372">So the total driver time for all four commands is about 6450 cycles.</span></span>
    > [!Note]  
    > <span data-ttu-id="e38d9-373">Der Treiber benötigt auch etwas Zeit, um den Status der GPU anzuzeigen.</span><span class="sxs-lookup"><span data-stu-id="e38d9-373">The driver also takes a little time to see what the status of the GPU is.</span></span> <span data-ttu-id="e38d9-374">Da die GPU-Arbeit trivial ist, sollte die GPU bereits ausgeführt werden.</span><span class="sxs-lookup"><span data-stu-id="e38d9-374">Because the GPU work is trivial, the GPU should be done already.</span></span> <span data-ttu-id="e38d9-375">" [**GetData**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3dquery9-getdata) " gibt "S OK" zurück \_ , basierend auf der Wahrscheinlichkeit, dass die GPU abgeschlossen ist.</span><span class="sxs-lookup"><span data-stu-id="e38d9-375">[**GetData**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3dquery9-getdata) will return S\_OK based on the likelihood that the GPU is finished.</span></span>

     

7.  <span data-ttu-id="e38d9-376">Nachdem der Treiber seine Arbeit beendet hat, gibt der Benutzermodus-Übergang die Steuerung an die Laufzeit zurück.</span><span class="sxs-lookup"><span data-stu-id="e38d9-376">When the driver finishes its work, the user-mode transition returns control to the runtime.</span></span> <span data-ttu-id="e38d9-377">Der Befehls Puffer ist jetzt leer.</span><span class="sxs-lookup"><span data-stu-id="e38d9-377">The command buffer is now empty.</span></span> <span data-ttu-id="e38d9-378">Angenommen, dies dauert ungefähr 5000 Zyklen.</span><span class="sxs-lookup"><span data-stu-id="e38d9-378">Assume this takes about 5000 cycles.</span></span>

<span data-ttu-id="e38d9-379">Die Zahlen für [**GetData**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3dquery9-getdata) umfassen Folgendes:</span><span class="sxs-lookup"><span data-stu-id="e38d9-379">The numbers for [**GetData**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3dquery9-getdata) include:</span></span>


```
GetData = kernel-transition + driver work + user-transition
GetData = 5000              + 6450        + 5000           
GetData = 16,450  

driver work = SetTexture + DrawPrimitive + Issue = 
driver work = 2964       + 3600          + 200   = 6450 cycles 
```



<span data-ttu-id="e38d9-380">Der Abfrage Mechanismus, der in Kombination mit QueryPerformanceCounter verwendet wird, misst die gesamte CPU-Arbeit.</span><span class="sxs-lookup"><span data-stu-id="e38d9-380">The query mechanism used in combination with QueryPerformanceCounter measures all of the CPU work.</span></span> <span data-ttu-id="e38d9-381">Dies erfolgt mit einer Kombination aus Abfrage Markierungen und Abfrage Status vergleichen.</span><span class="sxs-lookup"><span data-stu-id="e38d9-381">This is done with a combination of query markers, and query status comparisons.</span></span> <span data-ttu-id="e38d9-382">Die dem Befehls Puffer hinzugefügten Abfrage Marker zum Starten und Abbrechen werden verwendet, um zu steuern, wie viel Arbeit im Puffer liegt.</span><span class="sxs-lookup"><span data-stu-id="e38d9-382">Start and stop query markers added to the command buffer are used to control how much work is in the buffer.</span></span> <span data-ttu-id="e38d9-383">Wenn Sie warten, bis der richtige Rückgabecode zurückgegeben wird, wird die Start Messung unmittelbar vor dem Start einer sauberen Rendering-Sequenz durchgeführt, und die Beendigung der Messung erfolgt direkt, nachdem der Treiber die mit dem Inhalt des Befehls Puffers verknüpfte Arbeit abgeschlossen hat.</span><span class="sxs-lookup"><span data-stu-id="e38d9-383">By waiting until the right return code is returned, the start measurement is made just before a clean render sequence starts, and the stop measurement is made just after the driver has finished the work associated with the command buffer contents.</span></span> <span data-ttu-id="e38d9-384">Dadurch werden sowohl die CPU-Arbeit, die von der Laufzeit als auch der Treiber ausgeführt wird, erfasst.</span><span class="sxs-lookup"><span data-stu-id="e38d9-384">This effectively captures the CPU work done by the runtime as well as the driver.</span></span>

<span data-ttu-id="e38d9-385">Nachdem Sie nun über den Befehls Puffer und die Auswirkungen auf die Profilerstellung informiert sind, sollten Sie wissen, dass es einige andere Bedingungen gibt, die bewirken können, dass die Laufzeit den Befehls Puffer leert.</span><span class="sxs-lookup"><span data-stu-id="e38d9-385">Now that you know about the command buffer and the effect it can have on profiling, you should know that there are a few other conditions that can cause the runtime to empty the command buffer.</span></span> <span data-ttu-id="e38d9-386">Sie müssen in ihren Rendering-Sequenzen darauf achten.</span><span class="sxs-lookup"><span data-stu-id="e38d9-386">You need to watch out for these in your render sequences.</span></span> <span data-ttu-id="e38d9-387">Einige dieser Bedingungen gelten als Reaktion auf API-Aufrufe, andere als Reaktion auf Ressourcen Änderungen in der Laufzeit.</span><span class="sxs-lookup"><span data-stu-id="e38d9-387">Some of these conditions are in response to API calls, others are in response to resource changes in the runtime.</span></span> <span data-ttu-id="e38d9-388">Eine der folgenden Bedingungen führt zu einem modusübergang:</span><span class="sxs-lookup"><span data-stu-id="e38d9-388">Any of the following conditions will cause a mode transition:</span></span>

-   <span data-ttu-id="e38d9-389">Wenn eine der Sperr Methoden ([**Lock**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3dvertexbuffer9-lock)) für einen Vertex-Puffer, einen Index Puffer oder eine Textur (unter bestimmten Bedingungen mit bestimmten Flags) aufgerufen wird.</span><span class="sxs-lookup"><span data-stu-id="e38d9-389">When one of the lock methods ([**Lock**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3dvertexbuffer9-lock)) is called on a vertex buffer, index buffer, or texture (under certain conditions with certain flags).</span></span>
-   <span data-ttu-id="e38d9-390">Wenn ein Gerät oder Vertex-Puffer, Index Puffer oder eine Textur erstellt wird.</span><span class="sxs-lookup"><span data-stu-id="e38d9-390">When a device or vertex buffer, index buffer, or texture is created.</span></span>
-   <span data-ttu-id="e38d9-391">Wenn ein Gerät oder Vertex-Puffer, Index Puffer oder eine Textur durch die letzte Freigabe zerstört wird.</span><span class="sxs-lookup"><span data-stu-id="e38d9-391">When a device or vertex buffer, index buffer, or texture is destroyed by the last release.</span></span>
-   <span data-ttu-id="e38d9-392">Wenn " [**ValidateDevice**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-validatedevice) " aufgerufen wird.</span><span class="sxs-lookup"><span data-stu-id="e38d9-392">When [**ValidateDevice**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-validatedevice) is called.</span></span>
-   <span data-ttu-id="e38d9-393">Wenn [**Present**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-present) aufgerufen wird.</span><span class="sxs-lookup"><span data-stu-id="e38d9-393">When [**Present**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-present) is called.</span></span>
-   <span data-ttu-id="e38d9-394">Wenn sich der Befehls Puffer füllt.</span><span class="sxs-lookup"><span data-stu-id="e38d9-394">When the command buffer fills up.</span></span>
-   <span data-ttu-id="e38d9-395">Wenn [**GetData**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3dquery9-getdata) mit D3DGETDATA Flush aufgerufen wird \_ .</span><span class="sxs-lookup"><span data-stu-id="e38d9-395">When [**GetData**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3dquery9-getdata) is called with D3DGETDATA\_FLUSH.</span></span>

<span data-ttu-id="e38d9-396">Achten Sie darauf, diese Bedingungen in ihren Rendering-Sequenzen zu überwachen.</span><span class="sxs-lookup"><span data-stu-id="e38d9-396">Be careful to watch for these conditions in your render sequences.</span></span> <span data-ttu-id="e38d9-397">Jedes Mal, wenn ein modusübergang hinzugefügt wird, werden den Profil Erstellungs Messungen 10.000 Zyklen der Treiber Arbeit hinzugefügt.</span><span class="sxs-lookup"><span data-stu-id="e38d9-397">Every time a mode transition is added, 10,000 cycles of driver work will be added to your profiling measurements.</span></span> <span data-ttu-id="e38d9-398">Außerdem ist der Befehls Puffer nicht statisch formatiert.</span><span class="sxs-lookup"><span data-stu-id="e38d9-398">In addition, the command buffer is not statically sized.</span></span> <span data-ttu-id="e38d9-399">Die Laufzeit kann die Größe des Puffers in Reaktion auf die Menge der Arbeit ändern, die von der Anwendung generiert wird.</span><span class="sxs-lookup"><span data-stu-id="e38d9-399">The runtime may change the buffer's size in response to the amount of work that is being generated by the application.</span></span> <span data-ttu-id="e38d9-400">Dies ist noch eine andere Optimierung, die von einer rendersequenz abhängt.</span><span class="sxs-lookup"><span data-stu-id="e38d9-400">This is yet another optimization that is dependent on a render sequence.</span></span>

<span data-ttu-id="e38d9-401">Achten Sie daher darauf, während der Profilerstellung die Übergänge im Modus zu steuern</span><span class="sxs-lookup"><span data-stu-id="e38d9-401">So be careful to control mode transitions during profiling.</span></span> <span data-ttu-id="e38d9-402">Der-Abfrage Mechanismus bietet eine robuste Methode zum Leeren des Befehls Puffers, sodass Sie die zeitliche Steuerung des modusübergangs und die Menge der im Puffer enthaltenen Arbeit steuern können.</span><span class="sxs-lookup"><span data-stu-id="e38d9-402">The query mechanism offers a robust method for emptying the command buffer so that you can control the timing of the mode transition as well as the amount of work the buffer contains.</span></span> <span data-ttu-id="e38d9-403">Diese Vorgehensweise kann jedoch auch durch eine Reduzierung der Übergangszeit des Modus verbessert werden, damit Sie in Bezug auf das gemessene Ergebnis nicht signifikant ist.</span><span class="sxs-lookup"><span data-stu-id="e38d9-403">However, even this technique can be improved by reducing the mode transition time to make it insignificant with respect to the measured result.</span></span>

### <a name="make-the-render-sequence-large-compared-to-the-mode-transition"></a><span data-ttu-id="e38d9-404">Renderingsequenz im Vergleich zum modusübergang als groß festlegen</span><span class="sxs-lookup"><span data-stu-id="e38d9-404">Make the Render Sequence Large Compared to the Mode Transition</span></span>

<span data-ttu-id="e38d9-405">Im vorherigen Beispiel verbrauchen der kernelmodusschalter und der benutzermodusschalter ungefähr 10.000 Zyklen, die keine Lauf Zeit-und Treiber Arbeit haben.</span><span class="sxs-lookup"><span data-stu-id="e38d9-405">In the previous example, the kernel-mode switch and the user-mode switch consume about 10,000 cycles that have nothing to do with runtime and driver work.</span></span> <span data-ttu-id="e38d9-406">Da der modusübergang in das Betriebssystem integriert ist, kann er nicht auf 0 (null) reduziert werden.</span><span class="sxs-lookup"><span data-stu-id="e38d9-406">Since the mode transition is built into the operating system, it cannot be reduced to zero.</span></span> <span data-ttu-id="e38d9-407">Damit der Modus nicht mehr unbedeutend ist, muss die rendersequenz so angepasst werden, dass die Treiber-und Lauf Zeit Aufgaben eine Größenordnung haben, die größer als die Modusschalter ist.</span><span class="sxs-lookup"><span data-stu-id="e38d9-407">To make the mode transition insignificant, the render sequence needs to adjusted so that the driver and runtime work are an order of magnitude larger than the mode switches.</span></span> <span data-ttu-id="e38d9-408">Sie könnten versuchen, eine Subtraktion durchzuführen, um die Übergänge zu entfernen, aber die Amortisierungen der Kosten für eine weitaus größere Anzahl von Rendering-Sequenz Kosten ist zuverlässiger.</span><span class="sxs-lookup"><span data-stu-id="e38d9-408">You could try to do a subtraction to remove the transitions, but amortizing the cost over a much larger render sequence cost is more reliable.</span></span>

<span data-ttu-id="e38d9-409">Die Strategie zur Reduzierung des modusübergangs, bis Sie unbedeutend wird, besteht darin, der rendersequenz eine Schleife hinzuzufügen.</span><span class="sxs-lookup"><span data-stu-id="e38d9-409">The strategy for reducing the mode transition until it becomes insignificant is to add a loop to the render sequence.</span></span> <span data-ttu-id="e38d9-410">Betrachten Sie z. b. die Profil Erstellungs Ergebnisse, wenn eine Schleife hinzugefügt wird, die die rendersequenz 1500-mal wiederholt:</span><span class="sxs-lookup"><span data-stu-id="e38d9-410">For example, let look at the profiling results if a loop is added that will repeat the render sequence 1500 times:</span></span>


```
// Initialize the array with two textures, same size, same format
IDirect3DTexture* texArray[2];

CreateQuery(D3DQUERYTYPE_EVENT, pEvent);
pEvent->Issue(D3DISSUE_END);
while(S_FALSE == pEvent->GetData( NULL, 0, D3DGETDATA_FLUSH ))
    ;

LARGE_INTEGER start, stop;
// Now start counting because the video card is ready
QueryPerformanceCounter(&start);

// Add a loop to the render sequence 
for(int i = 0; i < 1500; i++)
{
  SetTexture(taxArray[i%2]);
  DrawPrimitive(D3DPT_TRIANGLELIST, i*3, 1);
}

pEvent->Issue(D3DISSUE_END);

while(S_FALSE == pEvent->GetData( NULL, 0, D3DGETDATA_FLUSH ))
    ;
QueryPerformanceCounter(&stop);
```



<span data-ttu-id="e38d9-411">Beispiel 4: Hinzufügen einer Schleife zur rendersequenz</span><span class="sxs-lookup"><span data-stu-id="e38d9-411">Example 4: Add a Loop to the Render Sequence</span></span>

<span data-ttu-id="e38d9-412">Dies sind die Ergebnisse, die mit QueryPerformanceCounter und QueryPerformanceFrequency gemessen werden:</span><span class="sxs-lookup"><span data-stu-id="e38d9-412">Here are the results measured with QueryPerformanceCounter and QueryPerformanceFrequency:</span></span>



| <span data-ttu-id="e38d9-413">Lokale Variable</span><span class="sxs-lookup"><span data-stu-id="e38d9-413">Local Variable</span></span> | <span data-ttu-id="e38d9-414">Anzahl von Tics</span><span class="sxs-lookup"><span data-stu-id="e38d9-414">Number of Tics</span></span> |
|----------------|----------------|
| <span data-ttu-id="e38d9-415">start</span><span class="sxs-lookup"><span data-stu-id="e38d9-415">start</span></span>          | <span data-ttu-id="e38d9-416">1792998845000</span><span class="sxs-lookup"><span data-stu-id="e38d9-416">1792998845000</span></span>  |
| <span data-ttu-id="e38d9-417">stop</span><span class="sxs-lookup"><span data-stu-id="e38d9-417">stop</span></span>           | <span data-ttu-id="e38d9-418">1792998847084</span><span class="sxs-lookup"><span data-stu-id="e38d9-418">1792998847084</span></span>  |
| <span data-ttu-id="e38d9-419">Freq</span><span class="sxs-lookup"><span data-stu-id="e38d9-419">freq</span></span>           | <span data-ttu-id="e38d9-420">3579545</span><span class="sxs-lookup"><span data-stu-id="e38d9-420">3579545</span></span>        |



 

<span data-ttu-id="e38d9-421">Die Verwendung von QueryPerformanceCounter misst 2.840 Ticks jetzt.</span><span class="sxs-lookup"><span data-stu-id="e38d9-421">Using QueryPerformanceCounter measures 2,840 ticks now.</span></span> <span data-ttu-id="e38d9-422">Das Umrechnen von Ticks in Zyklen ist das gleiche wie bereits gezeigt:</span><span class="sxs-lookup"><span data-stu-id="e38d9-422">Converting ticks to cycles is the same as we have already shown:</span></span>


```
# ticks  = (stop - start) = 1792998847084 - 1792998845000 = 2840 ticks
# cycles    = machine speed * number of ticks / QPF
# 6,900,000 = 2 GHz          * 2840           / 3,579,545
```



<span data-ttu-id="e38d9-423">Das heißt, es werden ungefähr 6,9 Millionen Zyklen auf diesem 2-GHz-Computer benötigt, um die 1500-Aufrufe in der Renderschleife zu verarbeiten.</span><span class="sxs-lookup"><span data-stu-id="e38d9-423">In other words, it takes about 6.9 million cycles on this 2 GHz machine to process the 1500 calls in the render loop.</span></span> <span data-ttu-id="e38d9-424">Von den 6,9 Millionen Zyklen ist die Zeitspanne im Modus von ungefähr 10K. die Profil Ergebnisse sind also fast vollständig mit der Verarbeitung von Arbeit, die mit [**SetTexture**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-settexture) und [**drawprimitiv**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-drawprimitive)verknüpft ist.</span><span class="sxs-lookup"><span data-stu-id="e38d9-424">Of the 6.9 million cycles, the amount of time in the mode transitions is approximately 10k, so now the profile results are almost entirely measuring work associated with [**SetTexture**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-settexture) and [**DrawPrimitive**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-drawprimitive).</span></span>

<span data-ttu-id="e38d9-425">Beachten Sie, dass das Codebeispiel ein Array mit zwei Texturen erfordert.</span><span class="sxs-lookup"><span data-stu-id="e38d9-425">Notice that the code sample requires an array of two textures.</span></span> <span data-ttu-id="e38d9-426">Um eine Lauf Zeitoptimierung zu vermeiden, die [**SetTexture**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-settexture) entfernt, wenn Sie bei jedem Aufruf denselben Textur Zeiger festlegt, verwenden Sie einfach ein Array aus zwei Texturen.</span><span class="sxs-lookup"><span data-stu-id="e38d9-426">To avoid a runtime optimization that would remove [**SetTexture**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-settexture) if it sets the same texture pointer every time it is called, simply use an array of two textures.</span></span> <span data-ttu-id="e38d9-427">Auf diese Weise wird bei jedem Durchlaufen der Schleife der Textur Zeiger geändert, und die vollständige Arbeit, die mit **SetTexture** verknüpft ist, wird ausgeführt.</span><span class="sxs-lookup"><span data-stu-id="e38d9-427">That way, each time through the loop, the texture pointer changes, and the full work associated with **SetTexture** is performed.</span></span> <span data-ttu-id="e38d9-428">Stellen Sie sicher, dass beide Texturen dieselbe Größe und dasselbe Format aufweisen, sodass sich bei der Textur kein anderer Zustand ändert.</span><span class="sxs-lookup"><span data-stu-id="e38d9-428">Be sure that both textures are the same size and format, so that no other state will change when the texture does.</span></span>

<span data-ttu-id="e38d9-429">Und jetzt verfügen Sie über eine Technik für die Profilerstellung Direct3D.</span><span class="sxs-lookup"><span data-stu-id="e38d9-429">And now you have a technique for profiling Direct3D.</span></span> <span data-ttu-id="e38d9-430">Es basiert auf dem High Performance Counter (QueryPerformanceCounter), um die Anzahl der Ticks aufzuzeichnen, die die CPU zur Verarbeitung der Arbeit benötigt.</span><span class="sxs-lookup"><span data-stu-id="e38d9-430">It relies on the high performance counter (QueryPerformanceCounter) to record the number of ticks it takes the CPU to process work.</span></span> <span data-ttu-id="e38d9-431">Die Arbeit wird sorgfältig gesteuert, um die Laufzeit-und Treiber Arbeit zu verwenden, die API-aufrufen mithilfe des Abfrage Mechanismus zugeordnet ist.</span><span class="sxs-lookup"><span data-stu-id="e38d9-431">The work is carefully controlled to be the runtime and driver work associated with API calls using the query mechanism.</span></span> <span data-ttu-id="e38d9-432">Eine Abfrage stellt zwei Steuerungsmöglichkeiten bereit: zuerst, um den Befehls Puffer zu leeren, bevor die Rendering-Sequenz gestartet wird, und zweitens, wenn die GPU-Arbeit abgeschlossen ist.</span><span class="sxs-lookup"><span data-stu-id="e38d9-432">A query provides two means of control: first to empty the command buffer before the render sequence starts, and secondly to return when the GPU work is finished.</span></span>

<span data-ttu-id="e38d9-433">Bisher wurde in diesem Artikel gezeigt, wie Sie ein Profil für eine Rendering-Sequenz erstellen.</span><span class="sxs-lookup"><span data-stu-id="e38d9-433">So far, this paper has shown how to profile a render sequence.</span></span> <span data-ttu-id="e38d9-434">Jede Rendering-Sequenz ist recht einfach, enthält einen einzelnen [**drawprimitiv**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-drawprimitive) -und einen [**SetTexture**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-settexture) -Aufruf.</span><span class="sxs-lookup"><span data-stu-id="e38d9-434">Each render sequence has been fairly simple, containing a single [**DrawPrimitive**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-drawprimitive) call and a [**SetTexture**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-settexture) call.</span></span> <span data-ttu-id="e38d9-435">Dies wurde erreicht, um den Fokus auf den Befehls Puffer und die Verwendung des Abfrage Mechanismus zu steuern.</span><span class="sxs-lookup"><span data-stu-id="e38d9-435">This was done to focus on the command buffer and the use of the query mechanism to control it.</span></span> <span data-ttu-id="e38d9-436">Im folgenden finden Sie eine kurze Zusammenfassung zum Erstellen eines Profils für eine beliebige Rendering-Sequenz:</span><span class="sxs-lookup"><span data-stu-id="e38d9-436">Here is a brief summary of how to profile an arbitrary render sequence:</span></span>

-   <span data-ttu-id="e38d9-437">Verwenden Sie einen leistungsstarken Leistungswert wie QueryPerformanceCounter, um die Zeit zu messen, die für die Verarbeitung der einzelnen API-Aufrufe benötigt wird.</span><span class="sxs-lookup"><span data-stu-id="e38d9-437">Use a high performance counter like QueryPerformanceCounter to measure the time it takes to process each API call.</span></span> <span data-ttu-id="e38d9-438">Verwenden Sie QueryPerformanceFrequency und die CPU-Taktfrequenz, um dies in die Anzahl der CPU-Zyklen pro API-Aufruf zu konvertieren.</span><span class="sxs-lookup"><span data-stu-id="e38d9-438">Use QueryPerformanceFrequency and the CPU clock rate to convert this to the number of CPU cycles per API call.</span></span>
-   <span data-ttu-id="e38d9-439">Minimieren Sie die GPU-Arbeitsaufwand, indem Sie Dreiecks Listen rendern, wobei jedes Dreieck ein Pixel enthält.</span><span class="sxs-lookup"><span data-stu-id="e38d9-439">Minimize the amount of GPU work by rendering triangle lists, where each triangle contains one pixel.</span></span>
-   <span data-ttu-id="e38d9-440">Verwenden Sie den Abfrage Mechanismus, um den Befehls Puffer vor der Rendering-Sequenz zu leeren.</span><span class="sxs-lookup"><span data-stu-id="e38d9-440">Use the query mechanism to empty the command buffer before the render sequence.</span></span> <span data-ttu-id="e38d9-441">Dadurch wird sichergestellt, dass die Profilerstellung die richtige Menge an Lauf Zeit-und Treiber Arbeit für die Rendering-Sequenz erfasst.</span><span class="sxs-lookup"><span data-stu-id="e38d9-441">This guarantees that profiling will capturing the correct amount of runtime and driver work associated with the render sequence.</span></span>
-   <span data-ttu-id="e38d9-442">Steuern Sie den Arbeitsaufwand, der dem Befehls Puffer mit Abfrage Ereignis Markierungen hinzugefügt wird.</span><span class="sxs-lookup"><span data-stu-id="e38d9-442">Control the amount of work added to the command buffer with query event markers.</span></span> <span data-ttu-id="e38d9-443">Dieselbe Abfrage erkennt, wenn die GPU ihre Arbeit abgeschlossen hat.</span><span class="sxs-lookup"><span data-stu-id="e38d9-443">This same query detects when the GPU finishes its work.</span></span> <span data-ttu-id="e38d9-444">Da die GPU-Arbeit trivial ist, entspricht dies praktisch dem Messen, wann die Treiber Arbeit abgeschlossen ist.</span><span class="sxs-lookup"><span data-stu-id="e38d9-444">Since the GPU work is trivial, this is virtually equivalent to measuring when the driver work is completed.</span></span>

<span data-ttu-id="e38d9-445">Alle diese Verfahren werden verwendet, um Statusänderungen zu Profilen.</span><span class="sxs-lookup"><span data-stu-id="e38d9-445">All of these techniques are used to profile state changes.</span></span> <span data-ttu-id="e38d9-446">Angenommen, Sie haben gelesen und verstanden, wie der Befehls Puffer gesteuert werden kann, und Sie haben die Baseline-Messungen für [**drawprimitiv**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-drawprimitive)erfolgreich abgeschlossen, können Sie den Rendering-Sequenzen Zustandsänderungen hinzufügen.</span><span class="sxs-lookup"><span data-stu-id="e38d9-446">Assuming that you have read and understood how to control the command buffer, and have successfully completed baseline measurements on [**DrawPrimitive**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-drawprimitive), you are ready to add state changes to your render sequences.</span></span> <span data-ttu-id="e38d9-447">Beim Hinzufügen von Zustandsänderungen zu einer Rendering-Sequenz gibt es einige zusätzliche Herausforderungen bei der Profilerstellung.</span><span class="sxs-lookup"><span data-stu-id="e38d9-447">There are a few additional profiling challenges when adding state changes to a render sequence.</span></span> <span data-ttu-id="e38d9-448">Wenn Sie Ihren Rendering-Sequenzen Zustandsänderungen hinzufügen möchten, stellen Sie sicher, dass Sie mit dem nächsten Abschnitt fortfahren.</span><span class="sxs-lookup"><span data-stu-id="e38d9-448">If you intend to add state changes to your render sequences, be sure to continue into the next section.</span></span>

## <a name="profiling-direct3d-state-changes"></a><span data-ttu-id="e38d9-449">Profilerstellung Direct3D Zustandsänderungen</span><span class="sxs-lookup"><span data-stu-id="e38d9-449">Profiling Direct3D State Changes</span></span>

<span data-ttu-id="e38d9-450">Direct3D verwendet viele Rendering-Zustände, um fast jeden Aspekt der Pipeline zu steuern.</span><span class="sxs-lookup"><span data-stu-id="e38d9-450">Direct3D uses many render states to control almost every aspect of the pipeline.</span></span> <span data-ttu-id="e38d9-451">Die APIs, die Zustandsänderungen verursachen, beinhalten eine beliebige Funktion oder Methode, die keine primitiven zeichnen- \* Aufrufe ist.</span><span class="sxs-lookup"><span data-stu-id="e38d9-451">The APIs that cause state changes include any function or method other than the Draw\*Primitive calls.</span></span>

<span data-ttu-id="e38d9-452">Zustandsänderungen sind schwierig, da Sie möglicherweise nicht in der Lage sind, die Kosten einer Zustandsänderung ohne Rendering anzuzeigen.</span><span class="sxs-lookup"><span data-stu-id="e38d9-452">State changes are tricky because you may not be able to see the cost of a state change without rendering.</span></span> <span data-ttu-id="e38d9-453">Dies ist das Ergebnis des Lazy-Algorithmus, den der Treiber und die GPU verwenden, um die Arbeit zu verzögern, bis Sie unbedingt abgeschlossen werden muss.</span><span class="sxs-lookup"><span data-stu-id="e38d9-453">This is a result of the lazy algorithm that the driver and the GPU use to defer work until it absolutely has to be done.</span></span> <span data-ttu-id="e38d9-454">Im Allgemeinen sollten Sie die folgenden Schritte ausführen, um eine einzelne Zustandsänderung zu messen:</span><span class="sxs-lookup"><span data-stu-id="e38d9-454">In general, you should follow these steps to measure a single state change:</span></span>

1.  <span data-ttu-id="e38d9-455">Profil für [**drawprimitiv**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-drawprimitive) zuerst erstellen.</span><span class="sxs-lookup"><span data-stu-id="e38d9-455">Profile [**DrawPrimitive**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-drawprimitive) first.</span></span>
2.  <span data-ttu-id="e38d9-456">Fügen Sie eine Statusänderung zur Rendering-Sequenz hinzu, und erstellen Sie ein Profil der neuen Sequenz.</span><span class="sxs-lookup"><span data-stu-id="e38d9-456">Add one state change to the render sequence and profile the new sequence.</span></span>
3.  <span data-ttu-id="e38d9-457">Subtrahieren Sie den Unterschied zwischen den beiden Sequenzen, um die Kosten für die Zustandsänderung zu erhalten.</span><span class="sxs-lookup"><span data-stu-id="e38d9-457">Subtract the difference between the two sequences to get the cost of the state change.</span></span>

<span data-ttu-id="e38d9-458">Natürlich gilt alles, was Sie mit der Verwendung des Abfrage Mechanismus gelernt haben und die rendersequenz in eine Schleife bringen, um die Kosten des Modus-Übergangs zu negieren.</span><span class="sxs-lookup"><span data-stu-id="e38d9-458">Naturally, everything you have learned about using the query mechanism and putting the render sequence in a loop to negate the cost of the mode transition still applies.</span></span>

### <a name="profiling-a-simple-state-change"></a><span data-ttu-id="e38d9-459">Profilerstellung für eine einfache Zustandsänderung</span><span class="sxs-lookup"><span data-stu-id="e38d9-459">Profiling a Simple State Change</span></span>

<span data-ttu-id="e38d9-460">Beginnend mit einer Rendering-Sequenz, die [**drawprimitiv**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-drawprimitive)enthält, finden Sie hier die Code Sequenz zum Messen der Kosten für das Hinzufügen von [**SetTexture**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-settexture):</span><span class="sxs-lookup"><span data-stu-id="e38d9-460">Starting with a render sequence that contains [**DrawPrimitive**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-drawprimitive), here is the code sequence for measuring the cost of adding [**SetTexture**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-settexture):</span></span>


```
// Get the start counter value as shown in Example 4 

// Initialize a texture array as shown in Example 4
IDirect3DTexture* texArray[2];

// Render sequence loop 
for(int i = 0; i < 1500; i++)
{
  SetTexture(0, texArray[i%2];
  
  // Force the state change to propagate to the GPU
  DrawPrimitive(D3DPT_TRIANGLELIST, i*3, 1);
}

// Get the stop counter value as shown in Example 4 
```



<span data-ttu-id="e38d9-461">Beispiel 5: Messen eines API-Aufrufes mit einer Statusänderung</span><span class="sxs-lookup"><span data-stu-id="e38d9-461">Example 5: Measuring One State Change API Call</span></span>

<span data-ttu-id="e38d9-462">Beachten Sie, dass die-Schleife zwei Aufrufe enthält: [**SetTexture**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-settexture) und [**drawprimitiv**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-drawprimitive).</span><span class="sxs-lookup"><span data-stu-id="e38d9-462">Notice that the loop contains two calls, [**SetTexture**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-settexture) and [**DrawPrimitive**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-drawprimitive).</span></span> <span data-ttu-id="e38d9-463">Die Rendering-Sequenz führt 1500-fache Schleifen aus und generiert ähnliche Ergebnisse wie die folgenden:</span><span class="sxs-lookup"><span data-stu-id="e38d9-463">The render sequence loops 1500 times and generates results similar to these:</span></span>



| <span data-ttu-id="e38d9-464">Lokale Variable</span><span class="sxs-lookup"><span data-stu-id="e38d9-464">Local Variable</span></span> | <span data-ttu-id="e38d9-465">Anzahl von Tics</span><span class="sxs-lookup"><span data-stu-id="e38d9-465">Number of Tics</span></span> |
|----------------|----------------|
| <span data-ttu-id="e38d9-466">start</span><span class="sxs-lookup"><span data-stu-id="e38d9-466">start</span></span>          | <span data-ttu-id="e38d9-467">1792998860000</span><span class="sxs-lookup"><span data-stu-id="e38d9-467">1792998860000</span></span>  |
| <span data-ttu-id="e38d9-468">stop</span><span class="sxs-lookup"><span data-stu-id="e38d9-468">stop</span></span>           | <span data-ttu-id="e38d9-469">1792998870260</span><span class="sxs-lookup"><span data-stu-id="e38d9-469">1792998870260</span></span>  |
| <span data-ttu-id="e38d9-470">Freq</span><span class="sxs-lookup"><span data-stu-id="e38d9-470">freq</span></span>           | <span data-ttu-id="e38d9-471">3579545</span><span class="sxs-lookup"><span data-stu-id="e38d9-471">3579545</span></span>        |



 

<span data-ttu-id="e38d9-472">Das Umrechnen von Ticks in Zyklen wiederum ergibt folgendes:</span><span class="sxs-lookup"><span data-stu-id="e38d9-472">Converting ticks to cycles once again yields:</span></span>


```
# ticks  = (stop - start) = 1792998870260 - 1792998860000 = 10,260 ticks
# cycles    = machine speed * number of ticks / QPF
5,775,000   = 2 GHz          * 10,260         / 3,579,545
```



<span data-ttu-id="e38d9-473">Durch die Unterteilung durch die Anzahl der Iterationen in der Schleife ergeben sich folgende Ergebnisse:</span><span class="sxs-lookup"><span data-stu-id="e38d9-473">Dividing by the number of iterations in the loop yields:</span></span>


```
5,775,000 cycles / 1500 iterations = 3850 cycles for one iteration
```



<span data-ttu-id="e38d9-474">Jede Iterations Schleife enthält eine Zustandsänderung und einen zeichnen-Befehl.</span><span class="sxs-lookup"><span data-stu-id="e38d9-474">Each iteration of the loop contains a state change and a draw call.</span></span> <span data-ttu-id="e38d9-475">Wenn Sie das Ergebnis der [**drawprimitive**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-drawprimitive) -Rendering-Sequenz subtrahieren, verbleibt Folgendes:</span><span class="sxs-lookup"><span data-stu-id="e38d9-475">Subtracting out the result of the [**DrawPrimitive**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-drawprimitive) render sequence leaves:</span></span>


```
3850 - 1100 = 2750 cycles for SetTexture
```



<span data-ttu-id="e38d9-476">Dies ist die durchschnittliche Anzahl von Zyklen zum Hinzufügen von [**SetTexture**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-settexture) zu dieser Rendering-Sequenz.</span><span class="sxs-lookup"><span data-stu-id="e38d9-476">This is the average number of cycles to add [**SetTexture**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-settexture) to this render sequence.</span></span> <span data-ttu-id="e38d9-477">Diese Methode kann auch auf andere Zustandsänderungen angewendet werden.</span><span class="sxs-lookup"><span data-stu-id="e38d9-477">This same technique can be applied to other state changes.</span></span>

<span data-ttu-id="e38d9-478">Warum wurde [**SetTexture**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-settexture) als einfache Zustandsänderung bezeichnet?</span><span class="sxs-lookup"><span data-stu-id="e38d9-478">Why is [**SetTexture**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-settexture) called a simple state change?</span></span> <span data-ttu-id="e38d9-479">Der Zustand, der festgelegt wird, wird eingeschränkt, sodass die Pipeline bei jeder Änderung des Status die gleiche Arbeitsmenge durchführt.</span><span class="sxs-lookup"><span data-stu-id="e38d9-479">Because the state that is being set is constrained so that the pipeline does the same amount of work each time the state is changed.</span></span> <span data-ttu-id="e38d9-480">Durch die Beschränkung beider Texturen auf die gleiche Größe und das gleiche Format wird für jeden **SetTexture** -Befehl die gleiche Menge an Arbeit sichergestellt.</span><span class="sxs-lookup"><span data-stu-id="e38d9-480">Constraining both textures to the same size and format assures the same amount of work for each **SetTexture** call.</span></span>

### <a name="profiling-a-state-change-that-needs-to-be-toggled"></a><span data-ttu-id="e38d9-481">Profilerstellung für eine Statusänderung, die umgeschaltet werden muss</span><span class="sxs-lookup"><span data-stu-id="e38d9-481">Profiling a State Change that Needs to Be Toggled</span></span>

<span data-ttu-id="e38d9-482">Es gibt andere Zustandsänderungen, die bewirken, dass sich der von der Grafik Pipeline ausgeführte Arbeitsaufwand für jede Iterationen der Renderschleife ändert.</span><span class="sxs-lookup"><span data-stu-id="e38d9-482">There are other state changes that cause the amount of work performed by the graphics pipeline to change for every iteration of the render loop.</span></span> <span data-ttu-id="e38d9-483">Wenn z. b. z-Tests aktiviert ist, aktualisiert jede Pixelfarbe ein Renderziel nur, nachdem der z-Wert des neuen Pixels mit dem z-Wert für das vorhandene Pixel getestet wurde.</span><span class="sxs-lookup"><span data-stu-id="e38d9-483">For example, if z-testing is enabled, each pixel color updates a render target only after the new pixel's z value is tested against the z-value for the existing pixel.</span></span> <span data-ttu-id="e38d9-484">Wenn z-testing deaktiviert ist, wird dieser pro-Pixel-Test nicht durchgeführt, und die Ausgabe wird wesentlich schneller geschrieben.</span><span class="sxs-lookup"><span data-stu-id="e38d9-484">If z-testing is disabled, this per-pixel test is not done and the output is written much faster.</span></span> <span data-ttu-id="e38d9-485">Durch das Aktivieren oder Deaktivieren des z-Test Zustands wird der Umfang der durchgeführten Arbeit (von der CPU und der GPU) während des Renderings erheblich geändert.</span><span class="sxs-lookup"><span data-stu-id="e38d9-485">Enabling or disabling the z-test state dramatically changes the amount of work done (by the CPU as well as the GPU) during rendering.</span></span>

<span data-ttu-id="e38d9-486">" [**Strenderstate**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-setrenderstate) " erfordert einen bestimmten renderzustand und einen Zustandswert, um z-Tests zu aktivieren bzw. zu deaktivieren.</span><span class="sxs-lookup"><span data-stu-id="e38d9-486">[**SetRenderState**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-setrenderstate) requires a particular render state and a state value to enable or disable z-testing.</span></span> <span data-ttu-id="e38d9-487">Der bestimmte Zustandswert wird zur Laufzeit ausgewertet, um zu bestimmen, wie viel Arbeit erforderlich ist.</span><span class="sxs-lookup"><span data-stu-id="e38d9-487">The particular state value is evaluated at runtime to determine how much work is necessary.</span></span> <span data-ttu-id="e38d9-488">Es ist schwierig, diese Zustandsänderung in einer Renderschleife zu messen und den Pipeline Status so zu ändern, dass er wechselt.</span><span class="sxs-lookup"><span data-stu-id="e38d9-488">It is difficult to measure this state change in a render loop and still precondition the pipeline state so that it switches.</span></span> <span data-ttu-id="e38d9-489">Die einzige Lösung ist das Umschalten der Zustandsänderung während der Rendering-Sequenz.</span><span class="sxs-lookup"><span data-stu-id="e38d9-489">The only solution is to toggle the state change during the render sequence.</span></span>

<span data-ttu-id="e38d9-490">Beispielsweise muss die Profil Erstellungs Methode wie folgt zweimal wiederholt werden:</span><span class="sxs-lookup"><span data-stu-id="e38d9-490">For example, the profiling technique needs to be repeated twice as follows:</span></span>

1.  <span data-ttu-id="e38d9-491">Beginnen Sie mit der Profilerstellung der [**drawprimitive**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-drawprimitive) -Rendering-Sequenz.</span><span class="sxs-lookup"><span data-stu-id="e38d9-491">Start by profiling the [**DrawPrimitive**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-drawprimitive) render sequence.</span></span> <span data-ttu-id="e38d9-492">Nennen Sie dies als Baseline.</span><span class="sxs-lookup"><span data-stu-id="e38d9-492">Call this the baseline.</span></span>
2.  <span data-ttu-id="e38d9-493">Profil für eine zweite Rendering-Sequenz erstellen, die die Statusänderung schaltet.</span><span class="sxs-lookup"><span data-stu-id="e38d9-493">Profile a second render sequence that toggles the state change.</span></span> <span data-ttu-id="e38d9-494">Die rendersequenzschleife enthält Folgendes:</span><span class="sxs-lookup"><span data-stu-id="e38d9-494">The render sequence loop contains:</span></span>
    -   <span data-ttu-id="e38d9-495">Eine Statusänderung zum Festlegen des Zustands in eine "false"-Bedingung.</span><span class="sxs-lookup"><span data-stu-id="e38d9-495">A state change to set the state into a "false" condition.</span></span>
    -   <span data-ttu-id="e38d9-496">[**Drawprimitiv**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-drawprimitive) genau wie die ursprüngliche Sequenz.</span><span class="sxs-lookup"><span data-stu-id="e38d9-496">[**DrawPrimitive**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-drawprimitive) just like the original sequence.</span></span>
    -   <span data-ttu-id="e38d9-497">Eine Statusänderung zum Festlegen des Zustands in eine "true"-Bedingung.</span><span class="sxs-lookup"><span data-stu-id="e38d9-497">A state change to set the state into a "true" condition.</span></span>
    -   <span data-ttu-id="e38d9-498">Ein zweites [**drawprimitiv**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-drawprimitive) , das die Realisierung der zweiten Zustandsänderung erzwingen soll.</span><span class="sxs-lookup"><span data-stu-id="e38d9-498">A second [**DrawPrimitive**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-drawprimitive) to force the second state change to be realized.</span></span>
3.  <span data-ttu-id="e38d9-499">Suchen Sie den Unterschied zwischen den beiden Rendering-Sequenzen.</span><span class="sxs-lookup"><span data-stu-id="e38d9-499">Find the difference between the two render sequences.</span></span> <span data-ttu-id="e38d9-500">Dies wird wie folgt erreicht:</span><span class="sxs-lookup"><span data-stu-id="e38d9-500">This is done by:</span></span>
    -   <span data-ttu-id="e38d9-501">Multiplizieren Sie die Baseline [**drawprimitive**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-drawprimitive) -Sequenz mit 2, da in der neuen Sequenz zwei **drawprimitive** -Aufrufe vorhanden sind.</span><span class="sxs-lookup"><span data-stu-id="e38d9-501">Multiply the baseline [**DrawPrimitive**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-drawprimitive) sequence by 2 because there are two **DrawPrimitive** calls in the new sequence.</span></span>
    -   <span data-ttu-id="e38d9-502">Subtrahieren Sie das Ergebnis der neuen Sequenz aus der ursprünglichen Sequenz.</span><span class="sxs-lookup"><span data-stu-id="e38d9-502">Subtract the result of the new sequence from the original sequence.</span></span>
    -   <span data-ttu-id="e38d9-503">Dividieren Sie das Ergebnis durch 2, um die durchschnittlichen Kosten der Zustandsänderung "false" und "true" zu erhalten.</span><span class="sxs-lookup"><span data-stu-id="e38d9-503">Divide the result by 2 to get the average cost of both the "false" and the "true" state change.</span></span>

<span data-ttu-id="e38d9-504">Mit der in der rendersequenz verwendeten Schleifen Technik müssen die Kosten für das Ändern des Pipeline Zustands gemessen werden, indem der Status von "true" in "false" und umgekehrt für jede Iterationen in der rendersequenz geändert wird.</span><span class="sxs-lookup"><span data-stu-id="e38d9-504">With the looping technique used in the render sequence, the cost of changing pipeline state needs to be measured by toggling the state from a "true" to a "false" condition and vice versa, for each iteration in the render sequence.</span></span> <span data-ttu-id="e38d9-505">Die Bedeutung von "true" und "false" hier ist kein Literalwert. Dies bedeutet einfach, dass der Zustand in gegen übergesetzte Bedingungen festgelegt werden muss.</span><span class="sxs-lookup"><span data-stu-id="e38d9-505">The meaning of "true" and "false" here are not literal, this simply means that the state needs to be set into opposing conditions.</span></span> <span data-ttu-id="e38d9-506">Dies bewirkt, dass beide Zustandsänderungen während der Profilerstellung gemessen werden.</span><span class="sxs-lookup"><span data-stu-id="e38d9-506">This causes both state changes to be measured during profiling.</span></span> <span data-ttu-id="e38d9-507">Natürlich gilt alles, was Sie mit der Verwendung des Abfrage Mechanismus gelernt haben und die Renderingsequenz in eine Schleife einfügen, um die Kosten für den modusübergang zu negieren.</span><span class="sxs-lookup"><span data-stu-id="e38d9-507">Of course everything you have learned about using the query mechanism and putting the render sequence in a loop to negate the cost of the mode transition still applies.</span></span>

<span data-ttu-id="e38d9-508">Hier ist beispielsweise die Code Sequenz zum Messen der Kosten für das ein-und Ausschalten von z-Tests:</span><span class="sxs-lookup"><span data-stu-id="e38d9-508">For example, here is the code sequence for measuring the cost of toggling z-testing on or off:</span></span>


```
// Get the start counter value as shown in Example 4 

// Add a loop to the render sequence 
for(int i = 0; i < 1500; i++)
{
  // Precondition the pipeline state to the "false" condition
  SetRenderState(D3DRS_ZENABLE, FALSE);
  
  // Force the state change to propagate to the GPU
  DrawPrimitive(D3DPT_TRIANGLELIST, (2*i + 0)*3, 1);

  // Set the pipeline state to the "true" condition
  SetRenderState(D3DRS_ZENABLE, TRUE);

  // Force the state change to propagate to the GPU
  DrawPrimitive(D3DPT_TRIANGLELIST, (2*i + 1)*3, 1); 
}

// Get the stop counter value as shown in Example 4 
```



<span data-ttu-id="e38d9-509">Beispiel 5: Messen der Statusänderung für das Umschalten</span><span class="sxs-lookup"><span data-stu-id="e38d9-509">Example 5: Measuring a Toggling State Change</span></span>

<span data-ttu-id="e38d9-510">Die Schleife schaltet den Zustand um, indem Sie zwei " [**strenderstate**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-setrenderstate) "-Aufrufe ausführt.</span><span class="sxs-lookup"><span data-stu-id="e38d9-510">The loop toggles the state by executing two [**SetRenderState**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-setrenderstate) calls.</span></span> <span data-ttu-id="e38d9-511">Der erste **setrenderstate** -Befehl deaktiviert z-Tests, und der zweite **setrenderstate** ermöglicht z-Tests.</span><span class="sxs-lookup"><span data-stu-id="e38d9-511">The first **SetRenderState** call disables z-testing and the second **SetRenderState** enables z-testing.</span></span> <span data-ttu-id="e38d9-512">Auf jeden " **strenderstate** " folgt " [**drawprimiprimitiv**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-drawprimitive) ", sodass die mit der Zustandsänderung verknüpfte Arbeit vom Treiber verarbeitet wird, anstatt nur ein ändertes Bit im Treiber festzulegen.</span><span class="sxs-lookup"><span data-stu-id="e38d9-512">Each **SetRenderState** is followed by [**DrawPrimitive**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-drawprimitive) so that the work associated with the state change is processed by the driver instead of only setting a dirty bit in the driver.</span></span>

<span data-ttu-id="e38d9-513">Diese Zahlen sind für diese Rendering-Sequenz angemessen:</span><span class="sxs-lookup"><span data-stu-id="e38d9-513">These numbers are reasonable for this render sequence:</span></span>



| <span data-ttu-id="e38d9-514">Lokale Variable</span><span class="sxs-lookup"><span data-stu-id="e38d9-514">Local Variable</span></span> | <span data-ttu-id="e38d9-515">Anzahl der Ticks</span><span class="sxs-lookup"><span data-stu-id="e38d9-515">Number of Ticks</span></span> |
|----------------|-----------------|
| <span data-ttu-id="e38d9-516">start</span><span class="sxs-lookup"><span data-stu-id="e38d9-516">start</span></span>          | <span data-ttu-id="e38d9-517">1792998845000</span><span class="sxs-lookup"><span data-stu-id="e38d9-517">1792998845000</span></span>   |
| <span data-ttu-id="e38d9-518">stop</span><span class="sxs-lookup"><span data-stu-id="e38d9-518">stop</span></span>           | <span data-ttu-id="e38d9-519">1792998861740</span><span class="sxs-lookup"><span data-stu-id="e38d9-519">1792998861740</span></span>   |
| <span data-ttu-id="e38d9-520">Freq</span><span class="sxs-lookup"><span data-stu-id="e38d9-520">freq</span></span>           | <span data-ttu-id="e38d9-521">3579545</span><span class="sxs-lookup"><span data-stu-id="e38d9-521">3579545</span></span>         |



 

<span data-ttu-id="e38d9-522">Das Umrechnen von Ticks in Zyklen wiederum ergibt folgendes:</span><span class="sxs-lookup"><span data-stu-id="e38d9-522">Converting ticks to cycles once again yields:</span></span>


```
# ticks  = (stop - start) = 1792998861740 - 1792998845000 = 15,120 ticks
# cycles    = machine speed * number of ticks / QPF
 9,300,000  = 2 GHz          * 16,740         / 3,579,545
```



<span data-ttu-id="e38d9-523">Durch die Unterteilung durch die Anzahl der Iterationen in der Schleife ergeben sich folgende Ergebnisse:</span><span class="sxs-lookup"><span data-stu-id="e38d9-523">Dividing by the number of iterations in the loop yields:</span></span>


```
9,300,000 cycles / 1500 iterations = 6200 cycles for one iteration
```



<span data-ttu-id="e38d9-524">Jede Iterations Schleife enthält zwei Statusänderungen und zwei Draw-Aufrufe.</span><span class="sxs-lookup"><span data-stu-id="e38d9-524">Each iteration of the loop contains two state changes and two draw calls.</span></span> <span data-ttu-id="e38d9-525">Das Subtrahieren der Draw-Aufrufe (ausgehend von 1100 Zyklen) verlässt Folgendes:</span><span class="sxs-lookup"><span data-stu-id="e38d9-525">Subtracting out the draw calls (assuming 1100 cycles) leaves:</span></span>


```
6200 - 1100 - 1100 = 4000 cycles for both state changes
```



<span data-ttu-id="e38d9-526">Dies ist die durchschnittliche Anzahl von Zyklen für beide Statusänderungen, sodass die durchschnittliche Zeit für jede Zustandsänderung lautet:</span><span class="sxs-lookup"><span data-stu-id="e38d9-526">This is the average number of cycles for both state changes so the average time for each state change is:</span></span>


```
4000 / 2  = 2000 cycles for each state change
```



<span data-ttu-id="e38d9-527">Daher ist die durchschnittliche Anzahl von Zyklen zum Aktivieren oder Deaktivieren von z-Tests 2000 Zyklen.</span><span class="sxs-lookup"><span data-stu-id="e38d9-527">Therefore, the average number of cycles to enable or disable z-testing is 2000 cycles.</span></span> <span data-ttu-id="e38d9-528">Beachten Sie, dass QueryPerformanceCounter z-enable halb und z-Deaktivierung der Hälfte der Zeit misst.</span><span class="sxs-lookup"><span data-stu-id="e38d9-528">It is worth noting that QueryPerformanceCounter is measuring z-enable half the time and z-disable half of the time.</span></span> <span data-ttu-id="e38d9-529">Mit dieser Technik wird der Durchschnitt der beiden Zustandsänderungen gemessen.</span><span class="sxs-lookup"><span data-stu-id="e38d9-529">This technique actually measures the average of both state changes.</span></span> <span data-ttu-id="e38d9-530">Das heißt, Sie messen die Zeit zum Umschalten eines Zustands.</span><span class="sxs-lookup"><span data-stu-id="e38d9-530">In other words, you are measuring the time to toggle a state.</span></span> <span data-ttu-id="e38d9-531">Mit dieser Technik können Sie nicht wissen, ob die Aktivierungs-und Deaktivierungs Zeiten gleichwertig sind, da Sie den Durchschnitt beider Elemente gemessen haben.</span><span class="sxs-lookup"><span data-stu-id="e38d9-531">Using this technique, you have no way of knowing if the enable and disable times are equivalent since you have measured the average of both of them.</span></span> <span data-ttu-id="e38d9-532">Dies ist jedoch eine angemessene Zahl, die beim budgetieren eines umgeschaltenden Zustands als Anwendung, die diese Zustandsänderung bewirkt, nur durch Umschalten dieses Zustands verwendet werden kann.</span><span class="sxs-lookup"><span data-stu-id="e38d9-532">Nevertheless, this is a reasonable number to use when budgeting a toggling state as an application that causes this state change can only do so by toggling this state.</span></span>

<span data-ttu-id="e38d9-533">Nun können Sie diese Techniken anwenden und Profile für alle gewünschten Zustandsänderungen erstellen.</span><span class="sxs-lookup"><span data-stu-id="e38d9-533">So now you can apply these techniques and profile all the state changes you want, right?</span></span> <span data-ttu-id="e38d9-534">Noch nicht ganz.</span><span class="sxs-lookup"><span data-stu-id="e38d9-534">Not quite.</span></span> <span data-ttu-id="e38d9-535">Sie müssen jedoch immer noch mit Optimierungen bedacht werden, die so entworfen wurden, dass Sie den Aufwand für die Arbeit reduzieren.</span><span class="sxs-lookup"><span data-stu-id="e38d9-535">You still need to be careful about optimizations that are designed to reduce the amount of work that needs to be done.</span></span> <span data-ttu-id="e38d9-536">Es gibt zwei Arten von Optimierungen, die Sie beim Entwerfen der Rendering-Sequenzen beachten sollten.</span><span class="sxs-lookup"><span data-stu-id="e38d9-536">There are two types of optimizations that you should be aware of when designing your render sequences.</span></span>

### <a name="watch-out-for-state-change-optimizations"></a><span data-ttu-id="e38d9-537">Überwachen der Optimierungen von Statusänderungen</span><span class="sxs-lookup"><span data-stu-id="e38d9-537">Watch Out for State Change Optimizations</span></span>

<span data-ttu-id="e38d9-538">Der vorherige Abschnitt zeigt, wie Sie ein Profil für beide Arten von Zustandsänderungen erstellen können: eine einfache Zustandsänderung, die so eingeschränkt ist, dass für jede Iterations Menge die gleiche Menge an Arbeit generiert wird, und eine umschaltbare Zustandsänderung, durch die der Umfang der Arbeit erheblich geändert wird.</span><span class="sxs-lookup"><span data-stu-id="e38d9-538">The previous section show how to profile both kinds of state changes: a simple state change that is constrained to generate the same amount of work for each iteration, and a toggling state change that dramatically changes the amount of work done.</span></span> <span data-ttu-id="e38d9-539">Was geschieht, wenn Sie die vorherige Rendering-Sequenz nehmen und eine andere Zustandsänderung hinzufügen?</span><span class="sxs-lookup"><span data-stu-id="e38d9-539">What happens if you take the previous render sequence and add another state change to it?</span></span> <span data-ttu-id="e38d9-540">Beispielsweise wird in diesem Beispiel die z->-enable-Rendering-Sequenz angenommen, und es wird ein z-Func-Vergleich hinzugefügt:</span><span class="sxs-lookup"><span data-stu-id="e38d9-540">For instance, this example takes the z>-enable render sequence and adds a z-func comparison to it:</span></span>


```
// Add a loop to the render sequence 
for(int i = 0; i < 1500; i++)
{
  // Precondition the pipeline state to the opposite condition
  SetRenderState(D3DRS_ZFUNC, D3DCMP_NEVER);

  // Precondition the pipeline state to the opposite condition
  SetRenderState(D3DRS_ZENABLE, FALSE);
  
  // Force the state change to propagate to the GPU
  DrawPrimitive(D3DPT_TRIANGLELIST, (2*i + 0)*3, 1);

  // Now set the state change you want to measure
  SetRenderState(D3DRS_ZFUNC, D3DCMP_ALWAYS);

  // Now set the state change you want to measure
  SetRenderState(D3DRS_ZENABLE, TRUE);

  // Force the state change to propagate to the GPU
  DrawPrimitive(D3DPT_TRIANGLELIST, (2*i + 1)*3, 1); 
}
```



<span data-ttu-id="e38d9-541">Mit dem z-Func-Zustand wird die Vergleichs Ebene beim Schreiben in den z-Puffer (zwischen dem z-Wert eines aktuellen Pixels mit dem z-Wert eines Pixels im tiefen Puffer) festgelegt.</span><span class="sxs-lookup"><span data-stu-id="e38d9-541">The z-func state sets the comparison level when writing to the z-buffer (between the z-value of a current pixel with the z-value of a pixel in the depth buffer).</span></span> <span data-ttu-id="e38d9-542">D3DCMP deaktiviert \_ den z-Test-Vergleich nie, während D3DCMP \_ immer den Vergleich so festlegt, dass er jedes Mal durchgeführt wird, wenn z-Tests durchgeführt werden.</span><span class="sxs-lookup"><span data-stu-id="e38d9-542">D3DCMP\_NEVER turns off the z-testing comparison while D3DCMP\_ALWAYS sets the comparison to happen every time z-testing is done.</span></span>

<span data-ttu-id="e38d9-543">Die Profilerstellung für eine dieser Statusänderungen in einer Rendering-Sequenz mit [**drawprimitiver**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-drawprimitive) generiert ähnliche Ergebnisse wie die folgenden:</span><span class="sxs-lookup"><span data-stu-id="e38d9-543">Profiling either one of these state changes in a render sequence with [**DrawPrimitive**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-drawprimitive) generates results similar to these:</span></span>



| <span data-ttu-id="e38d9-544">Änderung des einzelnen Zustands</span><span class="sxs-lookup"><span data-stu-id="e38d9-544">Single State Change</span></span> | <span data-ttu-id="e38d9-545">Durchschnittliche Anzahl von Zyklen</span><span class="sxs-lookup"><span data-stu-id="e38d9-545">Average Number of Cycles</span></span> |
|---------------------|--------------------------|
| <span data-ttu-id="e38d9-546">\_Nur D3DRS zenable</span><span class="sxs-lookup"><span data-stu-id="e38d9-546">D3DRS\_ZENABLE only</span></span> | <span data-ttu-id="e38d9-547">2000</span><span class="sxs-lookup"><span data-stu-id="e38d9-547">2000</span></span>                     |



 

<span data-ttu-id="e38d9-548">oder</span><span class="sxs-lookup"><span data-stu-id="e38d9-548">or</span></span>



| <span data-ttu-id="e38d9-549">Änderung des einzelnen Zustands</span><span class="sxs-lookup"><span data-stu-id="e38d9-549">Single State Change</span></span> | <span data-ttu-id="e38d9-550">Durchschnittliche Anzahl von Zyklen</span><span class="sxs-lookup"><span data-stu-id="e38d9-550">Average Number of Cycles</span></span> |
|---------------------|--------------------------|
| <span data-ttu-id="e38d9-551">\_Nur D3DRS zfunc</span><span class="sxs-lookup"><span data-stu-id="e38d9-551">D3DRS\_ZFUNC only</span></span>   | <span data-ttu-id="e38d9-552">600</span><span class="sxs-lookup"><span data-stu-id="e38d9-552">600</span></span>                      |



 

<span data-ttu-id="e38d9-553">Wenn Sie jedoch ein Profil für "D3DRS \_ zenable" und "D3DRS \_ zfunc" in derselben Rendering-Sequenz erstellen, sehen Sie die Ergebnisse wie die folgenden:</span><span class="sxs-lookup"><span data-stu-id="e38d9-553">But, if you profile both D3DRS\_ZENABLE and D3DRS\_ZFUNC in the same render sequence you could see results like these:</span></span>



| <span data-ttu-id="e38d9-554">Beide Statusänderungen</span><span class="sxs-lookup"><span data-stu-id="e38d9-554">Both State Changes</span></span>            | <span data-ttu-id="e38d9-555">Durchschnittliche Anzahl von Zyklen</span><span class="sxs-lookup"><span data-stu-id="e38d9-555">Average Number of Cycles</span></span> |
|-------------------------------|--------------------------|
| <span data-ttu-id="e38d9-556">D3DRS \_ zenable + D3DRS \_ zfunc</span><span class="sxs-lookup"><span data-stu-id="e38d9-556">D3DRS\_ZENABLE + D3DRS\_ZFUNC</span></span> | <span data-ttu-id="e38d9-557">2000</span><span class="sxs-lookup"><span data-stu-id="e38d9-557">2000</span></span>                     |



 

<span data-ttu-id="e38d9-558">Sie können davon ausgehen, dass das Ergebnis die Summe aus 2000-und 600-Zyklen (bzw. 2600) ist, da der Treiber alle Aufgaben durchführt, die mit der Festlegung beider renderzustände verknüpft sind.</span><span class="sxs-lookup"><span data-stu-id="e38d9-558">You could expect the result to be to be the sum of 2000 and 600 (or 2600) cycles because the driver is doing all the work associated with setting both render states.</span></span> <span data-ttu-id="e38d9-559">Stattdessen beträgt der Durchschnitt 2000 Zyklen.</span><span class="sxs-lookup"><span data-stu-id="e38d9-559">Instead, the average is 2000 cycles.</span></span>

<span data-ttu-id="e38d9-560">Dieses Ergebnis spiegelt eine in der Laufzeit, dem Treiber oder der GPU implementierte Status Änderungs Optimierung wider.</span><span class="sxs-lookup"><span data-stu-id="e38d9-560">This result reflects a state change optimization implemented in the runtime, the driver, or the GPU.</span></span> <span data-ttu-id="e38d9-561">In diesem Fall könnte der Treiber den ersten [**setrenderstate**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-setrenderstate) sehen und einen geänderten Zustand festlegen, der die Arbeit bis zu einem späteren Zeitpunkt verschiebt.</span><span class="sxs-lookup"><span data-stu-id="e38d9-561">In this case, the driver could see the first [**SetRenderState**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-setrenderstate) and set a dirty state which would postpone the work until later.</span></span> <span data-ttu-id="e38d9-562">Wenn der Treiber den zweiten **setrenderstate** sieht, könnte der gleiche geänderte Zustand redundant festgelegt werden, und die gleiche Arbeit würde erneut verschoben werden.</span><span class="sxs-lookup"><span data-stu-id="e38d9-562">When the driver sees the second **SetRenderState**, the same dirty state could be redundantly set and the same work would be postponed once again.</span></span> <span data-ttu-id="e38d9-563">Wenn [**drawprimitiv**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-drawprimitive) aufgerufen wird, wird die dem Zustand "geändert" zugeordnete Arbeit schließlich verarbeitet.</span><span class="sxs-lookup"><span data-stu-id="e38d9-563">When [**DrawPrimitive**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-drawprimitive) is called, the work associated with the dirty state is finally processed.</span></span> <span data-ttu-id="e38d9-564">Der Treiber führt die Arbeit einmal aus, was bedeutet, dass die ersten beiden Zustandsänderungen effektiv vom Treiber konsolidiert werden.</span><span class="sxs-lookup"><span data-stu-id="e38d9-564">The driver executes the work one time, which means that the first two state changes are effectively consolidated by the driver.</span></span> <span data-ttu-id="e38d9-565">Ebenso werden die dritten und vierten Zustandsänderungen durch den Treiber in eine einzelne Zustandsänderung konsolidiert, wenn der zweite **drawprimitiv** aufgerufen wird.</span><span class="sxs-lookup"><span data-stu-id="e38d9-565">Similarly, the third and fourth state changes are effectively consolidated by the driver into a single state change when the second **DrawPrimitive** is called.</span></span> <span data-ttu-id="e38d9-566">Das Ergebnis ist, dass der Treiber und die GPU eine einzelne Statusänderung für jeden zeichnen-Befehl verarbeiten.</span><span class="sxs-lookup"><span data-stu-id="e38d9-566">The net result is that the driver and the GPU process a single state change for each draw call.</span></span>

<span data-ttu-id="e38d9-567">Dies ist ein gutes Beispiel für eine Sequenz abhängige Treiber Optimierung.</span><span class="sxs-lookup"><span data-stu-id="e38d9-567">This is a good example of a sequence-dependent driver optimization.</span></span> <span data-ttu-id="e38d9-568">Der Treiber hat den Vorgang zweimal ausgeführt, indem er einen fehlerhaften Zustand festgelegt und die Arbeit dann einmal ausgeführt hat, um den geänderten Zustand zu löschen.</span><span class="sxs-lookup"><span data-stu-id="e38d9-568">The driver postponed work twice by setting a dirty state, and then performed the work once to clear the dirty state.</span></span> <span data-ttu-id="e38d9-569">Dies ist ein gutes Beispiel für die Art der Verbesserung der Effizienz, die durchgeführt werden kann, wenn die Arbeit bis zum absolut notwendig verzögert wird.</span><span class="sxs-lookup"><span data-stu-id="e38d9-569">This is a good example of the kind of efficiency improvement that can take place when work is deferred until absolutely necessary.</span></span>

<span data-ttu-id="e38d9-570">Woher wissen Sie, welche Zustandsänderungen intern einen fehlerhaften Zustand festlegen und daher die Arbeit bis zu einem späteren Zeitpunkt verschieben?</span><span class="sxs-lookup"><span data-stu-id="e38d9-570">How do you know which state changes set a dirty state internally and therefore postpone work until later?</span></span> <span data-ttu-id="e38d9-571">Nur durch das Testen von Rendering-Sequenzen (oder das Gespräch mit Treiber-Writer).</span><span class="sxs-lookup"><span data-stu-id="e38d9-571">Only by testing render sequences (or talking to driver writers).</span></span> <span data-ttu-id="e38d9-572">Treiber werden regelmäßig aktualisiert und verbessert, sodass die Liste der Optimierungen nicht statisch ist.</span><span class="sxs-lookup"><span data-stu-id="e38d9-572">Drivers are updated and improved periodically so the list of optimizations is not static.</span></span> <span data-ttu-id="e38d9-573">Es gibt nur eine Möglichkeit, um genau zu wissen, welche Zustandsänderung in einer bestimmten Rendering-Sequenz für einen bestimmten Satz von Hardwarekosten anfallen. und das soll Sie messen.</span><span class="sxs-lookup"><span data-stu-id="e38d9-573">There is only one way to absolutely know what a state change costs in a given render sequence, on a particular set of hardware; and that is to measure it.</span></span>

### <a name="watch-out-for-drawprimitive-optimizations"></a><span data-ttu-id="e38d9-574">Weitere Informationen zu drawprimitiven Optimierungen</span><span class="sxs-lookup"><span data-stu-id="e38d9-574">Watch Out for DrawPrimitive Optimizations</span></span>

<span data-ttu-id="e38d9-575">Zusätzlich zu den Optimierungen bei der Statusänderung versucht die Laufzeit, die Anzahl der Draw-Aufrufe zu optimieren, die der Treiber verarbeiten muss.</span><span class="sxs-lookup"><span data-stu-id="e38d9-575">In addition to state change optimizations, the runtime will attempt to optimize the number of draw calls that the driver has to process.</span></span> <span data-ttu-id="e38d9-576">Sehen Sie sich beispielsweise an, dass die Aufrufe zurück zeichnen:</span><span class="sxs-lookup"><span data-stu-id="e38d9-576">For example, consider these back to back draw calls:</span></span>


```
DrawPrimitive(D3DPT_TRIANGLELIST, 0, 3); // Draw 3 primitives, vertices 0 - 8
DrawPrimitive(D3DPT_TRIANGLELIST, 9, 4); // Draw 4 primitives, vertices 9 - 20
```



<span data-ttu-id="e38d9-577">Beispiel 5A: zwei Draw-Aufrufe</span><span class="sxs-lookup"><span data-stu-id="e38d9-577">Example 5a: Two Draw Calls</span></span>

<span data-ttu-id="e38d9-578">Diese Sequenz enthält zwei Draw-Aufrufe, die von der Laufzeit in einem einzelnen Aufruf konsolidiert werden, der entspricht:</span><span class="sxs-lookup"><span data-stu-id="e38d9-578">This sequence contains two draw calls, which the runtime will consolidate into a single call equivalent to:</span></span>


```
DrawPrimitive(D3DPT_TRIANGLELIST, 0, 7); // Draw 7 primitives, vertices 0 - 20
```



<span data-ttu-id="e38d9-579">Beispiel 5B: ein einzelner verketteten zeichnen-Befehl</span><span class="sxs-lookup"><span data-stu-id="e38d9-579">Example 5b: A Single Concatenated Draw Call</span></span>

<span data-ttu-id="e38d9-580">Die Laufzeit verkettet beide zeichnen-Aufrufe in einem einzelnen Aufruf, wodurch die Treiber Arbeit um 50 Prozent reduziert wird, da der Treiber jetzt nur einen Draw-Aufruf verarbeiten muss.</span><span class="sxs-lookup"><span data-stu-id="e38d9-580">The runtime will concatenate both of these particular draw calls into a single call, which reduces the driver work by 50 percent because the driver will now only need to process one draw call.</span></span>

<span data-ttu-id="e38d9-581">Im allgemeinen verkettet die Common Language Runtime zwei oder mehr Rückrufe für [**drawprimitive**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-drawprimitive) , wenn Folgendes gilt:</span><span class="sxs-lookup"><span data-stu-id="e38d9-581">In general, the runtime will concatenate two or more back-to-back [**DrawPrimitive**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-drawprimitive) calls when:</span></span>

1.  <span data-ttu-id="e38d9-582">Der primitive Typ ist eine Dreiecks Liste (D3DPT \_ trianglelist).</span><span class="sxs-lookup"><span data-stu-id="e38d9-582">The primitive type is a triangle list (D3DPT\_TRIANGLELIST).</span></span>
2.  <span data-ttu-id="e38d9-583">Jeder aufeinander folgende [**drawprimitive**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-drawprimitive) -Befehl muss auf aufeinander folgende Vertices innerhalb des Vertexpuffers verweisen.</span><span class="sxs-lookup"><span data-stu-id="e38d9-583">Each successive [**DrawPrimitive**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-drawprimitive) call must reference consecutive vertices within the vertex buffer.</span></span>

<span data-ttu-id="e38d9-584">Analog dazu sind die richtigen Bedingungen zum Verketten zweier oder mehrerer Rückrufe von [**DrawIndexedPrimitive**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-drawindexedprimitive) :</span><span class="sxs-lookup"><span data-stu-id="e38d9-584">Similarly, the right conditions for concatenating two or more back-to-back [**DrawIndexedPrimitive**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-drawindexedprimitive) calls are:</span></span>

1.  <span data-ttu-id="e38d9-585">Der primitive Typ ist eine Dreiecks Liste (D3DPT \_ trianglelist).</span><span class="sxs-lookup"><span data-stu-id="e38d9-585">The primitive type is a triangle list (D3DPT\_TRIANGLELIST).</span></span>
2.  <span data-ttu-id="e38d9-586">Jeder aufeinanderfolgende [**drawindexedprimitiver**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-drawindexedprimitive) -Befehl muss aufeinander folgende Indizes im Index Puffer sequenziell referenzieren.</span><span class="sxs-lookup"><span data-stu-id="e38d9-586">Each successive [**DrawIndexedPrimitive**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-drawindexedprimitive) call must sequential reference consecutive indices within the index buffer.</span></span>
3.  <span data-ttu-id="e38d9-587">Jeder aufeinanderfolgende [**drawindexedprimitiver**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-drawindexedprimitive) -Befehl muss für basevertexindex denselben Wert verwenden.</span><span class="sxs-lookup"><span data-stu-id="e38d9-587">Each successive [**DrawIndexedPrimitive**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-drawindexedprimitive) call must use the same value for BaseVertexIndex.</span></span>

<span data-ttu-id="e38d9-588">Um die Verkettung während der Profilerstellung zu verhindern, ändern Sie die rendersequenz so, dass der primitive Typ keine Dreiecks Liste ist, oder ändern Sie die rendersequenz so, dass keine Back-to-Back-Draw-Aufrufe vorhanden sind, die aufeinander folgende Vertices (oder Indizes) verwenden.</span><span class="sxs-lookup"><span data-stu-id="e38d9-588">To prevent concatenation during profiling, modify the render sequence so that the primitive type is not a triangle list, or modify the render sequence so that there are no back-to-back draw calls that use consecutive vertices (or indices).</span></span> <span data-ttu-id="e38d9-589">Genauer gesagt werden von der Laufzeit auch Draw-Aufrufe verkettet, die die beiden folgenden Bedingungen erfüllen:</span><span class="sxs-lookup"><span data-stu-id="e38d9-589">More specifically, the runtime will also concatenate draw calls that meet both of the following conditions:</span></span>

-   <span data-ttu-id="e38d9-590">Wenn der vorherige-Befehl [**drawprimitiv**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-drawprimitive)ist, wenn der nächste Draw-Befehl:</span><span class="sxs-lookup"><span data-stu-id="e38d9-590">When the previous call is [**DrawPrimitive**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-drawprimitive), if the next draw call:</span></span>
    -   <span data-ttu-id="e38d9-591">verwendet eine Dreiecks Liste und</span><span class="sxs-lookup"><span data-stu-id="e38d9-591">uses a triangle list, AND</span></span>
    -   <span data-ttu-id="e38d9-592">Gibt den startVertex = Vorheriges startVertex + vorherige primitivecount 3 an. \*</span><span class="sxs-lookup"><span data-stu-id="e38d9-592">specifies the StartVertex = previous StartVertex + previous PrimitiveCount \* 3</span></span>
-   <span data-ttu-id="e38d9-593">Wenn beim nächsten zeichnen-Befehl [**drawindexedprimitiv**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-drawindexedprimitive)verwendet wird:</span><span class="sxs-lookup"><span data-stu-id="e38d9-593">When using [**DrawIndexedPrimitive**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-drawindexedprimitive), if the next draw call:</span></span>
    -   <span data-ttu-id="e38d9-594">verwendet eine Dreiecks Liste und</span><span class="sxs-lookup"><span data-stu-id="e38d9-594">uses a triangle list, AND</span></span>
    -   <span data-ttu-id="e38d9-595">Gibt die Start Index = Previous startIndex + Previous primitivecount \* 3 und</span><span class="sxs-lookup"><span data-stu-id="e38d9-595">specifies the StartIndex = previous StartIndex + previous PrimitiveCount \* 3, AND</span></span>
    -   <span data-ttu-id="e38d9-596">Gibt den basevertexindex = Previous basevertexindex an.</span><span class="sxs-lookup"><span data-stu-id="e38d9-596">specifies the BaseVertexIndex = previous BaseVertexIndex</span></span>

<span data-ttu-id="e38d9-597">Im folgenden finden Sie ein feineres Beispiel für die Verkettung von zeichnen-aufrufen, die bei der Profilerstellung leicht zu übersehen ist.</span><span class="sxs-lookup"><span data-stu-id="e38d9-597">Here is a more subtle example of draw call concatenation that is easy to overlook when you are profiling.</span></span> <span data-ttu-id="e38d9-598">Angenommen, die Rendering-Sequenz sieht wie folgt aus:</span><span class="sxs-lookup"><span data-stu-id="e38d9-598">Assume the render sequence looks like this:</span></span>


```
  for(int i = 0; i < 1500; i++)
  {
    SetTexture(...);
    DrawPrimitive(D3DPT_TRIANGLELIST, i*3, 1);
  }
```



<span data-ttu-id="e38d9-599">Beispiel 5C: eine Zustandsänderung und ein zeichnen-Befehl</span><span class="sxs-lookup"><span data-stu-id="e38d9-599">Example 5c: One State Change and One Draw Call</span></span>

<span data-ttu-id="e38d9-600">Die Schleife durchläuft 1500 Dreiecke, legt eine Textur fest und zeichnet jedes Dreieck.</span><span class="sxs-lookup"><span data-stu-id="e38d9-600">The loop iterates through 1500 triangles, setting a texture and drawing each triangle.</span></span> <span data-ttu-id="e38d9-601">Diese Renderschleife dauert ungefähr 2750 Zyklen für die [**SetTexture**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-settexture) -und 1100-Zyklen für [**drawprimitive**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-drawprimitive) , wie in den vorherigen Abschnitten gezeigt.</span><span class="sxs-lookup"><span data-stu-id="e38d9-601">This render loop takes approximately 2750 cycles for [**SetTexture**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-settexture) and 1100 cycles for [**DrawPrimitive**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-drawprimitive) as shown in previous sections.</span></span> <span data-ttu-id="e38d9-602">Sie werden möglicherweise intuitiv davon ausgehen, dass das Verschieben von **SetTexture** außerhalb der Renderschleife die vom Treiber ausgeführte Menge an Arbeit um 1500 \* 2750 Zyklen verringern sollte. Dies ist der Arbeitsaufwand, der mit dem Aufrufen von **SetTexture** 1500-mal verbunden ist.</span><span class="sxs-lookup"><span data-stu-id="e38d9-602">You might intuitively expect that moving **SetTexture** outside the render loop should reduce the amount of work done by the driver by 1500 \* 2750 cycles, which is the amount of work associated with calling **SetTexture** 1500 times.</span></span> <span data-ttu-id="e38d9-603">Der Code Ausschnitt würde wie folgt aussehen:</span><span class="sxs-lookup"><span data-stu-id="e38d9-603">The code snippet would look like this:</span></span>


```
  SetTexture(...); // Set the state outside the loop
  for(int i = 0; i < 1500; i++)
  {
//    SetTexture(...);
    DrawPrimitive(D3DPT_TRIANGLELIST, i*3, 1);
  }
```



<span data-ttu-id="e38d9-604">Beispiel 5D: Beispiel 5C mit der Zustandsänderung außerhalb der Schleife</span><span class="sxs-lookup"><span data-stu-id="e38d9-604">Example 5d: Example 5c with the State Change Outside the Loop</span></span>

<span data-ttu-id="e38d9-605">Durch das Verschieben von [**SetTexture**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-settexture) außerhalb der Renderschleife wird die Menge an Arbeit reduziert, die **SetTexture** zugeordnet ist, da Sie einmal anstelle von 1500 Mal aufgerufen wird.</span><span class="sxs-lookup"><span data-stu-id="e38d9-605">Moving [**SetTexture**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-settexture) outside the render loop does reduce the amount of work associated with **SetTexture** since it is called once instead of 1500 times.</span></span> <span data-ttu-id="e38d9-606">Ein weniger offensichtlicher sekundärer Effekt ist, dass die Arbeit für [**drawprimitiv**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-drawprimitive) auch von 1500 aufrufen auf einen Aufruf reduziert wird, da alle Bedingungen zum Verketten von zeichnen-aufrufen erfüllt sind.</span><span class="sxs-lookup"><span data-stu-id="e38d9-606">A less obvious secondary effect is that the work for [**DrawPrimitive**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-drawprimitive) is also reduced from 1500 calls to 1 call because all of the conditions for concatenating draw calls are satisfied.</span></span> <span data-ttu-id="e38d9-607">Wenn die Rendering-Sequenz verarbeitet wird, verarbeitet die Laufzeit 1500-Aufrufe an einen einzelnen Treiber Aufruf.</span><span class="sxs-lookup"><span data-stu-id="e38d9-607">When the render sequence is processed, the runtime will process 1500 calls into a single driver call.</span></span> <span data-ttu-id="e38d9-608">Wenn Sie diese eine Codezeile verschieben, wurde die Menge der Treiber Arbeit drastisch reduziert:</span><span class="sxs-lookup"><span data-stu-id="e38d9-608">By moving this one line of code, the amount of driver work has been reduced dramatically:</span></span>


```
total work done = runtime + driver work

Example 5c: with SetTexture in the loop:
runtime work = 1500 SetTextures + 1500 DrawPrimitives 
driver  work = 1500 SetTextures + 1500 DrawPrimitives 

Example 5d: with SetTexture outside of the loop:
runtime work = 1 SetTexture + 1 DrawPrimitive + 1499 Concatenated DrawPrimitives 
driver  work = 1 SetTexture + 1 DrawPrimitive 
```



<span data-ttu-id="e38d9-609">Diese Ergebnisse sind vollständig richtig, sind jedoch im Kontext der ursprünglichen Frage sehr irreführend.</span><span class="sxs-lookup"><span data-stu-id="e38d9-609">These results are entirely correct, but are very misleading in the context of the original question.</span></span> <span data-ttu-id="e38d9-610">Die Optimierung des Draw-Aufrufes hat bewirkt, dass die Menge der Treiber Arbeit drastisch reduziert wurde.</span><span class="sxs-lookup"><span data-stu-id="e38d9-610">The draw call optimization has caused the amount of driver work to be dramatically reduced.</span></span> <span data-ttu-id="e38d9-611">Dies ist ein häufiges Problem bei der benutzerdefinierten Profilerstellung.</span><span class="sxs-lookup"><span data-stu-id="e38d9-611">This is a common problem when doing custom profiling.</span></span> <span data-ttu-id="e38d9-612">Wenn Sie Aufrufe aus einer Rendering-Sequenz entfernen, achten Sie darauf, die Verkettung von Draw-aufrufen zu vermeiden.</span><span class="sxs-lookup"><span data-stu-id="e38d9-612">When eliminating calls from a render sequence, be careful to avoid draw call concatenation.</span></span> <span data-ttu-id="e38d9-613">Tatsächlich handelt es sich hierbei um ein leistungsfähiges Beispiel für den Umfang der Verbesserung der Treiber Leistung, die durch diese Lauf Zeitoptimierung möglich ist.</span><span class="sxs-lookup"><span data-stu-id="e38d9-613">In fact, this scenario is a powerful example of the amount of improvement in driver performance possible by this runtime optimization.</span></span>

<span data-ttu-id="e38d9-614">Nun wissen Sie, wie Zustandsänderungen gemessen werden.</span><span class="sxs-lookup"><span data-stu-id="e38d9-614">So now you know how to measure state changes.</span></span> <span data-ttu-id="e38d9-615">Starten Sie die Profilerstellung für [**drawprimitiv**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-drawprimitive).</span><span class="sxs-lookup"><span data-stu-id="e38d9-615">Start by profiling [**DrawPrimitive**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-drawprimitive).</span></span> <span data-ttu-id="e38d9-616">Fügen Sie dann jede weitere Zustandsänderung der Sequenz hinzu (in einigen Fällen durch Hinzufügen eines Aufrufs und in anderen Fällen durch Hinzufügen von zwei aufrufen), und Messen Sie den Unterschied zwischen den beiden Sequenzen.</span><span class="sxs-lookup"><span data-stu-id="e38d9-616">Then add each additional state change to the sequence (in some cases adding one call and in other cases adding two calls) and measure the difference between the two sequences.</span></span> <span data-ttu-id="e38d9-617">Sie können die Ergebnisse in Ticks oder Zyklen oder Zeit konvertieren.</span><span class="sxs-lookup"><span data-stu-id="e38d9-617">You can convert the results to ticks or cycles or time.</span></span> <span data-ttu-id="e38d9-618">Ebenso wie das Messen von rendersequenzen mit QueryPerformanceCounter basiert das Messen einzelner Zustandsänderungen auf dem Abfrage Mechanismus zum Steuern des Befehls Puffers und dem Einfügen der Zustandsänderungen in einer Schleife, um die Auswirkungen der Modus-Übergänge zu minimieren.</span><span class="sxs-lookup"><span data-stu-id="e38d9-618">Just like measuring render sequences with QueryPerformanceCounter, measuring individual state changes relies on the query mechanism to control the command buffer, and putting the state changes in a loop to minimize the impact of the mode transitions.</span></span> <span data-ttu-id="e38d9-619">Mit dieser Technik werden die Kosten für das Umschalten eines Zustands gemessen, da der Profiler den Durchschnitt der Aktivierung und Deaktivierung des Zustands zurückgibt.</span><span class="sxs-lookup"><span data-stu-id="e38d9-619">This technique measures the cost of toggling a state, since the profiler returns the average of enabling and disabling the state.</span></span>

<span data-ttu-id="e38d9-620">Mit dieser Funktion können Sie beginnen, beliebige renderingsequenzen zu erzeugen und die zugeordnete Lauf Zeit-und Treiber Arbeit genau zu messen.</span><span class="sxs-lookup"><span data-stu-id="e38d9-620">With this capability, you can start generating arbitrary rendering sequences and accurately measuring the associated runtime and driver work.</span></span> <span data-ttu-id="e38d9-621">Die Zahlen können dann verwendet werden, um Budgetierungs Fragen zu beantworten, wie z. b. "wie viele dieser Aufrufe in der Rendering-Sequenz erfolgen können, während gleichzeitig eine angemessene Framerate beibehalten wird.</span><span class="sxs-lookup"><span data-stu-id="e38d9-621">The numbers can then be used to answer budgeting questions like "how many more of these calls" can be made in the render sequence while still maintaining a reasonable frame rate, assuming CPU-limited scenarios.</span></span>

## <a name="summary"></a><span data-ttu-id="e38d9-622">Zusammenfassung</span><span class="sxs-lookup"><span data-stu-id="e38d9-622">Summary</span></span>

<span data-ttu-id="e38d9-623">In diesem Artikel wird veranschaulicht, wie der Befehls Puffer gesteuert werden kann, sodass für einzelne Aufrufe eine exakte Profilerstellung durchgeführt werden kann.</span><span class="sxs-lookup"><span data-stu-id="e38d9-623">This paper demonstrates how to control the command buffer so that individual calls can be accurately profiled.</span></span> <span data-ttu-id="e38d9-624">Die Profil Erstellungs Nummern können in Ticks, Zyklen oder absoluter Zeit generiert werden.</span><span class="sxs-lookup"><span data-stu-id="e38d9-624">The profiling numbers can be generated in ticks, cycles, or absolute time.</span></span> <span data-ttu-id="e38d9-625">Sie stellen die Menge der Lauf Zeit-und Treiber Arbeit dar, die den einzelnen API-Anrufen zugeordnet sind.</span><span class="sxs-lookup"><span data-stu-id="e38d9-625">They represent the amount of runtime and driver work associated with each API call.</span></span>

<span data-ttu-id="e38d9-626">Beginnen Sie mit der Profilerstellung eines \* primitiven Aufrufes Aufrufes in einer-Rendering</span><span class="sxs-lookup"><span data-stu-id="e38d9-626">Start by profiling a Draw\*Primitive call in a render sequence.</span></span> <span data-ttu-id="e38d9-627">Beachten Sie Folgendes:</span><span class="sxs-lookup"><span data-stu-id="e38d9-627">Remember to:</span></span>

1.  <span data-ttu-id="e38d9-628">Verwenden Sie QueryPerformanceCounter, um die Anzahl der Ticks pro API-Aufrufe zu messen.</span><span class="sxs-lookup"><span data-stu-id="e38d9-628">Use QueryPerformanceCounter to measure the number of ticks per API call.</span></span> <span data-ttu-id="e38d9-629">Verwenden Sie QueryPerformanceFrequency, um die Ergebnisse in Zyklen oder Zeit zu konvertieren, wenn Sie möchten.</span><span class="sxs-lookup"><span data-stu-id="e38d9-629">Use QueryPerformanceFrequency to convert the results to cycles or time if you like.</span></span>
2.  <span data-ttu-id="e38d9-630">Verwenden Sie den Abfrage Mechanismus, um den Befehls Puffer vor dem Starten zu leeren.</span><span class="sxs-lookup"><span data-stu-id="e38d9-630">Use the query mechanism to empty the command buffer before starting.</span></span>
3.  <span data-ttu-id="e38d9-631">Schließen Sie die rendersequenz in eine Schleife ein, um die Auswirkung des modusübergangs zu minimieren.</span><span class="sxs-lookup"><span data-stu-id="e38d9-631">Include the render sequence in a loop to minimize the impact of the mode transition.</span></span>
4.  <span data-ttu-id="e38d9-632">Verwenden Sie den Abfrage Mechanismus, um zu messen, wann die GPU ihre Arbeit abgeschlossen hat.</span><span class="sxs-lookup"><span data-stu-id="e38d9-632">Use the query mechanism to measure when the GPU has completed its work.</span></span>
5.  <span data-ttu-id="e38d9-633">Achten Sie auf die Lauf Zeit Verkettung, bei der der Umfang der Arbeit maßgeblich beeinträchtigt wird.</span><span class="sxs-lookup"><span data-stu-id="e38d9-633">Watch out for runtime concatenation that will have a major impact on the amount of work done.</span></span>

<span data-ttu-id="e38d9-634">Dadurch erhalten Sie eine grundlegende Leistung für [**drawprimitive**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-drawprimitive) , die zum Erstellen von verwendet werden kann.</span><span class="sxs-lookup"><span data-stu-id="e38d9-634">This gives you a baseline performance for [**DrawPrimitive**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-drawprimitive) that can be used to build from.</span></span> <span data-ttu-id="e38d9-635">Zum Erstellen eines Profils für eine Statusänderung folgen Sie den folgenden zusätzlichen Tipps:</span><span class="sxs-lookup"><span data-stu-id="e38d9-635">To profile one state change, follow these additional tips:</span></span>

1.  <span data-ttu-id="e38d9-636">Fügen Sie die Zustandsänderung zu einem bekannten Rendering-Sequenz Profil der neuen Sequenz hinzu.</span><span class="sxs-lookup"><span data-stu-id="e38d9-636">Add the state change to a known render sequence profile the new sequence.</span></span> <span data-ttu-id="e38d9-637">Da die Tests in einer-Schleife durchgeführt werden, muss der Zustand zweimal in umgekehrten Werten festgelegt werden (z. b. aktivieren und deaktivieren).</span><span class="sxs-lookup"><span data-stu-id="e38d9-637">Since the testing is done in a loop, this requires setting the state twice into opposite values (like enable and disable for instance).</span></span>
2.  <span data-ttu-id="e38d9-638">Vergleichen Sie den Unterschied in den Zyklen zwischen den zwei Sequenzen.</span><span class="sxs-lookup"><span data-stu-id="e38d9-638">Compare the difference in cycle times between the two sequences.</span></span>
3.  <span data-ttu-id="e38d9-639">Bei Zustandsänderungen, die die Pipeline erheblich ändern (z. b. [**SetTexture**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-settexture)), subtrahieren Sie die Differenz zwischen den beiden Sequenzen, um die Zeit für die Zustandsänderung zu erhalten.</span><span class="sxs-lookup"><span data-stu-id="e38d9-639">For state changes that significantly change the pipeline (like [**SetTexture**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-settexture)), subtract the difference between the two sequences to get the time for state change.</span></span>
4.  <span data-ttu-id="e38d9-640">Bei Zustandsänderungen, bei denen die Pipeline erheblich geändert wird (und daher ein-/Ausschalten von Zuständen wie z. b. "\* Trend Name" erforderlich ist), wird der Unterschied zwischen den [**rendersequenzen**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-setrenderstate)subtrahiert</span><span class="sxs-lookup"><span data-stu-id="e38d9-640">For state changes that significantly change the pipeline (and therefore require toggling states like [**SetRenderState**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-setrenderstate)), subtract the difference between the render sequences and divide by 2.</span></span> <span data-ttu-id="e38d9-641">Dadurch wird die durchschnittliche Anzahl von Zyklen für jede Zustandsänderung generiert.</span><span class="sxs-lookup"><span data-stu-id="e38d9-641">This will generate the average number of cycles for each state change.</span></span>

<span data-ttu-id="e38d9-642">Seien Sie jedoch vorsichtig mit Optimierungen, die bei der Profilerstellung unerwartete Ergebnisse verursachen.</span><span class="sxs-lookup"><span data-stu-id="e38d9-642">But be careful of optimizations that cause unexpected results when profiling.</span></span> <span data-ttu-id="e38d9-643">Mit Status Änderungs Optimierungen können geänderte Zustände festgelegt werden, die dazu führten, dass die Arbeit verzögert wird.</span><span class="sxs-lookup"><span data-stu-id="e38d9-643">State change optimizations may set dirty states which causes work to be deferred.</span></span> <span data-ttu-id="e38d9-644">Dies kann zu Profil Ergebnissen führen, die nicht so intuitiv wie erwartet sind.</span><span class="sxs-lookup"><span data-stu-id="e38d9-644">This can cause profile results which are not as intuitive as expected.</span></span> <span data-ttu-id="e38d9-645">Zeichnen-Befehle, die verkettet werden, reduzieren die Treiber Arbeit drastisch, was zu irreführenden Schlussfolgerungen führen kann.</span><span class="sxs-lookup"><span data-stu-id="e38d9-645">Draw calls that are concatenated will dramatically reduce driver work which can lead to misleading conclusions.</span></span> <span data-ttu-id="e38d9-646">Sorgfältig geplante rendersequenzen werden verwendet, um die Verkettung von Zustandsänderungen und Draw-aufrufen zu verhindern.</span><span class="sxs-lookup"><span data-stu-id="e38d9-646">Carefully planned render sequences are used to prevent state change and draw call concatenations from occurring.</span></span> <span data-ttu-id="e38d9-647">Der Trick besteht darin, zu verhindern, dass die Optimierungen während der Profilerstellung durchgeführt werden, sodass die von Ihnen generierten Zahlen sinnvolle Budgetzahlen sind.</span><span class="sxs-lookup"><span data-stu-id="e38d9-647">The trick is to prevent the optimizations from happening during profiling so that the numbers you generate are reasonable budgeting numbers.</span></span>

> [!Note]  
> <span data-ttu-id="e38d9-648">Das Duplizieren dieser Profil Erstellungs Strategie in einer Anwendung ohne den Abfrage Mechanismus ist schwieriger.</span><span class="sxs-lookup"><span data-stu-id="e38d9-648">Duplicating this profiling strategy in an application without the query mechanism is more difficult.</span></span> <span data-ttu-id="e38d9-649">Vor Direct3D 9 besteht die einzige vorhersagbare Möglichkeit zum Leeren des Befehls Puffers darin, eine aktive Oberfläche (z. b. ein Renderziel) zu sperren, um zu warten, bis die GPU im Leerlauf ist</span><span class="sxs-lookup"><span data-stu-id="e38d9-649">Prior to Direct3D 9 the only predictable way to empty the command buffer is to lock an active surface (such as a render target) to wait until the GPU is idle.</span></span> <span data-ttu-id="e38d9-650">Dies liegt daran, dass das Sperren einer Oberfläche die Laufzeit zum Leeren des Befehls Puffers zwingt, wenn im Puffer renderbefehle vorhanden sind, die die Oberfläche vor dem Sperren aktualisieren sollten, zusätzlich zum warten auf den Abschluss der GPU.</span><span class="sxs-lookup"><span data-stu-id="e38d9-650">This is because locking a surface forces the runtime to empty the command buffer in case there are any rendering commands in the buffer that should update the surface before it gets locked, in addition to waiting for the GPU to finish.</span></span> <span data-ttu-id="e38d9-651">Diese Technik ist funktionsfähig, auch wenn Sie mit dem in Direct3D 9 eingeführten Abfrage Mechanismus besser verwahrter ist.</span><span class="sxs-lookup"><span data-stu-id="e38d9-651">This technique is functional, although it is more obtrusive that using the query mechanism introduced in Direct3D 9.</span></span>

 

## <a name="appendix"></a><span data-ttu-id="e38d9-652">Anhang</span><span class="sxs-lookup"><span data-stu-id="e38d9-652">Appendix</span></span>

<span data-ttu-id="e38d9-653">Bei den Zahlen in dieser Tabelle handelt es sich um einen Bereich von Näherungen für die Laufzeit-und Treiber Arbeit, die mit den einzelnen Statusänderungen verknüpft ist.</span><span class="sxs-lookup"><span data-stu-id="e38d9-653">The numbers in this table are a range of approximations for the amount of runtime and driver work associated with each of these state changes.</span></span> <span data-ttu-id="e38d9-654">Die Näherungs Werte basieren auf den tatsächlichen Messungen von Treibern, die die im Dokument gezeigten Verfahren verwenden.</span><span class="sxs-lookup"><span data-stu-id="e38d9-654">The approximations are based on actual measurements made on drivers using the techniques shown in the paper.</span></span> <span data-ttu-id="e38d9-655">Diese Zahlen wurden mit der Direct3D 9-Laufzeit generiert und sind Treiber abhängig.</span><span class="sxs-lookup"><span data-stu-id="e38d9-655">These numbers were generated using the Direct3D 9 runtime and are driver-dependent.</span></span>

<span data-ttu-id="e38d9-656">Die Verfahren in diesem Artikel sind so konzipiert, dass die Laufzeit und die Treiber Arbeit gemessen werden.</span><span class="sxs-lookup"><span data-stu-id="e38d9-656">The techniques in this paper are designed to measure runtime and driver work.</span></span> <span data-ttu-id="e38d9-657">Im Allgemeinen ist es nicht praktikabel, Ergebnisse bereitzustellen, die der Leistung der CPU und der GPU in jeder Anwendung entsprechen, da dies ein umfassendes Array von Rendering-Sequenzen erfordern würde.</span><span class="sxs-lookup"><span data-stu-id="e38d9-657">In general, it is impractical to provide results that match the performance of the CPU and the GPU in every application as this would require an exhaustive array of render sequences.</span></span> <span data-ttu-id="e38d9-658">Außerdem ist es besonders schwierig, die Leistung der GPU zu messen, da Sie stark von der Zustands Einrichtung in der Pipeline vor der Rendering-Sequenz abhängt.</span><span class="sxs-lookup"><span data-stu-id="e38d9-658">In addition, it is particularly difficult to benchmark performance of the GPU because it is highly dependent on the state setup in the pipeline before the render sequence.</span></span> <span data-ttu-id="e38d9-659">Beispielsweise hat das Aktivieren von Alpha Blending kaum Auswirkungen auf die erforderliche CPU-Arbeit, kann jedoch eine große Auswirkung auf die von der GPU ausgeführte Arbeitsauslastung haben.</span><span class="sxs-lookup"><span data-stu-id="e38d9-659">For instance, enabling alpha blending does little to affect the amount of CPU work necessary, but can have a big impact on the amount of work done by the GPU.</span></span> <span data-ttu-id="e38d9-660">Aus diesem Grund schränken die Verfahren in diesem Artikel die GPU auf den minimal möglichen Betrag ein, indem Sie die Menge der Daten einschränken, die gerendert werden müssen.</span><span class="sxs-lookup"><span data-stu-id="e38d9-660">Therefore, the techniques in this paper constrain the GPU work to the minimum amount possible by limiting the amount of data that needs to be rendered.</span></span> <span data-ttu-id="e38d9-661">Dies bedeutet, dass die Zahlen in der Tabelle am ehesten mit den Ergebnissen übereinstimmen, die von Anwendungen erzielt werden, die CPU-beschränkt sind (im Gegensatz zu einer Anwendung, die durch die GPU eingeschränkt ist).</span><span class="sxs-lookup"><span data-stu-id="e38d9-661">This means that the numbers in the table will most closely match the results attained from applications that are CPU limited (as opposed to an application that is limited by the GPU).</span></span>

<span data-ttu-id="e38d9-662">Es wird empfohlen, die vorgestellten Techniken zu verwenden, um die für Sie wichtigsten Szenarien und Konfigurationen abzudecken.</span><span class="sxs-lookup"><span data-stu-id="e38d9-662">You are encouraged to use the techniques presented to cover the scenarios and configurations most important to you.</span></span> <span data-ttu-id="e38d9-663">Die Werte in der Tabelle können verwendet werden, um mit den von Ihnen generierten Zahlen zu vergleichen.</span><span class="sxs-lookup"><span data-stu-id="e38d9-663">The values in the table can be used to compare with the numbers you generate.</span></span> <span data-ttu-id="e38d9-664">Da jeder Treiber variiert, ist die einzige Möglichkeit zum Generieren der tatsächlichen Zahlen, die Sie sehen, das Generieren von Profil Erstellungs Ergebnissen mithilfe ihrer Szenarien.</span><span class="sxs-lookup"><span data-stu-id="e38d9-664">Since each driver varies, the only way to generate the actual numbers you will see is to generate profiling results using your scenarios.</span></span>



| <span data-ttu-id="e38d9-665">API-Aufruf</span><span class="sxs-lookup"><span data-stu-id="e38d9-665">API Call</span></span>                             | <span data-ttu-id="e38d9-666">Durchschnittliche Anzahl von Zyklen</span><span class="sxs-lookup"><span data-stu-id="e38d9-666">Average number of Cycles</span></span> |
|--------------------------------------|--------------------------|
| <span data-ttu-id="e38d9-667">Setvertexdeclaration</span><span class="sxs-lookup"><span data-stu-id="e38d9-667">SetVertexDeclaration</span></span>                 | <span data-ttu-id="e38d9-668">6500-11250</span><span class="sxs-lookup"><span data-stu-id="e38d9-668">6500 - 11250</span></span>             |
| <span data-ttu-id="e38d9-669">Setf-VF</span><span class="sxs-lookup"><span data-stu-id="e38d9-669">SetFVF</span></span>                               | <span data-ttu-id="e38d9-670">6400-11200</span><span class="sxs-lookup"><span data-stu-id="e38d9-670">6400 - 11200</span></span>             |
| <span data-ttu-id="e38d9-671">Setvertexshader</span><span class="sxs-lookup"><span data-stu-id="e38d9-671">SetVertexShader</span></span>                      | <span data-ttu-id="e38d9-672">3000-12100</span><span class="sxs-lookup"><span data-stu-id="e38d9-672">3000 - 12100</span></span>             |
| <span data-ttu-id="e38d9-673">Setpixelshader</span><span class="sxs-lookup"><span data-stu-id="e38d9-673">SetPixelShader</span></span>                       | <span data-ttu-id="e38d9-674">6300-7000</span><span class="sxs-lookup"><span data-stu-id="e38d9-674">6300 - 7000</span></span>              |
| <span data-ttu-id="e38d9-675">Specularenable</span><span class="sxs-lookup"><span data-stu-id="e38d9-675">SPECULARENABLE</span></span>                       | <span data-ttu-id="e38d9-676">1900-11200</span><span class="sxs-lookup"><span data-stu-id="e38d9-676">1900 - 11200</span></span>             |
| <span data-ttu-id="e38d9-677">"Zielort"</span><span class="sxs-lookup"><span data-stu-id="e38d9-677">SetRenderTarget</span></span>                      | <span data-ttu-id="e38d9-678">6000-6250</span><span class="sxs-lookup"><span data-stu-id="e38d9-678">6000 - 6250</span></span>              |
| <span data-ttu-id="e38d9-679">Setpixelshaderconstant (1-Konstante)</span><span class="sxs-lookup"><span data-stu-id="e38d9-679">SetPixelShaderConstant (1 Constant)</span></span>  | <span data-ttu-id="e38d9-680">1500-9000</span><span class="sxs-lookup"><span data-stu-id="e38d9-680">1500 - 9000</span></span>              |
| <span data-ttu-id="e38d9-681">Normalizenormals</span><span class="sxs-lookup"><span data-stu-id="e38d9-681">NORMALIZENORMALS</span></span>                     | <span data-ttu-id="e38d9-682">2200-8100</span><span class="sxs-lookup"><span data-stu-id="e38d9-682">2200 - 8100</span></span>              |
| <span data-ttu-id="e38d9-683">Lightenable</span><span class="sxs-lookup"><span data-stu-id="e38d9-683">LightEnable</span></span>                          | <span data-ttu-id="e38d9-684">1300-9000</span><span class="sxs-lookup"><span data-stu-id="e38d9-684">1300 - 9000</span></span>              |
| <span data-ttu-id="e38d9-685">SetStreamSource</span><span class="sxs-lookup"><span data-stu-id="e38d9-685">SetStreamSource</span></span>                      | <span data-ttu-id="e38d9-686">3700-5800</span><span class="sxs-lookup"><span data-stu-id="e38d9-686">3700 - 5800</span></span>              |
| <span data-ttu-id="e38d9-687">Sonder</span><span class="sxs-lookup"><span data-stu-id="e38d9-687">LIGHTING</span></span>                             | <span data-ttu-id="e38d9-688">1700-7500</span><span class="sxs-lookup"><span data-stu-id="e38d9-688">1700 - 7500</span></span>              |
| <span data-ttu-id="e38d9-689">DiffuseMaterialSource</span><span class="sxs-lookup"><span data-stu-id="e38d9-689">DIFFUSEMATERIALSOURCE</span></span>                | <span data-ttu-id="e38d9-690">900-8300</span><span class="sxs-lookup"><span data-stu-id="e38d9-690">900 - 8300</span></span>               |
| <span data-ttu-id="e38d9-691">AmbientMaterialSource</span><span class="sxs-lookup"><span data-stu-id="e38d9-691">AMBIENTMATERIALSOURCE</span></span>                | <span data-ttu-id="e38d9-692">900-8200</span><span class="sxs-lookup"><span data-stu-id="e38d9-692">900 - 8200</span></span>               |
| <span data-ttu-id="e38d9-693">ColorVertex</span><span class="sxs-lookup"><span data-stu-id="e38d9-693">COLORVERTEX</span></span>                          | <span data-ttu-id="e38d9-694">800-7800</span><span class="sxs-lookup"><span data-stu-id="e38d9-694">800 - 7800</span></span>               |
| <span data-ttu-id="e38d9-695">Setlight</span><span class="sxs-lookup"><span data-stu-id="e38d9-695">SetLight</span></span>                             | <span data-ttu-id="e38d9-696">2200-5100</span><span class="sxs-lookup"><span data-stu-id="e38d9-696">2200 - 5100</span></span>              |
| <span data-ttu-id="e38d9-697">SetTransform</span><span class="sxs-lookup"><span data-stu-id="e38d9-697">SetTransform</span></span>                         | <span data-ttu-id="e38d9-698">3200-3750</span><span class="sxs-lookup"><span data-stu-id="e38d9-698">3200 - 3750</span></span>              |
| <span data-ttu-id="e38d9-699">Setindizes</span><span class="sxs-lookup"><span data-stu-id="e38d9-699">SetIndices</span></span>                           | <span data-ttu-id="e38d9-700">900-5600</span><span class="sxs-lookup"><span data-stu-id="e38d9-700">900 - 5600</span></span>               |
| <span data-ttu-id="e38d9-701">AMBIENT</span><span class="sxs-lookup"><span data-stu-id="e38d9-701">AMBIENT</span></span>                              | <span data-ttu-id="e38d9-702">1150-4800</span><span class="sxs-lookup"><span data-stu-id="e38d9-702">1150 - 4800</span></span>              |
| <span data-ttu-id="e38d9-703">SetTexture</span><span class="sxs-lookup"><span data-stu-id="e38d9-703">SetTexture</span></span>                           | <span data-ttu-id="e38d9-704">2500-3100</span><span class="sxs-lookup"><span data-stu-id="e38d9-704">2500 - 3100</span></span>              |
| <span data-ttu-id="e38d9-705">SpecularMaterialSource</span><span class="sxs-lookup"><span data-stu-id="e38d9-705">SPECULARMATERIALSOURCE</span></span>               | <span data-ttu-id="e38d9-706">900-4600</span><span class="sxs-lookup"><span data-stu-id="e38d9-706">900 - 4600</span></span>               |
| <span data-ttu-id="e38d9-707">Emissivematerialsource</span><span class="sxs-lookup"><span data-stu-id="e38d9-707">EMISSIVEMATERIALSOURCE</span></span>               | <span data-ttu-id="e38d9-708">900-4500</span><span class="sxs-lookup"><span data-stu-id="e38d9-708">900 - 4500</span></span>               |
| <span data-ttu-id="e38d9-709">Setmaterial</span><span class="sxs-lookup"><span data-stu-id="e38d9-709">SetMaterial</span></span>                          | <span data-ttu-id="e38d9-710">1000-3700</span><span class="sxs-lookup"><span data-stu-id="e38d9-710">1000 - 3700</span></span>              |
| <span data-ttu-id="e38d9-711">Zenzierbar</span><span class="sxs-lookup"><span data-stu-id="e38d9-711">ZENABLE</span></span>                              | <span data-ttu-id="e38d9-712">700-3900</span><span class="sxs-lookup"><span data-stu-id="e38d9-712">700 - 3900</span></span>               |
| <span data-ttu-id="e38d9-713">WRAP0</span><span class="sxs-lookup"><span data-stu-id="e38d9-713">WRAP0</span></span>                                | <span data-ttu-id="e38d9-714">1600-2700</span><span class="sxs-lookup"><span data-stu-id="e38d9-714">1600 - 2700</span></span>              |
| <span data-ttu-id="e38d9-715">MinFilter</span><span class="sxs-lookup"><span data-stu-id="e38d9-715">MINFILTER</span></span>                            | <span data-ttu-id="e38d9-716">1700-2500</span><span class="sxs-lookup"><span data-stu-id="e38d9-716">1700 - 2500</span></span>              |
| <span data-ttu-id="e38d9-717">MagFilter</span><span class="sxs-lookup"><span data-stu-id="e38d9-717">MAGFILTER</span></span>                            | <span data-ttu-id="e38d9-718">1700-2400</span><span class="sxs-lookup"><span data-stu-id="e38d9-718">1700 - 2400</span></span>              |
| <span data-ttu-id="e38d9-719">Setvertexshaderconstant (1 Konstante)</span><span class="sxs-lookup"><span data-stu-id="e38d9-719">SetVertexShaderConstant (1 Constant)</span></span> | <span data-ttu-id="e38d9-720">1000-2700</span><span class="sxs-lookup"><span data-stu-id="e38d9-720">1000 - 2700</span></span>              |
| <span data-ttu-id="e38d9-721">Colorop</span><span class="sxs-lookup"><span data-stu-id="e38d9-721">COLOROP</span></span>                              | <span data-ttu-id="e38d9-722">1500-2100</span><span class="sxs-lookup"><span data-stu-id="e38d9-722">1500 - 2100</span></span>              |
| <span data-ttu-id="e38d9-723">COLORARG2</span><span class="sxs-lookup"><span data-stu-id="e38d9-723">COLORARG2</span></span>                            | <span data-ttu-id="e38d9-724">1300-2000</span><span class="sxs-lookup"><span data-stu-id="e38d9-724">1300 - 2000</span></span>              |
| <span data-ttu-id="e38d9-725">COLORARG1</span><span class="sxs-lookup"><span data-stu-id="e38d9-725">COLORARG1</span></span>                            | <span data-ttu-id="e38d9-726">1300-1980</span><span class="sxs-lookup"><span data-stu-id="e38d9-726">1300 - 1980</span></span>              |
| <span data-ttu-id="e38d9-727">CullMode</span><span class="sxs-lookup"><span data-stu-id="e38d9-727">CULLMODE</span></span>                             | <span data-ttu-id="e38d9-728">500-2570</span><span class="sxs-lookup"><span data-stu-id="e38d9-728">500 - 2570</span></span>               |
| <span data-ttu-id="e38d9-729">Clipping</span><span class="sxs-lookup"><span data-stu-id="e38d9-729">CLIPPING</span></span>                             | <span data-ttu-id="e38d9-730">500-2550</span><span class="sxs-lookup"><span data-stu-id="e38d9-730">500 - 2550</span></span>               |
| <span data-ttu-id="e38d9-731">Drawindexedprimitiv</span><span class="sxs-lookup"><span data-stu-id="e38d9-731">DrawIndexedPrimitive</span></span>                 | <span data-ttu-id="e38d9-732">1200-1400</span><span class="sxs-lookup"><span data-stu-id="e38d9-732">1200 - 1400</span></span>              |
| <span data-ttu-id="e38d9-733">Adressssv</span><span class="sxs-lookup"><span data-stu-id="e38d9-733">ADDRESSV</span></span>                             | <span data-ttu-id="e38d9-734">1090-1500</span><span class="sxs-lookup"><span data-stu-id="e38d9-734">1090 - 1500</span></span>              |
| <span data-ttu-id="e38d9-735">Adresssu</span><span class="sxs-lookup"><span data-stu-id="e38d9-735">ADDRESSU</span></span>                             | <span data-ttu-id="e38d9-736">1070-1500</span><span class="sxs-lookup"><span data-stu-id="e38d9-736">1070 - 1500</span></span>              |
| <span data-ttu-id="e38d9-737">Drawprimitiv</span><span class="sxs-lookup"><span data-stu-id="e38d9-737">DrawPrimitive</span></span>                        | <span data-ttu-id="e38d9-738">1050-1150</span><span class="sxs-lookup"><span data-stu-id="e38d9-738">1050 - 1150</span></span>              |
| <span data-ttu-id="e38d9-739">Srgbtexture</span><span class="sxs-lookup"><span data-stu-id="e38d9-739">SRGBTEXTURE</span></span>                          | <span data-ttu-id="e38d9-740">150-1500</span><span class="sxs-lookup"><span data-stu-id="e38d9-740">150 - 1500</span></span>               |
| <span data-ttu-id="e38d9-741">Schablone Mask</span><span class="sxs-lookup"><span data-stu-id="e38d9-741">STENCILMASK</span></span>                          | <span data-ttu-id="e38d9-742">570-700</span><span class="sxs-lookup"><span data-stu-id="e38d9-742">570 - 700</span></span>                |
| <span data-ttu-id="e38d9-743">Stencilzfail</span><span class="sxs-lookup"><span data-stu-id="e38d9-743">STENCILZFAIL</span></span>                         | <span data-ttu-id="e38d9-744">500-800</span><span class="sxs-lookup"><span data-stu-id="e38d9-744">500 - 800</span></span>                |
| <span data-ttu-id="e38d9-745">Schablone Ref</span><span class="sxs-lookup"><span data-stu-id="e38d9-745">STENCILREF</span></span>                           | <span data-ttu-id="e38d9-746">550-700</span><span class="sxs-lookup"><span data-stu-id="e38d9-746">550 - 700</span></span>                |
| <span data-ttu-id="e38d9-747">AlphaBlendEnable</span><span class="sxs-lookup"><span data-stu-id="e38d9-747">ALPHABLENDENABLE</span></span>                     | <span data-ttu-id="e38d9-748">550-700</span><span class="sxs-lookup"><span data-stu-id="e38d9-748">550 - 700</span></span>                |
| <span data-ttu-id="e38d9-749">Schablone Func</span><span class="sxs-lookup"><span data-stu-id="e38d9-749">STENCILFUNC</span></span>                          | <span data-ttu-id="e38d9-750">560-680</span><span class="sxs-lookup"><span data-stu-id="e38d9-750">560 - 680</span></span>                |
| <span data-ttu-id="e38d9-751">Schablone</span><span class="sxs-lookup"><span data-stu-id="e38d9-751">STENCILWRITEMASK</span></span>                     | <span data-ttu-id="e38d9-752">520-700</span><span class="sxs-lookup"><span data-stu-id="e38d9-752">520 - 700</span></span>                |
| <span data-ttu-id="e38d9-753">Stencilfail</span><span class="sxs-lookup"><span data-stu-id="e38d9-753">STENCILFAIL</span></span>                          | <span data-ttu-id="e38d9-754">500-750</span><span class="sxs-lookup"><span data-stu-id="e38d9-754">500 - 750</span></span>                |
| <span data-ttu-id="e38d9-755">Zfunc</span><span class="sxs-lookup"><span data-stu-id="e38d9-755">ZFUNC</span></span>                                | <span data-ttu-id="e38d9-756">510-700</span><span class="sxs-lookup"><span data-stu-id="e38d9-756">510 - 700</span></span>                |
| <span data-ttu-id="e38d9-757">Zbeschreib teenable</span><span class="sxs-lookup"><span data-stu-id="e38d9-757">ZWRITEENABLE</span></span>                         | <span data-ttu-id="e38d9-758">520-680</span><span class="sxs-lookup"><span data-stu-id="e38d9-758">520 - 680</span></span>                |
| <span data-ttu-id="e38d9-759">Schablone möglich</span><span class="sxs-lookup"><span data-stu-id="e38d9-759">STENCILENABLE</span></span>                        | <span data-ttu-id="e38d9-760">540-650</span><span class="sxs-lookup"><span data-stu-id="e38d9-760">540 - 650</span></span>                |
| <span data-ttu-id="e38d9-761">Schablone-Pass</span><span class="sxs-lookup"><span data-stu-id="e38d9-761">STENCILPASS</span></span>                          | <span data-ttu-id="e38d9-762">560-630</span><span class="sxs-lookup"><span data-stu-id="e38d9-762">560 - 630</span></span>                |
| <span data-ttu-id="e38d9-763">Srcblend</span><span class="sxs-lookup"><span data-stu-id="e38d9-763">SRCBLEND</span></span>                             | <span data-ttu-id="e38d9-764">500-685</span><span class="sxs-lookup"><span data-stu-id="e38d9-764">500 - 685</span></span>                |
| <span data-ttu-id="e38d9-765">Zwei \_ seitiger \_ stencilmode</span><span class="sxs-lookup"><span data-stu-id="e38d9-765">Two\_Sided\_StencilMODE</span></span>              | <span data-ttu-id="e38d9-766">450-590</span><span class="sxs-lookup"><span data-stu-id="e38d9-766">450 - 590</span></span>                |
| <span data-ttu-id="e38d9-767">Alpha atestenable</span><span class="sxs-lookup"><span data-stu-id="e38d9-767">ALPHATESTENABLE</span></span>                      | <span data-ttu-id="e38d9-768">470-525</span><span class="sxs-lookup"><span data-stu-id="e38d9-768">470 - 525</span></span>                |
| <span data-ttu-id="e38d9-769">Alpha Aref</span><span class="sxs-lookup"><span data-stu-id="e38d9-769">ALPHAREF</span></span>                             | <span data-ttu-id="e38d9-770">460-530</span><span class="sxs-lookup"><span data-stu-id="e38d9-770">460 - 530</span></span>                |
| <span data-ttu-id="e38d9-771">Alphafunc</span><span class="sxs-lookup"><span data-stu-id="e38d9-771">ALPHAFUNC</span></span>                            | <span data-ttu-id="e38d9-772">450-540</span><span class="sxs-lookup"><span data-stu-id="e38d9-772">450 - 540</span></span>                |
| <span data-ttu-id="e38d9-773">Destblend</span><span class="sxs-lookup"><span data-stu-id="e38d9-773">DESTBLEND</span></span>                            | <span data-ttu-id="e38d9-774">475-510</span><span class="sxs-lookup"><span data-stu-id="e38d9-774">475 - 510</span></span>                |
| <span data-ttu-id="e38d9-775">Colorschreiteenable</span><span class="sxs-lookup"><span data-stu-id="e38d9-775">COLORWRITEENABLE</span></span>                     | <span data-ttu-id="e38d9-776">465-515</span><span class="sxs-lookup"><span data-stu-id="e38d9-776">465 - 515</span></span>                |
| <span data-ttu-id="e38d9-777">CCW- \_ stencilfail</span><span class="sxs-lookup"><span data-stu-id="e38d9-777">CCW\_STENCILFAIL</span></span>                     | <span data-ttu-id="e38d9-778">340-560</span><span class="sxs-lookup"><span data-stu-id="e38d9-778">340 - 560</span></span>                |
| <span data-ttu-id="e38d9-779">CCW- \_ stencilpass</span><span class="sxs-lookup"><span data-stu-id="e38d9-779">CCW\_STENCILPASS</span></span>                     | <span data-ttu-id="e38d9-780">340-545</span><span class="sxs-lookup"><span data-stu-id="e38d9-780">340 - 545</span></span>                |
| <span data-ttu-id="e38d9-781">CCW- \_ stencilzfail</span><span class="sxs-lookup"><span data-stu-id="e38d9-781">CCW\_STENCILZFAIL</span></span>                    | <span data-ttu-id="e38d9-782">330-495</span><span class="sxs-lookup"><span data-stu-id="e38d9-782">330 - 495</span></span>                |
| <span data-ttu-id="e38d9-783">Scissortestenable</span><span class="sxs-lookup"><span data-stu-id="e38d9-783">SCISSORTESTENABLE</span></span>                    | <span data-ttu-id="e38d9-784">375-440</span><span class="sxs-lookup"><span data-stu-id="e38d9-784">375 - 440</span></span>                |
| <span data-ttu-id="e38d9-785">CCW- \_ Schablone</span><span class="sxs-lookup"><span data-stu-id="e38d9-785">CCW\_STENCILFUNC</span></span>                     | <span data-ttu-id="e38d9-786">250-480</span><span class="sxs-lookup"><span data-stu-id="e38d9-786">250 - 480</span></span>                |
| <span data-ttu-id="e38d9-787">"S\cissorrect"</span><span class="sxs-lookup"><span data-stu-id="e38d9-787">SetScissorRect</span></span>                       | <span data-ttu-id="e38d9-788">150-340</span><span class="sxs-lookup"><span data-stu-id="e38d9-788">150 - 340</span></span>                |



 

## <a name="related-topics"></a><span data-ttu-id="e38d9-789">Zugehörige Themen</span><span class="sxs-lookup"><span data-stu-id="e38d9-789">Related topics</span></span>

<dl> <dt>

[<span data-ttu-id="e38d9-790">Erweiterte Themen</span><span class="sxs-lookup"><span data-stu-id="e38d9-790">Advanced Topics</span></span>](advanced-topics.md)
</dt> </dl>

 

 
