---
description: Jeder Entwickler, der Echtzeitanwendungen erstellt, die 3D-Grafiken verwenden, beschäftigt sich mit der Leistungsoptimierung. Dieser Abschnitt enthält Richtlinien zum erzielen der besten Leistung aus Ihrem Code.
ms.assetid: 074f848e-4a42-48a2-adf7-4026b8967413
title: Leistungsoptimierungen (Direct3D 9)
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: 4d42be994522f0d83e36387b1a5866b3eee10df3
ms.sourcegitcommit: a47bd86f517de76374e4fff33cfeb613eb259a7e
ms.translationtype: MT
ms.contentlocale: de-DE
ms.lasthandoff: 01/06/2021
ms.locfileid: "104480691"
---
# <a name="performance-optimizations-direct3d-9"></a><span data-ttu-id="9e1a1-104">Leistungsoptimierungen (Direct3D 9)</span><span class="sxs-lookup"><span data-stu-id="9e1a1-104">Performance Optimizations (Direct3D 9)</span></span>

<span data-ttu-id="9e1a1-105">Jeder Entwickler, der Echtzeitanwendungen erstellt, die 3D-Grafiken verwenden, beschäftigt sich mit der Leistungsoptimierung.</span><span class="sxs-lookup"><span data-stu-id="9e1a1-105">Every developer who creates real-time applications that use 3D graphics is concerned about performance optimization.</span></span> <span data-ttu-id="9e1a1-106">Dieser Abschnitt enthält Richtlinien zum erzielen der besten Leistung aus Ihrem Code.</span><span class="sxs-lookup"><span data-stu-id="9e1a1-106">This section provides guidelines for getting the best performance from your code.</span></span>

-   [<span data-ttu-id="9e1a1-107">Allgemeine Tipps zur Leistung</span><span class="sxs-lookup"><span data-stu-id="9e1a1-107">General Performance Tips</span></span>](#general-performance-tips)
-   [<span data-ttu-id="9e1a1-108">Datenbanken und culult</span><span class="sxs-lookup"><span data-stu-id="9e1a1-108">Databases and Culling</span></span>](#databases-and-culling)
-   [<span data-ttu-id="9e1a1-109">Batch Verarbeitung von primitiven</span><span class="sxs-lookup"><span data-stu-id="9e1a1-109">Batching Primitives</span></span>](#batching-primitives)
-   [<span data-ttu-id="9e1a1-110">Beleuchtungs Tipps</span><span class="sxs-lookup"><span data-stu-id="9e1a1-110">Lighting Tips</span></span>](#lighting-tips)
-   [<span data-ttu-id="9e1a1-111">Textur Größe</span><span class="sxs-lookup"><span data-stu-id="9e1a1-111">Texture Size</span></span>](#texture-size)
-   [<span data-ttu-id="9e1a1-112">Matrixtransformationen</span><span class="sxs-lookup"><span data-stu-id="9e1a1-112">Matrix Transforms</span></span>](#matrix-transforms)
-   [<span data-ttu-id="9e1a1-113">Verwenden dynamischer Texturen</span><span class="sxs-lookup"><span data-stu-id="9e1a1-113">Using Dynamic Textures</span></span>](#using-dynamic-textures)
-   [<span data-ttu-id="9e1a1-114">Verwenden dynamischer Scheitelpunkt-und Index Puffer</span><span class="sxs-lookup"><span data-stu-id="9e1a1-114">Using Dynamic Vertex and Index Buffers</span></span>](#using-dynamic-vertex-and-index-buffers)
-   [<span data-ttu-id="9e1a1-115">Verwenden von Meshes</span><span class="sxs-lookup"><span data-stu-id="9e1a1-115">Using Meshes</span></span>](#using-meshes)
-   [<span data-ttu-id="9e1a1-116">Z-Puffer Leistung</span><span class="sxs-lookup"><span data-stu-id="9e1a1-116">Z-Buffer Performance</span></span>](#z-buffer-performance)

## <a name="general-performance-tips"></a><span data-ttu-id="9e1a1-117">Allgemeine Tipps zur Leistung</span><span class="sxs-lookup"><span data-stu-id="9e1a1-117">General Performance Tips</span></span>

-   <span data-ttu-id="9e1a1-118">Löschen Sie nur, wenn Sie müssen.</span><span class="sxs-lookup"><span data-stu-id="9e1a1-118">Clear only when you must.</span></span>
-   <span data-ttu-id="9e1a1-119">Minimieren Sie Zustandsänderungen, und gruppieren Sie die verbleibenden Statusänderungen.</span><span class="sxs-lookup"><span data-stu-id="9e1a1-119">Minimize state changes and group the remaining state changes.</span></span>
-   <span data-ttu-id="9e1a1-120">Verwenden Sie kleinere Texturen, wenn dies möglich ist.</span><span class="sxs-lookup"><span data-stu-id="9e1a1-120">Use smaller textures, if you can do so.</span></span>
-   <span data-ttu-id="9e1a1-121">Zeichnen Sie Objekte in Ihrer Szene von vorne nach hinten.</span><span class="sxs-lookup"><span data-stu-id="9e1a1-121">Draw objects in your scene from front to back.</span></span>
-   <span data-ttu-id="9e1a1-122">Verwenden Sie Dreiecks Streifen anstelle von Listen und Lüfter.</span><span class="sxs-lookup"><span data-stu-id="9e1a1-122">Use triangle strips instead of lists and fans.</span></span> <span data-ttu-id="9e1a1-123">Um die optimale Leistung des Vertex-Caches zu erzielen, ordnen Sie für die Wiederverwendung von Dreiecks Scheitel Punkten anstelle einer späteren Verwendung von</span><span class="sxs-lookup"><span data-stu-id="9e1a1-123">For optimal vertex cache performance, arrange strips to reuse triangle vertices sooner, rather than later.</span></span>
-   <span data-ttu-id="9e1a1-124">Eine ordnungsgemäße Herabstufung von speziellen Effekten, die eine unverhältnismäßig große Freigabe von Systemressourcen erfordern.</span><span class="sxs-lookup"><span data-stu-id="9e1a1-124">Gracefully degrade special effects that require a disproportionate share of system resources.</span></span>
-   <span data-ttu-id="9e1a1-125">Testen Sie ständig die Leistung Ihrer Anwendung.</span><span class="sxs-lookup"><span data-stu-id="9e1a1-125">Constantly test your application's performance.</span></span>
-   <span data-ttu-id="9e1a1-126">Minimieren Sie Scheitelpunkt-Puffer Switches.</span><span class="sxs-lookup"><span data-stu-id="9e1a1-126">Minimize vertex buffer switches.</span></span>
-   <span data-ttu-id="9e1a1-127">Verwenden Sie nach Möglichkeit statische Scheitelpunkt Puffer.</span><span class="sxs-lookup"><span data-stu-id="9e1a1-127">Use static vertex buffers where possible.</span></span>
-   <span data-ttu-id="9e1a1-128">Verwenden Sie für statische Objekte anstelle eines Objekts pro Objekt einen großen statischen Vertex-Puffer pro f.</span><span class="sxs-lookup"><span data-stu-id="9e1a1-128">Use one large static vertex buffer per FVF for static objects, rather than one per object.</span></span>
-   <span data-ttu-id="9e1a1-129">Wenn Ihre Anwendung zufälligen Zugriff auf den Vertex-Puffer im AGP-Speicher benötigt, wählen Sie eine Scheitelpunkt Format Größe aus, die ein Vielfaches von 32 Bytes ist.</span><span class="sxs-lookup"><span data-stu-id="9e1a1-129">If your application needs random access into the vertex buffer in AGP memory, choose a vertex format size that is a multiple of 32 bytes.</span></span> <span data-ttu-id="9e1a1-130">Wählen Sie andernfalls das kleinste geeignete Format aus.</span><span class="sxs-lookup"><span data-stu-id="9e1a1-130">Otherwise, select the smallest appropriate format.</span></span>
-   <span data-ttu-id="9e1a1-131">Zeichnen Sie mithilfe indizierter primitiver Elemente.</span><span class="sxs-lookup"><span data-stu-id="9e1a1-131">Draw using indexed primitives.</span></span> <span data-ttu-id="9e1a1-132">Dies ermöglicht eine effizientere Scheitelpunkt Zwischenspeicherung innerhalb von Hardware.</span><span class="sxs-lookup"><span data-stu-id="9e1a1-132">This can allow for more efficient vertex caching within hardware.</span></span>
-   <span data-ttu-id="9e1a1-133">Wenn das tiefe Puffer Format einen Schablonen Kanal enthält, löschen Sie immer die Kanäle für Tiefe und Schablone gleichzeitig.</span><span class="sxs-lookup"><span data-stu-id="9e1a1-133">If the depth buffer format contains a stencil channel, always clear the depth and stencil channels at the same time.</span></span>
-   <span data-ttu-id="9e1a1-134">Kombinieren Sie nach Möglichkeit die Shader-Anweisung und die Datenausgabe.</span><span class="sxs-lookup"><span data-stu-id="9e1a1-134">Combine the shader instruction and the data output where possible.</span></span> <span data-ttu-id="9e1a1-135">Beispiel:</span><span class="sxs-lookup"><span data-stu-id="9e1a1-135">For example:</span></span>
    ```
    // Rather than doing a multiply and add, and then output the data with 
    //   two instructions:
    mad r2, r1, v0, c0
    mov oD0, r2

    // Combine both in a single instruction, because this eliminates an  
    //   additional register copy.
    mad oD0, r1, v0, c0 
    ```

    

## <a name="databases-and-culling"></a><span data-ttu-id="9e1a1-136">Datenbanken und culult</span><span class="sxs-lookup"><span data-stu-id="9e1a1-136">Databases and Culling</span></span>

<span data-ttu-id="9e1a1-137">Das Entwickeln einer zuverlässigen Datenbank der Objekte in ihrer Welt ist entscheidend für die ausgezeichnete Leistung in Direct3D.</span><span class="sxs-lookup"><span data-stu-id="9e1a1-137">Building a reliable database of the objects in your world is key to excellent performance in Direct3D.</span></span> <span data-ttu-id="9e1a1-138">Es ist wichtiger als die Verbesserungen bei der rasterisierung oder Hardware.</span><span class="sxs-lookup"><span data-stu-id="9e1a1-138">It is more important than improvements to rasterization or hardware.</span></span>

<span data-ttu-id="9e1a1-139">Sie sollten die niedrigste Polygon Anzahl verwalten, die Sie möglicherweise verwalten können.</span><span class="sxs-lookup"><span data-stu-id="9e1a1-139">You should maintain the lowest polygon count you can possibly manage.</span></span> <span data-ttu-id="9e1a1-140">Entwurf für eine niedrige Polygon Anzahl durch das Erstellen von Low-Polygon-Modellen von Anfang an.</span><span class="sxs-lookup"><span data-stu-id="9e1a1-140">Design for a low polygon count by building low-polygon models from the start.</span></span> <span data-ttu-id="9e1a1-141">Fügen Sie ggf. Polygone hinzu, ohne die Leistung zu einem späteren Zeitpunkt im Entwicklungsprozess zu beeinträchtigen.</span><span class="sxs-lookup"><span data-stu-id="9e1a1-141">Add polygons if you can do so without sacrificing performance later in the development process.</span></span> <span data-ttu-id="9e1a1-142">Beachten Sie, dass es sich bei den schnellsten Polygonen um diejenigen handelt, die Sie nicht</span><span class="sxs-lookup"><span data-stu-id="9e1a1-142">Remember, the fastest polygons are the ones you don't draw.</span></span>

## <a name="batching-primitives"></a><span data-ttu-id="9e1a1-143">Batch Verarbeitung von primitiven</span><span class="sxs-lookup"><span data-stu-id="9e1a1-143">Batching Primitives</span></span>

<span data-ttu-id="9e1a1-144">Um die beste Renderingleistung während der Ausführung zu erzielen, versuchen Sie, mit primitiven in Batches zu arbeiten und die Anzahl der renderzustandsänderungen so gering wie möglich zu halten.</span><span class="sxs-lookup"><span data-stu-id="9e1a1-144">To get the best rendering performance during execution, try to work with primitives in batches and keep the number of render-state changes as low as possible.</span></span> <span data-ttu-id="9e1a1-145">Wenn Sie z. b. über ein Objekt mit zwei Texturen verfügen, Gruppieren Sie die Dreiecke, die die erste Textur verwenden, und folgen Sie den notwendigen Rendering-Zuständen, um die Textur zu ändern.</span><span class="sxs-lookup"><span data-stu-id="9e1a1-145">For example, if you have an object with two textures, group the triangles that use the first texture and follow them with the necessary render state to change the texture.</span></span> <span data-ttu-id="9e1a1-146">Gruppieren Sie dann alle Dreiecke, die die zweite Textur verwenden.</span><span class="sxs-lookup"><span data-stu-id="9e1a1-146">Then group all the triangles that use the second texture.</span></span> <span data-ttu-id="9e1a1-147">Die einfachste Hardwareunterstützung für Direct3D wird mit Batches von Rendering-Zuständen und-Batches von primitiven über die Hardware Abstraktionsschicht (HAL) aufgerufen.</span><span class="sxs-lookup"><span data-stu-id="9e1a1-147">The simplest hardware support for Direct3D is called with batches of render states and batches of primitives through the hardware abstraction layer (HAL).</span></span> <span data-ttu-id="9e1a1-148">Je effektiver die Anweisungen in einem Batch verarbeitet werden, desto weniger HAL-Aufrufe werden während der Ausführung ausgeführt.</span><span class="sxs-lookup"><span data-stu-id="9e1a1-148">The more effectively the instructions are batched, the fewer HAL calls are performed during execution.</span></span>

## <a name="lighting-tips"></a><span data-ttu-id="9e1a1-149">Beleuchtungs Tipps</span><span class="sxs-lookup"><span data-stu-id="9e1a1-149">Lighting Tips</span></span>

<span data-ttu-id="9e1a1-150">Da mit Lichtern jedem gerenderten Frame eine pro-Vertex-Gebühr hinzugefügt wird, können Sie die Leistung erheblich verbessern, indem Sie darauf achten, wie Sie Sie in Ihrer Anwendung verwenden.</span><span class="sxs-lookup"><span data-stu-id="9e1a1-150">Because lights add a per-vertex cost to each rendered frame, you can improve performance significantly by being careful about how you use them in your application.</span></span> <span data-ttu-id="9e1a1-151">Die meisten der folgenden Tipps werden von der Maxime abgeleitet: "der schnellste Code ist Code, der niemals aufgerufen wird."</span><span class="sxs-lookup"><span data-stu-id="9e1a1-151">Most of the following tips derive from the maxim, "the fastest code is code that is never called."</span></span>

-   <span data-ttu-id="9e1a1-152">Verwenden Sie so wenig Lichtquellen wie möglich.</span><span class="sxs-lookup"><span data-stu-id="9e1a1-152">Use as few light sources as possible.</span></span> <span data-ttu-id="9e1a1-153">Um die allgemeine Beleuchtungs Stufe zu erhöhen, verwenden Sie z. b. das Ambient-Licht, anstatt eine neue Light-Quelle hinzuzufügen.</span><span class="sxs-lookup"><span data-stu-id="9e1a1-153">To increase the overall lighting level, for example, use the ambient light instead of adding a new light source.</span></span>
-   <span data-ttu-id="9e1a1-154">Direktionale Lichter sind effizienter als Punktbeleuchtung oder Scheinwerfer.</span><span class="sxs-lookup"><span data-stu-id="9e1a1-154">Directional lights are more efficient than point lights or spotlights.</span></span> <span data-ttu-id="9e1a1-155">Bei direktionalen Lichtern ist die Richtung des Lichts korrigiert und muss nicht pro Scheitelpunkt berechnet werden.</span><span class="sxs-lookup"><span data-stu-id="9e1a1-155">For directional lights, the direction to the light is fixed and doesn't need to be calculated on a per-vertex basis.</span></span>
-   <span data-ttu-id="9e1a1-156">Scheinwerfer können effizienter als Punkt Leuchten sein, da der Bereich außerhalb des Licht Lichts schnell berechnet wird.</span><span class="sxs-lookup"><span data-stu-id="9e1a1-156">Spotlights can be more efficient than point lights, because the area outside the cone of light is calculated quickly.</span></span> <span data-ttu-id="9e1a1-157">Ob die Scheinwerfer effizienter sind oder nicht, hängt davon ab, wie viel Ihrer Szene durch das Spotlight beleuchtet wird.</span><span class="sxs-lookup"><span data-stu-id="9e1a1-157">Whether spotlights are more efficient or not depends on how much of your scene is lit by the spotlight.</span></span>
-   <span data-ttu-id="9e1a1-158">Verwenden Sie den Range-Parameter, um die Lichter auf die Teile der Szene zu beschränken, die Sie beleuchten müssen.</span><span class="sxs-lookup"><span data-stu-id="9e1a1-158">Use the range parameter to limit your lights to only the parts of the scene you need to illuminate.</span></span> <span data-ttu-id="9e1a1-159">Alle hellen Typen werden relativ früh beendet, wenn Sie außerhalb des gültigen Bereichs liegen.</span><span class="sxs-lookup"><span data-stu-id="9e1a1-159">All the light types exit fairly early when they are out of range.</span></span>
-   <span data-ttu-id="9e1a1-160">Glanzlichter heben fast den doppelten Aufwand für ein Licht.</span><span class="sxs-lookup"><span data-stu-id="9e1a1-160">Specular highlights almost double the cost of a light.</span></span> <span data-ttu-id="9e1a1-161">Verwenden Sie Sie nur, wenn Sie müssen.</span><span class="sxs-lookup"><span data-stu-id="9e1a1-161">Use them only when you must.</span></span> <span data-ttu-id="9e1a1-162">Legen Sie den D3DRS \_ specularenable-Rendering-Zustand auf 0 (Standardwert) fest, wann immer dies möglich ist.</span><span class="sxs-lookup"><span data-stu-id="9e1a1-162">Set the D3DRS\_SPECULARENABLE render state to 0, the default value, whenever possible.</span></span> <span data-ttu-id="9e1a1-163">Wenn Sie Materialien definieren, müssen Sie den Glanz Wert auf NULL festlegen, um Glanzlichter für dieses Material zu deaktivieren. das Festlegen der Glanz Farbe auf 0, 0, 0 ist nicht ausreichend.</span><span class="sxs-lookup"><span data-stu-id="9e1a1-163">When defining materials, you must set the specular power value to zero to turn off specular highlights for that material; just setting the specular color to 0,0,0 is not enough.</span></span>

## <a name="texture-size"></a><span data-ttu-id="9e1a1-164">Textur Größe</span><span class="sxs-lookup"><span data-stu-id="9e1a1-164">Texture Size</span></span>

<span data-ttu-id="9e1a1-165">Die Leistung der Textur Zuordnung hängt stark von der Geschwindigkeit des Arbeitsspeichers ab.</span><span class="sxs-lookup"><span data-stu-id="9e1a1-165">Texture-mapping performance is heavily dependent on the speed of memory.</span></span> <span data-ttu-id="9e1a1-166">Es gibt eine Reihe von Möglichkeiten, die Cache Leistung der Texturen Ihrer Anwendung zu maximieren.</span><span class="sxs-lookup"><span data-stu-id="9e1a1-166">There are a number of ways to maximize the cache performance of your application's textures.</span></span>

-   <span data-ttu-id="9e1a1-167">Halten Sie die Texturen klein.</span><span class="sxs-lookup"><span data-stu-id="9e1a1-167">Keep the textures small.</span></span> <span data-ttu-id="9e1a1-168">Die kleineren Texturen sind, umso besser die Wahrscheinlichkeit, dass Sie im sekundären Cache der Haupt-CPU gewartet werden.</span><span class="sxs-lookup"><span data-stu-id="9e1a1-168">The smaller the textures are, the better chance they have of being maintained in the main CPU's secondary cache.</span></span>
-   <span data-ttu-id="9e1a1-169">Ändern Sie die Texturen nicht pro primitiver Basis.</span><span class="sxs-lookup"><span data-stu-id="9e1a1-169">Do not change the textures on a per-primitive basis.</span></span> <span data-ttu-id="9e1a1-170">Versuchen Sie, Polygone in der Reihenfolge ihrer verwendeten Texturen gruppiert zu halten.</span><span class="sxs-lookup"><span data-stu-id="9e1a1-170">Try to keep polygons grouped in order of the textures they use.</span></span>
-   <span data-ttu-id="9e1a1-171">Verwenden Sie nach Möglichkeit quadratische Texturen.</span><span class="sxs-lookup"><span data-stu-id="9e1a1-171">Use square textures whenever possible.</span></span> <span data-ttu-id="9e1a1-172">Texturen, deren Dimensionen 256 x 256 sind, sind die schnellste.</span><span class="sxs-lookup"><span data-stu-id="9e1a1-172">Textures whose dimensions are 256x256 are the fastest.</span></span> <span data-ttu-id="9e1a1-173">Wenn Ihre Anwendung beispielsweise vier 128 x 128-Texturen verwendet, stellen Sie sicher, dass Sie dieselbe Palette verwenden, und platzieren Sie Sie alle in einer 256x256-Textur.</span><span class="sxs-lookup"><span data-stu-id="9e1a1-173">If your application uses four 128x128 textures, for example, try to ensure that they use the same palette and place them all into one 256x256 texture.</span></span> <span data-ttu-id="9e1a1-174">Durch diese Vorgehensweise wird auch die Menge an Textur Austausch reduziert.</span><span class="sxs-lookup"><span data-stu-id="9e1a1-174">This technique also reduces the amount of texture swapping.</span></span> <span data-ttu-id="9e1a1-175">Natürlich sollten Sie die Texturen von 256x256 nur dann verwenden, wenn Ihre Anwendung eine viel Texturierung erfordert, da Texturen wie bereits erwähnt so klein wie möglich gehalten werden.</span><span class="sxs-lookup"><span data-stu-id="9e1a1-175">Of course, you should not use 256x256 textures unless your application requires that much texturing because, as mentioned, textures should be kept as small as possible.</span></span>

## <a name="matrix-transforms"></a><span data-ttu-id="9e1a1-176">Matrixtransformationen</span><span class="sxs-lookup"><span data-stu-id="9e1a1-176">Matrix Transforms</span></span>

<span data-ttu-id="9e1a1-177">Direct3D verwendet die Welt-und Ansichts Matrizen, die Sie zum Konfigurieren mehrerer interner Datenstrukturen festgelegt haben.</span><span class="sxs-lookup"><span data-stu-id="9e1a1-177">Direct3D uses the world and view matrices that you set to configure several internal data structures.</span></span> <span data-ttu-id="9e1a1-178">Jedes Mal, wenn Sie eine neue Welt-oder Sicht Matrix festlegen, berechnet das System die zugeordneten internen Strukturen neu.</span><span class="sxs-lookup"><span data-stu-id="9e1a1-178">Each time you set a new world or view matrix, the system recalculates the associated internal structures.</span></span> <span data-ttu-id="9e1a1-179">Wenn Sie diese Matrizen häufig festlegen, z. b. Tausende Male pro Frame, ist dies Rechenzeit aufwändig.</span><span class="sxs-lookup"><span data-stu-id="9e1a1-179">Setting these matrices frequently - for example, thousands of times per frame - is computationally time-consuming.</span></span> <span data-ttu-id="9e1a1-180">Sie können die Anzahl der erforderlichen Berechnungen minimieren, indem Sie Ihre Welt und Matrizen in einer World-View-Matrix verketten, die Sie als Weltmatrix festlegen, und dann die Ansichts Matrix auf die Identität festlegen.</span><span class="sxs-lookup"><span data-stu-id="9e1a1-180">You can minimize the number of required calculations by concatenating your world and view matrices into a world-view matrix that you set as the world matrix, and then setting the view matrix to the identity.</span></span> <span data-ttu-id="9e1a1-181">Behalten Sie zwischengespeicherte Kopien der einzelnen Welt, und zeigen Sie Matrizen an, sodass Sie die World Matrix nach Bedarf ändern, verketten und zurücksetzen können.</span><span class="sxs-lookup"><span data-stu-id="9e1a1-181">Keep cached copies of individual world and view matrices so that you can modify, concatenate, and reset the world matrix as needed.</span></span> <span data-ttu-id="9e1a1-182">Aus Gründen der Übersichtlichkeit in dieser Dokumentation verwenden Direct3D Samples diese Optimierung nur selten.</span><span class="sxs-lookup"><span data-stu-id="9e1a1-182">For clarity in this documentation, Direct3D samples rarely employ this optimization.</span></span>

## <a name="using-dynamic-textures"></a><span data-ttu-id="9e1a1-183">Verwenden dynamischer Texturen</span><span class="sxs-lookup"><span data-stu-id="9e1a1-183">Using Dynamic Textures</span></span>

<span data-ttu-id="9e1a1-184">Um herauszufinden, ob der Treiber dynamische Texturen unterstützt, überprüfen Sie das D3DCAPS2 \_ dynamictexturen-Flag der [**D3DCAPS9**](/windows/desktop/api/D3D9Caps/ns-d3d9caps-d3dcaps9) -Struktur.</span><span class="sxs-lookup"><span data-stu-id="9e1a1-184">To find out if the driver supports dynamic textures, check the D3DCAPS2\_DYNAMICTEXTURES flag of the [**D3DCAPS9**](/windows/desktop/api/D3D9Caps/ns-d3d9caps-d3dcaps9) structure.</span></span>

<span data-ttu-id="9e1a1-185">Beachten Sie beim Arbeiten mit dynamischen Texturen die folgenden Punkte:</span><span class="sxs-lookup"><span data-stu-id="9e1a1-185">Keep the following things in mind when working with dynamic textures.</span></span>

-   <span data-ttu-id="9e1a1-186">Sie können nicht verwaltet werden.</span><span class="sxs-lookup"><span data-stu-id="9e1a1-186">They cannot be managed.</span></span> <span data-ttu-id="9e1a1-187">Beispielsweise kann der Pool nicht mit D3DPOOL \_ verwaltet werden.</span><span class="sxs-lookup"><span data-stu-id="9e1a1-187">For example, their pool cannot be D3DPOOL\_MANAGED.</span></span>
-   <span data-ttu-id="9e1a1-188">Dynamische Texturen können auch dann gesperrt werden, wenn Sie in der D3DPOOL- \_ Standardeinstellung erstellt werden.</span><span class="sxs-lookup"><span data-stu-id="9e1a1-188">Dynamic textures can be locked, even if they are created in D3DPOOL\_DEFAULT.</span></span>
-   <span data-ttu-id="9e1a1-189">D3DLOCK \_ DISCARD ist ein gültiges sperrflag für dynamische Texturen.</span><span class="sxs-lookup"><span data-stu-id="9e1a1-189">D3DLOCK\_DISCARD is a valid lock flag for dynamic textures.</span></span>

<span data-ttu-id="9e1a1-190">Es empfiehlt sich, nur eine dynamische Textur Pro Format und möglicherweise pro Größe zu erstellen.</span><span class="sxs-lookup"><span data-stu-id="9e1a1-190">It is a good idea to create only one dynamic texture per format and possibly per size.</span></span> <span data-ttu-id="9e1a1-191">Dynamische Mipmaps, Cubes und Volumes werden aufgrund des zusätzlichen Aufwands beim Sperren der einzelnen Ebenen nicht empfohlen.</span><span class="sxs-lookup"><span data-stu-id="9e1a1-191">Dynamic mipmaps, cubes, and volumes are not recommended because of the additional overhead in locking every level.</span></span> <span data-ttu-id="9e1a1-192">Für Mipmaps ist D3DLOCK \_ DISCARD nur auf der obersten Ebene zulässig.</span><span class="sxs-lookup"><span data-stu-id="9e1a1-192">For mipmaps, D3DLOCK\_DISCARD is allowed only on the top level.</span></span> <span data-ttu-id="9e1a1-193">Alle Ebenen werden verworfen, indem nur die oberste Ebene gesperrt wird.</span><span class="sxs-lookup"><span data-stu-id="9e1a1-193">All levels are discarded by locking just the top level.</span></span> <span data-ttu-id="9e1a1-194">Dieses Verhalten ist für Volumes und Cubes identisch.</span><span class="sxs-lookup"><span data-stu-id="9e1a1-194">This behavior is the same for volumes and cubes.</span></span> <span data-ttu-id="9e1a1-195">Bei Cubes werden die oberste Ebene und die Vorderseite 0 gesperrt.</span><span class="sxs-lookup"><span data-stu-id="9e1a1-195">For cubes, the top level and face 0 are locked.</span></span>

<span data-ttu-id="9e1a1-196">Der folgende Pseudo Code zeigt ein Beispiel für die Verwendung einer dynamischen Textur.</span><span class="sxs-lookup"><span data-stu-id="9e1a1-196">The following pseudocode shows an example of using a dynamic texture.</span></span>


```
DrawProceduralTexture(pTex)
{
    // pTex should not be very small because overhead of 
    //   calling driver every D3DLOCK_DISCARD will not 
    //   justify the performance gain. Experimentation is encouraged.
    pTex->Lock(D3DLOCK_DISCARD);
    <Overwrite *entire* texture>
    pTex->Unlock();
    pDev->SetTexture();
    pDev->DrawPrimitive();
}
```



## <a name="using-dynamic-vertex-and-index-buffers"></a><span data-ttu-id="9e1a1-197">Verwenden dynamischer Scheitelpunkt-und Index Puffer</span><span class="sxs-lookup"><span data-stu-id="9e1a1-197">Using Dynamic Vertex and Index Buffers</span></span>

<span data-ttu-id="9e1a1-198">Wenn Sie einen statischen Vertex-Puffer sperren, während der-Grafikprozessor den Puffer verwendet, kann dies zu einer erheblichen Leistungs Einbuße werden.</span><span class="sxs-lookup"><span data-stu-id="9e1a1-198">Locking a static vertex buffer while the graphics processor is using the buffer can have a significant performance penalty.</span></span> <span data-ttu-id="9e1a1-199">Der Sperr Aufruf muss warten, bis der Grafikprozessor das Lesen von Vertex-oder Indexdaten aus dem Puffer abgeschlossen hat, bevor er an die aufrufende Anwendung zurückgegeben werden kann, eine beträchtliche Verzögerung.</span><span class="sxs-lookup"><span data-stu-id="9e1a1-199">The lock call must wait until the graphics processor is finished reading vertex or index data from the buffer before it can return to the calling application, a significant delay.</span></span> <span data-ttu-id="9e1a1-200">Das Sperren und anschließende Rendering von einem statischen Puffer mehrmals pro Frame verhindert außerdem, dass der Grafikprozessor renderingbefehle puffert, da er vor dem Zurückgeben des Sperr Zeigers Befehle beenden muss.</span><span class="sxs-lookup"><span data-stu-id="9e1a1-200">Locking and then rendering from a static buffer several times per frame also prevents the graphics processor from buffering rendering commands, since it must finish commands before returning the lock pointer.</span></span> <span data-ttu-id="9e1a1-201">Ohne gepufferte Befehle bleibt der Grafikprozessor im Leerlauf, bis die Anwendung den Vertex-Puffer oder Index Puffer füllt und einen Renderingbefehl ausgibt.</span><span class="sxs-lookup"><span data-stu-id="9e1a1-201">Without buffered commands, the graphics processor remains idle until after the application is finished filling the vertex buffer or index buffer and issues a rendering command.</span></span>

<span data-ttu-id="9e1a1-202">Im Idealfall würden die Scheitelpunkt-oder Indexdaten nie geändert werden, dies ist jedoch nicht immer möglich.</span><span class="sxs-lookup"><span data-stu-id="9e1a1-202">Ideally the vertex or index data would never change, however this is not always possible.</span></span> <span data-ttu-id="9e1a1-203">Es gibt viele Situationen, in denen die Anwendung Scheitel Punkte oder Indexdaten jedes Frames ändern muss, vielleicht sogar mehrmals pro Frame.</span><span class="sxs-lookup"><span data-stu-id="9e1a1-203">There are many situations where the application needs to change vertex or index data every frame, perhaps even multiple times per frame.</span></span> <span data-ttu-id="9e1a1-204">In diesen Fällen sollte der Scheitelpunkt oder Index Puffer mit D3DUSAGE Dynamic erstellt werden \_ .</span><span class="sxs-lookup"><span data-stu-id="9e1a1-204">For these situations, the vertex or index buffer should be created with D3DUSAGE\_DYNAMIC.</span></span> <span data-ttu-id="9e1a1-205">Dieses nutzungsflag bewirkt, dass Direct3D bei häufigen Sperr Vorgängen optimiert wird.</span><span class="sxs-lookup"><span data-stu-id="9e1a1-205">This usage flag causes Direct3D to optimize for frequent lock operations.</span></span> <span data-ttu-id="9e1a1-206">D3DUSAGE \_ Dynamic ist nur nützlich, wenn der Puffer häufig gesperrt ist. Daten, die konstant bleiben, sollten in einem statischen Scheitelpunkt oder Index Puffer abgelegt werden.</span><span class="sxs-lookup"><span data-stu-id="9e1a1-206">D3DUSAGE\_DYNAMIC is only useful when the buffer is locked frequently; data that remains constant should be placed in a static vertex or index buffer.</span></span>

<span data-ttu-id="9e1a1-207">Um eine Leistungsverbesserung bei der Verwendung dynamischer Scheitelpunkt Puffer zu erhalten, muss die Anwendung [**IDirect3DVertexBuffer9:: Lock**](/windows/desktop/api) oder [**IDirect3DIndexBuffer9:: Lock**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3dindexbuffer9-lock) mit den entsprechenden Flags aufzurufen.</span><span class="sxs-lookup"><span data-stu-id="9e1a1-207">To receive a performance improvement when using dynamic vertex buffers, the application must call [**IDirect3DVertexBuffer9::Lock**](/windows/desktop/api) or [**IDirect3DIndexBuffer9::Lock**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3dindexbuffer9-lock) with the appropriate flags.</span></span> <span data-ttu-id="9e1a1-208">D3DLOCK \_ DISCARD gibt an, dass die Anwendung die alten Scheitelpunkt-oder Indexdaten nicht im Puffer aufbewahren muss.</span><span class="sxs-lookup"><span data-stu-id="9e1a1-208">D3DLOCK\_DISCARD indicates that the application does not need to keep the old vertex or index data in the buffer.</span></span> <span data-ttu-id="9e1a1-209">Wenn der Grafikprozessor den Puffer weiterhin verwendet, wenn die Sperre mit D3DLOCK DISCARD aufgerufen wird \_ , wird anstelle der alten Puffer Daten ein Zeiger auf einen neuen Speicherbereich zurückgegeben.</span><span class="sxs-lookup"><span data-stu-id="9e1a1-209">If the graphics processor is still using the buffer when lock is called with D3DLOCK\_DISCARD, a pointer to a new region of memory is returned instead of the old buffer data.</span></span> <span data-ttu-id="9e1a1-210">Dies ermöglicht es dem Grafikprozessor, die alten Daten weiterhin zu verwenden, während die Anwendung Daten im neuen Puffer platziert.</span><span class="sxs-lookup"><span data-stu-id="9e1a1-210">This allows the graphics processor to continue using the old data while the application places data in the new buffer.</span></span> <span data-ttu-id="9e1a1-211">In der Anwendung ist keine zusätzliche Speicherverwaltung erforderlich. der alte Puffer wird wieder verwendet oder automatisch zerstört, wenn der Grafikprozessor damit fertig ist.</span><span class="sxs-lookup"><span data-stu-id="9e1a1-211">No additional memory management is required in the application; the old buffer is reused or destroyed automatically when the graphics processor is finished with it.</span></span> <span data-ttu-id="9e1a1-212">Beachten Sie, dass beim Sperren eines Puffers mit D3DLOCK \_ verwerfen immer der gesamte Puffer verworfen wird, wobei ein Offset ungleich 0 (null) oder ein Feld mit eingeschränkter Größe keine Informationen in entsperrungs Bereichen des Puffers beibehält</span><span class="sxs-lookup"><span data-stu-id="9e1a1-212">Note that locking a buffer with D3DLOCK\_DISCARD always discards the entire buffer, specifying a nonzero offset or limited size field does not preserve information in unlocked areas of the buffer.</span></span>

<span data-ttu-id="9e1a1-213">Es gibt Fälle, in denen die Menge der Daten, die die Anwendung für die Speicherung pro Sperre benötigt, klein ist, z. b. das Hinzufügen von vier Scheitel Punkten zum Rendering</span><span class="sxs-lookup"><span data-stu-id="9e1a1-213">There are cases where the amount of data the application needs to store per lock is small, such as adding four vertices to render a sprite.</span></span> <span data-ttu-id="9e1a1-214">D3DLOCK \_ noüberschreibung gibt an, dass die Anwendung keine Daten überschreibt, die bereits im dynamischen Puffer verwendet werden.</span><span class="sxs-lookup"><span data-stu-id="9e1a1-214">D3DLOCK\_NOOVERWRITE indicates that the application will not overwrite data already in use in the dynamic buffer.</span></span> <span data-ttu-id="9e1a1-215">Der Lock-Befehl gibt einen Zeiger auf die alten Daten zurück, sodass die Anwendung neue Daten in nicht verwendeten Regionen des Scheitel Punkts oder Index Puffers hinzufügen kann.</span><span class="sxs-lookup"><span data-stu-id="9e1a1-215">The lock call will return a pointer to the old data, allowing the application to add new data in unused regions of the vertex or index buffer.</span></span> <span data-ttu-id="9e1a1-216">Die Anwendung sollte Scheitel Punkte oder Indizes, die in einem zeichnen-Vorgang verwendet werden, nicht ändern, da Sie möglicherweise noch von dem Grafikprozessor verwendet werden.</span><span class="sxs-lookup"><span data-stu-id="9e1a1-216">The application should not modify vertices or indices used in a draw operation as they might still be in use by the graphics processor.</span></span> <span data-ttu-id="9e1a1-217">Die Anwendung sollte dann D3DLOCK \_ verwerfen verwenden, nachdem der dynamische Puffer voll ist, um einen neuen Speicherbereich zu erhalten, wobei die alten Scheitelpunkt-oder Indexdaten nach Abschluss des Grafikprozessors verworfen werden.</span><span class="sxs-lookup"><span data-stu-id="9e1a1-217">The application should then use D3DLOCK\_DISCARD after the dynamic buffer is full to receive a new region of memory, discarding the old vertex or index data after the graphics processor is finished.</span></span>

<span data-ttu-id="9e1a1-218">Der asynchrone Abfrage Mechanismus ist hilfreich, um zu bestimmen, ob Scheitel Punkte weiterhin vom Grafikprozessor verwendet werden.</span><span class="sxs-lookup"><span data-stu-id="9e1a1-218">The asynchronous query mechanism is useful to determine if vertices are still in use by the graphics processor.</span></span> <span data-ttu-id="9e1a1-219">Geben Sie \_ nach dem letzten drawprimitiven-Befehl, der die Scheitel Punkte verwendet, eine Abfrage vom Typ D3DQUERYTYPE-Ereignis aus.</span><span class="sxs-lookup"><span data-stu-id="9e1a1-219">Issue a query of type D3DQUERYTYPE\_EVENT after the last DrawPrimitive call that uses the vertices.</span></span> <span data-ttu-id="9e1a1-220">Die Scheitel Punkte werden nicht mehr verwendet, wenn [**IDirect3DQuery9:: GetData**](/windows/desktop/api) S \_ OK zurückgibt.</span><span class="sxs-lookup"><span data-stu-id="9e1a1-220">The vertices are no longer in use when [**IDirect3DQuery9::GetData**](/windows/desktop/api) returns S\_OK.</span></span> <span data-ttu-id="9e1a1-221">Wenn Sie einen Puffer mit D3DLOCK \_ verwerfen oder ohne Flags sperren, gewährleisten Sie immer, dass die Scheitel Punkte ordnungsgemäß mit dem Grafikprozessor synchronisiert werden. die Verwendung von Lock ohne Flags führt jedoch zu der zuvor beschriebenen Leistungs Einbuße.</span><span class="sxs-lookup"><span data-stu-id="9e1a1-221">Locking a buffer with D3DLOCK\_DISCARD or no flags will always guarantee the vertices are synchronized properly with the graphics processor, however using lock without flags will incur the performance penalty described earlier.</span></span> <span data-ttu-id="9e1a1-222">Andere API-Aufrufe wie [**IDirect3DDevice9:: BeginScene**](/windows/desktop/api), [**IDirect3DDevice9:: EndScene**](/windows/desktop/api)und [**IDirect3DDevice9::P Resent**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-present) garantieren nicht, dass der Grafikprozessor die Verwendung von Vertices abgeschlossen hat.</span><span class="sxs-lookup"><span data-stu-id="9e1a1-222">Other API calls such as [**IDirect3DDevice9::BeginScene**](/windows/desktop/api), [**IDirect3DDevice9::EndScene**](/windows/desktop/api), and [**IDirect3DDevice9::Present**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-present) do not guarantee the graphics processor is finished using vertices.</span></span>

<span data-ttu-id="9e1a1-223">Im folgenden finden Sie Möglichkeiten, dynamische Puffer und die richtigen Sperrflags zu verwenden.</span><span class="sxs-lookup"><span data-stu-id="9e1a1-223">Below are ways to use dynamic buffers and the proper lock flags.</span></span>


```
    // USAGE STYLE 1
    // Discard the entire vertex buffer and refill with thousands of vertices.
    // Might contain multiple objects and/or require multiple DrawPrimitive 
    //   calls separated by state changes, etc.
 
    // Determine the size of data to be moved into the vertex buffer.
    UINT nSizeOfData = nNumberOfVertices * m_nVertexStride;
 
    // Discard and refill the used portion of the vertex buffer.
    CONST DWORD dwLockFlags = D3DLOCK_DISCARD;
    
    // Lock the vertex buffer.
    BYTE* pBytes;
    if( FAILED( m_pVertexBuffer->Lock( 0, 0, &pBytes, dwLockFlags ) ) )
        return false;
    
    // Copy the vertices into the vertex buffer.
    memcpy( pBytes, pVertices, nSizeOfData );
    m_pVertexBuffer->Unlock();
 
    // Render the primitives.
    m_pDevice->DrawPrimitive( D3DPT_TRIANGLELIST, 0, nNumberOfVertices/3)
```




```
    // USAGE STYLE 2
    // Reusing one vertex buffer for multiple objects
 
    // Determine the size of data to be moved into the vertex buffer.
    UINT nSizeOfData = nNumberOfVertices * m_nVertexStride;
 
    // No overwrite will be used if the vertices can fit into 
    //   the space remaining in the vertex buffer.
    DWORD dwLockFlags = D3DLOCK_NOOVERWRITE;
    
    // Check to see if the entire vertex buffer has been used up yet.
    if( m_nNextVertexData > m_nSizeOfVB - nSizeOfData )
    {
        // No space remains. Start over from the beginning 
        //   of the vertex buffer.
        dwLockFlags = D3DLOCK_DISCARD;
        m_nNextVertexData = 0;
    }
    
    // Lock the vertex buffer.
    BYTE* pBytes;
    if( FAILED( m_pVertexBuffer->Lock( (UINT)m_nNextVertexData, nSizeOfData, 
               &pBytes, dwLockFlags ) ) )
        return false;
    
    // Copy the vertices into the vertex buffer.
    memcpy( pBytes, pVertices, nSizeOfData );
    m_pVertexBuffer->Unlock();
 
    // Render the primitives.
    m_pDevice->DrawPrimitive( D3DPT_TRIANGLELIST, 
               m_nNextVertexData/m_nVertexStride, nNumberOfVertices/3)
 
    // Advance to the next position in the vertex buffer.
    m_nNextVertexData += nSizeOfData;
```



## <a name="using-meshes"></a><span data-ttu-id="9e1a1-224">Verwenden von Meshes</span><span class="sxs-lookup"><span data-stu-id="9e1a1-224">Using Meshes</span></span>

<span data-ttu-id="9e1a1-225">Sie können die Netzen mithilfe von Direct3D-indizierten Dreiecken anstelle von indizierten Dreiecks Streifen optimieren.</span><span class="sxs-lookup"><span data-stu-id="9e1a1-225">You can optimize meshes by using Direct3D indexed triangles instead of indexed triangle strips.</span></span> <span data-ttu-id="9e1a1-226">Die Hardware erkennt, dass 95 Prozent der aufeinander folgenden Dreiecke tatsächlich zu einem Streifen und entsprechend angepasst werden.</span><span class="sxs-lookup"><span data-stu-id="9e1a1-226">The hardware will discover that 95 percent of successive triangles actually form strips and adjust accordingly.</span></span> <span data-ttu-id="9e1a1-227">Viele Treiber führen dies auch für ältere Hardware aus.</span><span class="sxs-lookup"><span data-stu-id="9e1a1-227">Many drivers do this for older hardware also.</span></span>

<span data-ttu-id="9e1a1-228">D3DX Mesh-Objekte können jedes Dreieck oder Gesicht aufweisen, das mit einem DWORD-Attribut gekennzeichnet ist, das als Attribut dieses Gesichts bezeichnet wird.</span><span class="sxs-lookup"><span data-stu-id="9e1a1-228">D3DX mesh objects can have each triangle, or face, tagged with a DWORD, called the attribute of that face.</span></span> <span data-ttu-id="9e1a1-229">Die Semantik des DWORD ist Benutzer definiert.</span><span class="sxs-lookup"><span data-stu-id="9e1a1-229">The semantics of the DWORD are user-defined.</span></span> <span data-ttu-id="9e1a1-230">Sie werden von D3DX verwendet, um das Mesh in Teilmengen zu klassifizieren.</span><span class="sxs-lookup"><span data-stu-id="9e1a1-230">They are used by D3DX to classify the mesh into subsets.</span></span> <span data-ttu-id="9e1a1-231">Die Anwendung legt mit dem [**ID3DXMesh:: LockAttributeBuffer**](id3dxmesh--lockattributebuffer.md) -Befehl spezifische Attribute fest.</span><span class="sxs-lookup"><span data-stu-id="9e1a1-231">The application sets per-face attributes using the [**ID3DXMesh::LockAttributeBuffer**](id3dxmesh--lockattributebuffer.md) call.</span></span> <span data-ttu-id="9e1a1-232">Die [**ID3DXMesh:: optimiert**](id3dxmesh--optimize.md) -Methode verfügt über eine Option zum Gruppieren der messcheitel Punkte und Gesichter von Attributen mithilfe der D3DXMESHOPT \_ attrsort-Option.</span><span class="sxs-lookup"><span data-stu-id="9e1a1-232">The [**ID3DXMesh::Optimize**](id3dxmesh--optimize.md) method has an option to group the mesh vertices and faces on attributes using the D3DXMESHOPT\_ATTRSORT option.</span></span> <span data-ttu-id="9e1a1-233">Wenn dies geschehen ist, berechnet das Mesh-Objekt eine Attribut Tabelle, die von der Anwendung durch Aufrufen von [**ID3DXBaseMesh:: GetAttributeTable**](id3dxbasemesh--getattributetable.md)abgerufen werden kann.</span><span class="sxs-lookup"><span data-stu-id="9e1a1-233">When this is done, the mesh object calculates an attribute table that can be obtained by the application by calling [**ID3DXBaseMesh::GetAttributeTable**](id3dxbasemesh--getattributetable.md).</span></span> <span data-ttu-id="9e1a1-234">Dieser Befehl gibt 0 (null) zurück, wenn das Mesh nicht nach Attributen sortiert ist.</span><span class="sxs-lookup"><span data-stu-id="9e1a1-234">This call returns 0 if the mesh is not sorted by attributes.</span></span> <span data-ttu-id="9e1a1-235">Es gibt keine Möglichkeit für eine Anwendung, eine Attribut Tabelle festzulegen, da Sie von der **ID3DXMesh:: optimiert** -Methode generiert wird.</span><span class="sxs-lookup"><span data-stu-id="9e1a1-235">There is no way for an application to set an attribute table because it is generated by the **ID3DXMesh::Optimize** method.</span></span> <span data-ttu-id="9e1a1-236">Die Attribut Sortierung ist Daten sensibel. wenn die Anwendung also weiß, dass ein Mesh Attribut sortiert ist, muss dennoch **ID3DXMesh:: optimiert** aufgerufen werden, um die Attribut Tabelle zu generieren.</span><span class="sxs-lookup"><span data-stu-id="9e1a1-236">The attribute sort is data sensitive, so if the application knows that a mesh is attribute sorted, it still needs to call **ID3DXMesh::Optimize** to generate the attribute table.</span></span>

<span data-ttu-id="9e1a1-237">In den folgenden Themen werden die verschiedenen Attribute eines Mesh beschrieben.</span><span class="sxs-lookup"><span data-stu-id="9e1a1-237">The following topics describe the different attributes of a mesh.</span></span>

### <a name="attribute-id"></a><span data-ttu-id="9e1a1-238">Attribut-ID</span><span class="sxs-lookup"><span data-stu-id="9e1a1-238">Attribute ID</span></span>

<span data-ttu-id="9e1a1-239">Eine Attribut-ID ist ein Wert, der eine Gruppe von Gesichtern einer Attribut Gruppe zuordnet.</span><span class="sxs-lookup"><span data-stu-id="9e1a1-239">An attribute id is a value that associates a group of faces with an attribute group.</span></span> <span data-ttu-id="9e1a1-240">Diese ID beschreibt, welche Teilmenge von Gesichter [**ID3DXBaseMesh::D rawsubset**](id3dxbasemesh--drawsubset.md) zeichnen soll.</span><span class="sxs-lookup"><span data-stu-id="9e1a1-240">This id describes which subset of faces [**ID3DXBaseMesh::DrawSubset**](id3dxbasemesh--drawsubset.md) should draw.</span></span> <span data-ttu-id="9e1a1-241">Attribut-IDs werden für die Gesichter im Attribut Puffer angegeben.</span><span class="sxs-lookup"><span data-stu-id="9e1a1-241">Attribute ids are specified for the faces in the attribute buffer.</span></span> <span data-ttu-id="9e1a1-242">Die tatsächlichen Werte der Attribut-IDs können alles sein, was in 32 Bits passt, aber es ist üblich, 0 bis n zu verwenden, wobei n die Anzahl der Attribute ist.</span><span class="sxs-lookup"><span data-stu-id="9e1a1-242">The actual values of the attribute ids can be anything that fits in 32 bits, but it is common to use 0 to n where n is the number of attributes.</span></span>

### <a name="attribute-buffer"></a><span data-ttu-id="9e1a1-243">Attribut Puffer</span><span class="sxs-lookup"><span data-stu-id="9e1a1-243">Attribute Buffer</span></span>

<span data-ttu-id="9e1a1-244">Der Attribut Puffer ist ein Array von DWords (eins pro Gesicht), das angibt, zu welcher Attribut Gruppe die einzelnen Gesichter gehören.</span><span class="sxs-lookup"><span data-stu-id="9e1a1-244">The attribute buffer is an array of DWORDs (one per face) that specifies which attribute group each face belongs in.</span></span> <span data-ttu-id="9e1a1-245">Dieser Puffer wird bei der Erstellung eines Mesh mit 0 (null) initialisiert, wird jedoch entweder von den Lade Routinen ausgefüllt oder muss vom Benutzer ausgefüllt werden, wenn mehr als ein Attribut mit der ID 0 gewünscht wird.</span><span class="sxs-lookup"><span data-stu-id="9e1a1-245">This buffer is initialized to zero on creation of a mesh, but is either filled by the load routines or must be filled by the user if more than one attribute with id 0 is desired.</span></span> <span data-ttu-id="9e1a1-246">Dieser Puffer enthält die Informationen, die zum Sortieren des Netzes auf der Grundlage von Attributen in [**ID3DXMesh:: optimiert**](id3dxmesh--optimize.md)verwendet werden.</span><span class="sxs-lookup"><span data-stu-id="9e1a1-246">This buffer contains the information that is used to sort the mesh based on attributes in [**ID3DXMesh::Optimize**](id3dxmesh--optimize.md).</span></span> <span data-ttu-id="9e1a1-247">Wenn keine Attribut Tabelle vorhanden ist, scannt [**ID3DXBaseMesh::D rawsubset**](id3dxbasemesh--drawsubset.md) den Puffer, um die Gesichter des zu zeichnenden Attributs auszuwählen.</span><span class="sxs-lookup"><span data-stu-id="9e1a1-247">If no attribute table is present, [**ID3DXBaseMesh::DrawSubset**](id3dxbasemesh--drawsubset.md) scans this buffer to select the faces of the given attribute to draw.</span></span>

### <a name="attribute-table"></a><span data-ttu-id="9e1a1-248">Attribut Tabelle</span><span class="sxs-lookup"><span data-stu-id="9e1a1-248">Attribute Table</span></span>

<span data-ttu-id="9e1a1-249">Bei der Attribut Tabelle handelt es sich um eine Struktur im Besitz des Netzes.</span><span class="sxs-lookup"><span data-stu-id="9e1a1-249">The attribute table is a structure owned and maintained by the mesh.</span></span> <span data-ttu-id="9e1a1-250">Die einzige Möglichkeit für die Generierung ist das Aufrufen von [**ID3DXMesh::**](id3dxmesh--optimize.md) Optimization mit aktivierter Attribut Sortierung oder stärkerer Optimierung.</span><span class="sxs-lookup"><span data-stu-id="9e1a1-250">The only way for one to be generated is by calling [**ID3DXMesh::Optimize**](id3dxmesh--optimize.md) with attribute sorting or stronger optimization enabled.</span></span> <span data-ttu-id="9e1a1-251">Die Attribut Tabelle wird verwendet, um schnell einen einzelnen zeichnen-primitiven Aufrufen von [**ID3DXBaseMesh::D rawsubset**](id3dxbasemesh--drawsubset.md)zu initiieren.</span><span class="sxs-lookup"><span data-stu-id="9e1a1-251">The attribute table is used to quickly initiate a single draw primitive call to [**ID3DXBaseMesh::DrawSubset**](id3dxbasemesh--drawsubset.md).</span></span> <span data-ttu-id="9e1a1-252">Der einzige andere Verwendungszweck besteht darin, dass fortlaufende Netze auch diese Struktur beibehalten, sodass Sie sehen können, welche Gesichter und Scheitel Punkte auf der aktuellen Detailebene aktiv sind.</span><span class="sxs-lookup"><span data-stu-id="9e1a1-252">The only other use is that progressing meshes also maintain this structure, so it is possible to see what faces and vertices are active at the current level of detail.</span></span>

## <a name="z-buffer-performance"></a><span data-ttu-id="9e1a1-253">Z-Puffer Leistung</span><span class="sxs-lookup"><span data-stu-id="9e1a1-253">Z-Buffer Performance</span></span>

<span data-ttu-id="9e1a1-254">Anwendungen können die Leistung bei Verwendung von z-Pufferung und Texturierung steigern, indem Sie sicherstellen, dass Szenen von vorne nach hinten gerendert werden.</span><span class="sxs-lookup"><span data-stu-id="9e1a1-254">Applications can increase performance when using z-buffering and texturing by ensuring that scenes are rendered from front to back.</span></span> <span data-ttu-id="9e1a1-255">Strukturierte z-gepufferte primitive werden für den z-Puffer auf der Basis der Scan Linie vorgetestet.</span><span class="sxs-lookup"><span data-stu-id="9e1a1-255">Textured z-buffered primitives are pretested against the z-buffer on a scan line basis.</span></span> <span data-ttu-id="9e1a1-256">Wenn eine Scanzeile von einem zuvor gerenderten Polygon ausgeblendet wird, lehnt das System Sie schnell und effizient ab.</span><span class="sxs-lookup"><span data-stu-id="9e1a1-256">If a scan line is hidden by a previously rendered polygon, the system rejects it quickly and efficiently.</span></span> <span data-ttu-id="9e1a1-257">Z-Pufferung kann die Leistung verbessern, aber das Verfahren ist besonders nützlich, wenn eine Szene die gleichen Pixel mehrmals zeichnet.</span><span class="sxs-lookup"><span data-stu-id="9e1a1-257">Z-buffering can improve performance, but the technique is most useful when a scene draws the same pixels more than once.</span></span> <span data-ttu-id="9e1a1-258">Dies ist schwierig zu berechnen, aber Sie können oft eine genaue Näherung treffen.</span><span class="sxs-lookup"><span data-stu-id="9e1a1-258">This is difficult to calculate exactly, but you can often make a close approximation.</span></span> <span data-ttu-id="9e1a1-259">Wenn die gleichen Pixel weniger als zweimal gezeichnet werden, können Sie die beste Leistung erzielen, indem Sie z-bufferoff deaktivieren und die Szene von hinten wieder in den Vordergrund rendern.</span><span class="sxs-lookup"><span data-stu-id="9e1a1-259">If the same pixels are drawn less than twice, you can achieve the best performance by turning z-buffering off and rendering the scene from back to front.</span></span>

## <a name="related-topics"></a><span data-ttu-id="9e1a1-260">Zugehörige Themen</span><span class="sxs-lookup"><span data-stu-id="9e1a1-260">Related topics</span></span>

<dl> <dt>

[<span data-ttu-id="9e1a1-261">Programmiertipps</span><span class="sxs-lookup"><span data-stu-id="9e1a1-261">Programming Tips</span></span>](programming-tips.md)
</dt> </dl>

 

 
