---
description: Das prtdemo-Beispiel und der prtcmdline-Simulator, die im DirectX SDK enthalten sind, stellen Übertragungs Vektoren an den Scheitel Punkten eines Netzes dar.
ms.assetid: cee049e8-3245-4fce-ab2f-ba251eacc72a
title: Darstellen von PRT mit Texturen (Direct3D 9)
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: 4647cfc85451ede9507e007ed556a203a3cd890a
ms.sourcegitcommit: a47bd86f517de76374e4fff33cfeb613eb259a7e
ms.translationtype: MT
ms.contentlocale: de-DE
ms.lasthandoff: 01/06/2021
ms.locfileid: "104213978"
---
# <a name="representing-prt-with-textures-direct3d-9"></a><span data-ttu-id="29050-103">Darstellen von PRT mit Texturen (Direct3D 9)</span><span class="sxs-lookup"><span data-stu-id="29050-103">Representing PRT With Textures (Direct3D 9)</span></span>

<span data-ttu-id="29050-104">Das prtdemo-Beispiel und der prtcmdline-Simulator, die im DirectX SDK enthalten sind, stellen Übertragungs Vektoren an den Scheitel Punkten eines Netzes dar.</span><span class="sxs-lookup"><span data-stu-id="29050-104">The PRTDemo sample and PRTCmdLine simulator included in the DirectX SDK represent transfer vectors at the vertices of a mesh.</span></span> <span data-ttu-id="29050-105">Damit das PRT-Signal genau dargestellt werden kann, ist dies möglicherweise ein Mosaik, das für aktuelle Spiele nicht praktikabel ist.</span><span class="sxs-lookup"><span data-stu-id="29050-105">In order to represent the PRT signal accurately, this can require tessellations that may be impractical for current games.</span></span> <span data-ttu-id="29050-106">Das darstellen von Übertragungs Vektoren in Textur Karten ist ein alternativer Ansatz, bei dem die gleichen Datenkosten unabhängig von der Mesh-Komplexität entstehen.</span><span class="sxs-lookup"><span data-stu-id="29050-106">Representing transfer vectors in texture maps is an alternative approach that has the same data cost independent of mesh complexity.</span></span> <span data-ttu-id="29050-107">Es gibt mehrere Möglichkeiten, Übertragungs Vektor-Textur Zuordnungen mithilfe der D3DX PRT-Bibliothek zu generieren.</span><span class="sxs-lookup"><span data-stu-id="29050-107">There are several ways to generate transfer vector texture maps using the D3DX PRT Library.</span></span>

## <a name="precomputing-transfer-vectors"></a><span data-ttu-id="29050-108">Vorab berechnen von Übertragungs Vektoren</span><span class="sxs-lookup"><span data-stu-id="29050-108">Precomputing Transfer Vectors</span></span>

<span data-ttu-id="29050-109">Ein Ansatz wäre das Ändern der prtdemo-und prtcmdline-Beispiele, um bei jeder textrisierung einer Oberfläche einen Übertragungs Vektor zu berechnen.</span><span class="sxs-lookup"><span data-stu-id="29050-109">One approach would be to modify the PRTDemo and PRTCmdLine samples to compute a transfer vector at every texel in a parameterization of a surface.</span></span> <span data-ttu-id="29050-110">Gehen Sie dazu wie folgt vor:</span><span class="sxs-lookup"><span data-stu-id="29050-110">To do this:</span></span>

1.  <span data-ttu-id="29050-111">Ändern Sie den [**D3DXCreatePRTEngine**](d3dxcreateprtengine.md) -Aufrufwert, um Texturkoordinaten aus dem Mesh zu extrahieren (extractuvs müssen **true** sein).</span><span class="sxs-lookup"><span data-stu-id="29050-111">Modify the call to [**D3DXCreatePRTEngine**](d3dxcreateprtengine.md) to extract texture coordinates from the mesh (ExtractUVs must be **TRUE**)</span></span>
2.  <span data-ttu-id="29050-112">Ersetzen Sie [**D3DXCreatePRTBuffer**](d3dxcreateprtbuffer.md) -Aufrufe durch [**D3DXCreatePRTBufferTex**](d3dxcreateprtbuffertex.md) , indem Sie die gleiche Textur Größe verwenden.</span><span class="sxs-lookup"><span data-stu-id="29050-112">Replace [**D3DXCreatePRTBuffer**](d3dxcreateprtbuffer.md) calls with [**D3DXCreatePRTBufferTex**](d3dxcreateprtbuffertex.md) using the same texture size.</span></span>

<span data-ttu-id="29050-113">Alle ID3DXPRTEngine-Methoden können mit Ausnahme von computebounceadaptive, computessadaptive, computess und computedirectlightingshadaptive mit pro-texsimulationen verwendet werden.</span><span class="sxs-lookup"><span data-stu-id="29050-113">All ID3DXPRTEngine methods work with per-texel simulations except for: ComputeBounceAdaptive, ComputeSSAdaptive, ComputeSS, and ComputeDirectLightingSHAdaptive.</span></span> <span data-ttu-id="29050-114">Während die Textur Raumsimulation das richtige Ergebnis generiert, kann Sie häufig recht langsam sein, da Sie höchstwahrscheinlich Übertragungs Vektoren mit hoher Dichte berechnen wird.</span><span class="sxs-lookup"><span data-stu-id="29050-114">While texture-space simulation will generate the correct result, it can often be fairly slow since it will most likely be computing transfer vectors at a high density.</span></span>

<span data-ttu-id="29050-115">Ein anderer Ansatz ist die Berechnung einer adaptiven pro-Vertex-PRT-Simulation (mit Texturkoordinaten, die für die pro-tex-Daten verwendet werden) und anschließendem Aufrufs von [**ID3DXPRTEngine:: resamplebuffer**](id3dxprtengine--resamplebuffer.md) (mithilfe eines Ausgabepuffers, der mit [**D3DXCreatePRTBufferTex**](d3dxcreateprtbuffertex.md) bei entsprechender Auflösung erstellt wurde).</span><span class="sxs-lookup"><span data-stu-id="29050-115">Another approach is to compute an adaptive per-vertex PRT simulation (with texture coordinates that will be used for the per-texel data) and then call [**ID3DXPRTEngine::ResampleBuffer**](id3dxprtengine--resamplebuffer.md) (using an output buffer created using [**D3DXCreatePRTBufferTex**](d3dxcreateprtbuffertex.md) at the appropriate resolution).</span></span> <span data-ttu-id="29050-116">Dies funktioniert mit allen D3DX PRT-Funktionen im SDK und ist häufig viel effizienter als das direkte Berechnen eines pro-texübertragungs Puffers.</span><span class="sxs-lookup"><span data-stu-id="29050-116">This works with all D3DX PRT functionality in the SDK and can often be much more efficient than directly computing a per-texel transfer buffer.</span></span>

## <a name="runtime-calculations"></a><span data-ttu-id="29050-117">Lauf Zeit Berechnungen</span><span class="sxs-lookup"><span data-stu-id="29050-117">Runtime Calculations</span></span>

<span data-ttu-id="29050-118">Wenn ein einzelner Cluster verwendet wird, können die Ergebnisse gefiltert und MIP-zugeordnet werden, wie jede andere Textur, und der Pixelshader ist identisch mit dem Vertex-Shader-Code, der mit prtdemo ausgeliefert wird.</span><span class="sxs-lookup"><span data-stu-id="29050-118">If a single cluster is used the results can be filtered and mip-mapped like any other texture and the pixel shader is identical to the vertex shader code that ships with PRTDemo.</span></span>

<span data-ttu-id="29050-119">Wenn bei der Komprimierung mehrere Cluster generiert werden, können die Daten nicht gefiltert oder falsch zugeordnet werden, da Clustering-Indizes nicht kontinuierlich sind.</span><span class="sxs-lookup"><span data-stu-id="29050-119">If compression generates multiple clusters, you cannot filter or mipmap the data because clustering indexes are not continuous.</span></span> <span data-ttu-id="29050-120">Im folgenden finden Sie einige Alternativen zur Verarbeitung von multiclusterdaten:</span><span class="sxs-lookup"><span data-stu-id="29050-120">Here are some alternatives for handling multi-clustered data:</span></span>

-   <span data-ttu-id="29050-121">Führen Sie den gesamten Filter im Pixel-Shader aus.</span><span class="sxs-lookup"><span data-stu-id="29050-121">Do all of the filtering yourself in the pixel shader.</span></span> <span data-ttu-id="29050-122">Leider ist dies aus Leistungsgründen in der Regel unpraktisch.</span><span class="sxs-lookup"><span data-stu-id="29050-122">Unfortunately, this is generally impractical for performance reasons.</span></span>
-   <span data-ttu-id="29050-123">Wenn es sich bei den Texturen um nicht MIP-zugeordnete Texturen mit geringer Auflösung handelt (d. h. Licht Maps), ist es höchstwahrscheinlich effizienter, die Beleuchtung direkt im Textur Bereich zu berechnen, wobei keine Filterung stattfindet, und das Objekt mit einer schattierten Textur zu Rendering.</span><span class="sxs-lookup"><span data-stu-id="29050-123">If the textures are low resolution non mip-mapped textures (ie: light maps), it is most likely more efficient to just compute the lighting directly in texture space - where no filtering will occur, and render the object with a shaded texture.</span></span> <span data-ttu-id="29050-124">Dabei handelt es sich im Wesentlichen um eine dynamische lichtkarte, die vollständig auf der GPU erstellt wird.</span><span class="sxs-lookup"><span data-stu-id="29050-124">This is essentially a dynamic light map that is created entirely on the GPU.</span></span>
-   <span data-ttu-id="29050-125">Wenn ein Textur Atlas verwendet wird (siehe [Verwenden von uvatlas (Direct3D 9)](using-uvatlas.md)), können Sie die Szene manuell gruppieren, indem Sie alle Übertragungs Vektoren in einer verbundenen Komponente im Textur Raum im gleichen Cluster befinden.</span><span class="sxs-lookup"><span data-stu-id="29050-125">If a texture atlas is used (see [Using UVAtlas (Direct3D 9)](using-uvatlas.md)), you could manually cluster the scene by having all transfer vectors in a connected component in texture space be in the same cluster.</span></span> <span data-ttu-id="29050-126">Auf diese Weise können Sie die Textur filtern, da sich alle zugänglichen texeln durch die Konstruktion im gleichen Cluster befinden würden.</span><span class="sxs-lookup"><span data-stu-id="29050-126">This way you can filter the texture because all texels accessed would be in the same cluster by construction.</span></span> <span data-ttu-id="29050-127">Die Cluster-ID für eine bestimmte Fläche kann vom Vertexshader weitergegeben werden.</span><span class="sxs-lookup"><span data-stu-id="29050-127">The cluster ID for a given face could be propagated from the vertex shader.</span></span>

<span data-ttu-id="29050-128">Pixel-Shader haben weitaus weniger Konstante Register, die nicht indiziert werden können. Daher unterscheidet sich der Pixelshader etwas von dem Vertexshader.</span><span class="sxs-lookup"><span data-stu-id="29050-128">Pixel shaders have much fewer constant registers that cannot be indexed, so the pixel shader is somewhat different than the vertex shader.</span></span> <span data-ttu-id="29050-129">Das Speichern der pro-Cluster-Arbeit in einer dynamischen Textur mit niedriger Auflösung und die Verwendung von Textur Ladungen wäre die effizienteste Methode zum Rendering, wenn mehrere Cluster verwendet werden.</span><span class="sxs-lookup"><span data-stu-id="29050-129">Storing the per-cluster work in a low resolution dynamic texture and using texture loads would be the most efficient way to render when using multiple clusters.</span></span>

## <a name="related-topics"></a><span data-ttu-id="29050-130">Zugehörige Themen</span><span class="sxs-lookup"><span data-stu-id="29050-130">Related topics</span></span>

<dl> <dt>

[<span data-ttu-id="29050-131">Voraus berechnete Strahlungs Übertragung</span><span class="sxs-lookup"><span data-stu-id="29050-131">Precomputed Radiance Transfer</span></span>](precomputed-radiance-transfer.md)
</dt> <dt>

<span data-ttu-id="29050-132">[Beispiel für eine PRT-Demo](https://msdn.microsoft.com/library/Ee418763(v=VS.85).aspx)</span><span class="sxs-lookup"><span data-stu-id="29050-132">[PRT Demo Sample](https://msdn.microsoft.com/library/Ee418763(v=VS.85).aspx)</span></span>
</dt> <dt>

<span data-ttu-id="29050-133">[PRT-Simulator (prtcmdline.exe)](https://msdn.microsoft.com/library/Ee418766(v=VS.85).aspx)</span><span class="sxs-lookup"><span data-stu-id="29050-133">[PRT Simulator (prtcmdline.exe)](https://msdn.microsoft.com/library/Ee418766(v=VS.85).aspx)</span></span>
</dt> </dl>

 

 



