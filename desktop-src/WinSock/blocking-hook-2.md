---
description: Obwohl dieser Mechanismus für einfache Anwendungen ausreichend ist, kann er die komplexen Anforderungen für die Nachrichten Verteilung erweiterter Anwendungen, wie z. b. solche mit dem MDI-Modell (Multiple Document Interface), nicht unterstützen.
ms.assetid: e4558e71-bbec-415a-a7c2-9025a4d6c474
title: Hook blockieren
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: 2dcd098692784a662456c990a238bd309db0c321
ms.sourcegitcommit: 831e8f3db78ab820e1710cede244553c70e50500
ms.translationtype: MT
ms.contentlocale: de-DE
ms.lasthandoff: 01/07/2021
ms.locfileid: "106368079"
---
# <a name="blocking-hook"></a><span data-ttu-id="656fa-103">Hook blockieren</span><span class="sxs-lookup"><span data-stu-id="656fa-103">Blocking Hook</span></span>

<span data-ttu-id="656fa-104">Obwohl dieser Mechanismus für einfache Anwendungen ausreichend ist, kann er die komplexen Anforderungen für die Nachrichten Verteilung erweiterter Anwendungen, wie z. b. solche mit dem MDI-Modell (Multiple Document Interface), nicht unterstützen.</span><span class="sxs-lookup"><span data-stu-id="656fa-104">Although this mechanism is sufficient for simple applications, it cannot support the complex message-dispatching requirements of more advanced applications such as those using the Multiple Document Interface (MDI) model.</span></span> <span data-ttu-id="656fa-105">Bei solchen Anwendungen kann ein Thread spezifischer blockierender Hook von der Anwendung installiert werden.</span><span class="sxs-lookup"><span data-stu-id="656fa-105">For such applications, a thread-specific blocking hook may be installed by the application.</span></span> <span data-ttu-id="656fa-106">Diese wird vom Dienstanbieter anstelle des standardmäßigen blockierenden Hooks aufgerufen, der im vorherigen beschrieben wird.</span><span class="sxs-lookup"><span data-stu-id="656fa-106">This will be called by the service provider instead of the default blocking hook described in the preceding.</span></span> <span data-ttu-id="656fa-107">Ein Dienstanbieter muss einen Zeiger auf den Thread für Thread übergreifende Blockierung aus dem Ws2-32.dll abrufen, \_ indem [**wpuqueryblockingcallback**](/windows/desktop/api/Ws2spi/nf-ws2spi-wpuqueryblockingcallback)aufgerufen wird.</span><span class="sxs-lookup"><span data-stu-id="656fa-107">A service provider must retrieve a pointer to the per-thread blocking hook from the Ws2\_32.dll by calling [**WPUQueryBlockingCallback**](/windows/desktop/api/Ws2spi/nf-ws2spi-wpuqueryblockingcallback).</span></span> <span data-ttu-id="656fa-108">Wenn die Anwendung keinen eigenen blockierenden Hook installiert hat, wird ein Zeiger auf die standardmäßige blockierende Hook-Funktion zurückgegeben.</span><span class="sxs-lookup"><span data-stu-id="656fa-108">If the application has not installed its own blocking hook a pointer to the default blocking hook function will be returned.</span></span>

<span data-ttu-id="656fa-109">Ein Windows Sockets-Dienstanbieter kann nicht davon ausgehen, dass ein von der Anwendung bereitgestellter blockierter Hook das Fortsetzen der Nachrichtenverarbeitung zulässt</span><span class="sxs-lookup"><span data-stu-id="656fa-109">A Windows Sockets service provider cannot assume that an application-supplied blocking hook allows message processing to continue as the default blocking hook does.</span></span> <span data-ttu-id="656fa-110">Einige Anwendungen können die Möglichkeit der wieder eintretende Nachricht nicht tolerieren, wenn ein Blockierungs Vorgang aussteht.</span><span class="sxs-lookup"><span data-stu-id="656fa-110">Some applications cannot tolerate the possibility of reentrant messages while a blocking operation is outstanding.</span></span> <span data-ttu-id="656fa-111">Die blockierende Hook-Funktion einer solchen Anwendung würde einfach **false** zurückgeben.</span><span class="sxs-lookup"><span data-stu-id="656fa-111">Such an application's blocking hook function would simply return **FALSE**.</span></span> <span data-ttu-id="656fa-112">Wenn ein Dienstanbieter von Nachrichten für den internen Vorgang abhängig ist, kann er **gekmessage**(hmywnd...) ausführen, bevor er den blockierenden Hook der Anwendung ausführt, sodass er seine eigenen Nachrichten abrufen kann, ohne dass sich dies auf den Rest des Systems auswirkt.</span><span class="sxs-lookup"><span data-stu-id="656fa-112">If a service provider depends on messages for its internal operation, it may execute **PeekMessage**(hMyWnd...) before executing the application's blocking hook so that it can get its own messages without affecting the rest of the system.</span></span>

<span data-ttu-id="656fa-113">In präemptiven Multithread-Versionen von Windows ist kein standardmäßiger blockierter Hook installiert.</span><span class="sxs-lookup"><span data-stu-id="656fa-113">There is no default blocking hook installed in preemptive multithreaded versions of Windows.</span></span> <span data-ttu-id="656fa-114">Dies liegt daran, dass andere Prozesse nicht blockiert werden, wenn eine einzelne Anwendung auf den Abschluss eines Vorgangs wartet (und daher nicht " **Peer-Message** " oder " **GetMessage** " aufrufen, was dazu führt, dass die Anwendung den Prozessor in nicht präemptiven Fenstern liefert).</span><span class="sxs-lookup"><span data-stu-id="656fa-114">This is because other processes will not be blocked if a single application is waiting for an operation to complete (and hence not calling **PeekMessage** or **GetMessage** which causes the application to yield the processor in nonpreemptive Windows).</span></span> <span data-ttu-id="656fa-115">Wenn der Dienstanbieter [**wpuqueryblockingcallback**](/windows/desktop/api/Ws2spi/nf-ws2spi-wpuqueryblockingcallback) aufruft, wird ein NULL-Zeiger zurückgegeben, der angibt, dass der Anbieter systemeigene Blockierungs Funktionen von Betriebssystemen verwenden soll.</span><span class="sxs-lookup"><span data-stu-id="656fa-115">When the service provider calls [**WPUQueryBlockingCallback**](/windows/desktop/api/Ws2spi/nf-ws2spi-wpuqueryblockingcallback) a null pointer will be returned indicating that the provider is to use native operating system blocking functions.</span></span> <span data-ttu-id="656fa-116">Um die Abwärtskompatibilität zu erhalten, kann jedoch ein von der Anwendung bereitgestellter blockierter Hook in Windows immer noch auf Thread Basis installiert werden.</span><span class="sxs-lookup"><span data-stu-id="656fa-116">However, in order to preserve backward compatibility, an application-supplied blocking hook can still be installed on a per-thread basis in Windows.</span></span>

<span data-ttu-id="656fa-117">Der Winsock-Dienstanbieter ruft den blockierenden Hook nur auf, wenn Folgendes zutrifft: die Routine ist eine, die so definiert ist, dass Sie blockiert werden kann, der angegebene Socket ist ein blockierender Socket, und die Anforderung kann nicht sofort abgeschlossen werden.</span><span class="sxs-lookup"><span data-stu-id="656fa-117">The Winsock service provider calls the blocking hook only if all of the following are true: the routine is one which is defined as being able to block, the specified socket is a blocking socket, and the request cannot be completed immediately.</span></span> <span data-ttu-id="656fa-118">Wenn nur nicht blockierende Sockets und [**wspasyncselect**](/previous-versions/windows/desktop/legacy/ms742267(v=vs.85)) / [**wspeventselect**](/previous-versions/windows/hardware/network/ff566287(v=vs.85)) anstelle von [**wspselect**](/previous-versions/windows/desktop/legacy/ms742289(v=vs.85)) verwendet werden, wird der blockierende Hook nie aufgerufen.</span><span class="sxs-lookup"><span data-stu-id="656fa-118">If only nonblocking sockets and [**WSPAsyncSelect**](/previous-versions/windows/desktop/legacy/ms742267(v=vs.85))/[**WSPEventSelect**](/previous-versions/windows/hardware/network/ff566287(v=vs.85)) instead of [**WSPSelect**](/previous-versions/windows/desktop/legacy/ms742289(v=vs.85)) are used, then the blocking hook will never be called.</span></span>

> [!Note]  
> <span data-ttu-id="656fa-119">Wenn während der Zeit, in der pseudoblocking zum Blockieren eines Threads verwendet wird, eine Windows-Meldung für den Thread empfangen wird, besteht das Risiko, dass der Thread versucht, einen anderen Winsock-Aufruf auszugeben.</span><span class="sxs-lookup"><span data-stu-id="656fa-119">If, during the time pseudoblocking is being used to block a thread, a Windows message is received for the thread, there is a risk that the thread will attempt to issue another Winsock call.</span></span> <span data-ttu-id="656fa-120">Aufgrund der Schwierigkeit, diese Bedingung sicher zu verwalten, hat die Windows Sockets 1,1-Spezifikation dieses Verhalten nicht zugelassen.</span><span class="sxs-lookup"><span data-stu-id="656fa-120">Because of the difficulty of managing this condition safely, the Windows Sockets 1.1 specification disallowed this behavior.</span></span> <span data-ttu-id="656fa-121">Es ist nicht zulässig, dass ein angegebener Thread mehrere, nicht aufgerufenen Winsock-Funktionsaufrufe durchführen kann.</span><span class="sxs-lookup"><span data-stu-id="656fa-121">It is not permissible for a given thread to make multiple, nested Winsock function calls.</span></span> <span data-ttu-id="656fa-122">Nur ein ausstehender Funktions Aufrufwert ist für einen bestimmten Thread zulässig.</span><span class="sxs-lookup"><span data-stu-id="656fa-122">Only one outstanding function call is allowed for a particular thread.</span></span> <span data-ttu-id="656fa-123">Alle geschsasteten Winsock-Funktionsaufrufe schlagen mit dem Fehler "wsaerprogress" fehl.</span><span class="sxs-lookup"><span data-stu-id="656fa-123">Any nested Winsock function calls fail with the error WSAEINPROGRESS.</span></span> <span data-ttu-id="656fa-124">Es sollte hervorgehoben werden, dass diese Einschränkung sowohl für blockierende als auch für nicht blockierende Vorgänge gilt, aber nur in Windows Sockets 1,1-Umgebungen.</span><span class="sxs-lookup"><span data-stu-id="656fa-124">It should be emphasized that this restriction applies to both blocking and nonblocking operations, but only in Windows Sockets 1.1 environments.</span></span> <span data-ttu-id="656fa-125">Es gibt einige Ausnahmen zu dieser Regel, einschließlich zwei Funktionen, mit denen eine Anwendung ermitteln kann, ob ein Pseudo Blockierungs Vorgang tatsächlich ausgeführt wird, und um einen solchen Vorgang bei Bedarf abzubrechen.</span><span class="sxs-lookup"><span data-stu-id="656fa-125">There are a few exceptions to this rule, including two functions that allow an application to determine whether a pseudoblocking operation is in fact in progress, and to cancel such an operation if need be.</span></span> <span data-ttu-id="656fa-126">Diese werden im folgenden beschrieben.</span><span class="sxs-lookup"><span data-stu-id="656fa-126">These are described in the following.</span></span>

 

 

 
