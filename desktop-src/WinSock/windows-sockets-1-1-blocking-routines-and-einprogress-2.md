---
description: Ein wichtiges Problem beim Portieren von Anwendungen aus einer Berkeley Sockets-Umgebung in eine Windows-Umgebung ist die Blockierung. Dies bedeutet, dass eine Funktion aufgerufen wird, die erst zurückgegeben wird, wenn der zugehörige Vorgang abgeschlossen ist.
ms.assetid: 13aedad7-5f3b-4d73-b8e5-be3a095294bc
title: Windows Sockets 1,1 blockierende Routinen und einen Fortschritt
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: 1ea6d45b4d25578505a3cb4ab4beb7c2c2fe90e4
ms.sourcegitcommit: 831e8f3db78ab820e1710cede244553c70e50500
ms.translationtype: MT
ms.contentlocale: de-DE
ms.lasthandoff: 01/07/2021
ms.locfileid: "106343761"
---
# <a name="windows-sockets-11-blocking-routines-and-einprogress"></a><span data-ttu-id="1f302-103">Windows Sockets 1,1 blockierende Routinen und einen Fortschritt</span><span class="sxs-lookup"><span data-stu-id="1f302-103">Windows Sockets 1.1 Blocking Routines and EINPROGRESS</span></span>

<span data-ttu-id="1f302-104">Ein wichtiges Problem beim Portieren von Anwendungen aus einer Berkeley Sockets-Umgebung in eine Windows-Umgebung ist die Blockierung. Dies bedeutet, dass eine Funktion aufgerufen wird, die erst zurückgegeben wird, wenn der zugehörige Vorgang abgeschlossen ist.</span><span class="sxs-lookup"><span data-stu-id="1f302-104">One major issue in porting applications from a Berkeley Sockets environment to a Windows environment involves blocking; that is, invoking a function that does not return until the associated operation is completed.</span></span> <span data-ttu-id="1f302-105">Ein Problem tritt auf, wenn der Vorgang eine beliebig lange Zeit in Anspruch nimmt: ein Beispiel ist eine [**empfangener**](/windows/desktop/api/winsock/nf-winsock-recv) -Funktion, die blockiert werden kann, bis Daten vom Peer System empfangen wurden.</span><span class="sxs-lookup"><span data-stu-id="1f302-105">A problem arises when the operation takes an arbitrarily long time to complete: an example is a [**recv**](/windows/desktop/api/winsock/nf-winsock-recv) function, which might block until data has been received from the peer system.</span></span> <span data-ttu-id="1f302-106">Das Standardverhalten im Berkeley Sockets-Modell besteht darin, dass ein Socket im Blockierungs Modus betrieben wird, es sei denn, der Programmierer fordert explizit an, dass Vorgänge als nicht blockierende behandelt werden.</span><span class="sxs-lookup"><span data-stu-id="1f302-106">The default behavior within the Berkeley Sockets model is for a socket to operate in blocking mode unless the programmer explicitly requests that operations be treated as nonblocking.</span></span> <span data-ttu-id="1f302-107">Windows Sockets 1,1-Umgebungen konnten keine präemptiven Zeitplanung annehmen.</span><span class="sxs-lookup"><span data-stu-id="1f302-107">Windows Sockets 1.1 environments could not assume preemptive scheduling.</span></span> <span data-ttu-id="1f302-108">Daher wird dringend empfohlen, dass Programmierer die nicht blockierenden (asynchronen) Vorgänge verwenden, sofern dies mit Windows Sockets 1,1 möglich ist.</span><span class="sxs-lookup"><span data-stu-id="1f302-108">Therefore, it was strongly recommended that programmers use the nonblocking (asynchronous) operations if at all possible with Windows Sockets 1.1.</span></span> <span data-ttu-id="1f302-109">Da dies nicht immer möglich war, wurden die im folgenden beschriebenen Funktionen zur Pseudo Blockierung bereitgestellt.</span><span class="sxs-lookup"><span data-stu-id="1f302-109">Because this was not always possible, the pseudo-blocking facilities described in the following were provided.</span></span>

> [!Note]  
> <span data-ttu-id="1f302-110">Windows Sockets 2 wird nur mit präemptiven 32-Bit-Betriebssystemen ausgeführt, bei denen Deadlocks kein Problem darstellen.</span><span class="sxs-lookup"><span data-stu-id="1f302-110">Windows Sockets 2 only runs on preemptive 32-bit operating systems where deadlocks are not a problem.</span></span> <span data-ttu-id="1f302-111">Für Windows Sockets 1,1 Empfohlene Programmierverfahren sind in Windows Sockets 2 nicht erforderlich.</span><span class="sxs-lookup"><span data-stu-id="1f302-111">Programming practices recommended for Windows Sockets 1.1 are not necessary in Windows Sockets 2.</span></span>

 

<span data-ttu-id="1f302-112">Selbst bei einem blockierenden Socket sind einige Funktionen – [**Bind**](/windows/desktop/api/winsock/nf-winsock-bind), [**getsockopt**](/windows/desktop/api/winsock/nf-winsock-getsockopt)und [**getPeer Name**](/windows/desktop/api/winsock/nf-winsock-getpeername) – sofort fertiggestellt.</span><span class="sxs-lookup"><span data-stu-id="1f302-112">Even on a blocking socket, some functions — [**bind**](/windows/desktop/api/winsock/nf-winsock-bind), [**getsockopt**](/windows/desktop/api/winsock/nf-winsock-getsockopt), and [**getpeername**](/windows/desktop/api/winsock/nf-winsock-getpeername) for example — complete immediately.</span></span> <span data-ttu-id="1f302-113">Es gibt keinen Unterschied zwischen einem blockierenden und einem nicht blockierenden Vorgang für diese Funktionen.</span><span class="sxs-lookup"><span data-stu-id="1f302-113">There is no difference between a blocking and a nonblocking operation for those functions.</span></span> <span data-ttu-id="1f302-114">Andere Vorgänge, z. b. " [**empfangener**](/windows/desktop/api/winsock/nf-winsock-recv)", können sofort durchgeführt werden, oder es kann je nach den verschiedenen Transportbedingungen beliebig lange dauern.</span><span class="sxs-lookup"><span data-stu-id="1f302-114">Other operations, such as [**recv**](/windows/desktop/api/winsock/nf-winsock-recv), can complete immediately or take an arbitrary time to complete, depending on various transport conditions.</span></span> <span data-ttu-id="1f302-115">Bei Anwendung auf einen blockierenden Socket werden diese Vorgänge als blockierende Vorgänge bezeichnet.</span><span class="sxs-lookup"><span data-stu-id="1f302-115">When applied to a blocking socket, these operations are referred to as blocking operations.</span></span> <span data-ttu-id="1f302-116">Die folgenden Funktionen können blockieren:</span><span class="sxs-lookup"><span data-stu-id="1f302-116">The following functions can block:</span></span>

-   [<span data-ttu-id="1f302-117">**empfangener**</span><span class="sxs-lookup"><span data-stu-id="1f302-117">**recv**</span></span>](/windows/desktop/api/winsock/nf-winsock-recv)
-   [<span data-ttu-id="1f302-118">**recvfrom**</span><span class="sxs-lookup"><span data-stu-id="1f302-118">**recvfrom**</span></span>](/windows/desktop/api/winsock/nf-winsock-recvfrom)
-   [<span data-ttu-id="1f302-119">**Senden**</span><span class="sxs-lookup"><span data-stu-id="1f302-119">**send**</span></span>](/windows/desktop/api/Winsock2/nf-winsock2-send)
-   [<span data-ttu-id="1f302-120">**SendTo**</span><span class="sxs-lookup"><span data-stu-id="1f302-120">**sendto**</span></span>](/windows/desktop/api/winsock/nf-winsock-sendto)

<span data-ttu-id="1f302-121">Mit 16-Bit-Windows Sockets 1,1 wird ein blockierender Vorgang, der nicht sofort ausgeführt werden kann, wie folgt durch Pseudo Blockierung behandelt.</span><span class="sxs-lookup"><span data-stu-id="1f302-121">With 16-bit Windows Sockets 1.1, a blocking operation that cannot complete immediately is handled by pseudo-blocking as follows.</span></span>

<span data-ttu-id="1f302-122">Der Dienstanbieter initiiert den Vorgang und gibt dann eine Schleife ein, in der alle Windows-Meldungen gesendet werden (falls erforderlich, um den Prozessor an einen anderen Thread zu senden), und dann wird überprüft, ob die Windows Sockets-Funktion abgeschlossen ist.</span><span class="sxs-lookup"><span data-stu-id="1f302-122">The service provider initiates the operation, then enters a loop in which it dispatches any Windows messages (yielding the processor to another thread, if necessary), and then checks for the completion of the Windows Sockets function.</span></span> <span data-ttu-id="1f302-123">Wenn die Funktion abgeschlossen wurde oder [**wsacancelblockingcallaufgerufen**](/windows/desktop/api/winsock2/nf-winsock2-wsacancelblockingcall) wurde, wird die blockierende Funktion mit einem entsprechenden Ergebnis abgeschlossen.</span><span class="sxs-lookup"><span data-stu-id="1f302-123">If the function has completed, or if [**WSACancelBlockingCall**](/windows/desktop/api/winsock2/nf-winsock2-wsacancelblockingcall) has been invoked, the blocking function completes with an appropriate result.</span></span>

<span data-ttu-id="1f302-124">Ein Dienstanbieter muss die Installation einer blockierenden Hookfunktion zulassen, von der keine Nachrichten verarbeitet werden, um die Möglichkeit zu vermeiden, dass wieder eintretende Nachrichten auftreten, während ein Blockierungs Vorgang aussteht.</span><span class="sxs-lookup"><span data-stu-id="1f302-124">A service provider must allow installation of a blocking hook function that does not process messages in order to avoid the possibility of re-entrant messages while a blocking operation is outstanding.</span></span> <span data-ttu-id="1f302-125">Die einfachste solche blockierende Hook-Funktion würde **false** zurückgeben.</span><span class="sxs-lookup"><span data-stu-id="1f302-125">The simplest such blocking hook function would return **FALSE**.</span></span> <span data-ttu-id="1f302-126">Wenn eine Windows Sockets-DLL von Nachrichten für den internen Vorgang abhängt, kann Sie " **Peer Message**(**hmywnd**...)" ausführen, bevor die Anwendung blockiert wird, die den Hook blockiert, sodass Sie Ihre Nachrichten abrufen kann, ohne dass sich dies auf den Rest des Systems auswirkt.</span><span class="sxs-lookup"><span data-stu-id="1f302-126">If a Windows Sockets DLL depends on messages for internal operation, it can execute **PeekMessage**(**hMyWnd**...) before executing the application blocking hook so that it can get its messages without affecting the rest of the system.</span></span>

<span data-ttu-id="1f302-127">Wenn in einer 16-Bit-Windows Sockets 1,1-Umgebung eine Windows-Meldung für einen Prozess empfangen wird, für den zurzeit ein Blockierungs Vorgang ausgeführt wird, besteht das Risiko, dass die Anwendung versucht, einen weiteren Windows Sockets-Rückruf auszugeben.</span><span class="sxs-lookup"><span data-stu-id="1f302-127">In a 16-bit Windows Sockets 1.1 environment, if a Windows message is received for a process for which a blocking operation is in progress, there is a risk that the application will attempt to issue another Windows Sockets call.</span></span> <span data-ttu-id="1f302-128">Aufgrund der Schwierigkeiten bei der sicheren Verwaltung dieser Bedingung unterstützt Windows Sockets 1,1 dieses Anwendungsverhalten nicht.</span><span class="sxs-lookup"><span data-stu-id="1f302-128">Because of the difficulty in managing this condition safely, Windows Sockets 1.1 does not support such application behavior.</span></span> <span data-ttu-id="1f302-129">Es ist nicht zulässig, dass eine Anwendung mehr als einen aufzurufenden Windows Sockets-Funktions aufzurufen.</span><span class="sxs-lookup"><span data-stu-id="1f302-129">An application is not permitted to make more than one nested Windows Sockets function call.</span></span> <span data-ttu-id="1f302-130">Nur ein ausstehender Funktions Aufrufwert ist für eine bestimmte Aufgabe zulässig.</span><span class="sxs-lookup"><span data-stu-id="1f302-130">Only one outstanding function call is allowed for a particular task.</span></span> <span data-ttu-id="1f302-131">Die einzigen Ausnahmen sind zwei Funktionen, die zur Unterstützung des Programmierers in dieser Situation bereitgestellt werden: [**WSAIsBlocking**](/windows/desktop/api/winsock2/nf-winsock2-wsaisblocking) und [**wsacancelblockingcall.**](/windows/desktop/api/winsock2/nf-winsock2-wsacancelblockingcall)</span><span class="sxs-lookup"><span data-stu-id="1f302-131">The only exceptions are two functions that are provided to assist the programmer in this situation: [**WSAIsBlocking**](/windows/desktop/api/winsock2/nf-winsock2-wsaisblocking) and [**WSACancelBlockingCall**](/windows/desktop/api/winsock2/nf-winsock2-wsacancelblockingcall).</span></span>

<span data-ttu-id="1f302-132">Die [**WSAIsBlocking**](/windows/desktop/api/winsock2/nf-winsock2-wsaisblocking) -Funktion kann jederzeit aufgerufen werden, um zu bestimmen, ob ein blockierender Windows Sockets 1,1-Aufruf ausgeführt wird.</span><span class="sxs-lookup"><span data-stu-id="1f302-132">The [**WSAIsBlocking**](/windows/desktop/api/winsock2/nf-winsock2-wsaisblocking) function can be called at any time to determine whether or not a blocking Windows Sockets 1.1 call is in progress.</span></span> <span data-ttu-id="1f302-133">Ebenso kann die [**wsacancelblockingcall-Funktion**](/windows/desktop/api/winsock2/nf-winsock2-wsacancelblockingcall) jederzeit aufgerufen werden, um einen aktiven blockierenden Aufruf abzubrechen.</span><span class="sxs-lookup"><span data-stu-id="1f302-133">Similarly, the [**WSACancelBlockingCall**](/windows/desktop/api/winsock2/nf-winsock2-wsacancelblockingcall) function can be called at any time to cancel an in-progress blocking call.</span></span> <span data-ttu-id="1f302-134">Jede andere Schachtelung von Windows Sockets-Funktionen schlägt mit dem Fehler "wsaerprogress" fehl.</span><span class="sxs-lookup"><span data-stu-id="1f302-134">Any other nesting of Windows Sockets functions fails with the error WSAEINPROGRESS.</span></span>

<span data-ttu-id="1f302-135">Es sollte hervorgehoben werden, dass diese Einschränkung für blockierende und nicht blockierende Vorgänge gilt.</span><span class="sxs-lookup"><span data-stu-id="1f302-135">It should be emphasized that this restriction applies to both blocking and nonblocking operations.</span></span> <span data-ttu-id="1f302-136">Bei Windows Sockets 2-Anwendungen, die Version 2,0 oder höher zum Aufruf von [**WSAStartup**](/windows/desktop/api/winsock/nf-winsock-wsastartup)aushandeln, wird keine Einschränkung für die Schachtelung von Vorgängen beendet.</span><span class="sxs-lookup"><span data-stu-id="1f302-136">For Windows Sockets 2 applications that negotiate version 2.0 or higher at the time of calling [**WSAStartup**](/windows/desktop/api/winsock/nf-winsock-wsastartup), no restriction on the nesting of operations exits.</span></span> <span data-ttu-id="1f302-137">Vorgänge können in seltenen Fällen, z. b. während eines [**wsaaccept**](/windows/desktop/api/Winsock2/nf-winsock2-wsaaccept) -Rückrufs zur bedingten Akzeptanz, oder wenn ein Dienstanbieter wiederum eine Windows Sockets 2-Funktion aufruft.</span><span class="sxs-lookup"><span data-stu-id="1f302-137">Operations can become nested under rare circumstances, such as during a [**WSAAccept**](/windows/desktop/api/Winsock2/nf-winsock2-wsaaccept) conditional-acceptance callback, or if a service provider in turn invokes a Windows Sockets 2 function.</span></span>

<span data-ttu-id="1f302-138">Obwohl dieser Mechanismus für einfache Anwendungen ausreichend ist, kann er die komplexen Anforderungen für die Nachrichten Verteilung erweiterter Anwendungen (z. b. solche, die das MDI-Modell verwenden) nicht unterstützen.</span><span class="sxs-lookup"><span data-stu-id="1f302-138">Although this mechanism is sufficient for simple applications, it cannot support the complex message-dispatching requirements of more advanced applications (for example, those using the MDI model).</span></span> <span data-ttu-id="1f302-139">Bei solchen Anwendungen enthält die Windows Sockets-API die Funktion [**wsasetblockinghook**](/windows/desktop/api/winsock2/nf-winsock2-wsasetblockinghook), die es der Anwendung ermöglicht, eine spezielle Routine anzugeben, die anstelle der standardmäßigen nachrichtendispatchroutine aufgerufen werden kann, die in der vorherigen Diskussion beschrieben wird.</span><span class="sxs-lookup"><span data-stu-id="1f302-139">For such applications, the Windows Sockets API includes the function [**WSASetBlockingHook**](/windows/desktop/api/winsock2/nf-winsock2-wsasetblockinghook), which allows the application to specify a special routine which can be called instead of the default message dispatch routine described in the preceding discussion.</span></span>

<span data-ttu-id="1f302-140">Der Windows Sockets-Anbieter Ruft den blockierenden Hook nur auf, wenn Folgendes zutrifft:</span><span class="sxs-lookup"><span data-stu-id="1f302-140">The Windows Sockets provider calls the blocking hook only if all of the following are true:</span></span>

-   <span data-ttu-id="1f302-141">Die Routine ist eine, die so definiert ist, dass Sie blockiert werden kann.</span><span class="sxs-lookup"><span data-stu-id="1f302-141">The routine is one that is defined as being able to block.</span></span>
-   <span data-ttu-id="1f302-142">Der angegebene Socket ist ein blockierender Socket.</span><span class="sxs-lookup"><span data-stu-id="1f302-142">The specified socket is a blocking socket.</span></span>
-   <span data-ttu-id="1f302-143">Die Anforderung kann nicht sofort abgeschlossen werden.</span><span class="sxs-lookup"><span data-stu-id="1f302-143">The request cannot be completed immediately.</span></span>

<span data-ttu-id="1f302-144">Ein Socket ist standardmäßig auf "blockieren" festgelegt, aber die [**ioctlsocket**](/windows/desktop/api/winsock/nf-winsock-ioctlsocket) -Funktion mit der Funktion " **atonbio** ioctl" oder " [**WSAAsyncSelect**](/windows/desktop/api/winsock/nf-winsock-wsaasyncselect) " kann einen Socket in den nicht blockierenden Modus setzen.</span><span class="sxs-lookup"><span data-stu-id="1f302-144">A socket is set to blocking by default, but the [**ioctlsocket**](/windows/desktop/api/winsock/nf-winsock-ioctlsocket) function with the **FIONBIO** IOCTL or the [**WSAAsyncSelect**](/windows/desktop/api/winsock/nf-winsock-wsaasyncselect) function can set a socket to nonblocking mode.</span></span>

<span data-ttu-id="1f302-145">Der blockierende Hook wird niemals aufgerufen, und die Anwendung muss sich nicht mit den erneuten Eintretens befassen, die der blockierende Hook einführen kann, wenn eine Anwendung diese Richtlinien befolgt:</span><span class="sxs-lookup"><span data-stu-id="1f302-145">The blocking hook is never called and the application does not need to be concerned with the re-entrancy issues the blocking hook can introduce, if an application follows these guidelines:</span></span>

-   <span data-ttu-id="1f302-146">Es werden nur nicht blockierende Sockets verwendet.</span><span class="sxs-lookup"><span data-stu-id="1f302-146">It uses only nonblocking sockets.</span></span>
-   <span data-ttu-id="1f302-147">Dabei werden die Routinen " [**WSAAsyncSelect**](/windows/desktop/api/winsock/nf-winsock-wsaasyncselect) " und "/" und " **WSAAsyncGetXbyY** " anstelle von " [**Select**](/windows/desktop/api/Winsock2/nf-winsock2-select) " und " **getxbyy** " verwendet.</span><span class="sxs-lookup"><span data-stu-id="1f302-147">It uses the [**WSAAsyncSelect**](/windows/desktop/api/winsock/nf-winsock-wsaasyncselect) and/or the **WSAAsyncGetXByY** routines instead of [**select**](/windows/desktop/api/Winsock2/nf-winsock2-select) and the **getXbyY** routines.</span></span>

<span data-ttu-id="1f302-148">Wenn eine Windows Sockets 1,1-Anwendung einen asynchronen oder nicht blockierenden Vorgang aufruft, der einen Zeiger auf ein Speicher Objekt (z. b. einen Puffer oder eine globale Variable) als Argument annimmt, liegt es in der Verantwortung der Anwendung, sicherzustellen, dass das Objekt für Windows-Sockets während des Vorgangs verfügbar ist.</span><span class="sxs-lookup"><span data-stu-id="1f302-148">If a Windows Sockets 1.1 application invokes an asynchronous or nonblocking operation that takes a pointer to a memory object (a buffer or a global variable, for example) as an argument, it is the responsibility of the application to ensure that the object is available to Windows Sockets throughout the operation.</span></span> <span data-ttu-id="1f302-149">Die Anwendung darf keine Windows-Funktion aufrufen, die sich auf die Zuordnung oder Adress Lebensfähigkeit des Beteiligten Arbeitsspeichers auswirken könnte.</span><span class="sxs-lookup"><span data-stu-id="1f302-149">The application must not invoke any Windows function that might affect the mapping or address viability of the memory involved.</span></span>

 

 



