---
description: In diesem Thema wird beschrieben, wie ein benutzerdefinierter Videorenderer für DirectShow geschrieben wird.
ms.assetid: abba5113-125f-4dac-b566-99c0d9b5978c
title: Alternative Videorenderer
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: 070e55375d9d1d5a32c306853aafcb431a76c368
ms.sourcegitcommit: a47bd86f517de76374e4fff33cfeb613eb259a7e
ms.translationtype: MT
ms.contentlocale: de-DE
ms.lasthandoff: 01/06/2021
ms.locfileid: "103747280"
---
# <a name="alternative-video-renderers"></a><span data-ttu-id="9253e-103">Alternative Videorenderer</span><span class="sxs-lookup"><span data-stu-id="9253e-103">Alternative Video Renderers</span></span>

<span data-ttu-id="9253e-104">In diesem Thema wird beschrieben, wie ein benutzerdefinierter Videorenderer für DirectShow geschrieben wird.</span><span class="sxs-lookup"><span data-stu-id="9253e-104">This topic describes how to write a custom video renderer for DirectShow.</span></span>

> [!Note]  
> <span data-ttu-id="9253e-105">Anstatt einen benutzerdefinierten Videorenderer zu schreiben, empfiehlt es sich, ein Plug-in-zuordnerpresenter für den Video Mischungs-Renderer (VMR) oder den [**erweiterten Videorenderer**](enhanced-video-renderer-filter.md) (EVR) zu schreiben.</span><span class="sxs-lookup"><span data-stu-id="9253e-105">Instead of writing a custom video renderer, it is recommended that you write a plug-in allocator-presenter for the Video Mixing Renderer (VMR) or [**Enhanced Video Renderer**](enhanced-video-renderer-filter.md) (EVR).</span></span> <span data-ttu-id="9253e-106">Mit diesem Ansatz erhalten Sie alle Vorteile der VMR/EVR, einschließlich der Unterstützung für die DirectX-Video Beschleunigung (DXVA), der Deinterlacing von Hardware und der Frame-Step-Methode, und Sie sind wahrscheinlich stabiler als ein benutzerdefinierter Videorenderer.</span><span class="sxs-lookup"><span data-stu-id="9253e-106">This approach will give you all of the benefits of the VMR/EVR, including support for DirectX Video Acceleration (DXVA), hardware deinterlacing, and frame stepping, and is likely to be more robust than a custom video renderer.</span></span> <span data-ttu-id="9253e-107">Weitere Informationen finden Sie unter den folgenden Themen:</span><span class="sxs-lookup"><span data-stu-id="9253e-107">For more information, see the following topics:</span></span>
>
> -   [<span data-ttu-id="9253e-108">VMR-renderlosen Wiedergabemodus (benutzerdefinierter Zuweiser)</span><span class="sxs-lookup"><span data-stu-id="9253e-108">VMR Renderless Playback Mode (Custom Allocator-Presenters)</span></span>](vmr-renderless-playback-mode--custom-allocator-presenters.md)
> -   [<span data-ttu-id="9253e-109">Schreiben von EVR Presenter</span><span class="sxs-lookup"><span data-stu-id="9253e-109">How to Write an EVR Presenter</span></span>](/windows/desktop/medfound/how-to-write-an-evr-presenter)

 

## <a name="writing-an-alternative-renderer"></a><span data-ttu-id="9253e-110">Schreiben eines alternativen Renderers</span><span class="sxs-lookup"><span data-stu-id="9253e-110">Writing an Alternative Renderer</span></span>

<span data-ttu-id="9253e-111">Microsoft DirectShow stellt einen Fenster basierten Videorenderer bereit. Außerdem wird in der Lauf Zeit Installation ein Vollbild-Renderer bereitstellt.</span><span class="sxs-lookup"><span data-stu-id="9253e-111">Microsoft DirectShow provides a window-based video renderer; it also provides a full-screen renderer in the run-time installation.</span></span> <span data-ttu-id="9253e-112">Sie können die DirectShow-Basisklassen zum Schreiben alternativer Videorenderer verwenden.</span><span class="sxs-lookup"><span data-stu-id="9253e-112">You can use the DirectShow base classes to write alternative video renderers.</span></span> <span data-ttu-id="9253e-113">Damit Alternative Renderer ordnungsgemäß mit DirectShow-basierten Anwendungen interagieren können, müssen die Renderer den in diesem Artikel beschriebenen Richtlinien entsprechen.</span><span class="sxs-lookup"><span data-stu-id="9253e-113">For alternative renderers to interact correctly with DirectShow-based applications, the renderers must adhere to the guidelines outlined in this article.</span></span> <span data-ttu-id="9253e-114">Sie können die [**cbaserenderer**](cbaserenderer.md) -Klasse und die [**cbasevideorenderer**](cbasevideorenderer.md) -Klasse verwenden, um diese Richtlinien bei der Implementierung eines alternativen Videorenderers zu befolgen.</span><span class="sxs-lookup"><span data-stu-id="9253e-114">You can use the [**CBaseRenderer**](cbaserenderer.md) and [**CBaseVideoRenderer**](cbasevideorenderer.md) classes to help follow these guidelines when implementing an alternative video render.</span></span> <span data-ttu-id="9253e-115">Aufgrund der kontinuierlichen Entwicklung von DirectShow sollten Sie die Implementierung regelmäßig überprüfen, um sicherzustellen, dass die Renderer mit der neuesten Version von DirectShow kompatibel sind.</span><span class="sxs-lookup"><span data-stu-id="9253e-115">Because of the ongoing development of DirectShow, review your implementation periodically to ensure that the renderers are compatible with the most recent version of DirectShow.</span></span>

<span data-ttu-id="9253e-116">In diesem Thema werden viele Benachrichtigungen erläutert, die ein Renderer für die Behandlung verantwortlich ist.</span><span class="sxs-lookup"><span data-stu-id="9253e-116">This topic discusses many notifications that a renderer is responsible for handling.</span></span> <span data-ttu-id="9253e-117">Eine kurze Übersicht über DirectShow-Benachrichtigungen kann beim Festlegen der Stufe helfen.</span><span class="sxs-lookup"><span data-stu-id="9253e-117">A brief review of DirectShow notifications might help to set the stage.</span></span> <span data-ttu-id="9253e-118">Es gibt im Wesentlichen drei Arten von Benachrichtigungen, die in DirectShow auftreten:</span><span class="sxs-lookup"><span data-stu-id="9253e-118">There are essentially three kinds of notifications that occur in DirectShow:</span></span>

-   <span data-ttu-id="9253e-119">*Streambenachrichtigungen*, bei denen es sich um Ereignisse handelt, die im Mediendaten Strom auftreten und von einem Filter an den nächsten weitergeleitet werden.</span><span class="sxs-lookup"><span data-stu-id="9253e-119">*Stream notifications*, which are events that occur in the media stream and are passed from one filter to the next.</span></span> <span data-ttu-id="9253e-120">Dabei kann es sich um das beginnen-leeren, das Beenden oder das Senden von Datenströmen handeln, die durch Aufrufen der entsprechenden Methode für die Eingabe-PIN des downstreamfilters (z. b. [**IPin:: beginflush**](/windows/desktop/api/Strmif/nf-strmif-ipin-beginflush)) gesendet werden.</span><span class="sxs-lookup"><span data-stu-id="9253e-120">These can be begin-flushing, end-flushing or end-of-stream notifications and are sent by calling the appropriate method on the downstream filter's input pin (for example [**IPin::BeginFlush**](/windows/desktop/api/Strmif/nf-strmif-ipin-beginflush)).</span></span>
-   <span data-ttu-id="9253e-121">*Filtern Sie Diagramm Benachrichtigungen*, bei denen es sich um Ereignisse handelt, die von einem Filter an [**den \_**](ec-complete.md)Filter Graph-Manager gesendet werden</span><span class="sxs-lookup"><span data-stu-id="9253e-121">*Filter graph notifications*, which are events sent from a filter to the Filter Graph Manager such as [**EC\_COMPLETE**](ec-complete.md).</span></span> <span data-ttu-id="9253e-122">Dies wird erreicht, indem die [**imediaeventsink:: notify**](/windows/desktop/api/Strmif/nf-strmif-imediaeventsink-notify) -Methode für den Filter Graph-Manager aufgerufen wird.</span><span class="sxs-lookup"><span data-stu-id="9253e-122">This is accomplished by calling the [**IMediaEventSink::Notify**](/windows/desktop/api/Strmif/nf-strmif-imediaeventsink-notify) method on the Filter Graph Manager.</span></span>
-   <span data-ttu-id="9253e-123">*Anwendungs Benachrichtigungen*, die von der steuernden Anwendung vom Filter Graph-Manager abgerufen werden.</span><span class="sxs-lookup"><span data-stu-id="9253e-123">*Application notifications*, which are retrieved from the Filter Graph Manager by the controlling application.</span></span> <span data-ttu-id="9253e-124">Eine Anwendung ruft die [**imediaevent:: GetEvent**](/windows/desktop/api/Control/nf-control-imediaevent-getevent) -Methode im Filter Graph-Manager auf, um diese Ereignisse abzurufen.</span><span class="sxs-lookup"><span data-stu-id="9253e-124">An application calls the [**IMediaEvent::GetEvent**](/windows/desktop/api/Control/nf-control-imediaevent-getevent) method on the Filter Graph Manager to retrieve these events.</span></span> <span data-ttu-id="9253e-125">Häufig übergibt der Filter Graph-Manager die empfangenen Ereignisse an die Anwendung.</span><span class="sxs-lookup"><span data-stu-id="9253e-125">Often, the Filter Graph Manager passes through the events it receives to the application.</span></span>

<span data-ttu-id="9253e-126">In diesem Thema wird die Verantwortung des rendererfilters bei der Behandlung von empfangenen Datenstrom Benachrichtigungen und beim Senden entsprechender Filter Diagramm Benachrichtigungen erläutert.</span><span class="sxs-lookup"><span data-stu-id="9253e-126">This topic discusses the responsibility of the renderer filter in handling stream notifications it receives and in sending appropriate filter graph notifications.</span></span>

## <a name="handling-end-of-stream-and-flushing-notifications"></a><span data-ttu-id="9253e-127">Verarbeiten von Streamende und leeren von Benachrichtigungen</span><span class="sxs-lookup"><span data-stu-id="9253e-127">Handling End-of-stream and Flushing Notifications</span></span>

<span data-ttu-id="9253e-128">Eine End-of-Stream-Benachrichtigung beginnt mit einem upstreamfilter (z. b. dem Quell Filter), wenn dieser Filter erkennt, dass er keine weiteren Daten senden kann.</span><span class="sxs-lookup"><span data-stu-id="9253e-128">An end-of-stream notification begins at an upstream filter (such as the source filter) when that filter detects that it can send no more data.</span></span> <span data-ttu-id="9253e-129">Sie wird durch jeden Filter im Diagramm geleitet und endet schließlich mit dem Renderer, der für das anschließende Senden einer EC- [**\_ vollständigen**](ec-complete.md) Benachrichtigung an den Filter Graph-Manager zuständig ist.</span><span class="sxs-lookup"><span data-stu-id="9253e-129">It is passed through every filter in the graph and eventually ends at the renderer, which is responsible for subsequently sending an [**EC\_COMPLETE**](ec-complete.md) notification to the Filter Graph Manager.</span></span> <span data-ttu-id="9253e-130">Renderer haben besondere Verantwortlichkeiten, wenn diese Benachrichtigungen behandelt werden.</span><span class="sxs-lookup"><span data-stu-id="9253e-130">Renderers have special responsibilities when it comes to handling these notifications.</span></span>

<span data-ttu-id="9253e-131">Ein Renderer empfängt eine Benachrichtigung über das Ende des Datenstroms, wenn die [**IPin:: EndOfStream**](/windows/desktop/api/Strmif/nf-strmif-ipin-endofstream) -Methode der Eingabe-PIN vom upstreamfilter aufgerufen wird.</span><span class="sxs-lookup"><span data-stu-id="9253e-131">A renderer receives an end-of-stream notification when its input pin's [**IPin::EndOfStream**](/windows/desktop/api/Strmif/nf-strmif-ipin-endofstream) method is called by the upstream filter.</span></span> <span data-ttu-id="9253e-132">Ein Renderer sollte diese Benachrichtigung notieren und weiterhin alle Daten Renderingdaten, die Sie bereits empfangen haben.</span><span class="sxs-lookup"><span data-stu-id="9253e-132">A renderer should note this notification and continue to render any data it has already received.</span></span> <span data-ttu-id="9253e-133">Nachdem alle verbleibenden Daten empfangen wurden, sollte der Renderer eine " [**EC \_ Complete**](ec-complete.md) "-Benachrichtigung an den Filter Graph-Manager senden.</span><span class="sxs-lookup"><span data-stu-id="9253e-133">Once all remaining data has been received, the renderer should send an [**EC\_COMPLETE**](ec-complete.md) notification to the Filter Graph Manager.</span></span> <span data-ttu-id="9253e-134">Die " **EC \_ Complete** "-Benachrichtigung sollte nur einmal von einem Renderer gesendet werden, wenn das Ende eines Streams erreicht wird.</span><span class="sxs-lookup"><span data-stu-id="9253e-134">The **EC\_COMPLETE** notification should be sent only once by a renderer each time it reaches the end of a stream.</span></span> <span data-ttu-id="9253e-135">Außerdem dürfen keine **EC- \_ Complete** -Benachrichtigungen gesendet werden, außer wenn das Filter Diagramm ausgeführt wird.</span><span class="sxs-lookup"><span data-stu-id="9253e-135">Furthermore, **EC\_COMPLETE** notifications must never be sent except when the filter graph is running.</span></span> <span data-ttu-id="9253e-136">Wenn das Filter Diagramm angehalten wird, wenn ein Quell Filter eine End-of-Stream-Benachrichtigung sendet, sollte das **EC \_ Complete** nicht gesendet werden, bis das Filter Diagramm schließlich ausgeführt wird.</span><span class="sxs-lookup"><span data-stu-id="9253e-136">Therefore, if the filter graph is paused when a source filter sends an end-of-stream notification, then **EC\_COMPLETE** should not be sent until the filter graph is finally run.</span></span>

<span data-ttu-id="9253e-137">Alle Aufrufe der [**IMemInputPin:: Receive**](/windows/desktop/api/Strmif/nf-strmif-imeminputpin-receive) -Methode oder der [**IMemInputPin:: receivemultiple**](/windows/desktop/api/Strmif/nf-strmif-imeminputpin-receivemultiple) -Methode nach einer Datenstrom Benachrichtigung sollten abgelehnt werden.</span><span class="sxs-lookup"><span data-stu-id="9253e-137">Any calls to the [**IMemInputPin::Receive**](/windows/desktop/api/Strmif/nf-strmif-imeminputpin-receive) or [**IMemInputPin::ReceiveMultiple**](/windows/desktop/api/Strmif/nf-strmif-imeminputpin-receivemultiple) methods after an end-of-stream notification is signaled should be rejected.</span></span> <span data-ttu-id="9253e-138">**E \_ "Unerwartet** " ist die geeignetste Fehlermeldung, die in diesem Fall zurückgegeben wird.</span><span class="sxs-lookup"><span data-stu-id="9253e-138">**E\_UNEXPECTED** is the most appropriate error message to return in this case.</span></span>

<span data-ttu-id="9253e-139">Beim Beenden eines Filter Diagramms sollten alle zwischengespeicherten Datenstrom Benachrichtigungen gelöscht und beim nächsten Start nicht erneut gesendet werden.</span><span class="sxs-lookup"><span data-stu-id="9253e-139">When a filter graph is stopped, any cached end-of-stream notification should be cleared and not resent when next started.</span></span> <span data-ttu-id="9253e-140">Dies liegt daran, dass der Filter Graph-Manager immer alle Filter vor dem Ausführen hält, sodass das ordnungsgemäße leeren erfolgt.</span><span class="sxs-lookup"><span data-stu-id="9253e-140">This is because the Filter Graph Manager always pauses all filters just before running them so that proper flushing occurs.</span></span> <span data-ttu-id="9253e-141">Wenn z. b. das Filter Diagramm angehalten wird und eine Datenstrom-Benachrichtigung empfangen wird, und dann das Filter Diagramm angehalten wird, sollte der Renderer beim anschließenden Ausführen keine [**EC \_ Complete**](ec-complete.md) -Benachrichtigung senden.</span><span class="sxs-lookup"><span data-stu-id="9253e-141">So, for example, if the filter graph is paused and an end-of-stream notification is received, and then the filter graph is stopped, the renderer should not send an [**EC\_COMPLETE**](ec-complete.md) notification when it is subsequently run.</span></span> <span data-ttu-id="9253e-142">Wenn keine Suchvorgänge stattgefunden haben, sendet der Quell Filter automatisch eine andere datenstreambenachrichtigung während des anhaltezustands, der einem Testlauf vorangestellt wird.</span><span class="sxs-lookup"><span data-stu-id="9253e-142">If no seeks have occurred, the source filter will automatically send another end-of-stream notification during the pause state that precedes a run state.</span></span> <span data-ttu-id="9253e-143">Wenn andererseits eine Suche stattgefunden hat, während das Filter Diagramm angehalten wurde, kann es vorkommen, dass der Quell Filterdaten enthält, die gesendet werden, sodass keine Datenstrom-Benachrichtigung gesendet wird.</span><span class="sxs-lookup"><span data-stu-id="9253e-143">If, on the other hand, a seek has occurred while the filter graph is stopped, then the source filter might have data to send, so it won't send an end-of-stream notification.</span></span>

<span data-ttu-id="9253e-144">Videorenderer sind häufig von streamingbenachrichtigungen für mehr als das Senden von [**EC \_ Complete**](ec-complete.md) -Benachrichtigungen abhängig.</span><span class="sxs-lookup"><span data-stu-id="9253e-144">Video renderers often depend on end-of-stream notifications for more than the sending of [**EC\_COMPLETE**](ec-complete.md) notifications.</span></span> <span data-ttu-id="9253e-145">Wenn z. b. die Wiedergabe eines Datenstroms abgeschlossen ist (d. h., es wird eine Datenstrom Benachrichtigung gesendet) und ein anderes Fenster über ein Video-rendererfenster gezogen wird, wird eine Reihe von WM-Zeichnungs Fenstern generiert. [**\_**](/windows/desktop/gdi/wm-paint)</span><span class="sxs-lookup"><span data-stu-id="9253e-145">For example, if a stream has finished playing (that is, an end-of-stream notification is sent) and another window is dragged over a video renderer window, a number of [**WM\_PAINT**](/windows/desktop/gdi/wm-paint) window messages will be generated.</span></span> <span data-ttu-id="9253e-146">Die übliche Vorgehensweise zum Ausführen von videorendererversuchen besteht darin, den aktuellen Frame beim Empfang von **WM \_** -Zeichnungs Nachrichten nicht neu zu zeichnen (basierend auf der Annahme, dass ein anderer Frame gezeichnet werden soll).</span><span class="sxs-lookup"><span data-stu-id="9253e-146">The typical practice for running video renderers is to refrain from repainting the current frame upon receipt of **WM\_PAINT** messages (based on the assumption that another frame to be drawn will be received).</span></span> <span data-ttu-id="9253e-147">Wenn jedoch das Ende der Stream-Benachrichtigung gesendet wurde, befindet sich der Renderer in einem Wartezustand. Es wird noch ausgeführt, aber es wird darauf hingewiesen, dass keine zusätzlichen Daten empfangen werden.</span><span class="sxs-lookup"><span data-stu-id="9253e-147">However, when the end-of-stream notification has been sent, the renderer is in a waiting state; it is still running but is aware that it will not receive any additional data.</span></span> <span data-ttu-id="9253e-148">Unter diesen Umständen zeichnet der Renderer den Wiedergabe Bereich in der Regel schwarz.</span><span class="sxs-lookup"><span data-stu-id="9253e-148">Under these circumstances, the renderer customarily draws the playback area black.</span></span>

<span data-ttu-id="9253e-149">Das Behandeln von Leerung ist eine zusätzliche Komplikation für Renderer.</span><span class="sxs-lookup"><span data-stu-id="9253e-149">Handling flushing is an additional complication for renderers.</span></span> <span data-ttu-id="9253e-150">Das leeren erfolgt durch ein paar von [**IPin**](/windows/desktop/api/Strmif/nn-strmif-ipin) -Methoden namens [**beginflush**](/windows/desktop/api/Strmif/nf-strmif-ipin-beginflush) und [**endflush**](/windows/desktop/api/Strmif/nf-strmif-ipin-endflush).</span><span class="sxs-lookup"><span data-stu-id="9253e-150">Flushing is carried out through a pair of [**IPin**](/windows/desktop/api/Strmif/nn-strmif-ipin) methods called [**BeginFlush**](/windows/desktop/api/Strmif/nf-strmif-ipin-beginflush) and [**EndFlush**](/windows/desktop/api/Strmif/nf-strmif-ipin-endflush).</span></span> <span data-ttu-id="9253e-151">Das leeren ist im Grunde ein zusätzlicher Zustand, den der Renderer verarbeiten muss.</span><span class="sxs-lookup"><span data-stu-id="9253e-151">Flushing is essentially an additional state that the renderer must handle.</span></span> <span data-ttu-id="9253e-152">Es ist unzulässig, dass ein Quell Filter **beginflush** aufruft, ohne **endflush** aufzurufen, sodass der Status kurz und diskret ist. der Renderer muss jedoch Daten oder Benachrichtigungen, die er während des Leerungs Übergangs empfängt, ordnungsgemäß verarbeiten.</span><span class="sxs-lookup"><span data-stu-id="9253e-152">It is illegal for a source filter to call **BeginFlush** without calling **EndFlush**, so hopefully the state is short and discrete; however, the renderer must correctly handle data or notifications it receives during the flush transition.</span></span>

<span data-ttu-id="9253e-153">Alle Daten, die nach dem Aufrufen von [**beginflush**](/windows/desktop/api/Strmif/nf-strmif-ipin-beginflush) empfangen werden, sollten sofort abgelehnt werden, indem Sie **\_ false** zurückgeben</span><span class="sxs-lookup"><span data-stu-id="9253e-153">Any data received after calling [**BeginFlush**](/windows/desktop/api/Strmif/nf-strmif-ipin-beginflush) should be rejected immediately by returning **S\_FALSE**.</span></span> <span data-ttu-id="9253e-154">Außerdem sollten alle zwischengespeicherten Datenstrom Benachrichtigungen auch gelöscht werden, wenn ein Renderer geleert wird.</span><span class="sxs-lookup"><span data-stu-id="9253e-154">Furthermore, any cached end-of-stream notification should also be cleared when a renderer is flushed.</span></span> <span data-ttu-id="9253e-155">Ein Renderer wird in der Regel als Reaktion auf eine Suche geleert.</span><span class="sxs-lookup"><span data-stu-id="9253e-155">A renderer will typically be flushed in response to a seek.</span></span> <span data-ttu-id="9253e-156">Durch das leeren wird sichergestellt, dass alte Daten aus dem Filter Diagramm gelöscht werden, bevor neue Beispiele gesendet werden.</span><span class="sxs-lookup"><span data-stu-id="9253e-156">The flush ensures that old data is cleared from the filter graph before fresh samples are sent.</span></span> <span data-ttu-id="9253e-157">(In der Regel wird die Wiedergabe von zwei Abschnitten eines Streams, einer nach anderen, am besten durch verzögerte Befehle behandelt, anstatt darauf zu warten, dass ein Abschnitt abgeschlossen wird, und dann einen Seek-Befehl auszugeben.)</span><span class="sxs-lookup"><span data-stu-id="9253e-157">(Typically, the playing of two sections of a stream, one after another, is best handled through deferred commands rather than waiting for one section to finish and then issuing a seek command.)</span></span>

## <a name="handling-state-changes-and-pause-completion"></a><span data-ttu-id="9253e-158">Behandeln von Zustandsänderungen und Beenden der Beendigung</span><span class="sxs-lookup"><span data-stu-id="9253e-158">Handling State Changes and Pause Completion</span></span>

<span data-ttu-id="9253e-159">Ein rendererfilter verhält sich wie jeder andere Filter im Filter Diagramm, wenn der Zustand geändert wird, mit der folgenden Ausnahme.</span><span class="sxs-lookup"><span data-stu-id="9253e-159">A renderer filter behaves the same as any other filter in the filter graph when its state is changed, with the following exception.</span></span> <span data-ttu-id="9253e-160">Nachdem der Renderer angehalten wurde, werden einige Daten in der Warteschlange eingereiht und können nach der anschließenden Ausführung gerendert werden.</span><span class="sxs-lookup"><span data-stu-id="9253e-160">After being paused, the renderer will have some data queued, ready to be rendered when subsequently run.</span></span> <span data-ttu-id="9253e-161">Wenn der Videorenderer beendet wird, behält er diese Daten in der Warteschlange.</span><span class="sxs-lookup"><span data-stu-id="9253e-161">When the video renderer is stopped, it holds on to this queued data.</span></span> <span data-ttu-id="9253e-162">Dies ist eine Ausnahme von der DirectShow-Regel, dass keine Ressourcen von Filtern gehalten werden sollen, während das Filter Diagramm angehalten wird.</span><span class="sxs-lookup"><span data-stu-id="9253e-162">This is an exception to the DirectShow rule that no resources should be held by filters while the filter graph is stopped.</span></span>

<span data-ttu-id="9253e-163">Der Grund für diese Ausnahme ist, dass der Renderer beim Speichern von Ressourcen immer ein Bild hat, mit dem das Fenster neu gezeichnet werden kann, wenn [**eine \_ WM**](/windows/desktop/gdi/wm-paint) -Zeichnungs Nachricht empfangen wird.</span><span class="sxs-lookup"><span data-stu-id="9253e-163">The reason for this exception is that by holding resources, the renderer will always have an image with which to repaint the window if it receives a [**WM\_PAINT**](/windows/desktop/gdi/wm-paint) message.</span></span> <span data-ttu-id="9253e-164">Außerdem verfügt sie über ein Bild, das Methoden, wie z. b. [**cbasecontrolvideo:: getstaticimage**](cbasecontrolvideo-getstaticimage.md), zu erfüllen, die eine Kopie des aktuellen Bilds anfordern.</span><span class="sxs-lookup"><span data-stu-id="9253e-164">It also has an image to satisfy methods, such as [**CBaseControlVideo::GetStaticImage**](cbasecontrolvideo-getstaticimage.md), that request a copy of the current image.</span></span> <span data-ttu-id="9253e-165">Ein weiterer Effekt bei der Aufrechterhaltung von Ressourcen besteht darin, dass die Zuweisung von an das Image die Zuweisung der Zuweisung verhindert, dass die Zuweisung der nächsten Zustandsänderung erheblich beschleunigt wird, da die Abbild Puffer bereits zugeordnet sind.</span><span class="sxs-lookup"><span data-stu-id="9253e-165">Another effect of holding resources is that holding on to the image stops the allocator from being decommitted, which in turn makes the next state change occur much faster because the image buffers are already allocated.</span></span>

<span data-ttu-id="9253e-166">Ein Videorenderer sollte nur bei der Ausführung von ein-und ausgehen.</span><span class="sxs-lookup"><span data-stu-id="9253e-166">A video renderer should render and release samples only while running.</span></span> <span data-ttu-id="9253e-167">Während der Ausführung wird der Filter möglicherweise gerengt (z. b. beim Zeichnen eines statischen Poster-Bilds in einem Fenster), sollte aber nicht freigegeben werden.</span><span class="sxs-lookup"><span data-stu-id="9253e-167">While paused, the filter might render them (for example, when drawing a static poster image in a window), but should not release them.</span></span> <span data-ttu-id="9253e-168">Audiorenderer führen während der angehaltenen Ausführung kein Rendering durch (Sie können z. b. auch andere Aktivitäten ausführen, z. b. das Wave-Gerät).</span><span class="sxs-lookup"><span data-stu-id="9253e-168">Audio renderers will do no rendering while paused (although they can perform other activities, such as preparing the wave device, for example).</span></span> <span data-ttu-id="9253e-169">Die Zeit, zu der die Beispiele gerendert werden sollen, wird durch Kombinieren der streamzeit im Beispiel mit der als Parameter an die [**IMediaControl:: Run**](/windows/desktop/api/Control/nf-control-imediacontrol-run) -Methode übergebenen Verweis Zeit erreicht.</span><span class="sxs-lookup"><span data-stu-id="9253e-169">The time at which the samples should be rendered is obtained by combining the stream time in the sample with the reference time passed as a parameter to the [**IMediaControl::Run**](/windows/desktop/api/Control/nf-control-imediacontrol-run) method.</span></span> <span data-ttu-id="9253e-170">Renderer sollten Beispiele mit Startzeiten, die kleiner oder gleich den Endzeiten sind, ablehnen.</span><span class="sxs-lookup"><span data-stu-id="9253e-170">Renderers should reject samples with start times less than or equal to end times.</span></span>

<span data-ttu-id="9253e-171">Wenn eine Anwendung ein Filter Diagramm anhält, wird das Filter Diagramm nicht von der [**IMediaControl::P ause**](/windows/desktop/api/Control/nf-control-imediacontrol-pause) -Methode zurückgegeben, bis die Daten in der Warteschlange vorhanden sind.</span><span class="sxs-lookup"><span data-stu-id="9253e-171">When an application pauses a filter graph, the filter graph does not return from its [**IMediaControl::Pause**](/windows/desktop/api/Control/nf-control-imediacontrol-pause) method until there is data queued at the renderers.</span></span> <span data-ttu-id="9253e-172">Um dies sicherzustellen, sollte beim Anhalten eines Renderers S false zurückgegeben werden, \_ Wenn keine Daten vorhanden sind, die darauf warten, gerendert zu werden.</span><span class="sxs-lookup"><span data-stu-id="9253e-172">In order to ensure this, when a renderer is paused, it should return S\_FALSE if there is no data waiting to be rendered.</span></span> <span data-ttu-id="9253e-173">Wenn sich Daten in der Warteschlange befinden, können Sie **S \_ OK** zurückgeben.</span><span class="sxs-lookup"><span data-stu-id="9253e-173">If it has data queued, then it can return **S\_OK**.</span></span>

<span data-ttu-id="9253e-174">Der Filter Graph-Manager überprüft alle Rückgabewerte beim Anhalten eines Filter Diagramms, um sicherzustellen, dass die Renderer Daten in die Warteschlange eingereiht haben.</span><span class="sxs-lookup"><span data-stu-id="9253e-174">The Filter Graph Manager checks all return values when pausing a filter graph, to ensure that the renderers have data queued.</span></span> <span data-ttu-id="9253e-175">Wenn mindestens ein Filter nicht bereit ist, ruft der Filter Diagramm-Manager die Filter im Diagramm durch Aufrufen von [**imediafilter:: GetState**](/windows/desktop/api/Strmif/nf-strmif-imediafilter-getstate)ab.</span><span class="sxs-lookup"><span data-stu-id="9253e-175">If one or more filters are not ready, then the Filter Graph Manager polls the filters in the graph by calling [**IMediaFilter::GetState**](/windows/desktop/api/Strmif/nf-strmif-imediafilter-getstate).</span></span> <span data-ttu-id="9253e-176">Die **GetState** -Methode nimmt einen Timeout Parameter an.</span><span class="sxs-lookup"><span data-stu-id="9253e-176">The **GetState** method takes a time-out parameter.</span></span> <span data-ttu-id="9253e-177">Ein Filter (in der Regel ein Renderer), der noch darauf wartet, dass Daten vor dem Abschluss der Zustandsänderung eintreffen, gibt den **VFW \_ S \_ State \_ Intermediate** zurück, wenn die **GetState** -Methode abläuft.</span><span class="sxs-lookup"><span data-stu-id="9253e-177">A filter (typically a renderer) that is still waiting for data to arrive before completing the state change returns **VFW\_S\_STATE\_INTERMEDIATE** if the **GetState** method expires.</span></span> <span data-ttu-id="9253e-178">Sobald die Daten beim Renderer eintreffen, sollte **GetState** sofort mit **S \_ OK** zurückgegeben werden.</span><span class="sxs-lookup"><span data-stu-id="9253e-178">Once data arrives at the renderer, **GetState** should be returned immediately with **S\_OK**.</span></span>

<span data-ttu-id="9253e-179">Sowohl im zwischen-als auch im abgeschlossenen Zustand ist der gemeldete Filter Zustand " \_ angehalten".</span><span class="sxs-lookup"><span data-stu-id="9253e-179">In both the intermediate and completed state, the reported filter state will be State\_Paused.</span></span> <span data-ttu-id="9253e-180">Nur der Rückgabewert gibt an, ob der Filter wirklich bereit ist.</span><span class="sxs-lookup"><span data-stu-id="9253e-180">Only the return value indicates whether the filter is really ready or not.</span></span> <span data-ttu-id="9253e-181">Wenn ein Renderer auf das Eintreffen der Daten wartet, sendet der Quell Filter eine Streamende Benachrichtigung, und die Statusänderung muss ebenfalls abgeschlossen werden.</span><span class="sxs-lookup"><span data-stu-id="9253e-181">If, while a renderer is waiting for data to arrive, its source filter sends an end-of-stream notification, then that should also complete the state change.</span></span>

<span data-ttu-id="9253e-182">Wenn alle Filter tatsächlich über Daten verfügen, die darauf warten, gerendert zu werden, vervollständigt das Filter Diagramm die Änderung des anhaltezustands.</span><span class="sxs-lookup"><span data-stu-id="9253e-182">Once all filters actually have data waiting to be rendered, the filter graph will complete its pause state change.</span></span>

## <a name="handling-termination"></a><span data-ttu-id="9253e-183">Behandeln der Beendigung</span><span class="sxs-lookup"><span data-stu-id="9253e-183">Handling Termination</span></span>

<span data-ttu-id="9253e-184">Videorenderer müssen Beendigungs Ereignisse des Benutzers ordnungsgemäß behandeln.</span><span class="sxs-lookup"><span data-stu-id="9253e-184">Video renderers must correctly handle termination events from the user.</span></span> <span data-ttu-id="9253e-185">Dies impliziert das ordnungsgemäße Ausblenden des Fensters und das wissen, was zu tun ist, wenn ein Fenster danach gezwungen wird, angezeigt zu werden.</span><span class="sxs-lookup"><span data-stu-id="9253e-185">This implies correctly hiding the window and knowing what to do if a window is subsequently forced to be displayed.</span></span> <span data-ttu-id="9253e-186">Außerdem müssen Videorenderer den Filter Graph-Manager benachrichtigen, wenn das Fenster zerstört wird (oder genauer, wenn der Renderer aus dem Filter Diagramm entfernt wird), um Ressourcen freizugeben.</span><span class="sxs-lookup"><span data-stu-id="9253e-186">Also, video renderers must notify the Filter Graph Manager when its window is destroyed (or more accurately, when the renderer is removed from the filter graph) to free resources.</span></span>

<span data-ttu-id="9253e-187">Wenn der Benutzer das Videofenster schließt (z. b. durch Drücken von Alt + F4), besteht die Konvention darin, das Fenster sofort auszublenden und eine [**EC \_ userabort**](ec-userabort.md) -Benachrichtigung an den Filter Graph-Manager zu senden.</span><span class="sxs-lookup"><span data-stu-id="9253e-187">If the user closes the video window (for instance by pressing ALT+F4), the convention is to hide the window immediately and send an [**EC\_USERABORT**](ec-userabort.md) notification to the Filter Graph Manager.</span></span> <span data-ttu-id="9253e-188">Diese Benachrichtigung wird an die Anwendung übermittelt, wodurch das Abspielen des Diagramms beendet wird.</span><span class="sxs-lookup"><span data-stu-id="9253e-188">This notification is passed through to the application, which will stop the graph playing.</span></span> <span data-ttu-id="9253e-189">Nach dem Senden von " **EC \_ userabort**" sollte ein Videorenderer alle zusätzlichen, übermittelten Beispiele ablehnen.</span><span class="sxs-lookup"><span data-stu-id="9253e-189">After sending **EC\_USERABORT**, a video renderer should reject any additional samples delivered to it.</span></span>

<span data-ttu-id="9253e-190">Das vom Graph beendete Flag sollte vom Renderer beibehalten werden, bis er anschließend beendet wird. an diesem Punkt sollte er zurückgesetzt werden, damit eine Anwendung die Benutzeraktion außer Kraft setzen und die Darstellung des Diagramms fortsetzen kann, wenn es sich wünscht.</span><span class="sxs-lookup"><span data-stu-id="9253e-190">The graph-stopped flag should be left on by the renderer until it is subsequently stopped, at which point it should be reset so that an application can override the user action and continue playing the graph if it desires.</span></span> <span data-ttu-id="9253e-191">Wenn ALT + F4 gedrückt wird, während das Video ausgeführt wird, wird das Fenster ausgeblendet, und alle weiteren übermittelten Beispiele werden abgelehnt.</span><span class="sxs-lookup"><span data-stu-id="9253e-191">If ALT+F4 is pressed while the video is running, the window will be hidden and all further samples delivered will be rejected.</span></span> <span data-ttu-id="9253e-192">Wenn das Fenster anschließend angezeigt wird (z. b. über [**IVideoWindow::p UT \_ sichtbar**](/windows/desktop/api/Control/nf-control-ivideowindow-put_visible)), sollten keine [**EC- \_ Repaint**](ec-repaint.md) -Benachrichtigungen generiert werden.</span><span class="sxs-lookup"><span data-stu-id="9253e-192">If the window is subsequently shown (perhaps through [**IVideoWindow::put\_Visible**](/windows/desktop/api/Control/nf-control-ivideowindow-put_visible)), then no [**EC\_REPAINT**](ec-repaint.md) notifications should be generated.</span></span>

<span data-ttu-id="9253e-193">Der Videorenderer sollte außerdem das [**EC- \_ Fenster \_**](ec-window-destroyed.md) , das beim Beenden des Videorenderers gelöscht wird, an das Filter Diagramm senden.</span><span class="sxs-lookup"><span data-stu-id="9253e-193">The video renderer should also send the [**EC\_WINDOW\_DESTROYED**](ec-window-destroyed.md) notification to the filter graph when the video renderer is terminating.</span></span> <span data-ttu-id="9253e-194">Es empfiehlt sich, dies zu behandeln, wenn die [**ibasefilter:: joinfiltergraph**](/windows/desktop/api/Strmif/nf-strmif-ibasefilter-joinfiltergraph) -Methode des Renderers mit einem NULL-Parameter aufgerufen wird (was anzeigt, dass der Renderer aus dem Filter Diagramm entfernt werden soll), anstatt zu warten, bis das eigentliche Videofenster zerstört wird.</span><span class="sxs-lookup"><span data-stu-id="9253e-194">In fact, it is best to handle this when the renderer's [**IBaseFilter::JoinFilterGraph**](/windows/desktop/api/Strmif/nf-strmif-ibasefilter-joinfiltergraph) method is called with a null parameter (indicating that the renderer is about to be removed from the filter graph), rather than waiting until the actual video window is destroyed.</span></span> <span data-ttu-id="9253e-195">Wenn diese Benachrichtigung gesendet wird, kann der Plug-in-Verteiler im Filter Graph-Manager Ressourcen übergeben, die vom Fenster Fokus auf andere Filter, z. b. Audiogeräte, abhängen.</span><span class="sxs-lookup"><span data-stu-id="9253e-195">Sending this notification enables the plug-in distributor in the Filter Graph Manager to pass on resources that depend on window focus to other filters, such as audio devices.</span></span>

## <a name="handling-dynamic-format-changes"></a><span data-ttu-id="9253e-196">Behandeln dynamischer Format Änderungen</span><span class="sxs-lookup"><span data-stu-id="9253e-196">Handling Dynamic Format Changes</span></span>

<span data-ttu-id="9253e-197">In einigen Fällen kann der upstreamfilter des Renderers versuchen, das Videoformat zu ändern, während das Video wiedergegeben wird.</span><span class="sxs-lookup"><span data-stu-id="9253e-197">In some cases, the renderer's upstream filter might try to change the video format while the video is playing.</span></span> <span data-ttu-id="9253e-198">In den meisten Fällen ist dies das Video Dekompressor, das eine dynamische Formatänderung auslöst.</span><span class="sxs-lookup"><span data-stu-id="9253e-198">It is most often the video decompressor that initiates a dynamic format change.</span></span>

<span data-ttu-id="9253e-199">Ein upstreamfilter, der versucht, Formate dynamisch zu ändern, sollte immer die [**IPin:: queryaccept**](/windows/desktop/api/Strmif/nf-strmif-ipin-queryaccept) -Methode für die Renderer-Eingabe-PIN aufgerufen werden.</span><span class="sxs-lookup"><span data-stu-id="9253e-199">An upstream filter attempting to change formats dynamically should always call the [**IPin::QueryAccept**](/windows/desktop/api/Strmif/nf-strmif-ipin-queryaccept) method on the renderer input pin.</span></span> <span data-ttu-id="9253e-200">Ein Videorenderer hat einige Möglichkeiten, welche Arten von dynamischen Formatänderungen er unterstützen sollte.</span><span class="sxs-lookup"><span data-stu-id="9253e-200">A video renderer has some leeway as to what kinds of dynamic format changes it should support.</span></span> <span data-ttu-id="9253e-201">Der upstreamfilter sollte mindestens das Ändern von Paletten ermöglichen.</span><span class="sxs-lookup"><span data-stu-id="9253e-201">At a minimum, it should allow the upstream filter to change palettes.</span></span> <span data-ttu-id="9253e-202">Wenn ein upstreamfilter die Medientypen ändert, wird der Medientyp dem ersten im neuen Format übermittelten Beispiel angefügt.</span><span class="sxs-lookup"><span data-stu-id="9253e-202">When an upstream filter changes media types, it attaches the media type to the first sample delivered in the new format.</span></span> <span data-ttu-id="9253e-203">Wenn der Renderer Beispiele in einer Warteschlange zum Rendern enthält, sollte das Format erst geändert werden, wenn das Beispiel mit der Typänderung gerendert wird.</span><span class="sxs-lookup"><span data-stu-id="9253e-203">If the renderer holds samples in a queue for rendering, it should not change the format until it renders the sample with the type change.</span></span>

<span data-ttu-id="9253e-204">Ein Videorenderer kann auch eine Formatänderung vom Decoder anfordern.</span><span class="sxs-lookup"><span data-stu-id="9253e-204">A video renderer can also request a format change from the decoder.</span></span> <span data-ttu-id="9253e-205">Beispielsweise könnte der Decoder den Decoder bitten, ein DirectDraw-kompatibles Format mit einer negativen **biheight** bereitzustellen.</span><span class="sxs-lookup"><span data-stu-id="9253e-205">For example, it might ask the decoder to provide a DirectDraw-compatible format with a negative **biHeight**.</span></span> <span data-ttu-id="9253e-206">Wenn der Renderer angehalten wurde, sollte er [**queryaccept**](/windows/desktop/api/Strmif/nf-strmif-ipin-queryaccept) in der upstreampin aufgerufen werden, um zu sehen, welche Formate der Decoder bereitstellen kann.</span><span class="sxs-lookup"><span data-stu-id="9253e-206">When the renderer is paused, it should call [**QueryAccept**](/windows/desktop/api/Strmif/nf-strmif-ipin-queryaccept) on the upstream pin to see which formats the decoder can provide.</span></span> <span data-ttu-id="9253e-207">Der Decoder listet jedoch möglicherweise nicht alle Typen auf, die akzeptiert werden können, sodass der Renderer einige Typen anbieten sollte, auch wenn der Decoder Sie nicht ankündigt.</span><span class="sxs-lookup"><span data-stu-id="9253e-207">The decoder might not enumerate all of the types that it can accept, however, so the renderer should offer some types even if the decoder does not advertise them.</span></span>

<span data-ttu-id="9253e-208">Wenn der Decoder zum angeforderten Format wechseln kann, wird er von [**queryaccept**](/windows/desktop/api/Strmif/nf-strmif-ipin-queryaccept)in " **\_ OK** " zurückgegeben.</span><span class="sxs-lookup"><span data-stu-id="9253e-208">If the decoder can switch to the requested format, it returns **S\_OK** from [**QueryAccept**](/windows/desktop/api/Strmif/nf-strmif-ipin-queryaccept).</span></span> <span data-ttu-id="9253e-209">Der Renderer fügt dann den neuen Medientyp an das nächste Medien Beispiel auf der upstreamzuweisung an.</span><span class="sxs-lookup"><span data-stu-id="9253e-209">The renderer then attaches the new media type to the next media sample on the upstream allocator.</span></span> <span data-ttu-id="9253e-210">Damit dies funktioniert, muss der Renderer eine benutzerdefinierte Zuweisung bereitstellen, die eine private Methode zum Anfügen des Medientyps an das nächste Beispiel implementiert.</span><span class="sxs-lookup"><span data-stu-id="9253e-210">For this to work, the renderer must provide a custom allocator that implements a private method for attaching the media type to the next sample.</span></span> <span data-ttu-id="9253e-211">(Geben Sie in dieser privaten Methode [**imediasample:: setmediatype**](/windows/desktop/api/Strmif/nf-strmif-imediasample-setmediatype) ein, um den Typ festzulegen.)</span><span class="sxs-lookup"><span data-stu-id="9253e-211">(Within this private method, call [**IMediaSample::SetMediaType**](/windows/desktop/api/Strmif/nf-strmif-imediasample-setmediatype) to set the type.)</span></span>

<span data-ttu-id="9253e-212">Die Eingabe-PIN des Renderers sollte die benutzerdefinierte Zuweisung des Renderers in der [**IMemInputPin:: getallocator**](/windows/desktop/api/Strmif/nf-strmif-imeminputpin-getallocator) -Methode zurückgeben.</span><span class="sxs-lookup"><span data-stu-id="9253e-212">The renderer's input pin should return the renderer's custom allocator in the [**IMemInputPin::GetAllocator**](/windows/desktop/api/Strmif/nf-strmif-imeminputpin-getallocator) method.</span></span> <span data-ttu-id="9253e-213">Überschreiben Sie [**IMemInputPin:: notifyzuweisung**](/windows/desktop/api/Strmif/nf-strmif-imeminputpin-notifyallocator) , sodass es fehlschlägt, wenn der upstreamfilter die Zuweisung des Renderers nicht verwendet.</span><span class="sxs-lookup"><span data-stu-id="9253e-213">Override [**IMemInputPin::NotifyAllocator**](/windows/desktop/api/Strmif/nf-strmif-imeminputpin-notifyallocator) so that it fails if the upstream filter does not use the renderer's allocator.</span></span>

<span data-ttu-id="9253e-214">Bei einigen Decodern bewirkt das Festlegen von **biheight** auf eine positive Zahl für YUV-Typen, dass der Decoder das Bild nach oben zeichnet.</span><span class="sxs-lookup"><span data-stu-id="9253e-214">With some decoders, setting **biHeight** to a positive number on YUV types causes the decoder to draw the image upside down.</span></span> <span data-ttu-id="9253e-215">(Dies ist falsch und sollte im Decoder als Fehler angesehen werden.)</span><span class="sxs-lookup"><span data-stu-id="9253e-215">(This is incorrect, and should be considered a bug in the decoder.)</span></span>

<span data-ttu-id="9253e-216">Immer dann, wenn eine Formatänderung durch den Videorenderer erkannt wird, sollte eine Benachrichtigung über die Änderung der [**EC- \_ Anzeige \_**](ec-display-changed.md) gesendet werden.</span><span class="sxs-lookup"><span data-stu-id="9253e-216">Whenever a format change is detected by the video renderer, it should send an [**EC\_DISPLAY\_CHANGED**](ec-display-changed.md) notification.</span></span> <span data-ttu-id="9253e-217">Die meisten Videorenderer wählen während der Verbindung ein Format aus, sodass das Format effizient über GDI gezeichnet werden kann.</span><span class="sxs-lookup"><span data-stu-id="9253e-217">Most video renderers pick a format during connection so that the format can be drawn efficiently through GDI.</span></span> <span data-ttu-id="9253e-218">Wenn der Benutzer den aktuellen Anzeigemodus ändert, ohne den Computer neu zu starten, findet ein Renderer möglicherweise eine ungültige Abbild Format Verbindung und sollte diese Benachrichtigung senden.</span><span class="sxs-lookup"><span data-stu-id="9253e-218">If the user changes the current display mode without restarting the computer, a renderer might find itself with a bad image format connection and should send this notification.</span></span> <span data-ttu-id="9253e-219">Der erste Parameter sollte die PIN sein, die erneut eine Verbindung herstellen muss.</span><span class="sxs-lookup"><span data-stu-id="9253e-219">The first parameter should be the pin that needs reconnecting.</span></span> <span data-ttu-id="9253e-220">Der Filter Diagramm-Manager ordnet an, dass das Filter Diagramm angehalten und die PIN erneut verbunden wird.</span><span class="sxs-lookup"><span data-stu-id="9253e-220">The Filter Graph Manager will arrange for the filter graph to be stopped and the pin reconnected.</span></span> <span data-ttu-id="9253e-221">Während der nachfolgenden erneuten Verbindung kann der Renderer ein geeignetere Format akzeptieren.</span><span class="sxs-lookup"><span data-stu-id="9253e-221">During the subsequent reconnection, the renderer can accept a more appropriate format.</span></span>

<span data-ttu-id="9253e-222">Wenn ein Videorenderer eine palettenänderung im Stream erkennt, sollte die [**\_ \_ geänderte**](ec-palette-changed.md) Benachrichtigung der EC-Palette an den Filter Graph-Manager gesendet werden.</span><span class="sxs-lookup"><span data-stu-id="9253e-222">Whenever a video renderer detects a palette change in the stream it should send the [**EC\_PALETTE\_CHANGED**](ec-palette-changed.md) notification to the Filter Graph Manager.</span></span> <span data-ttu-id="9253e-223">Die DirectShow-Videorenderer erkennen, ob eine Palette im dynamischen Format tatsächlich geändert wurde.</span><span class="sxs-lookup"><span data-stu-id="9253e-223">The DirectShow video renderers detect whether a palette has really changed in dynamic format or not.</span></span> <span data-ttu-id="9253e-224">Die Videorenderer führen dies nicht nur aus, um die Anzahl der gesendeten Änderungen an der **EC- \_ Palette \_** zu filtern, sondern auch die Menge an Palettenerstellung, Installation und Löschvorgang zu verringern.</span><span class="sxs-lookup"><span data-stu-id="9253e-224">The video renderers do this not only to filter out the number of **EC\_PALETTE\_CHANGED** notifications sent but also to reduce the amount of palette creation, installation, and deletion required.</span></span>

<span data-ttu-id="9253e-225">Schließlich erkennt der Videorenderer möglicherweise auch, dass sich die Größe des Videos geändert hat. in diesem Fall sollte die Benachrichtigung über [**eine \_ geänderte EC-Video \_ Größe \_**](ec-video-size-changed.md) gesendet werden.</span><span class="sxs-lookup"><span data-stu-id="9253e-225">Finally, the video renderer might also detect that the size of the video has changed, in which case, it should send the [**EC\_VIDEO\_SIZE\_CHANGED**](ec-video-size-changed.md) notification.</span></span> <span data-ttu-id="9253e-226">Eine Anwendung kann diese Benachrichtigung verwenden, um Speicherplatz in einem Verbund Dokument auszuhandeln.</span><span class="sxs-lookup"><span data-stu-id="9253e-226">An application might use this notification to negotiate space in a compound document.</span></span> <span data-ttu-id="9253e-227">Die tatsächlichen Video Dimensionen sind über die [**ibasicvideo**](/windows/desktop/api/Control/nn-control-ibasicvideo) -Steuerelement Schnittstelle verfügbar.</span><span class="sxs-lookup"><span data-stu-id="9253e-227">The actual video dimensions are available through the [**IBasicVideo**](/windows/desktop/api/Control/nn-control-ibasicvideo) control interface.</span></span> <span data-ttu-id="9253e-228">Die DirectShow-Renderer erkennen, ob die Größe des Videos tatsächlich geändert wurde oder nicht, bevor diese Ereignisse gesendet werden.</span><span class="sxs-lookup"><span data-stu-id="9253e-228">The DirectShow renderers detect whether the video has actually changed size or not prior to sending these events.</span></span>

## <a name="handling-persistent-properties"></a><span data-ttu-id="9253e-229">Behandeln von permanenten Eigenschaften</span><span class="sxs-lookup"><span data-stu-id="9253e-229">Handling Persistent Properties</span></span>

<span data-ttu-id="9253e-230">Alle Eigenschaften, die über die [**ibasicvideo**](/windows/desktop/api/Control/nn-control-ibasicvideo) -und die [**IVideoWindow**](/windows/desktop/api/Control/nn-control-ivideowindow) -Schnittstelle festgelegt werden, sind für die Verbindungs Dauer permanent.</span><span class="sxs-lookup"><span data-stu-id="9253e-230">All properties set through the [**IBasicVideo**](/windows/desktop/api/Control/nn-control-ibasicvideo) and [**IVideoWindow**](/windows/desktop/api/Control/nn-control-ivideowindow) interfaces are meant to be persistent across connections.</span></span> <span data-ttu-id="9253e-231">Daher sollten beim Trennen und erneuten Verbinden eines Renderers keine Auswirkungen auf die Fenstergröße,-Position oder-Stile angezeigt werden.</span><span class="sxs-lookup"><span data-stu-id="9253e-231">Therefore, disconnecting and reconnecting a renderer should show no effects on the window size, position, or styles.</span></span> <span data-ttu-id="9253e-232">Wenn sich die Video Dimensionen jedoch zwischen den Verbindungen ändern, sollte der Renderer die Quell-und Ziel Rechtecke auf ihre Standardwerte zurücksetzen.</span><span class="sxs-lookup"><span data-stu-id="9253e-232">However, if the video dimensions change between connections, the renderer should reset the source and destination rectangles to their defaults.</span></span> <span data-ttu-id="9253e-233">Die Quell-und Zielpositionen werden über die **ibasicvideo** -Schnittstelle festgelegt.</span><span class="sxs-lookup"><span data-stu-id="9253e-233">The source and destination positions are set through the **IBasicVideo** interface.</span></span>

<span data-ttu-id="9253e-234">Sowohl [**ibasicvideo**](/windows/desktop/api/Control/nn-control-ibasicvideo) als auch [**IVideoWindow**](/windows/desktop/api/Control/nn-control-ivideowindow) bieten ausreichenden Zugriff auf Eigenschaften, damit eine Anwendung alle Daten in der Schnittstelle in einem persistenten Format speichern und wiederherstellen kann.</span><span class="sxs-lookup"><span data-stu-id="9253e-234">Both [**IBasicVideo**](/windows/desktop/api/Control/nn-control-ibasicvideo) and [**IVideoWindow**](/windows/desktop/api/Control/nn-control-ivideowindow) provide enough access to properties to allow an application to save and restore all the data in the interface in a persistent format.</span></span> <span data-ttu-id="9253e-235">Dies ist nützlich für Anwendungen, die die genaue Konfiguration und die Eigenschaften von Filter Diagrammen während einer Bearbeitungs Sitzung speichern und später wiederherstellen müssen.</span><span class="sxs-lookup"><span data-stu-id="9253e-235">This will be useful to applications that must save the exact configuration and properties of filter graphs during an editing session and restore them later.</span></span>

## <a name="handling-ec_repaint-notifications"></a><span data-ttu-id="9253e-236">Behandeln von EC- \_ Repaint-Benachrichtigungen</span><span class="sxs-lookup"><span data-stu-id="9253e-236">Handling EC\_REPAINT Notifications</span></span>

<span data-ttu-id="9253e-237">Die [**EC \_ Repaint**](ec-repaint.md) -Benachrichtigung wird nur gesendet, wenn der Renderer entweder angehalten oder beendet wurde.</span><span class="sxs-lookup"><span data-stu-id="9253e-237">The [**EC\_REPAINT**](ec-repaint.md) notification is sent only when the renderer is either paused or stopped.</span></span> <span data-ttu-id="9253e-238">Diese Benachrichtigung signalisiert dem Filter Graph-Manager, dass der Renderer Daten benötigt.</span><span class="sxs-lookup"><span data-stu-id="9253e-238">This notification signals to the Filter Graph Manager that the renderer needs data.</span></span> <span data-ttu-id="9253e-239">Wenn das Filter Diagramm angehalten wird, wenn es eine dieser Benachrichtigungen empfängt, wird das Filter Diagramm angehalten. warten Sie, bis alle Filterdaten empfangen haben (durch Aufrufen von [**GetState**](/windows/desktop/api/Strmif/nf-strmif-imediafilter-getstate)), und beenden Sie es dann erneut.</span><span class="sxs-lookup"><span data-stu-id="9253e-239">If the filter graph is stopped when it receives one of these notifications, it will pause the filter graph, wait for all filters to receive data (by calling [**GetState**](/windows/desktop/api/Strmif/nf-strmif-imediafilter-getstate)), and then stop it again.</span></span> <span data-ttu-id="9253e-240">Wenn er angehalten wurde, sollte ein Videorenderer an dem Bild halten, damit nachfolgende WM-Zeichnungs Meldungen verarbeitet werden können. [**\_**](/windows/desktop/gdi/wm-paint)</span><span class="sxs-lookup"><span data-stu-id="9253e-240">When stopped, a video renderer should hold on to the image so that subsequent [**WM\_PAINT**](/windows/desktop/gdi/wm-paint) messages can be handled.</span></span>

<span data-ttu-id="9253e-241">Wenn ein Videorenderer eine WM-Zeichnungs [**Nachricht \_**](/windows/desktop/gdi/wm-paint) erhält, wenn er angehalten oder angehalten wird, und er nichts hat, mit dem das Fenster gezeichnet werden soll, sollte der [**EC \_ Repaint**](ec-repaint.md) an den Filter Graph-Manager gesendet werden.</span><span class="sxs-lookup"><span data-stu-id="9253e-241">Therefore, if a video renderer receives a [**WM\_PAINT**](/windows/desktop/gdi/wm-paint) message when stopped or paused, and it has nothing with which to paint its window, then it should send [**EC\_REPAINT**](ec-repaint.md) to the Filter Graph Manager.</span></span> <span data-ttu-id="9253e-242">Wenn eine **EC \_ Repaint** -Benachrichtigung empfangen wird, während Sie angehalten wurde, ruft der Filter Graph-Manager [**imediaposition::p UT \_ CurrentPosition**](/windows/desktop/api/Control/nf-control-imediaposition-put_currentposition) mit der aktuellen Position auf (d. h., sucht nach der aktuellen Position).</span><span class="sxs-lookup"><span data-stu-id="9253e-242">If an **EC\_REPAINT** notification is received while paused, then the Filter Graph Manager calls [**IMediaPosition::put\_CurrentPosition**](/windows/desktop/api/Control/nf-control-imediaposition-put_currentposition) with the current position (that is, seeks to the current position).</span></span> <span data-ttu-id="9253e-243">Dies bewirkt, dass die Quell Filter das Filter Diagramm leeren und bewirkt, dass neue Daten über das Filter Diagramm gesendet werden.</span><span class="sxs-lookup"><span data-stu-id="9253e-243">This causes the source filters to flush the filter graph and causes new data to be sent through the filter graph.</span></span>

<span data-ttu-id="9253e-244">Ein Renderer darf jeweils nur eine dieser Benachrichtigungen senden.</span><span class="sxs-lookup"><span data-stu-id="9253e-244">A renderer must send only one of these notifications at a time.</span></span> <span data-ttu-id="9253e-245">Nachdem der Renderer eine Benachrichtigung gesendet hat, sollte daher sichergestellt werden, dass nicht mehr gesendet werden, bis einige Beispiele übermittelt wurden.</span><span class="sxs-lookup"><span data-stu-id="9253e-245">Therefore, once the renderer sends a notification, it should ensure no more are sent until some samples are delivered.</span></span> <span data-ttu-id="9253e-246">Die herkömmliche Vorgehensweise besteht darin, ein Flag zu verwenden, das kennzeichnet, dass ein Repaint gesendet werden kann, das ausgeschaltet wird, nachdem eine [**EC \_ Repaint**](ec-repaint.md) -Benachrichtigung gesendet wurde.</span><span class="sxs-lookup"><span data-stu-id="9253e-246">The conventional way to do this is to have a flag to signify that a repaint can be sent, which is turned off after an [**EC\_REPAINT**](ec-repaint.md) notification is sent.</span></span> <span data-ttu-id="9253e-247">Dieses Flag sollte zurückgesetzt werden, wenn Daten übermittelt werden, oder wenn die Eingabe-PIN geleert wird, aber nicht, wenn das Ende des Streams in der eingabepin signalisiert wird.</span><span class="sxs-lookup"><span data-stu-id="9253e-247">This flag should be reset once data is delivered or when the input pin is flushed, but not if end-of-stream is signaled on the input pin.</span></span>

<span data-ttu-id="9253e-248">Wenn der Renderer seine [**EC- \_ Repaint**](ec-repaint.md) -Benachrichtigungen nicht überwacht, wird der Filter Graph-Manager mit **EC \_ Repaint** -Anforderungen überflutet (was relativ aufwendig ist).</span><span class="sxs-lookup"><span data-stu-id="9253e-248">If the renderer does not monitor its [**EC\_REPAINT**](ec-repaint.md) notifications, it will flood the Filter Graph Manager with **EC\_REPAINT** requests (which are relatively expensive to process).</span></span> <span data-ttu-id="9253e-249">Wenn ein Renderer z. b. kein Bild hat, das gezeichnet werden soll, und ein anderes Fenster in einem vollständigen Drag-Vorgang auf das Fenster des Renderers gezogen wird, empfängt der Renderer mehrere [**WM \_ Paint**](/windows/desktop/gdi/wm-paint) -Meldungen.</span><span class="sxs-lookup"><span data-stu-id="9253e-249">For example, if a renderer has no image to draw, and another window is dragged across the window of the renderer in a full-drag operation, the renderer receives multiple [**WM\_PAINT**](/windows/desktop/gdi/wm-paint) messages.</span></span> <span data-ttu-id="9253e-250">Nur der erste muss eine **EC \_ Repaint** -Ereignis Benachrichtigung vom Renderer an den Filter Graph-Manager generieren.</span><span class="sxs-lookup"><span data-stu-id="9253e-250">Only the first of these should generate an **EC\_REPAINT** event notification from the renderer to the Filter Graph Manager.</span></span>

<span data-ttu-id="9253e-251">Ein Renderer sollte seine Eingabe-PIN als ersten Parameter an die [**EC \_ Repaint**](ec-repaint.md) -Benachrichtigung senden.</span><span class="sxs-lookup"><span data-stu-id="9253e-251">A renderer should send its input pin as the first parameter to the [**EC\_REPAINT**](ec-repaint.md) notification.</span></span> <span data-ttu-id="9253e-252">Auf diese Weise wird die angefügte Ausgabepin für [**imediaeventsink**](/windows/desktop/api/Strmif/nn-strmif-imediaeventsink)abgefragt, und wenn diese unterstützt wird, wird zuerst die **EC \_ Repaint** -Benachrichtigung gesendet.</span><span class="sxs-lookup"><span data-stu-id="9253e-252">By doing this, the attached output pin will be queried for [**IMediaEventSink**](/windows/desktop/api/Strmif/nn-strmif-imediaeventsink), and if supported, the **EC\_REPAINT** notification will be sent there first.</span></span> <span data-ttu-id="9253e-253">Dadurch können Ausgabe Pins Repaint verarbeiten, bevor das Filter Diagramm berührt werden muss.</span><span class="sxs-lookup"><span data-stu-id="9253e-253">This enables output pins to handle repaints before the filter graph must be touched.</span></span> <span data-ttu-id="9253e-254">Dies wird nicht durchgeführt, wenn das Filter Diagramm angehalten wird, da keine Puffer von der Zuweiser Renderer-Zuweisung bereitgestellt werden können.</span><span class="sxs-lookup"><span data-stu-id="9253e-254">This will not be done if the filter graph is stopped, because no buffers would be available from the decommitted renderer allocator.</span></span>

<span data-ttu-id="9253e-255">Wenn die Ausgabe-PIN die Anforderung nicht verarbeiten kann und das Filter Diagramm ausgeführt wird, wird die [**EC \_ Repaint**](ec-repaint.md) -Benachrichtigung ignoriert.</span><span class="sxs-lookup"><span data-stu-id="9253e-255">If the output pin cannot handle the request and the filter graph is running, then the [**EC\_REPAINT**](ec-repaint.md) notification is ignored.</span></span> <span data-ttu-id="9253e-256">Eine Ausgabe-PIN muss **S \_ OK** aus [**imediaeventsink:: notify**](/windows/desktop/api/Strmif/nf-strmif-imediaeventsink-notify) zurückgeben, um zu signalisieren, dass die Repaint-Anforderung erfolgreich verarbeitet wurde.</span><span class="sxs-lookup"><span data-stu-id="9253e-256">An output pin must return **S\_OK** from [**IMediaEventSink::Notify**](/windows/desktop/api/Strmif/nf-strmif-imediaeventsink-notify) to signal that it processed the repaint request successfully.</span></span> <span data-ttu-id="9253e-257">Die Ausgabepin wird für den Arbeits Thread des Filter-Graph-Managers aufgerufen, wodurch vermieden wird, dass der Renderer die Ausgabepin direkt aufruft und somit alle Deadlockprobleme nach sich zieht.</span><span class="sxs-lookup"><span data-stu-id="9253e-257">The output pin will be called on the Filter Graph Manager worker thread, which avoids having the renderer call the output pin directly, and so sidesteps any deadlock issues.</span></span> <span data-ttu-id="9253e-258">Wenn das Filter Diagramm beendet oder angehalten wurde und die Ausgabe die Anforderung nicht verarbeitet, wird die Standard Verarbeitung durchgeführt.</span><span class="sxs-lookup"><span data-stu-id="9253e-258">If the filter graph is stopped or paused and the output doesn't handle the request, then the default processing is done.</span></span>

## <a name="handling-notifications-in-full-screen-mode"></a><span data-ttu-id="9253e-259">Behandeln von Benachrichtigungen im Full-Screen Modus</span><span class="sxs-lookup"><span data-stu-id="9253e-259">Handling Notifications in Full-Screen Mode</span></span>

<span data-ttu-id="9253e-260">Der [**IVideoWindow**](/windows/desktop/api/Control/nn-control-ivideowindow) -Plug-in-Verteiler (PID) im Filter Diagramm verwaltet die Vollbildwiedergabe.</span><span class="sxs-lookup"><span data-stu-id="9253e-260">The [**IVideoWindow**](/windows/desktop/api/Control/nn-control-ivideowindow) plug-in distributor (PID) in the filter graph manages full-screen playback.</span></span> <span data-ttu-id="9253e-261">Ein Videorenderer wird für einen spezialisierten Vollbild-Renderer ausgetauscht, ein Fenster eines Renderers auf den voll Bildschirm gestreckt, oder der Renderer muss die Vollbildwiedergabe direkt implementieren.</span><span class="sxs-lookup"><span data-stu-id="9253e-261">It will swap a video renderer out for a specialist full-screen renderer, stretch a window of a renderer to full screen, or have the renderer implement full-screen playback directly.</span></span> <span data-ttu-id="9253e-262">Um mit voll Bild Protokollen zu interagieren, sollte ein Videorenderer eine [**EC- \_ Aktivierungs**](ec-activate.md) Benachrichtigung senden, wenn das Fenster aktiviert oder deaktiviert ist.</span><span class="sxs-lookup"><span data-stu-id="9253e-262">To interact in full-screen protocols, a video renderer should send an [**EC\_ACTIVATE**](ec-activate.md) notification whenever its window is either activated or deactivated.</span></span> <span data-ttu-id="9253e-263">Anders ausgedrückt: für jede WM activateapp-Nachricht, die ein Renderer empfängt, sollte eine **EC- \_ Aktivierungs** Benachrichtigung gesendet werden \_ .</span><span class="sxs-lookup"><span data-stu-id="9253e-263">In other words, an **EC\_ACTIVATE** notification should be sent for each WM\_ACTIVATEAPP message a renderer receives.</span></span>

<span data-ttu-id="9253e-264">Wenn ein Renderer im Vollbildmodus verwendet wird, verwalten diese Benachrichtigungen den Wechsel in den und aus diesem Vollbildmodus.</span><span class="sxs-lookup"><span data-stu-id="9253e-264">When a renderer is being used in full-screen mode, these notifications manage the switching into and out of that full-screen mode.</span></span> <span data-ttu-id="9253e-265">Die Fenster Deaktivierung tritt normalerweise auf, wenn ein Benutzer Alt + Tab drückt, um zu einem anderen Fenster zu wechseln, das der DirectShow-Vollbild-Renderer als Hinweis verwendet, um zum typischen Renderingmodus zurückzukehren.</span><span class="sxs-lookup"><span data-stu-id="9253e-265">Window deactivation typically occurs when a user presses ALT+TAB to switch to another window, which the DirectShow full-screen renderer uses as a cue to return to typical rendering mode.</span></span>

<span data-ttu-id="9253e-266">Wenn die [**EC- \_ Aktivierungs**](ec-activate.md) Benachrichtigung an den Filter Graph-Manager gesendet wird, wenn der Vollbildmodus gewechselt wird, sendet der Filter Graph-Manager eine [**EC- \_ Vollbild \_**](ec-fullscreen-lost.md) -Benachrichtigung an die steuernde Anwendung.</span><span class="sxs-lookup"><span data-stu-id="9253e-266">When the [**EC\_ACTIVATE**](ec-activate.md) notification is sent to the Filter Graph Manager upon switching out of full-screen mode, the Filter Graph Manager sends an [**EC\_FULLSCREEN\_LOST**](ec-fullscreen-lost.md) notification to the controlling application.</span></span> <span data-ttu-id="9253e-267">Die Anwendung kann diese Benachrichtigung verwenden, um z. b. den Status einer voll Bild Schaltfläche wiederherzustellen.</span><span class="sxs-lookup"><span data-stu-id="9253e-267">The application might use this notification to restore the state of a full-screen button, for example.</span></span> <span data-ttu-id="9253e-268">Die **EC- \_ Aktivierungs** Benachrichtigungen werden intern von DirectShow verwendet, um den Vollbild-Wechsel für Hinweise von den Videorenderer zu verwalten.</span><span class="sxs-lookup"><span data-stu-id="9253e-268">The **EC\_ACTIVATE** notifications are used internally by DirectShow to manage full-screen switching on cues from the video renderers.</span></span>

## <a name="summary-of-notifications"></a><span data-ttu-id="9253e-269">Zusammenfassung der Benachrichtigungen</span><span class="sxs-lookup"><span data-stu-id="9253e-269">Summary of Notifications</span></span>

<span data-ttu-id="9253e-270">In diesem Abschnitt werden die Filter Diagramm Benachrichtigungen aufgelistet, die von einem Renderer gesendet werden können.</span><span class="sxs-lookup"><span data-stu-id="9253e-270">This section lists the filter graph notifications that a renderer can send.</span></span>



| <span data-ttu-id="9253e-271">Ereignisbenachrichtigung</span><span class="sxs-lookup"><span data-stu-id="9253e-271">Event notification</span></span>                                        | <span data-ttu-id="9253e-272">BESCHREIBUNG</span><span class="sxs-lookup"><span data-stu-id="9253e-272">Description</span></span>                                                                                                                                                                                       |
|-----------------------------------------------------------|---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| [<span data-ttu-id="9253e-273">**Aktivieren von EC \_**</span><span class="sxs-lookup"><span data-stu-id="9253e-273">**EC\_ACTIVATE**</span></span>](ec-activate.md)                       | <span data-ttu-id="9253e-274">Wird von Videorenderer im Vollbild-Renderingmodus für jede \_ empfangene WM activateapp-Nachricht gesendet.</span><span class="sxs-lookup"><span data-stu-id="9253e-274">Sent by video renderers in full-screen rendering mode for each WM\_ACTIVATEAPP message received.</span></span>                                                                                                  |
| [<span data-ttu-id="9253e-275">**EC \_ Complete**</span><span class="sxs-lookup"><span data-stu-id="9253e-275">**EC\_COMPLETE**</span></span>](ec-complete.md)                       | <span data-ttu-id="9253e-276">Wird von renderatoren gesendet, nachdem alle Daten gerendert wurden.</span><span class="sxs-lookup"><span data-stu-id="9253e-276">Sent by renderers after all data has been rendered.</span></span>                                                                                                                                               |
| [<span data-ttu-id="9253e-277">**EC- \_ Anzeige \_ geändert**</span><span class="sxs-lookup"><span data-stu-id="9253e-277">**EC\_DISPLAY\_CHANGED**</span></span>](ec-display-changed.md)        | <span data-ttu-id="9253e-278">Wird von Videorenderer gesendet, wenn sich ein Anzeige Format ändert.</span><span class="sxs-lookup"><span data-stu-id="9253e-278">Sent by video renderers when a display format changes.</span></span>                                                                                                                                            |
| [<span data-ttu-id="9253e-279">**EC- \_ Palette \_ geändert**</span><span class="sxs-lookup"><span data-stu-id="9253e-279">**EC\_PALETTE\_CHANGED**</span></span>](ec-palette-changed.md)        | <span data-ttu-id="9253e-280">Wird gesendet, wenn ein Videorenderer eine palettenänderung im Stream erkennt.</span><span class="sxs-lookup"><span data-stu-id="9253e-280">Sent whenever a video renderer detects a palette change in the stream.</span></span>                                                                                                                            |
| [<span data-ttu-id="9253e-281">**EC- \_ Repaint**</span><span class="sxs-lookup"><span data-stu-id="9253e-281">**EC\_REPAINT**</span></span>](ec-repaint.md)                         | <span data-ttu-id="9253e-282">Wird von beendeten oder angehaltenen Videorenderer gesendet, wenn eine WM \_ -Zeichnungs Nachricht empfangen wird und keine anzuzeigenden Daten vorhanden sind.</span><span class="sxs-lookup"><span data-stu-id="9253e-282">Sent by stopped or paused video renderers when a WM\_PAINT message is received and there is no data to display.</span></span> <span data-ttu-id="9253e-283">Dies bewirkt, dass der Filter Graph-Manager einen Frame zum Zeichnen in die Anzeige generiert.</span><span class="sxs-lookup"><span data-stu-id="9253e-283">This causes the Filter Graph Manager to generate a frame to paint to the display.</span></span> |
| [<span data-ttu-id="9253e-284">**EC \_ userabort**</span><span class="sxs-lookup"><span data-stu-id="9253e-284">**EC\_USERABORT**</span></span>](ec-userabort.md)                     | <span data-ttu-id="9253e-285">Wird von Videorenderer gesendet, um eine vom Benutzer angeforderte Sperre zu signalisieren (z. b. ein Benutzer, der das Videofenster schließt).</span><span class="sxs-lookup"><span data-stu-id="9253e-285">Sent by video renderers to signal a closure that the user requested (for example, a user closing the video window).</span></span>                                                                               |
| [<span data-ttu-id="9253e-286">**Größe des EC- \_ Videos \_ \_ geändert**</span><span class="sxs-lookup"><span data-stu-id="9253e-286">**EC\_VIDEO\_SIZE\_CHANGED**</span></span>](ec-video-size-changed.md) | <span data-ttu-id="9253e-287">Wird von videorendererarbeitern gesendet, wenn eine Änderung an der systemeigenen Videogröße erkannt wird.</span><span class="sxs-lookup"><span data-stu-id="9253e-287">Sent by video renderers whenever a change in native video size is detected.</span></span>                                                                                                                       |
| [<span data-ttu-id="9253e-288">**EC- \_ Fenster \_ zerstört**</span><span class="sxs-lookup"><span data-stu-id="9253e-288">**EC\_WINDOW\_DESTROYED**</span></span>](ec-window-destroyed.md)      | <span data-ttu-id="9253e-289">Wird von Videorenderer gesendet, wenn der Filter entfernt oder zerstört wird, sodass Ressourcen, die vom Fenster Fokus abhängen, an andere Filter weitergegeben werden können.</span><span class="sxs-lookup"><span data-stu-id="9253e-289">Sent by video renderers when the filter is removed or destroyed so that resources that depend on window focus can be passed to other filters.</span></span>                                                     |



 

## <a name="related-topics"></a><span data-ttu-id="9253e-290">Zugehörige Themen</span><span class="sxs-lookup"><span data-stu-id="9253e-290">Related topics</span></span>

<dl> <dt>

[<span data-ttu-id="9253e-291">Schreiben von Videorenderer</span><span class="sxs-lookup"><span data-stu-id="9253e-291">Writing Video Renderers</span></span>](writing-video-renderers.md)
</dt> </dl>

 

 
