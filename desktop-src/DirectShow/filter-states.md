---
description: Filter Zustände
ms.assetid: 97418307-eb50-4c8e-b03b-a2cd08139bdc
title: Filter Zustände
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: 2d61f66e1446d97d289f7e489f116f747f339d9a
ms.sourcegitcommit: a47bd86f517de76374e4fff33cfeb613eb259a7e
ms.translationtype: MT
ms.contentlocale: de-DE
ms.lasthandoff: 01/06/2021
ms.locfileid: "106343142"
---
# <a name="filter-states"></a><span data-ttu-id="29268-103">Filter Zustände</span><span class="sxs-lookup"><span data-stu-id="29268-103">Filter States</span></span>

<span data-ttu-id="29268-104">Filter haben drei mögliche Zustände: "beendet", "angehalten" und "wird ausgeführt".</span><span class="sxs-lookup"><span data-stu-id="29268-104">Filters have three possible states: stopped, paused, and running.</span></span> <span data-ttu-id="29268-105">Der Zweck des angehaltenen Zustands besteht darin, Daten im Diagramm zu finden, sodass ein Run-Befehl sofort antwortet.</span><span class="sxs-lookup"><span data-stu-id="29268-105">The purpose of the paused state is to cue data in the graph, so that a run command responds immediately.</span></span> <span data-ttu-id="29268-106">Der Filter Graph-Manager steuert alle Zustandsübergänge.</span><span class="sxs-lookup"><span data-stu-id="29268-106">The Filter Graph Manager controls all state transitions.</span></span> <span data-ttu-id="29268-107">Wenn eine Anwendung [**IMediaControl:: Run**](/windows/desktop/api/Control/nf-control-imediacontrol-run), [**IMediaControl::P ause**](/windows/desktop/api/Control/nf-control-imediacontrol-pause)oder [**IMediaControl:: beenden**](/windows/desktop/api/Control/nf-control-imediacontrol-stop)aufruft, ruft der Filter Graph-Manager die entsprechende [**imediafilter**](/windows/desktop/api/Strmif/nn-strmif-imediafilter) -Methode für alle Filter auf.</span><span class="sxs-lookup"><span data-stu-id="29268-107">When an application calls [**IMediaControl::Run**](/windows/desktop/api/Control/nf-control-imediacontrol-run), [**IMediaControl::Pause**](/windows/desktop/api/Control/nf-control-imediacontrol-pause), or [**IMediaControl::Stop**](/windows/desktop/api/Control/nf-control-imediacontrol-stop), the Filter Graph Manager calls the corresponding [**IMediaFilter**](/windows/desktop/api/Strmif/nn-strmif-imediafilter) method on all of the filters.</span></span> <span data-ttu-id="29268-108">Übergänge zwischen dem Status "beendet" und "wird ausgeführt" durchlaufen immer den angehaltenen Status. wenn die Anwendungs Aufrufe in einem beendeten Diagramm **ausgeführt** werden, hält der Filter-Graph-Manager das Diagramm vor dem Ausführen an.</span><span class="sxs-lookup"><span data-stu-id="29268-108">Transitions between stopped and running always go through the paused state, so if the application calls **Run** on a stopped graph, the Filter Graph Manager pauses the graph before running it.</span></span>

<span data-ttu-id="29268-109">Bei den meisten Filtern sind die Zustände "wird ausgeführt" und "angehalten" identisch.</span><span class="sxs-lookup"><span data-stu-id="29268-109">For most filters, the running and paused states are identical.</span></span> <span data-ttu-id="29268-110">Sehen Sie sich das folgende Filter Diagramm an:</span><span class="sxs-lookup"><span data-stu-id="29268-110">Consider the following filter graph:</span></span>

<span data-ttu-id="29268-111">Quelle > Transform > Renderer</span><span class="sxs-lookup"><span data-stu-id="29268-111">Source > Transform > Renderer</span></span>

<span data-ttu-id="29268-112">Nehmen Sie jetzt an, dass der Quell Filter keine Live Erfassungs Quelle ist.</span><span class="sxs-lookup"><span data-stu-id="29268-112">Assume for now that the source filter is not a live capture source.</span></span> <span data-ttu-id="29268-113">Wenn der Quell Filter angehalten wird, erstellt er einen Thread, der neue Daten generiert und so schnell wie möglich in Medien Beispiele schreibt.</span><span class="sxs-lookup"><span data-stu-id="29268-113">When the source filter pauses, it creates a thread that generates new data and writes it into media samples as quickly as possible.</span></span> <span data-ttu-id="29268-114">Der Thread überträgt die Beispiele durch Aufrufen von [**IMemInputPin:: Receive**](/windows/desktop/api/Strmif/nf-strmif-imeminputpin-receive) in der Eingabe-PIN des Transformations Filters.</span><span class="sxs-lookup"><span data-stu-id="29268-114">The thread "pushes" the samples downstream by calling [**IMemInputPin::Receive**](/windows/desktop/api/Strmif/nf-strmif-imeminputpin-receive) on the transform filter's input pin.</span></span> <span data-ttu-id="29268-115">Der Transformations Filter empfängt die Beispiele für den Thread des Quell Filters.</span><span class="sxs-lookup"><span data-stu-id="29268-115">The transform filter receives the samples on the source filter's thread.</span></span> <span data-ttu-id="29268-116">Es kann einen Arbeits Thread verwenden, um die Beispiele an den Renderer zu übermitteln, in der Regel werden Sie jedoch im gleichen Thread bereitstellt.</span><span class="sxs-lookup"><span data-stu-id="29268-116">It may use a worker thread to deliver the samples to the renderer, but typically it delivers them on the same thread.</span></span> <span data-ttu-id="29268-117">Während der Renderer angehalten wird, wartet er auf den Empfang eines Beispiels.</span><span class="sxs-lookup"><span data-stu-id="29268-117">While the renderer is paused, it waits to receive a sample.</span></span> <span data-ttu-id="29268-118">Nachdem eine solche Anwendung empfangen wurde, wird Sie auf unbestimmte Zeit blockiert und aufbewahrt.</span><span class="sxs-lookup"><span data-stu-id="29268-118">After it receives one, it blocks and holds that sample indefinitely.</span></span> <span data-ttu-id="29268-119">Wenn es sich um einen Videorenderer handelt, wird das Beispiel als Poster-Bild angezeigt, und das Bild wird bei Bedarf neu gezeichnet.</span><span class="sxs-lookup"><span data-stu-id="29268-119">If it is a video renderer, it displays the sample as a poster image, repainting the image as necessary.</span></span>

<span data-ttu-id="29268-120">An diesem Punkt ist der Stream vollständig gepuffert und zum Rendern bereit.</span><span class="sxs-lookup"><span data-stu-id="29268-120">At this point, the stream is fully cued and ready for rendering.</span></span> <span data-ttu-id="29268-121">Wenn das Diagramm angehalten bleibt, werden die Beispiele im Diagramm hinter dem ersten Beispiel zusammengefasst, bis jeder Filter in [**Receive**](/windows/desktop/api/Strmif/nf-strmif-imeminputpin-receive) oder [**imemzucator:: GetBuffer**](/windows/desktop/api/Strmif/nf-strmif-imemallocator-getbuffer)blockiert wird.</span><span class="sxs-lookup"><span data-stu-id="29268-121">If the graph remains paused, samples will "pile up" in the graph behind the first sample, until every filter is blocked in [**Receive**](/windows/desktop/api/Strmif/nf-strmif-imeminputpin-receive) or [**IMemAllocator::GetBuffer**](/windows/desktop/api/Strmif/nf-strmif-imemallocator-getbuffer).</span></span> <span data-ttu-id="29268-122">Obwohl keine Daten verloren gehen.</span><span class="sxs-lookup"><span data-stu-id="29268-122">No data is lost, though.</span></span> <span data-ttu-id="29268-123">Nachdem die Blockierung des Quell Threads aufgehoben wurde, wird er von dem Zeitpunkt, an dem er blockiert wurde, einfach wieder aufgenommen.</span><span class="sxs-lookup"><span data-stu-id="29268-123">Once the source thread is unblocked, it simply resumes from the point where it blocked.</span></span>

<span data-ttu-id="29268-124">Der Quell Filter und der Transformations Filter ignorieren den Übergang von "angehalten" zu "wird ausgeführt" – Sie verarbeiten die Daten einfach so schnell wie möglich.</span><span class="sxs-lookup"><span data-stu-id="29268-124">The source filter and the transform filter ignore the transition from paused to running—they simply continue to process data as fast as possible.</span></span> <span data-ttu-id="29268-125">Wenn der Renderer jedoch ausgeführt wird, beginnt er mit dem Rendern von Beispielen.</span><span class="sxs-lookup"><span data-stu-id="29268-125">But when the renderer runs, it starts rendering samples.</span></span> <span data-ttu-id="29268-126">Zuerst wird das Beispiel gerendert, während es angehalten wurde.</span><span class="sxs-lookup"><span data-stu-id="29268-126">First it renders the sample it held while it was paused.</span></span> <span data-ttu-id="29268-127">Dann wird jedes Mal, wenn ein neues Beispiel empfangen wird, die Präsentationszeit des Beispiels berechnet.</span><span class="sxs-lookup"><span data-stu-id="29268-127">Then, each time it receives a new sample, it calculates the sample's presentation time.</span></span> <span data-ttu-id="29268-128">(Ausführliche Informationen finden Sie unter [Zeit und Uhren in DirectShow](time-and-clocks-in-directshow.md).) Der Renderer hält jede Stichprobe bis zur Präsentationszeit an. an dieser Stelle wird das Beispiel gerendert.</span><span class="sxs-lookup"><span data-stu-id="29268-128">(For details, see [Time and Clocks in DirectShow](time-and-clocks-in-directshow.md).) The renderer holds each sample until the presentation time, at which point it renders the sample.</span></span> <span data-ttu-id="29268-129">Beim Warten auf die Präsentationszeit werden entweder in der [**Receive**](/windows/desktop/api/Strmif/nf-strmif-imeminputpin-receive) -Methode blockiert, oder es werden neue Beispiele für einen Arbeits Thread mit einer Warteschlange empfangen.</span><span class="sxs-lookup"><span data-stu-id="29268-129">While it waits for the presentation time, it either blocks in the [**Receive**](/windows/desktop/api/Strmif/nf-strmif-imeminputpin-receive) method, or receives new samples on a worker thread with a queue.</span></span> <span data-ttu-id="29268-130">Filter, die vom Renderer abgeleitet werden, sind nicht an der Planung beteiligt.</span><span class="sxs-lookup"><span data-stu-id="29268-130">Filters upstream from the renderer are not involved in scheduling.</span></span>

<span data-ttu-id="29268-131">Live Quellen, z. b. Erfassungsgeräte, stellen eine Ausnahme von dieser allgemeinen Architektur dar.</span><span class="sxs-lookup"><span data-stu-id="29268-131">Live sources, such as capture devices, are an exception to this general architecture.</span></span> <span data-ttu-id="29268-132">Bei einer Live Quelle ist es nicht sinnvoll, Daten vorab zu über leiten.</span><span class="sxs-lookup"><span data-stu-id="29268-132">With a live source, it is not appropriate to cue any data in advance.</span></span> <span data-ttu-id="29268-133">Die Anwendung hält das Diagramm möglicherweise an und wartet dann lange, bevor es ausgeführt wird.</span><span class="sxs-lookup"><span data-stu-id="29268-133">The application might pause the graph and then wait for a long time before running it.</span></span> <span data-ttu-id="29268-134">Das Diagramm sollte keine "veralteten" Beispiele darstellen.</span><span class="sxs-lookup"><span data-stu-id="29268-134">The graph should not render "stale" samples.</span></span> <span data-ttu-id="29268-135">Daher erzeugt eine Live Quelle keine Stichproben, die während der Ausführung angehalten werden.</span><span class="sxs-lookup"><span data-stu-id="29268-135">Therefore, a live source produces no samples while paused, only while running.</span></span> <span data-ttu-id="29268-136">Um diese Tatsache an den Filter Graph-Manager zu signalisieren, gibt die [**imediafilter:: GetState**](/windows/desktop/api/Strmif/nf-strmif-imediafilter-getstate) -Methode des Quell Filters die Vfw s-Funktion "cant" zurück \_ \_ \_ .</span><span class="sxs-lookup"><span data-stu-id="29268-136">To signal this fact to the Filter Graph Manager, the source filter's [**IMediaFilter::GetState**](/windows/desktop/api/Strmif/nf-strmif-imediafilter-getstate) method returns VFW\_S\_CANT\_CUE.</span></span> <span data-ttu-id="29268-137">Dieser Rückgabecode gibt an, dass der Filter in den angehaltenen Zustand gewechselt ist, obwohl der Renderer keine Daten empfangen hat.</span><span class="sxs-lookup"><span data-stu-id="29268-137">This return code indicates that the filter has switched to the paused state, even though the renderer did not receive any data.</span></span>

<span data-ttu-id="29268-138">Wenn ein Filter anhält, lehnt er alle weiteren abgelieferten Beispiele ab.</span><span class="sxs-lookup"><span data-stu-id="29268-138">When a filter stops, it rejects any more samples delivered to it.</span></span> <span data-ttu-id="29268-139">Quell Filter beenden ihre streamingthreads, und andere Filter beenden alle Arbeitsthreads, die Sie möglicherweise erstellt haben.</span><span class="sxs-lookup"><span data-stu-id="29268-139">Source filters shut down their streaming threads, and other filters shut down any worker threads they may have created.</span></span> <span data-ttu-id="29268-140">PIN-Zuordnungen werden deaktiviert.</span><span class="sxs-lookup"><span data-stu-id="29268-140">Pins decommit their allocators.</span></span>

### <a name="state-transitions"></a><span data-ttu-id="29268-141">Statusübergänge</span><span class="sxs-lookup"><span data-stu-id="29268-141">State Transitions</span></span>

<span data-ttu-id="29268-142">Der Filter Graph-Manager führt alle Zustandsübergänge in der Upstream-Reihenfolge aus, beginnend mit dem Renderer und geht rückwärts zum Quell Filter zurück.</span><span class="sxs-lookup"><span data-stu-id="29268-142">The Filter Graph Manager carries out all state transitions in upstream order, starting from the renderer and working backward to the source filter.</span></span> <span data-ttu-id="29268-143">Diese Reihenfolge ist erforderlich, um zu verhindern, dass Beispiele gelöscht werden, und um zu verhindern, dass das Diagramm blockiert wird.</span><span class="sxs-lookup"><span data-stu-id="29268-143">This ordering is necessary to prevent samples from being dropped and to prevent the graph from deadlocking.</span></span> <span data-ttu-id="29268-144">Die wichtigsten Statusübergänge liegen zwischen angehalten und beendet:</span><span class="sxs-lookup"><span data-stu-id="29268-144">The most crucial state transitions are between paused and stopped:</span></span>

-   <span data-ttu-id="29268-145">Angehalten: da jeder Filter angehalten wird, wird er zum Empfangen von Beispielen vom nächsten Filter bereit.</span><span class="sxs-lookup"><span data-stu-id="29268-145">Stopped to paused: As each filter pauses, it becomes ready to receive samples from the next filter.</span></span> <span data-ttu-id="29268-146">Der Quell Filter ist der letzte, der angehalten werden soll.</span><span class="sxs-lookup"><span data-stu-id="29268-146">The source filter is the last to pause.</span></span> <span data-ttu-id="29268-147">Er erstellt den Streaminginhalt und beginnt mit der Übermittlung von Beispielen.</span><span class="sxs-lookup"><span data-stu-id="29268-147">It creates the streaming thread and begins delivering samples.</span></span> <span data-ttu-id="29268-148">Da alle downstreamfilter angehalten werden, lehnt der Filter keine Stichproben ab.</span><span class="sxs-lookup"><span data-stu-id="29268-148">Because all of the downstream filters are paused, no filter rejects any samples.</span></span> <span data-ttu-id="29268-149">Der Filter Graph-Manager schließt den Übergang erst ab, wenn jeder Renderer im Diagramm ein Beispiel erhalten hat (mit Ausnahme von Live Quellen, wie zuvor beschrieben).</span><span class="sxs-lookup"><span data-stu-id="29268-149">The Filter Graph Manager does not complete the transition until every renderer in the graph has received a sample (with the exception of live sources, as described earlier).</span></span>
-   <span data-ttu-id="29268-150">Angehalten an beendet: Wenn ein Filter angehalten wird, werden alle darin befindlichen Beispiele freigegeben, wodurch alle in [**GetBuffer**](/windows/desktop/api/Strmif/nf-strmif-imemallocator-getbuffer)wartenden upstreamfilter aufgehoben werden.</span><span class="sxs-lookup"><span data-stu-id="29268-150">Paused to stopped: When a filter stops, it releases any samples that it holds, which unblocks any upstream filters waiting in [**GetBuffer**](/windows/desktop/api/Strmif/nf-strmif-imemallocator-getbuffer).</span></span> <span data-ttu-id="29268-151">Wenn der Filter auf eine Ressource in der [**Receive**](/windows/desktop/api/Strmif/nf-strmif-imeminputpin-receive) -Methode wartet, wartet er nicht mehr und kehrt von **Receive** zurück, wodurch der aufrufende Filter aufgehoben wird.</span><span class="sxs-lookup"><span data-stu-id="29268-151">If the filter is waiting for a resource inside the [**Receive**](/windows/desktop/api/Strmif/nf-strmif-imeminputpin-receive) method, it stops waiting and returns from **Receive**, which unblocks the calling filter.</span></span> <span data-ttu-id="29268-152">Wenn der Filter Graph-Manager den nächsten upstreamfilter stoppt, wird dieser Filter daher weder in **GetBuffer** noch im **Empfangs** Vorgang blockiert, und er kann auf den Befehl "beenden" reagieren.</span><span class="sxs-lookup"><span data-stu-id="29268-152">Therefore, when the Filter Graph Manager stops the next upstream filter, that filter is not blocked in either **GetBuffer** or **Receive**, and can respond to the stop command.</span></span> <span data-ttu-id="29268-153">Der upstreamfilter liefert möglicherweise einige zusätzliche Stichproben, bevor er den Befehl "beenden" erhält, aber der downstreamfilter lehnt sie ab, weil er bereits beendet wurde.</span><span class="sxs-lookup"><span data-stu-id="29268-153">The upstream filter might deliver a few extra samples before it gets the stop command, but the downstream filter simply rejects them, because it already stopped.</span></span>

## <a name="related-topics"></a><span data-ttu-id="29268-154">Zugehörige Themen</span><span class="sxs-lookup"><span data-stu-id="29268-154">Related topics</span></span>

<dl> <dt>

[<span data-ttu-id="29268-155">Datenfluss im Filter Diagramm</span><span class="sxs-lookup"><span data-stu-id="29268-155">Data Flow in the Filter Graph</span></span>](data-flow-in-the-filter-graph.md)
</dt> </dl>

 

 



