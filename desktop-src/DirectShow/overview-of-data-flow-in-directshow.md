---
description: Übersicht über den Datenfluss in DirectShow
ms.assetid: a1b30592-5106-44f5-8ee0-577573670167
title: Übersicht über den Datenfluss in DirectShow
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: 5b5a34444991d6cba62026935f5ec2d7aa4eba77
ms.sourcegitcommit: a47bd86f517de76374e4fff33cfeb613eb259a7e
ms.translationtype: MT
ms.contentlocale: de-DE
ms.lasthandoff: 01/06/2021
ms.locfileid: "104482259"
---
# <a name="overview-of-data-flow-in-directshow"></a><span data-ttu-id="85f20-103">Übersicht über den Datenfluss in DirectShow</span><span class="sxs-lookup"><span data-stu-id="85f20-103">Overview of Data Flow in DirectShow</span></span>

<span data-ttu-id="85f20-104">In diesem Abschnitt erhalten Sie einen umfassenden Überblick über die Funktionsweise des Datenflusses in DirectShow.</span><span class="sxs-lookup"><span data-stu-id="85f20-104">This section gives a broad overview of how data flow works in DirectShow.</span></span> <span data-ttu-id="85f20-105">Details finden Sie in den anderen Abschnitten der Dokumentation.</span><span class="sxs-lookup"><span data-stu-id="85f20-105">Details can be found in other sections of the documentation.</span></span>

<span data-ttu-id="85f20-106">Daten werden in Puffern gespeichert, bei denen es sich um einfache Arrays von Bytes handelt.</span><span class="sxs-lookup"><span data-stu-id="85f20-106">Data is held in buffers, which are simply arrays of bytes.</span></span> <span data-ttu-id="85f20-107">Jeder Puffer wird von einem COM-Objekt umschließt, das als *Medien Beispiel* bezeichnet wird, das die [**imediasample**](/windows/desktop/api/Strmif/nn-strmif-imediasample) -Schnittstelle implementiert.</span><span class="sxs-lookup"><span data-stu-id="85f20-107">Each buffer is wrapped by a COM object called a *media sample*, which implements the [**IMediaSample**](/windows/desktop/api/Strmif/nn-strmif-imediasample) interface.</span></span> <span data-ttu-id="85f20-108">Beispiele werden von einem anderen Objekttyp erstellt, der als Zuweiser bezeichnet wird und die [**imemzuordcator**](/windows/desktop/api/Strmif/nn-strmif-imemallocator) -Schnittstelle implementiert.</span><span class="sxs-lookup"><span data-stu-id="85f20-108">Samples are created by another type of object, called an allocator, which implements the [**IMemAllocator**](/windows/desktop/api/Strmif/nn-strmif-imemallocator) interface.</span></span> <span data-ttu-id="85f20-109">Eine Zuweisung wird für jede Pin-Verbindung zugewiesen, obwohl zwei oder mehr Pin-Verbindungen dieselbe Zuweisung gemeinsam verwenden können.</span><span class="sxs-lookup"><span data-stu-id="85f20-109">An allocator is assigned for every pin connection, although two or more pin connections might share the same allocator.</span></span> <span data-ttu-id="85f20-110">Dieses Verfahren wird in der folgenden Abbildung veranschaulicht.</span><span class="sxs-lookup"><span data-stu-id="85f20-110">The following image illustrates this process.</span></span>

![Puffer, Beispiele und Zuweisungen](images/dataflow.png)

<span data-ttu-id="85f20-112">Jeder Zuweiser erstellt einen Pool mit Medien Beispielen und ordnet die Puffer für jede Stichprobe zu.</span><span class="sxs-lookup"><span data-stu-id="85f20-112">Each allocator creates a pool of media samples and allocates the buffers for each sample.</span></span> <span data-ttu-id="85f20-113">Wenn ein Filter einen Puffer mit Daten füllen muss, fordert er eine Stichprobe von der Zuweisung an, indem [**imemzuordcator:: GetBuffer**](/windows/desktop/api/Strmif/nf-strmif-imemallocator-getbuffer)aufgerufen wird.</span><span class="sxs-lookup"><span data-stu-id="85f20-113">Whenever a filter needs to fill a buffer with data, it requests a sample from the allocator by calling [**IMemAllocator::GetBuffer**](/windows/desktop/api/Strmif/nf-strmif-imemallocator-getbuffer).</span></span> <span data-ttu-id="85f20-114">Wenn die Zuweisung über Beispiele verfügt, die zurzeit nicht von einem anderen Filter verwendet werden, gibt die **GetBuffer** -Methode sofort einen Zeiger auf das Beispiel zurück.</span><span class="sxs-lookup"><span data-stu-id="85f20-114">If the allocator has any samples that are not currently in use by another filter, the **GetBuffer** method returns immediately with a pointer to the sample.</span></span> <span data-ttu-id="85f20-115">Wenn alle Beispiele der Zuweiser verwendet werden, wird die-Methode blockiert, bis eine Stichprobe verfügbar ist.</span><span class="sxs-lookup"><span data-stu-id="85f20-115">If all of the allocator's samples are in use, the method blocks until a sample becomes available.</span></span> <span data-ttu-id="85f20-116">Wenn die Methode ein Beispiel zurückgibt, fügt der Filterdaten in den Puffer ein, legt die entsprechenden Flags für das Beispiel fest (in der Regel mit einem Zeitstempel) und übermittelt das Beispiel Downstream.</span><span class="sxs-lookup"><span data-stu-id="85f20-116">When the method does return a sample, the filter puts data into the buffer, sets the appropriate flags on the sample (typically including a time stamp), and delivers the sample downstream.</span></span>

<span data-ttu-id="85f20-117">Wenn ein rendererfilter ein Beispiel empfängt, überprüft er den Zeitstempel und hält den Zeitstempel auf dem Beispiel, bis die Referenz Uhr des Filter Diagramms anzeigt, dass die Daten gerendert werden sollen.</span><span class="sxs-lookup"><span data-stu-id="85f20-117">When a renderer filter receives a sample, it checks the time stamp and holds onto the sample until the filter graph's reference clock indicates that the data should be rendered.</span></span> <span data-ttu-id="85f20-118">Nachdem der Filter die Daten gerendert hat, wird das Beispiel freigegeben.</span><span class="sxs-lookup"><span data-stu-id="85f20-118">After the filter renders the data, it releases the sample.</span></span> <span data-ttu-id="85f20-119">Das Beispiel wechselt nicht zurück in den Pool der zuordnerpools, bis der Verweis Zähler der Stichprobe NULL ist, was bedeutet, dass jeder Filter das Beispiel freigegeben hat.</span><span class="sxs-lookup"><span data-stu-id="85f20-119">The sample does not go back into the allocator's pool of samples until the sample's reference count is zero, meaning that every filter has released the sample.</span></span> <span data-ttu-id="85f20-120">Dieses Verfahren wird in der folgenden Abbildung veranschaulicht.</span><span class="sxs-lookup"><span data-stu-id="85f20-120">The following image illustrates this process.</span></span>

![Decoder, der auf ein Beispiel für ein kostenloses Medium wartet](images/dataflow2.png)

<span data-ttu-id="85f20-122">Der upstreamfilter kann vor dem Renderer ausgeführt werden, d. –., er kann Puffer schneller auffüllen, als er von dem Renderer verarbeitet wird.</span><span class="sxs-lookup"><span data-stu-id="85f20-122">The upstream filter might run ahead of the renderer — that is, it might fill buffers faster than the renderer consumes them.</span></span> <span data-ttu-id="85f20-123">Auch hier werden die Beispiele nicht frühzeitig gerendert, da der Renderer diese bis zur Präsentationszeit speichert.</span><span class="sxs-lookup"><span data-stu-id="85f20-123">Even so, samples do not get rendered early, because the renderer holds each until its presentation time.</span></span> <span data-ttu-id="85f20-124">Außerdem werden Puffer nicht versehentlich überschrieben, da **getSample** nur Beispiele zurückgibt, die andernfalls nicht verwendet werden.</span><span class="sxs-lookup"><span data-stu-id="85f20-124">Moreover, the upstream filter will not overwrite buffers accidentally, because **GetSample** only returns samples that are not otherwise in use.</span></span> <span data-ttu-id="85f20-125">Der Betrag, um den der upstreamfilter ausgeführt werden kann, richtet sich nach der Anzahl der Stichproben im Pool des zuordcators.</span><span class="sxs-lookup"><span data-stu-id="85f20-125">The amount by which the upstream filter can run ahead is determined by the number of samples in the allocator's pool.</span></span>

<span data-ttu-id="85f20-126">Das vorherige Diagramm zeigt nur eine Zuweisung, aber in der Regel sind mehrere Zuweisungen pro Stream vorhanden.</span><span class="sxs-lookup"><span data-stu-id="85f20-126">The previous diagram only shows one allocator, but typically there are several allocators per stream.</span></span> <span data-ttu-id="85f20-127">Wenn der Renderer ein Beispiel freigibt, kann er daher einen kaskadierenden Effekt haben.</span><span class="sxs-lookup"><span data-stu-id="85f20-127">Thus, when the renderer releases a sample, it can have a cascading effect.</span></span> <span data-ttu-id="85f20-128">Das folgende Diagramm zeigt eine Situation, in der ein Decoder einen komprimierten Videorahmen enthält, während er darauf wartet, dass der Renderer ein Beispiel freigibt.</span><span class="sxs-lookup"><span data-stu-id="85f20-128">The following diagram shows a situation where a decoder holds a compressed video frame while it waits for the renderer to release a sample.</span></span> <span data-ttu-id="85f20-129">Ein Parserfilter wartet auch darauf, dass der Decoder ein Beispiel freigibt.</span><span class="sxs-lookup"><span data-stu-id="85f20-129">A parser filter is also waiting for the decoder to release a sample.</span></span>

![zwei Filter, die auf Beispiele warten](images/dataflow3.png)

<span data-ttu-id="85f20-131">Wenn der Renderer das Beispiel freigibt, gibt der vom Decoder ausstehend aufrufende **GetBuffer** zurück.</span><span class="sxs-lookup"><span data-stu-id="85f20-131">When the renderer releases its sample, the decoder's pending call to **GetBuffer** returns.</span></span> <span data-ttu-id="85f20-132">Der Decoder kann dann den komprimierten Videorahmen decodieren und das aufgehaltener Beispiel freigeben. Dadurch wird die Blockierung des ausstehenden **GetBuffer** -Aufrufens des Parsers aufgehoben.</span><span class="sxs-lookup"><span data-stu-id="85f20-132">The decoder can then decode the compressed video frame and release the sample it was holding, thereby unblocking the parser's pending **GetBuffer** call.</span></span>

## <a name="related-topics"></a><span data-ttu-id="85f20-133">Zugehörige Themen</span><span class="sxs-lookup"><span data-stu-id="85f20-133">Related topics</span></span>

<dl> <dt>

[<span data-ttu-id="85f20-134">Datenfluss im Filter Diagramm</span><span class="sxs-lookup"><span data-stu-id="85f20-134">Data Flow in the Filter Graph</span></span>](data-flow-in-the-filter-graph.md)
</dt> </dl>

 

 



