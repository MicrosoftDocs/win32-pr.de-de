---
description: Kopieren und Zugreifen auf Ressourcen Daten (Direct3D 10)
ms.assetid: 34fd4d15-ee64-4acf-967d-a4afb6f26329
title: Kopieren und Zugreifen auf Ressourcen Daten (Direct3D 10)
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: 38bd075585ee3123e163075a50b06b53a77a214c
ms.sourcegitcommit: c7add10d695482e1ceb72d62b8a4ebd84ea050f7
ms.translationtype: MT
ms.contentlocale: de-DE
ms.lasthandoff: 01/07/2021
ms.locfileid: "103748520"
---
# <a name="copying-and-accessing-resource-data-direct3d-10"></a><span data-ttu-id="6d51a-103">Kopieren und Zugreifen auf Ressourcen Daten (Direct3D 10)</span><span class="sxs-lookup"><span data-stu-id="6d51a-103">Copying and Accessing Resource Data (Direct3D 10)</span></span>

<span data-ttu-id="6d51a-104">Es ist nicht mehr erforderlich, Ressourcen als in Videospeicher oder Systemspeicher zu erstellen.</span><span class="sxs-lookup"><span data-stu-id="6d51a-104">It is no longer necessary to think about resources as being created in either video memory or system memory.</span></span> <span data-ttu-id="6d51a-105">Oder, unabhängig davon, ob die Laufzeit den Arbeitsspeicher verwalten soll.</span><span class="sxs-lookup"><span data-stu-id="6d51a-105">Or whether or not the runtime should manage the memory.</span></span> <span data-ttu-id="6d51a-106">Dank der Architektur des neuen WDDM (Windows Display Driver Model) erstellen Anwendungen nun Direct3D 10 Ressourcen mit unterschiedlichen [**nutzungsflags**](/windows/desktop/api/D3D10/ne-d3d10-d3d10_usage) , um anzugeben, wie die Anwendung die Ressourcen Daten verwenden soll.</span><span class="sxs-lookup"><span data-stu-id="6d51a-106">Thanks to the architecture of the new WDDM (Windows Display Driver Model), applications now create Direct3D 10 resources with different [**usage**](/windows/desktop/api/D3D10/ne-d3d10-d3d10_usage) flags to indicate how the application intends on using the resource data.</span></span> <span data-ttu-id="6d51a-107">Das neue Treibermodell virtualisiert den von den Ressourcen genutzten Arbeitsspeicher. Anschließend wird der Betriebssystem-/Treiber-/arbeitsspeichermanager zum Platzieren von Ressourcen im leistungsfähigsten Speicherbereich verwendet, der mit der erwarteten Nutzung möglich ist.</span><span class="sxs-lookup"><span data-stu-id="6d51a-107">The new driver model virtualizes the memory used by resources; it then becomes the responsibility of the operating system/driver/memory manager to place resources in the most performant area of memory possible given the expected usage.</span></span>

<span data-ttu-id="6d51a-108">Der Standardfall ist, dass Ressourcen für die GPU verfügbar sind.</span><span class="sxs-lookup"><span data-stu-id="6d51a-108">The default case is for resources to be available to the GPU.</span></span> <span data-ttu-id="6d51a-109">Natürlich gibt es Zeiten, in denen die Ressourcen Daten für die CPU verfügbar sein müssen.</span><span class="sxs-lookup"><span data-stu-id="6d51a-109">Of course, having said that, there are times when the resource data needs to be available to the CPU.</span></span> <span data-ttu-id="6d51a-110">Beim Kopieren von Ressourcen Daten, sodass der entsprechende Prozessor ohne Beeinträchtigung der Leistung darauf zugreifen kann, müssen Sie wissen, wie die API-Methoden funktionieren.</span><span class="sxs-lookup"><span data-stu-id="6d51a-110">Copying resource data around so that the appropriate processor can access it without impacting performance requires some knowledge of how the API methods work.</span></span>

-   [<span data-ttu-id="6d51a-111">Kopieren von Ressourcen Daten</span><span class="sxs-lookup"><span data-stu-id="6d51a-111">Copying Resource Data</span></span>](#copying-and-accessing-resource-data-direct3d-10)
-   [<span data-ttu-id="6d51a-112">Zugreifen auf Ressourcen Daten</span><span class="sxs-lookup"><span data-stu-id="6d51a-112">Accessing Resource Data</span></span>](#copying-and-accessing-resource-data-direct3d-10)

## <a name="copying-resource-data"></a><span data-ttu-id="6d51a-113">Kopieren von Ressourcen Daten</span><span class="sxs-lookup"><span data-stu-id="6d51a-113">Copying Resource Data</span></span>

<span data-ttu-id="6d51a-114">Ressourcen werden im Arbeitsspeicher erstellt, wenn Direct3D einen Create-Befehl ausführt.</span><span class="sxs-lookup"><span data-stu-id="6d51a-114">Resources are created in memory when Direct3D executes a Create call.</span></span> <span data-ttu-id="6d51a-115">Sie können im Videospeicher, im Systemspeicher oder in einer beliebigen anderen Art von Arbeitsspeicher erstellt werden.</span><span class="sxs-lookup"><span data-stu-id="6d51a-115">They can be created in video memory, system memory, or any other kind of memory.</span></span> <span data-ttu-id="6d51a-116">Da das WDDM-Treibermodell diesen Arbeitsspeicher virtualisiert, müssen Anwendungen nicht mehr nachverfolgen, welche Art von Arbeitsspeicher Ressourcen in erstellt werden.</span><span class="sxs-lookup"><span data-stu-id="6d51a-116">Since WDDM driver model virtualizes this memory, applications no longer need to keep track of what kind of memory resources are created in.</span></span>

<span data-ttu-id="6d51a-117">Im Idealfall befinden sich alle Ressourcen im Videospeicher, sodass die GPU unmittelbaren Zugriff auf Sie haben kann.</span><span class="sxs-lookup"><span data-stu-id="6d51a-117">Ideally, all resources would be located in video memory so that the GPU can have immediate access to them.</span></span> <span data-ttu-id="6d51a-118">Allerdings ist es manchmal erforderlich, dass die CPU die Ressourcen Daten liest oder dass die GPU auf Ressourcen Daten zugreift, auf die die CPU geschrieben hat.</span><span class="sxs-lookup"><span data-stu-id="6d51a-118">However, it is sometimes necessary for the CPU to read the resource data or for the GPU to access resource data the CPU has written to.</span></span> <span data-ttu-id="6d51a-119">Direct3D 10 verarbeitet diese verschiedenen Szenarien, indem angefordert wird, dass die Anwendung eine Verwendung angibt, und bietet dann mehrere Methoden zum Kopieren von Ressourcen Daten bei Bedarf.</span><span class="sxs-lookup"><span data-stu-id="6d51a-119">Direct3D 10 handles these different scenarios by requesting the application specify a usage, and then offers several methods for copying resource data when necessary.</span></span>

<span data-ttu-id="6d51a-120">Abhängig davon, wie die Ressource erstellt wurde, ist es nicht immer möglich, direkt auf die zugrunde liegenden Daten zuzugreifen.</span><span class="sxs-lookup"><span data-stu-id="6d51a-120">Depending on how the resource was created, it is not always possible to directly access the underlying data.</span></span> <span data-ttu-id="6d51a-121">Dies kann bedeuten, dass die Ressourcen Daten aus der Quell Ressource in eine andere Ressource kopiert werden müssen, auf die der entsprechende Prozessor zugreifen kann.</span><span class="sxs-lookup"><span data-stu-id="6d51a-121">This may mean that the resource data must be copied from the source resource to another resource that is accessible by the appropriate processor.</span></span> <span data-ttu-id="6d51a-122">Im Hinblick auf Direct3D 10 können auf Standard Ressourcen direkt durch die GPU zugegriffen werden, und auf dynamische und stagingressourcen kann direkt über die CPU zugegriffen werden.</span><span class="sxs-lookup"><span data-stu-id="6d51a-122">In terms of Direct3D 10, default resources can be accessed directly by the GPU, dynamic and staging resources can be directly accessed by the CPU.</span></span>

<span data-ttu-id="6d51a-123">Nachdem eine Ressource erstellt wurde, kann Sie [**nicht mehr**](/windows/desktop/api/D3D10/ne-d3d10-d3d10_usage) geändert werden.</span><span class="sxs-lookup"><span data-stu-id="6d51a-123">Once a resource has been created, its [**usage**](/windows/desktop/api/D3D10/ne-d3d10-d3d10_usage) cannot be changed.</span></span> <span data-ttu-id="6d51a-124">Kopieren Sie stattdessen den Inhalt einer Ressource in eine andere Ressource, die mit einer anderen Verwendung erstellt wurde.</span><span class="sxs-lookup"><span data-stu-id="6d51a-124">Instead, copy the contents of one resource to another resource that was created with a different usage.</span></span> <span data-ttu-id="6d51a-125">Direct3D 10 stellt diese Funktionalität mit drei verschiedenen Methoden bereit.</span><span class="sxs-lookup"><span data-stu-id="6d51a-125">Direct3D 10 provides this functionality with three different methods.</span></span> <span data-ttu-id="6d51a-126">Die ersten beiden Methoden ( [**ID3D10Device:: copyresource**](/windows/desktop/api/D3D10/nf-d3d10-id3d10device-copyresource) und [**ID3D10Device:: copysubresourceregion**](/windows/desktop/api/D3D10/nf-d3d10-id3d10device-copysubresourceregion)) dienen zum Kopieren von Ressourcen Daten aus einer Ressource in eine andere.</span><span class="sxs-lookup"><span data-stu-id="6d51a-126">The first two methods( [**ID3D10Device::CopyResource**](/windows/desktop/api/D3D10/nf-d3d10-id3d10device-copyresource) and [**ID3D10Device::CopySubresourceRegion**](/windows/desktop/api/D3D10/nf-d3d10-id3d10device-copysubresourceregion)) are designed to copy resource data from one resource to another.</span></span> <span data-ttu-id="6d51a-127">Die dritte Methode ([**ID3D10Device:: updatesubresource**](/windows/desktop/api/D3D10/nf-d3d10-id3d10device-updatesubresource)) ist so konzipiert, dass Daten aus dem Arbeitsspeicher in eine Ressource kopiert werden.</span><span class="sxs-lookup"><span data-stu-id="6d51a-127">The third method ([**ID3D10Device::UpdateSubresource**](/windows/desktop/api/D3D10/nf-d3d10-id3d10device-updatesubresource)) is designed to copy data from memory to a resource.</span></span>

<span data-ttu-id="6d51a-128">Es gibt zwei Hauptarten von Ressourcen: mappable und Non-mappable.</span><span class="sxs-lookup"><span data-stu-id="6d51a-128">There are two main kinds of resources: mappable and non-mappable.</span></span> <span data-ttu-id="6d51a-129">Ressourcen, die mit dynamischer oder stagingverwendungen erstellt werden, sind mappable, während Ressourcen, die mit standardmäßigen oder unveränderlichen Verwendungen erstellt wurden, nicht mappbar sind.</span><span class="sxs-lookup"><span data-stu-id="6d51a-129">Resources created with dynamic or staging usages are mappable, while resources created with default or immutable usages are non-mappable.</span></span>

<span data-ttu-id="6d51a-130">Das Kopieren von Daten in nicht mappbare Ressourcen ist sehr schnell, da dies der häufigste Fall ist und für eine gute Leistung optimiert wurde.</span><span class="sxs-lookup"><span data-stu-id="6d51a-130">Copying data among non-mappable resources is very fast because this is the most common case and has been optimized to perform well.</span></span> <span data-ttu-id="6d51a-131">Da diese Ressourcen nicht direkt von der CPU zugänglich sind, werden Sie optimiert, sodass Sie von der GPU schnell bearbeitet werden können.</span><span class="sxs-lookup"><span data-stu-id="6d51a-131">Since these resources are not directly accessible by the CPU, they are optimized so that the GPU can manipulate them quickly.</span></span>

<span data-ttu-id="6d51a-132">Das Kopieren von Daten zwischen mappable-Ressourcen ist problematisch, da die Leistung von der Nutzung abhängig ist, mit der die Ressource erstellt wurde.</span><span class="sxs-lookup"><span data-stu-id="6d51a-132">Copying data among mappable resources is more problematic because the performance will depend on the usage the resource was created with.</span></span> <span data-ttu-id="6d51a-133">Beispielsweise kann die GPU eine dynamische Ressource recht schnell lesen, aber nicht in Sie schreiben, und die GPU kann die stagingressourcen nicht direkt lesen oder in diese schreiben.</span><span class="sxs-lookup"><span data-stu-id="6d51a-133">For example, the GPU can read a dynamic resource fairly quickly but cannot write to them, and the GPU cannot read or write to staging resources directly.</span></span>

<span data-ttu-id="6d51a-134">Anwendungen, die Daten aus einer Ressource mit der standardmäßigen Verwendung in eine Ressource mit stagingverwendung kopieren möchten (um der CPU das Lesen der Daten zu ermöglichen, d. h. das GPU-Lese Back Problem), müssen dies mit Bedacht tun.</span><span class="sxs-lookup"><span data-stu-id="6d51a-134">Applications that wish to copy data from a resource with default usage to a resource with staging usage (to allow the CPU to read the data -- i.e. the GPU readback problem) must do so with care.</span></span> <span data-ttu-id="6d51a-135">Weitere Informationen zu diesem letzten Fall finden Sie unter [zugreifen auf Ressourcen Daten](#copying-and-accessing-resource-data-direct3d-10) .</span><span class="sxs-lookup"><span data-stu-id="6d51a-135">See [Accessing Resource Data](#copying-and-accessing-resource-data-direct3d-10) for more details on this last case.</span></span>

## <a name="accessing-resource-data"></a><span data-ttu-id="6d51a-136">Zugreifen auf Ressourcen Daten</span><span class="sxs-lookup"><span data-stu-id="6d51a-136">Accessing Resource Data</span></span>

<span data-ttu-id="6d51a-137">Der Zugriff auf eine Ressource erfordert die Zuordnung der Ressource. die Zuordnung bedeutet im Wesentlichen, dass die Anwendung versucht, dem CPU-Zugriff auf den Arbeitsspeicher zu übergeben.</span><span class="sxs-lookup"><span data-stu-id="6d51a-137">Accessing a resource requires mapping the resource; mapping essentially means the application is trying to give the CPU access to memory.</span></span> <span data-ttu-id="6d51a-138">Der Prozess der Zuordnung einer Ressource, sodass die CPU auf den zugrunde liegenden Speicher zugreifen kann, kann zu Leistungs Engpässen führen. aus diesem Grund müssen Sie darauf achten, wie und wann diese Aufgabe durchgeführt werden soll.</span><span class="sxs-lookup"><span data-stu-id="6d51a-138">The process of mapping a resource so that the CPU can access the underlying memory can cause some performance bottlenecks and for this reason, care must be taken as to how and when to perform this task.</span></span>

<span data-ttu-id="6d51a-139">Die Leistung kann angehalten werden, wenn die Anwendung versucht, eine Ressource zu einem falschen Zeitpunkt zuzuordnen.</span><span class="sxs-lookup"><span data-stu-id="6d51a-139">Performance can grind to a halt if the application tries to map a resource at the wrong time.</span></span> <span data-ttu-id="6d51a-140">Wenn die Anwendung versucht, auf die Ergebnisse eines Vorgangs zuzugreifen, bevor dieser Vorgang abgeschlossen ist, tritt ein Pipeline-Stall ein.</span><span class="sxs-lookup"><span data-stu-id="6d51a-140">If the application tries to access the results of an operation before that operation is finished, a pipeline stall will occur.</span></span>

<span data-ttu-id="6d51a-141">Wenn Sie einen Zuordnungs Vorgang zum falschen Zeitpunkt durchführen, kann dies zu einem schwerwiegenden Leistungsabfall führen, indem die GPU und die CPU voneinander synchronisiert werden.</span><span class="sxs-lookup"><span data-stu-id="6d51a-141">Performing a map operation at the wrong time could potentially cause a severe drop in performance by forcing the GPU and the CPU to synchronize with each other.</span></span> <span data-ttu-id="6d51a-142">Diese Synchronisierung wird ausgeführt, wenn die Anwendung auf eine Ressource zugreifen möchte, bevor Sie von der GPU in eine Ressource kopiert werden kann, die die CPU zuordnen kann.</span><span class="sxs-lookup"><span data-stu-id="6d51a-142">This synchronization will occur if the application wants to access a resource before the GPU is finished copying it into a resource the CPU can map.</span></span>

<span data-ttu-id="6d51a-143">Die CPU kann nur aus Ressourcen lesen, die mit dem d3d10 Usage-Staging-Flag erstellt wurden \_ \_ .</span><span class="sxs-lookup"><span data-stu-id="6d51a-143">The CPU can only read from resources created with the D3D10\_USAGE\_STAGING flag.</span></span> <span data-ttu-id="6d51a-144">Da mit diesem Flag erstellte Ressourcen nicht als Ausgaben der Pipeline festgelegt werden können, müssen die Daten in eine Ressource kopiert werden, die mit dem Staging-Flag erstellt wurde, wenn die CPU die Daten in einer von der GPU generierten Ressource lesen möchte.</span><span class="sxs-lookup"><span data-stu-id="6d51a-144">Since resources created with this flag cannot be set as outputs of the pipeline, if the CPU wants to read the data in a resource generated by the GPU, the data must be copied to a resource created with the staging flag.</span></span> <span data-ttu-id="6d51a-145">Die Anwendung kann dies mithilfe der [**ID3D10Device:: copyresource**](/windows/desktop/api/D3D10/nf-d3d10-id3d10device-copyresource) -Methode oder der [**ID3D10Device:: copysubresourceregion**](/windows/desktop/api/D3D10/nf-d3d10-id3d10device-copysubresourceregion) -Methode durchführen, um den Inhalt einer Ressource in eine andere zu kopieren.</span><span class="sxs-lookup"><span data-stu-id="6d51a-145">The application may do this by using the [**ID3D10Device::CopyResource**](/windows/desktop/api/D3D10/nf-d3d10-id3d10device-copyresource) or [**ID3D10Device::CopySubresourceRegion**](/windows/desktop/api/D3D10/nf-d3d10-id3d10device-copysubresourceregion) methods to copy the contents of one resource to another.</span></span> <span data-ttu-id="6d51a-146">Die Anwendung kann dann durch Aufrufen der entsprechenden Map-Methode Zugriff auf diese Ressource erhalten.</span><span class="sxs-lookup"><span data-stu-id="6d51a-146">The application can then gain access to this resource by calling the appropriate Map method.</span></span> <span data-ttu-id="6d51a-147">Wenn der Zugriff auf die Ressource nicht mehr benötigt wird, sollte die Anwendung die entsprechende unmap-Methode aufrufen.</span><span class="sxs-lookup"><span data-stu-id="6d51a-147">When access to the resource is no longer needed, the application should then call the corresponding Unmap method.</span></span> <span data-ttu-id="6d51a-148">Beispiel: [**ID3D10Texture2D:: Map**](/windows/desktop/api/D3D10/nf-d3d10-id3d10texture2d-map) und [**ID3D10Texture2D:: unmap**](/windows/desktop/api/D3D10/nf-d3d10-id3d10texture2d-unmap).</span><span class="sxs-lookup"><span data-stu-id="6d51a-148">For example, [**ID3D10Texture2D::Map**](/windows/desktop/api/D3D10/nf-d3d10-id3d10texture2d-map) and [**ID3D10Texture2D::Unmap**](/windows/desktop/api/D3D10/nf-d3d10-id3d10texture2d-unmap).</span></span> <span data-ttu-id="6d51a-149">Die verschiedenen Map-Methoden geben abhängig von den eingabeflags bestimmte Werte zurück.</span><span class="sxs-lookup"><span data-stu-id="6d51a-149">The different Map methods return some specific values depending on the input flags.</span></span> <span data-ttu-id="6d51a-150">Weitere Informationen finden Sie im [**Abschnitt Karten Hinweise**](/windows/desktop/api/D3D10/nf-d3d10-id3d10texture1d-map) .</span><span class="sxs-lookup"><span data-stu-id="6d51a-150">See [**Map Remarks section**](/windows/desktop/api/D3D10/nf-d3d10-id3d10texture1d-map) for details.</span></span>

> [!Note]  
> <span data-ttu-id="6d51a-151">Wenn die Anwendung die Map-Methode aufruft, empfängt Sie einen Zeiger auf die Ressourcen Daten, auf die zugegriffen werden soll.</span><span class="sxs-lookup"><span data-stu-id="6d51a-151">When the application calls the Map method, it receives a pointer to the resource data to access.</span></span> <span data-ttu-id="6d51a-152">Die Laufzeit stellt sicher, dass der Zeiger abhängig von der [Funktionsebene](../direct3d11/overviews-direct3d-11-devices-downlevel-intro.md)über eine bestimmte Ausrichtung verfügt.</span><span class="sxs-lookup"><span data-stu-id="6d51a-152">The runtime ensures that the pointer has a specific alignment, depending on [feature level](../direct3d11/overviews-direct3d-11-devices-downlevel-intro.md).</span></span> <span data-ttu-id="6d51a-153">Für [**D3D- \_ Funktions \_ Ebene von \_ 10 \_ 0**](/windows/win32/api/d3dcommon/ne-d3dcommon-d3d_feature_level) und höher wird der Zeiger auf 16 Bytes ausgerichtet.</span><span class="sxs-lookup"><span data-stu-id="6d51a-153">For [**D3D\_FEATURE\_LEVEL\_10\_0**](/windows/win32/api/d3dcommon/ne-d3dcommon-d3d_feature_level) and higher, the pointer is aligned to 16 bytes.</span></span> <span data-ttu-id="6d51a-154">Für einen niedrigeren [**Wert als D3D \_ \_ Featureebene \_ 10 \_ 0**](/windows/win32/api/d3dcommon/ne-d3dcommon-d3d_feature_level)ist der Zeiger auf 4 Bytes ausgerichtet.</span><span class="sxs-lookup"><span data-stu-id="6d51a-154">For lower than [**D3D\_FEATURE\_LEVEL\_10\_0**](/windows/win32/api/d3dcommon/ne-d3dcommon-d3d_feature_level), the pointer is aligned to 4 bytes.</span></span> <span data-ttu-id="6d51a-155">Die 16-Byte-Ausrichtung ermöglicht es der Anwendung, [SSE](/previous-versions/visualstudio/visual-studio-2010/t467de55(v=vs.100))-optimierte Vorgänge für die Daten nativ auszuführen, ohne eine Neuausrichtung oder Kopie auszuführen.</span><span class="sxs-lookup"><span data-stu-id="6d51a-155">The 16-byte alignment allows the application to perform [SSE](/previous-versions/visualstudio/visual-studio-2010/t467de55(v=vs.100))-optimized operations on the data natively, without realignment or copy.</span></span>

 

### <a name="performance-considerations"></a><span data-ttu-id="6d51a-156">Überlegungen zur Leistung</span><span class="sxs-lookup"><span data-stu-id="6d51a-156">Performance Considerations</span></span>

<span data-ttu-id="6d51a-157">Es empfiehlt sich, einen PC als einen Computer zu betrachten, der als parallele Architektur mit zwei Haupttypen von Prozessoren ausgeführt wird: eine oder mehrere CPU-und mindestens eine GPU.</span><span class="sxs-lookup"><span data-stu-id="6d51a-157">It is best to think of a PC as a machine running as a parallel architecture with two main types of processors: one or more CPU's and one or more GPU's.</span></span> <span data-ttu-id="6d51a-158">Wie bei jeder parallelen Architektur wird die beste Leistung erzielt, wenn jeder Prozessor mit ausreichenden Aufgaben geplant wird, um zu verhindern, dass er in den Leerlauf versetzt wird, und wenn die Arbeit eines Prozessors nicht auf die Arbeit eines anderen Prozessors wartet.</span><span class="sxs-lookup"><span data-stu-id="6d51a-158">As in any parallel architecture, the best performance is achieved when each processor is scheduled with enough tasks to prevent it from going idle and when the work of one processor is not waiting on the work of another.</span></span>

<span data-ttu-id="6d51a-159">Das ungünstigste Szenario bei GPU-/CPU-Parallelität besteht darin, dass ein Prozessor gezwungen werden muss, auf die Ergebnisse der von einer anderen Aufgabe ausgeführten Arbeit zu warten.</span><span class="sxs-lookup"><span data-stu-id="6d51a-159">The worst-case scenario for GPU/CPU parallelism is the need to force one processor to wait for the results of work done by another.</span></span> <span data-ttu-id="6d51a-160">Direct3D 10 versucht, diese Kosten zu entfernen, indem die [**ID3D10Device:: copyresource**](/windows/desktop/api/D3D10/nf-d3d10-id3d10device-copyresource) -und [**ID3D10Device:: copysubresourceregion**](/windows/desktop/api/D3D10/nf-d3d10-id3d10device-copysubresourceregion) -Methoden asynchron gemacht werden. die Kopie wurde nicht notwendigerweise von dem Zeitpunkt ausgeführt, an dem die Methode zurückgegeben wird.</span><span class="sxs-lookup"><span data-stu-id="6d51a-160">Direct3D 10 tries to remove this cost by making the [**ID3D10Device::CopyResource**](/windows/desktop/api/D3D10/nf-d3d10-id3d10device-copyresource) and [**ID3D10Device::CopySubresourceRegion**](/windows/desktop/api/D3D10/nf-d3d10-id3d10device-copysubresourceregion) methods asynchronous; the copy has not necessarily executed by the time the method returns.</span></span> <span data-ttu-id="6d51a-161">Der Vorteil besteht darin, dass die Anwendung nicht die Leistungskosten für das eigentliche Kopieren der Daten abzahlt, bis die CPU auf die Daten zugreift. Dies ist der Fall, wenn Map aufgerufen wird.</span><span class="sxs-lookup"><span data-stu-id="6d51a-161">The benefit of this is that the application does not pay the performance cost of actually copying the data until the CPU accesses the data, which is when Map is called.</span></span> <span data-ttu-id="6d51a-162">Wenn die Map-Methode aufgerufen wird, nachdem die Daten tatsächlich kopiert wurden, tritt kein Leistungsverlust auf.</span><span class="sxs-lookup"><span data-stu-id="6d51a-162">If the Map method is called after the data has actually been copied, no performance loss occurs.</span></span> <span data-ttu-id="6d51a-163">Wenn andererseits die Map-Methode aufgerufen wird, bevor die Daten kopiert wurden, tritt ein Pipeline-Stall auf.</span><span class="sxs-lookup"><span data-stu-id="6d51a-163">On the other hand, if the Map method is called before the data has been copied, then a pipeline stall will occur.</span></span>

<span data-ttu-id="6d51a-164">Asynchrone Aufrufe in Direct3D 10 (bei denen es sich um die meisten Methoden und insbesondere renderingaufrufe handelt) werden in dem als Befehls Puffer bezeichneten Vorgang gespeichert.</span><span class="sxs-lookup"><span data-stu-id="6d51a-164">Asynchronous calls in Direct3D 10 (which are the vast majority of methods, and especially rendering calls) are stored in what is called a command buffer.</span></span> <span data-ttu-id="6d51a-165">Dieser Puffer ist für den Grafiktreiber intern und wird zum Batches von Aufrufen an die zugrunde liegende Hardware verwendet, sodass der kostspielige Wechsel vom Benutzermodus in den Kernel Modus in Microsoft Windows so selten wie möglich erfolgt.</span><span class="sxs-lookup"><span data-stu-id="6d51a-165">This buffer is internal to the graphics driver and is used to batch calls to the underlying hardware so that the costly switch from user mode to kernel mode in Microsoft Windows occurs as rarely as possible.</span></span>

<span data-ttu-id="6d51a-166">Der Befehls Puffer wird geleert, wodurch ein Benutzer-/kernelmodusschalter in einer von vier Situationen wie folgt verursacht wird.</span><span class="sxs-lookup"><span data-stu-id="6d51a-166">The command buffer is flushed, thus causing a user/kernel mode switch, in one of four situations, which are as follows.</span></span>

1.  <span data-ttu-id="6d51a-167">[**Present**](/windows/win32/api/dxgi/nf-dxgi-idxgiswapchain-present) wird aufgerufen.</span><span class="sxs-lookup"><span data-stu-id="6d51a-167">[**Present**](/windows/win32/api/dxgi/nf-dxgi-idxgiswapchain-present) is called.</span></span>
2.  <span data-ttu-id="6d51a-168">[**ID3D10Device:: Flush**](/windows/desktop/api/D3D10/nf-d3d10-id3d10device-flush) wird aufgerufen.</span><span class="sxs-lookup"><span data-stu-id="6d51a-168">[**ID3D10Device::Flush**](/windows/desktop/api/D3D10/nf-d3d10-id3d10device-flush) is called.</span></span>
3.  <span data-ttu-id="6d51a-169">Der Befehls Puffer ist voll. seine Größe ist dynamisch und wird vom Betriebs System und dem Grafiktreiber gesteuert.</span><span class="sxs-lookup"><span data-stu-id="6d51a-169">The command buffer is full; its size is dynamic and is controlled by the Operating System and the graphics driver.</span></span>
4.  <span data-ttu-id="6d51a-170">Die CPU erfordert Zugriff auf die Ergebnisse eines Befehls, der auf die Ausführung im Befehls Puffer wartet.</span><span class="sxs-lookup"><span data-stu-id="6d51a-170">The CPU requires access to the results of a command waiting to execute in the command buffer.</span></span>

<span data-ttu-id="6d51a-171">In den vier oben genannten Situationen ist die Zahl vier die wichtigste für die Leistung.</span><span class="sxs-lookup"><span data-stu-id="6d51a-171">Of the four situations above, number four is the most critical to performance.</span></span> <span data-ttu-id="6d51a-172">Wenn die Anwendung einen [**ID3D10Device:: copyresource**](/windows/desktop/api/D3D10/nf-d3d10-id3d10device-copyresource) -oder [**ID3D10Device:: copysubresourceregion**](/windows/desktop/api/D3D10/nf-d3d10-id3d10device-copysubresourceregion) -Befehl ausgibt, wird dieser Befehl im Befehls Puffer in die Warteschlange eingereiht.</span><span class="sxs-lookup"><span data-stu-id="6d51a-172">If the application issues a [**ID3D10Device::CopyResource**](/windows/desktop/api/D3D10/nf-d3d10-id3d10device-copyresource) or [**ID3D10Device::CopySubresourceRegion**](/windows/desktop/api/D3D10/nf-d3d10-id3d10device-copysubresourceregion) call, this call is queued in the command buffer.</span></span> <span data-ttu-id="6d51a-173">Wenn die Anwendung dann versucht, die stagingressource, die das Ziel des Kopier Aufrufens war, vor dem leeren des Befehls Puffers zuzuordnen, wird ein Pipeline-Stall ausgelöst, da nicht nur der Kopiermethoden Aufrufe ausgeführt werden muss, sondern alle anderen gepufferten Befehle im Befehls Puffer ebenfalls ausgeführt werden müssen.</span><span class="sxs-lookup"><span data-stu-id="6d51a-173">If the application then tries to map the staging resource that was the target of the copy call before the command buffer has been flushed, a pipeline stall will occur because not only does the Copy method call need to execute, but all other buffered commands in the command buffer must execute as well.</span></span> <span data-ttu-id="6d51a-174">Dies bewirkt, dass die GPU und CPU synchronisiert werden, da die CPU auf den Zugriff auf die stagingressource wartet, während die GPU den Befehls Puffer geleert und schließlich die Ressource abfüllt, die die CPU benötigt.</span><span class="sxs-lookup"><span data-stu-id="6d51a-174">This will cause the GPU and CPU to synchronize because the CPU will be waiting to access the staging resource while the GPU is emptying the command buffer and finally filling the resource the CPU needs.</span></span> <span data-ttu-id="6d51a-175">Nachdem die GPU die Kopie abgeschlossen hat, beginnt die CPU mit dem Zugriff auf die stagingressource. während dieser Zeit befindet sich die GPU jedoch im Leerlauf.</span><span class="sxs-lookup"><span data-stu-id="6d51a-175">Once the GPU finishes the copy, the CPU will begin accessing the staging resource, but during this time, the GPU will be sitting idle.</span></span>

<span data-ttu-id="6d51a-176">Wenn dies häufig zur Laufzeit erfolgt, wird die Leistung erheblich beeinträchtigt.</span><span class="sxs-lookup"><span data-stu-id="6d51a-176">Doing this frequently at runtime will severely degrade performance.</span></span> <span data-ttu-id="6d51a-177">Aus diesem Grund sollte die Zuordnung von mit der Standardverwendung erstellten Ressourcen mit Bedacht erfolgen.</span><span class="sxs-lookup"><span data-stu-id="6d51a-177">For that reason, mapping of resources created with default usage should be done with care.</span></span> <span data-ttu-id="6d51a-178">Die Anwendung muss lange genug warten, bis der Befehls Puffer geleert ist, und daher wird die Ausführung aller Befehle beendet, bevor versucht wird, die entsprechende stagingressource zuzuordnen.</span><span class="sxs-lookup"><span data-stu-id="6d51a-178">The application needs to wait long enough for the command buffer to be emptied and thus have all of those commands finish executing before it tries to map the corresponding staging resource.</span></span> <span data-ttu-id="6d51a-179">Wie lange sollte die Anwendung warten?</span><span class="sxs-lookup"><span data-stu-id="6d51a-179">How long should the application wait?</span></span> <span data-ttu-id="6d51a-180">Mindestens zwei Frames, da dadurch die Parallelität zwischen den CPU (s) und der GPU für eine maximale Nutzung aktiviert wird.</span><span class="sxs-lookup"><span data-stu-id="6d51a-180">At least two frames because this will enable parallelism between the CPU(s) and the GPU to be maximally leveraged.</span></span> <span data-ttu-id="6d51a-181">Die GPU funktioniert so, dass die GPU während der Verarbeitung von Frame N durch das Übermitteln von Aufrufen an den Befehls Puffer ausgelastet ist, dass die GPU mit dem Ausführen der Aufrufe aus dem vorherigen Frame, N-1, ausgelastet ist.</span><span class="sxs-lookup"><span data-stu-id="6d51a-181">The way the GPU works is that while the application is processing frame N by submitting calls to the command buffer, the GPU is busy executing the calls from the previous frame, N-1.</span></span>

<span data-ttu-id="6d51a-182">Wenn also eine Anwendung eine Ressource zuordnen möchte, die aus dem Videospeicher stammt und [**ID3D10Device:: copyresource**](/windows/desktop/api/D3D10/nf-d3d10-id3d10device-copyresource) oder [**ID3D10Device:: copysubresourceregion**](/windows/desktop/api/D3D10/nf-d3d10-id3d10device-copysubresourceregion) bei Frame n aufruft, beginnt dieser Aufruf tatsächlich mit der Ausführung bei Frame n + 1, wenn die Anwendung Aufrufe für den nächsten Frame übermittelt.</span><span class="sxs-lookup"><span data-stu-id="6d51a-182">So if an application wants to map a resource that originates in video memory and calls [**ID3D10Device::CopyResource**](/windows/desktop/api/D3D10/nf-d3d10-id3d10device-copyresource) or [**ID3D10Device::CopySubresourceRegion**](/windows/desktop/api/D3D10/nf-d3d10-id3d10device-copysubresourceregion) at frame N, this call will actually begin to execute at frame N+1, when the application is submitting calls for the next frame.</span></span> <span data-ttu-id="6d51a-183">Der Kopiervorgang sollte abgeschlossen sein, wenn die Anwendung den Frame "N + 2" verarbeitet.</span><span class="sxs-lookup"><span data-stu-id="6d51a-183">The copy should be finished when the application is processing frame N+2.</span></span>



<table>
<colgroup>
<col style="width: 50%" />
<col style="width: 50%" />
</colgroup>
<thead>
<tr class="header">
<th><span data-ttu-id="6d51a-184">Frame</span><span class="sxs-lookup"><span data-stu-id="6d51a-184">Frame</span></span></th>
<th><span data-ttu-id="6d51a-185">GPU-/CPU-Status</span><span class="sxs-lookup"><span data-stu-id="6d51a-185">GPU/CPU Status</span></span></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><span data-ttu-id="6d51a-186">N</span><span class="sxs-lookup"><span data-stu-id="6d51a-186">N</span></span></td>
<td><ul>
<li><span data-ttu-id="6d51a-187">"CPU" gibt Rendering-Aufrufe für aktuellen Frame aus.</span><span class="sxs-lookup"><span data-stu-id="6d51a-187">CPU issues render calls for current frame.</span></span></li>
</ul></td>
</tr>
<tr class="even">
<td><span data-ttu-id="6d51a-188">N + 1</span><span class="sxs-lookup"><span data-stu-id="6d51a-188">N+1</span></span></td>
<td><ul>
<li><span data-ttu-id="6d51a-189">GPU führt Aufrufe aus, die während des Frame N von der CPU gesendet werden</span><span class="sxs-lookup"><span data-stu-id="6d51a-189">GPU executing calls sent from CPU during frame N.</span></span></li>
<li><span data-ttu-id="6d51a-190">"CPU" gibt Rendering-Aufrufe für aktuellen Frame aus.</span><span class="sxs-lookup"><span data-stu-id="6d51a-190">CPU issues render calls for current frame.</span></span></li>
</ul></td>
</tr>
<tr class="odd">
<td><span data-ttu-id="6d51a-191">N + 2</span><span class="sxs-lookup"><span data-stu-id="6d51a-191">N+2</span></span></td>
<td><ul>
<li><span data-ttu-id="6d51a-192">Die GPU hat das Ausführen von Aufrufen von der CPU während Frame N abgeschlossen. die Ergebnisse sind bereit.</span><span class="sxs-lookup"><span data-stu-id="6d51a-192">GPU finished executing calls sent from CPU during frame N. Results ready.</span></span></li>
<li><span data-ttu-id="6d51a-193">GPU-Aufrufe, die von der CPU während des Frame N + 1 gesendet werden.</span><span class="sxs-lookup"><span data-stu-id="6d51a-193">GPU executing calls sent from CPU during frame N+1.</span></span></li>
<li><span data-ttu-id="6d51a-194">"CPU" gibt Rendering-Aufrufe für aktuellen Frame aus.</span><span class="sxs-lookup"><span data-stu-id="6d51a-194">CPU issues render calls for current frame.</span></span></li>
</ul></td>
</tr>
<tr class="even">
<td><span data-ttu-id="6d51a-195">N + 3</span><span class="sxs-lookup"><span data-stu-id="6d51a-195">N+3</span></span></td>
<td><ul>
<li><span data-ttu-id="6d51a-196">Die GPU hat das Ausführen von Aufrufen von der CPU während des Frame N + 1 abgeschlossen.</span><span class="sxs-lookup"><span data-stu-id="6d51a-196">GPU finished executing calls sent from CPU during frame N+1.</span></span> <span data-ttu-id="6d51a-197">Die Ergebnisse sind bereit.</span><span class="sxs-lookup"><span data-stu-id="6d51a-197">Results ready.</span></span></li>
<li><span data-ttu-id="6d51a-198">GPU führt Aufrufe aus, die während des Frames N + 2 von der CPU gesendet werden.</span><span class="sxs-lookup"><span data-stu-id="6d51a-198">GPU executing calls sent from CPU during frame N+2.</span></span></li>
<li><span data-ttu-id="6d51a-199">"CPU" gibt Rendering-Aufrufe für aktuellen Frame aus.</span><span class="sxs-lookup"><span data-stu-id="6d51a-199">CPU issues render calls for current frame.</span></span></li>
</ul></td>
</tr>
<tr class="odd">
<td><span data-ttu-id="6d51a-200">N + 4</span><span class="sxs-lookup"><span data-stu-id="6d51a-200">N+4</span></span></td>
<td><span data-ttu-id="6d51a-201">...</span><span class="sxs-lookup"><span data-stu-id="6d51a-201">...</span></span></td>
</tr>
</tbody>
</table>



 

## <a name="related-topics"></a><span data-ttu-id="6d51a-202">Zugehörige Themen</span><span class="sxs-lookup"><span data-stu-id="6d51a-202">Related topics</span></span>

<dl> <dt>

[<span data-ttu-id="6d51a-203">Ressourcen (Direct3D 10)</span><span class="sxs-lookup"><span data-stu-id="6d51a-203">Resources (Direct3D 10)</span></span>](d3d10-graphics-programming-guide-resources.md)
</dt> </dl>

 

 
