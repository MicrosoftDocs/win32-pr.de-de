---
description: Ein kritisches Abschnitts Objekt stellt eine Synchronisierung ähnlich der von einem Mutex-Objekt bereit, mit dem Unterschied, dass ein kritischer Abschnitt nur von den Threads eines einzelnen Prozesses verwendet werden kann.
ms.assetid: 2ec11a42-3d12-4d60-9dd7-dc38926d56e1
title: Kritische Abschnittsobjekte
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: cbcada1f2ddbc6d370445f36a3dbd51c5c9f54bf
ms.sourcegitcommit: 831e8f3db78ab820e1710cede244553c70e50500
ms.translationtype: MT
ms.contentlocale: de-DE
ms.lasthandoff: 01/08/2021
ms.locfileid: "106359187"
---
# <a name="critical-section-objects"></a><span data-ttu-id="aa79d-103">Kritische Abschnittsobjekte</span><span class="sxs-lookup"><span data-stu-id="aa79d-103">Critical Section Objects</span></span>

<span data-ttu-id="aa79d-104">Ein *kritisches Abschnitts Objekt* stellt eine Synchronisierung ähnlich der von einem Mutex-Objekt bereit, mit dem Unterschied, dass ein kritischer Abschnitt nur von den Threads eines einzelnen Prozesses verwendet werden kann.</span><span class="sxs-lookup"><span data-stu-id="aa79d-104">A *critical section object* provides synchronization similar to that provided by a mutex object, except that a critical section can be used only by the threads of a single process.</span></span> <span data-ttu-id="aa79d-105">Kritische Abschnitts Objekte können nicht Prozess übergreifend gemeinsam verwendet werden.</span><span class="sxs-lookup"><span data-stu-id="aa79d-105">Critical section objects cannot be shared across processes.</span></span>

<span data-ttu-id="aa79d-106">Ereignis-, Mutex-und Semaphor-Objekte können auch in einer Einzel Prozess Anwendung verwendet werden, aber wichtige Abschnitts Objekte bieten einen etwas schnelleren und effizienteren Mechanismus für die Synchronisierung gegenseitiger Ausschlüsse (eine prozessorspezifische Test-und Set-Anweisung).</span><span class="sxs-lookup"><span data-stu-id="aa79d-106">Event, mutex, and semaphore objects can also be used in a single-process application, but critical section objects provide a slightly faster, more efficient mechanism for mutual-exclusion synchronization (a processor-specific test and set instruction).</span></span> <span data-ttu-id="aa79d-107">Ebenso wie ein Mutex-Objekt kann ein kritisches Abschnitts Objekt jeweils nur jeweils einem Thread zugewiesen werden, wodurch es sinnvoll ist, eine freigegebene Ressource vor gleichzeitigem Zugriff zu schützen.</span><span class="sxs-lookup"><span data-stu-id="aa79d-107">Like a mutex object, a critical section object can be owned by only one thread at a time, which makes it useful for protecting a shared resource from simultaneous access.</span></span> <span data-ttu-id="aa79d-108">Anders als bei einem Mutex-Objekt gibt es keine Möglichkeit, zu erkennen, ob ein kritischer Abschnitt abgebrochen wurde.</span><span class="sxs-lookup"><span data-stu-id="aa79d-108">Unlike a mutex object, there is no way to tell whether a critical section has been abandoned.</span></span>

<span data-ttu-id="aa79d-109">Ab Windows Server 2003 mit Service Pack 1 (SP1) rufen Threads, die auf einen kritischen Abschnitt warten, den kritischen Abschnitt nicht auf der Grundlage von First-Come, First-Service ab.</span><span class="sxs-lookup"><span data-stu-id="aa79d-109">Starting with Windows Server 2003 with Service Pack 1 (SP1), threads waiting on a critical section do not acquire the critical section on a first-come, first-serve basis.</span></span> <span data-ttu-id="aa79d-110">Diese Änderung erhöht die Leistung für den meisten Code erheblich.</span><span class="sxs-lookup"><span data-stu-id="aa79d-110">This change increases performance significantly for most code.</span></span> <span data-ttu-id="aa79d-111">Einige Anwendungen sind jedoch von der FIFO-Reihenfolge (First in, First Out) abhängig und können bei aktuellen Versionen von Windows schlecht oder gar nicht verwendet werden (z. b. Anwendungen, die kritische Abschnitte als Raten Limits verwendet haben).</span><span class="sxs-lookup"><span data-stu-id="aa79d-111">However, some applications depend on first-in, first-out (FIFO) ordering and may perform poorly or not at all on current versions of Windows (for example, applications that have been using critical sections as a rate-limiter).</span></span> <span data-ttu-id="aa79d-112">Um sicherzustellen, dass Ihr Code weiterhin ordnungsgemäß funktioniert, müssen Sie möglicherweise eine weitere Synchronisierungs Ebene hinzufügen.</span><span class="sxs-lookup"><span data-stu-id="aa79d-112">To ensure that your code continues to work correctly, you may need to add an additional level of synchronization.</span></span> <span data-ttu-id="aa79d-113">Angenommen, Sie verfügen über einen Producer-Thread und einen Consumerthread, der ein kritisches Abschnitts Objekt verwendet, um Ihre Arbeit zu synchronisieren.</span><span class="sxs-lookup"><span data-stu-id="aa79d-113">For example, suppose you have a producer thread and a consumer thread that are using a critical section object to synchronize their work.</span></span> <span data-ttu-id="aa79d-114">Erstellen Sie zwei Ereignis Objekte, eines für jeden Thread, mit dem signalisiert wird, dass es für den anderen Thread bereit ist, fortzufahren.</span><span class="sxs-lookup"><span data-stu-id="aa79d-114">Create two event objects, one for each thread to use to signal that it is ready for the other thread to proceed.</span></span> <span data-ttu-id="aa79d-115">Der Consumer-Thread wartet, bis der Producer sein Ereignis signalisiert, bevor er in den kritischen Abschnitt wechselt, und der Producer-Thread wartet, bis der Consumer-Thread sein Ereignis signalisiert, bevor er in den kritischen Abschnitt wechselt.</span><span class="sxs-lookup"><span data-stu-id="aa79d-115">The consumer thread will wait for the producer to signal its event before entering the critical section, and the producer thread will wait for the consumer thread to signal its event before entering the critical section.</span></span> <span data-ttu-id="aa79d-116">Nachdem jeder Thread den kritischen Abschnitt verlassen hat, signalisiert er dem Ereignis, den anderen Thread freizugeben.</span><span class="sxs-lookup"><span data-stu-id="aa79d-116">After each thread leaves the critical section, it signals its event to release the other thread.</span></span>

<span data-ttu-id="aa79d-117">**Windows Server 2003 und Windows XP:** Threads, die auf einen kritischen Abschnitt warten, werden einer Warteschlange hinzugefügt. Sie werden aktiviert und erhalten im Allgemeinen den kritischen Abschnitt in der Reihenfolge, in der Sie der Warteschlange hinzugefügt wurden.</span><span class="sxs-lookup"><span data-stu-id="aa79d-117">**Windows Server 2003 and Windows XP:** Threads that are waiting on a critical section are added to a wait queue; they are woken and generally acquire the critical section in the order in which they were added to the queue.</span></span> <span data-ttu-id="aa79d-118">Wenn Threads dieser Warteschlange jedoch schnell genug hinzugefügt werden, kann die Leistung beeinträchtigt werden, da die Zeit zum Wecken der einzelnen wartenden Threads benötigt wird.</span><span class="sxs-lookup"><span data-stu-id="aa79d-118">However, if threads are added to this queue at a fast enough rate, performance can be degraded because of the time it takes to awaken each waiting thread.</span></span>

<span data-ttu-id="aa79d-119">Der Prozess ist dafür verantwortlich, den von einem kritischen Abschnitt verwendeten Arbeitsspeicher zuzuordnen.</span><span class="sxs-lookup"><span data-stu-id="aa79d-119">The process is responsible for allocating the memory used by a critical section.</span></span> <span data-ttu-id="aa79d-120">Dies erfolgt in der Regel durch einfaches Deklarieren einer Variablen vom Typ **Critical \_ section**.</span><span class="sxs-lookup"><span data-stu-id="aa79d-120">Typically, this is done by simply declaring a variable of type **CRITICAL\_SECTION**.</span></span> <span data-ttu-id="aa79d-121">Bevor der Thread des Prozesses ihn verwenden kann, initialisieren Sie den kritischen Abschnitt mithilfe der [**InitializeCriticalSection**](/windows/win32/api/synchapi/nf-synchapi-initializecriticalsection) -oder [**InitializeCriticalSectionAndSpinCount**](/windows/win32/api/synchapi/nf-synchapi-initializecriticalsectionandspincount) -Funktion.</span><span class="sxs-lookup"><span data-stu-id="aa79d-121">Before the threads of the process can use it, initialize the critical section by using the [**InitializeCriticalSection**](/windows/win32/api/synchapi/nf-synchapi-initializecriticalsection) or [**InitializeCriticalSectionAndSpinCount**](/windows/win32/api/synchapi/nf-synchapi-initializecriticalsectionandspincount) function.</span></span>

<span data-ttu-id="aa79d-122">Ein Thread verwendet die Funktion " [**EnterCriticalSection**](/windows/win32/api/synchapi/nf-synchapi-entercriticalsection) " oder " [**TryEnterCriticalSection**](/windows/win32/api/synchapi/nf-synchapi-tryentercriticalsection) ", um den Besitz eines kritischen Abschnitts anzufordern.</span><span class="sxs-lookup"><span data-stu-id="aa79d-122">A thread uses the [**EnterCriticalSection**](/windows/win32/api/synchapi/nf-synchapi-entercriticalsection) or [**TryEnterCriticalSection**](/windows/win32/api/synchapi/nf-synchapi-tryentercriticalsection) function to request ownership of a critical section.</span></span> <span data-ttu-id="aa79d-123">Er verwendet die [**LeaveCriticalSection**](/windows/win32/api/synchapi/nf-synchapi-leavecriticalsection) -Funktion, um den Besitz eines kritischen Abschnitts freizugeben.</span><span class="sxs-lookup"><span data-stu-id="aa79d-123">It uses the [**LeaveCriticalSection**](/windows/win32/api/synchapi/nf-synchapi-leavecriticalsection) function to release ownership of a critical section.</span></span> <span data-ttu-id="aa79d-124">Wenn das Objekt des kritischen Abschnitts momentan einem anderen Thread gehört, wartet " **EnterCriticalSection** " unbegrenzt auf den Besitz.</span><span class="sxs-lookup"><span data-stu-id="aa79d-124">If the critical section object is currently owned by another thread, **EnterCriticalSection** waits indefinitely for ownership.</span></span> <span data-ttu-id="aa79d-125">Wenn dagegen ein Mutex-Objekt für den gegenseitigen Ausschluss verwendet wird, akzeptieren die [Wait-Funktionen](wait-functions.md) ein angegebenes Timeout Intervall.</span><span class="sxs-lookup"><span data-stu-id="aa79d-125">In contrast, when a mutex object is used for mutual exclusion, the [wait functions](wait-functions.md) accept a specified time-out interval.</span></span> <span data-ttu-id="aa79d-126">Die **TryEnterCriticalSection** -Funktion versucht, einen kritischen Abschnitt einzugeben, ohne den aufrufenden Thread zu blockieren.</span><span class="sxs-lookup"><span data-stu-id="aa79d-126">The **TryEnterCriticalSection** function attempts to enter a critical section without blocking the calling thread.</span></span>

<span data-ttu-id="aa79d-127">Wenn ein Thread im Besitz eines kritischen Abschnitts ist, kann er zusätzliche Aufrufe an " [**EnterCriticalSection**](/windows/win32/api/synchapi/nf-synchapi-entercriticalsection) " oder " [**TryEnterCriticalSection**](/windows/win32/api/synchapi/nf-synchapi-tryentercriticalsection) " durchführen, ohne die Ausführung zu blockieren.</span><span class="sxs-lookup"><span data-stu-id="aa79d-127">When a thread owns a critical section, it can make additional calls to [**EnterCriticalSection**](/windows/win32/api/synchapi/nf-synchapi-entercriticalsection) or [**TryEnterCriticalSection**](/windows/win32/api/synchapi/nf-synchapi-tryentercriticalsection) without blocking its execution.</span></span> <span data-ttu-id="aa79d-128">Dadurch wird verhindert, dass ein Thread sich selbst blockiert, während er auf einen kritischen Abschnitt wartet, den er bereits besitzt.</span><span class="sxs-lookup"><span data-stu-id="aa79d-128">This prevents a thread from deadlocking itself while waiting for a critical section that it already owns.</span></span> <span data-ttu-id="aa79d-129">Um den Besitz freizugeben, muss der Thread [**LeaveCriticalSection**](/windows/win32/api/synchapi/nf-synchapi-leavecriticalsection) einmal für jedes Mal aufgerufen werden, wenn er in den kritischen Abschnitt eingetreten ist.</span><span class="sxs-lookup"><span data-stu-id="aa79d-129">To release its ownership, the thread must call [**LeaveCriticalSection**](/windows/win32/api/synchapi/nf-synchapi-leavecriticalsection) one time for each time that it entered the critical section.</span></span> <span data-ttu-id="aa79d-130">Es gibt keine Garantie für die Reihenfolge, in der wartende Threads den Besitz des kritischen Abschnitts erhalten.</span><span class="sxs-lookup"><span data-stu-id="aa79d-130">There is no guarantee about the order in which waiting threads will acquire ownership of the critical section.</span></span>

<span data-ttu-id="aa79d-131">Ein Thread verwendet die [**InitializeCriticalSectionAndSpinCount**](/windows/win32/api/synchapi/nf-synchapi-initializecriticalsectionandspincount) -Funktion oder die [**setcriticalsectionspincount**](/windows/win32/api/synchapi/nf-synchapi-setcriticalsectionspincount) -Funktion, um eine Spin-Anzahl für das kritische Abschnitts Objekt anzugeben.</span><span class="sxs-lookup"><span data-stu-id="aa79d-131">A thread uses the [**InitializeCriticalSectionAndSpinCount**](/windows/win32/api/synchapi/nf-synchapi-initializecriticalsectionandspincount) or [**SetCriticalSectionSpinCount**](/windows/win32/api/synchapi/nf-synchapi-setcriticalsectionspincount) function to specify a spin count for the critical section object.</span></span> <span data-ttu-id="aa79d-132">Wenn ein Thread versucht, einen wichtigen, gesperrten Abschnitt abzurufen, wechselt der Thread in eine Schleife, prüft, ob die Sperre freigegeben wurde, und wenn die Sperre nicht freigegeben wird, wechselt der Thread in den Standbymodus.</span><span class="sxs-lookup"><span data-stu-id="aa79d-132">Spinning means that when a thread tries to acquire a critical section that is locked, the thread enters a loop, checks to see if the lock is released, and if the lock is not released, the thread goes to sleep.</span></span> <span data-ttu-id="aa79d-133">Auf Systemen mit einem Prozessor wird die Spin-Anzahl ignoriert, und der kritische Abschnitt Spin count wird auf 0 (null) festgelegt.</span><span class="sxs-lookup"><span data-stu-id="aa79d-133">On single-processor systems, the spin count is ignored and the critical section spin count is set to 0 (zero).</span></span> <span data-ttu-id="aa79d-134">Wenn der kritische Abschnitt auf Multiprozessorsystemen nicht verfügbar ist, ruft der aufrufende Thread *dwSpinCount* -Zeiten auf, bevor er einen Warte Vorgang für ein Semaphor ausführt, das dem kritischen Abschnitt zugeordnet ist.</span><span class="sxs-lookup"><span data-stu-id="aa79d-134">On multiprocessor systems, if the critical section is unavailable, the calling thread spins *dwSpinCount* times before performing a wait operation on a semaphore that is associated with the critical section.</span></span> <span data-ttu-id="aa79d-135">Wenn der kritische Abschnitt während des drehvorgangs frei wird, vermeidet der aufrufenden Thread den warte Vorgang.</span><span class="sxs-lookup"><span data-stu-id="aa79d-135">If the critical section becomes free during the spin operation, the calling thread avoids the wait operation.</span></span>

<span data-ttu-id="aa79d-136">Jeder Thread des Prozesses kann die [**DeleteCriticalSection**](/windows/win32/api/synchapi/nf-synchapi-deletecriticalsection) -Funktion verwenden, um die Systemressourcen freizugeben, die beim Initialisieren des kritischen Abschnitts Objekts zugeordnet werden.</span><span class="sxs-lookup"><span data-stu-id="aa79d-136">Any thread of the process can use the [**DeleteCriticalSection**](/windows/win32/api/synchapi/nf-synchapi-deletecriticalsection) function to release the system resources that are allocated when the critical section object is initialized.</span></span> <span data-ttu-id="aa79d-137">Nachdem diese Funktion aufgerufen wurde, kann das Objekt für den kritischen Abschnitt nicht für die Synchronisierung verwendet werden.</span><span class="sxs-lookup"><span data-stu-id="aa79d-137">After this function is called, the critical section object cannot be used for synchronization.</span></span>

<span data-ttu-id="aa79d-138">Wenn ein Objekt im Besitz eines kritischen Abschnitts ist, sind die Threads, die auf den Besitz in einem " [**EnterCriticalSection**](/windows/win32/api/synchapi/nf-synchapi-entercriticalsection)"-Befehl warten, nur betroffen.</span><span class="sxs-lookup"><span data-stu-id="aa79d-138">When a critical section object is owned, the only other threads affected are the threads that are waiting for ownership in a call to [**EnterCriticalSection**](/windows/win32/api/synchapi/nf-synchapi-entercriticalsection).</span></span> <span data-ttu-id="aa79d-139">Threads, die nicht warten, können weiterhin ausgeführt werden.</span><span class="sxs-lookup"><span data-stu-id="aa79d-139">Threads that are not waiting are free to continue running.</span></span>

## <a name="related-topics"></a><span data-ttu-id="aa79d-140">Zugehörige Themen</span><span class="sxs-lookup"><span data-stu-id="aa79d-140">Related topics</span></span>

<dl> <dt>

[<span data-ttu-id="aa79d-141">Mutex-Objekte</span><span class="sxs-lookup"><span data-stu-id="aa79d-141">Mutex Objects</span></span>](mutex-objects.md)
</dt> <dt>

[<span data-ttu-id="aa79d-142">Verwenden von kritischen Abschnitts Objekten</span><span class="sxs-lookup"><span data-stu-id="aa79d-142">Using Critical Section Objects</span></span>](using-critical-section-objects.md)
</dt> </dl>

 

 
