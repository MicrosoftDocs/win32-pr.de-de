---
description: Bei einem asynchronen Prozedur Aufruf(APC) handelt es sich um eine Funktion, die asynchron im Kontext eines bestimmten Threads ausgeführt wird.
ms.assetid: 0197d78e-a4dc-414b-88ba-c5ec5f2ed614
title: Asynchrone Prozedur Aufrufe
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: dd95e9afd663e2a462335b3c47bfe99462b449e7
ms.sourcegitcommit: 831e8f3db78ab820e1710cede244553c70e50500
ms.translationtype: MT
ms.contentlocale: de-DE
ms.lasthandoff: 01/08/2021
ms.locfileid: "103960247"
---
# <a name="asynchronous-procedure-calls"></a><span data-ttu-id="f2ae4-103">Asynchrone Prozedur Aufrufe</span><span class="sxs-lookup"><span data-stu-id="f2ae4-103">Asynchronous Procedure Calls</span></span>

<span data-ttu-id="f2ae4-104">Bei einem *asynchronen Prozedur Aufruf(* APC) handelt es sich um eine Funktion, die asynchron im Kontext eines bestimmten Threads ausgeführt wird.</span><span class="sxs-lookup"><span data-stu-id="f2ae4-104">An *asynchronous procedure call* (APC) is a function that executes asynchronously in the context of a particular thread.</span></span> <span data-ttu-id="f2ae4-105">Wenn ein APC in die Warteschlange eines Threads eingereiht wird, gibt das System einen Software unterbrechungs Fehler aus.</span><span class="sxs-lookup"><span data-stu-id="f2ae4-105">When an APC is queued to a thread, the system issues a software interrupt.</span></span> <span data-ttu-id="f2ae4-106">Wenn der Thread das nächste Mal geplant wird, wird die APC-Funktion ausgeführt.</span><span class="sxs-lookup"><span data-stu-id="f2ae4-106">The next time the thread is scheduled, it will run the APC function.</span></span> <span data-ttu-id="f2ae4-107">Ein vom System generiertes APC wird als *kernelmodusapc* bezeichnet.</span><span class="sxs-lookup"><span data-stu-id="f2ae4-107">An APC generated by the system is called a *kernel-mode APC*.</span></span> <span data-ttu-id="f2ae4-108">Ein APC, das von einer Anwendung generiert wird, wird als *APC im Benutzermodus* bezeichnet.</span><span class="sxs-lookup"><span data-stu-id="f2ae4-108">An APC generated by an application is called a *user-mode APC*.</span></span> <span data-ttu-id="f2ae4-109">Ein Thread muss sich in einem wartungstabellenzustand befinden, um ein APC im Benutzermodus auszuführen.</span><span class="sxs-lookup"><span data-stu-id="f2ae4-109">A thread must be in an alertable state to run a user-mode APC.</span></span>

<span data-ttu-id="f2ae4-110">Jeder Thread verfügt über eine eigene APC-Warteschlange.</span><span class="sxs-lookup"><span data-stu-id="f2ae4-110">Each thread has its own APC queue.</span></span> <span data-ttu-id="f2ae4-111">Eine Anwendung fügt eine APC in eine Warteschlange ein, indem Sie die [**queueuserapc**](/windows/win32/api/processthreadsapi/nf-processthreadsapi-queueuserapc) -Funktion aufrufen.</span><span class="sxs-lookup"><span data-stu-id="f2ae4-111">An application queues an APC to a thread by calling the [**QueueUserAPC**](/windows/win32/api/processthreadsapi/nf-processthreadsapi-queueuserapc) function.</span></span> <span data-ttu-id="f2ae4-112">Der aufrufende Thread gibt die Adresse einer APC-Funktion im Aufruf von **queueuserapc** an.</span><span class="sxs-lookup"><span data-stu-id="f2ae4-112">The calling thread specifies the address of an APC function in the call to **QueueUserAPC**.</span></span> <span data-ttu-id="f2ae4-113">Die Warteschlange eines APC ist eine Anforderung, dass der Thread die APC-Funktion aufruft.</span><span class="sxs-lookup"><span data-stu-id="f2ae4-113">The queuing of an APC is a request for the thread to call the APC function.</span></span>

<span data-ttu-id="f2ae4-114">Wenn ein APC im Benutzermodus in die Warteschlange eingereiht wird, wird der Thread, in der er in die Warteschlange eingereiht wird, nicht so weitergeleitet, dass die APC-Funktion aufgerufen wird</span><span class="sxs-lookup"><span data-stu-id="f2ae4-114">When a user-mode APC is queued, the thread to which it is queued is not directed to call the APC function unless it is in an alertable state.</span></span> <span data-ttu-id="f2ae4-115">Ein Thread wechselt in einen mindestwarnzeit-Zustand, wenn er die Funktion " [**sleepex**](/windows/win32/api/synchapi/nf-synchapi-sleepex)", " [**signalobjectandwait**](/windows/win32/api/synchapi/nf-synchapi-signalobjectandwait)", " [**MsgWaitForMultipleObjectsEx**](/windows/desktop/api/Winuser/nf-winuser-msgwaitformultipleobjectsex)", " [**WaitForMultipleObjectsEx**](/windows/win32/api/winuser/nf-winuser-msgwaitformultipleobjectsex)" oder " [**WaitForSingleObjectEx**](/windows/win32/api/synchapi/nf-synchapi-waitforsingleobjectex) " aufruft.</span><span class="sxs-lookup"><span data-stu-id="f2ae4-115">A thread enters an alertable state when it calls the [**SleepEx**](/windows/win32/api/synchapi/nf-synchapi-sleepex), [**SignalObjectAndWait**](/windows/win32/api/synchapi/nf-synchapi-signalobjectandwait), [**MsgWaitForMultipleObjectsEx**](/windows/desktop/api/Winuser/nf-winuser-msgwaitformultipleobjectsex), [**WaitForMultipleObjectsEx**](/windows/win32/api/winuser/nf-winuser-msgwaitformultipleobjectsex), or [**WaitForSingleObjectEx**](/windows/win32/api/synchapi/nf-synchapi-waitforsingleobjectex) function.</span></span> <span data-ttu-id="f2ae4-116">Wenn der Warte Vorgang erfüllt ist, bevor das APC in die Warteschlange eingereiht wird, befindet sich der Thread nicht mehr in einem Warteschlangen-Wartestatus, sodass die APC-Funktion nicht ausgeführt wird.</span><span class="sxs-lookup"><span data-stu-id="f2ae4-116">If the wait is satisfied before the APC is queued, the thread is no longer in an alertable wait state so the APC function will not be executed.</span></span> <span data-ttu-id="f2ae4-117">Das APC wird jedoch immer noch in die Warteschlange eingereiht, sodass die APC-Funktion ausgeführt wird, wenn der Thread eine andere Warteschlangen-wait-Funktion aufruft.</span><span class="sxs-lookup"><span data-stu-id="f2ae4-117">However, the APC is still queued, so the APC function will be executed when the thread calls another alertable wait function.</span></span>

<span data-ttu-id="f2ae4-118">Die Funktionen "read [**fileex**](/windows/win32/api/fileapi/nf-fileapi-readfileex)", " [**setwaitabletimer**](/windows/win32/api/synchapi/nf-synchapi-setwaitabletimer)", " [**setwaitabletimerex**](/windows/win32/api/synchapi/nf-synchapi-setwaitabletimerex)" und " [**Write fileex**](/windows/win32/api/fileapi/nf-fileapi-writefileex) " werden mithilfe eines APC als Rückrufmechanismus für Abschluss Benachrichtigungen implementiert.</span><span class="sxs-lookup"><span data-stu-id="f2ae4-118">The [**ReadFileEx**](/windows/win32/api/fileapi/nf-fileapi-readfileex), [**SetWaitableTimer**](/windows/win32/api/synchapi/nf-synchapi-setwaitabletimer), [**SetWaitableTimerEx**](/windows/win32/api/synchapi/nf-synchapi-setwaitabletimerex), and [**WriteFileEx**](/windows/win32/api/fileapi/nf-fileapi-writefileex) functions are implemented using an APC as the completion notification callback mechanism.</span></span>

<span data-ttu-id="f2ae4-119">Wenn Sie einen [Thread Pool](../procthread/thread-pools.md)verwenden, beachten Sie, dass APCs nicht ebenso wie andere Signalmechanismen funktionieren, da das System die Lebensdauer von Threads im Thread Pool steuert. Daher ist es möglich, dass ein Thread beendet wird, bevor die Benachrichtigung übermittelt wird.</span><span class="sxs-lookup"><span data-stu-id="f2ae4-119">If you are using a [thread pool](../procthread/thread-pools.md), note that APCs do not work as well as other signaling mechanisms because the system controls the lifetime of thread pool threads, so it is possible for a thread to be terminated before the notification is delivered.</span></span> <span data-ttu-id="f2ae4-120">Verwenden Sie anstelle eines APC-basierten Signalisierungs Mechanismus, wie z. b. den *pfncompletionroutine* -Parameter von [**setwaitabletimer**](/windows/win32/api/synchapi/nf-synchapi-setwaitabletimer) oder [**setwaitabletimerex**](/windows/win32/api/synchapi/nf-synchapi-setwaitabletimerex), ein Objekt, das für [](/windows/win32/api/threadpoolapiset/nf-threadpoolapiset-createthreadpooltimer)die Wiederverwendbarkeit verwendet wurde</span><span class="sxs-lookup"><span data-stu-id="f2ae4-120">Instead of using an APC-based signaling mechanism such as the *pfnCompletionRoutine* parameter of [**SetWaitableTimer**](/windows/win32/api/synchapi/nf-synchapi-setwaitabletimer) or [**SetWaitableTimerEx**](/windows/win32/api/synchapi/nf-synchapi-setwaitabletimerex), use a waitable object such as a timer created with [**CreateThreadpoolTimer**](/windows/win32/api/threadpoolapiset/nf-threadpoolapiset-createthreadpooltimer).</span></span> <span data-ttu-id="f2ae4-121">Verwenden Sie für die e/a-Vorgänge ein e/a-Abschluss Objekt, das mit " [**kreatethcdpoolio**](/windows/win32/api/threadpoolapiset/nf-threadpoolapiset-createthreadpoolio) " erstellt wurde, oder eine auf *hevent* basierende [**über**](/windows/win32/api/minwinbase/ns-minwinbase-overlapped) Lapp Ende Struktur, wobei das Ereignis an die Funktion " [**SetThreadpoolWait**](/windows/win32/api/threadpoolapiset/nf-threadpoolapiset-setthreadpoolwait) " übergeben werden kann.</span><span class="sxs-lookup"><span data-stu-id="f2ae4-121">For I/O, use an I/O completion object created with [**CreateThreadpoolIo**](/windows/win32/api/threadpoolapiset/nf-threadpoolapiset-createthreadpoolio) or an *hEvent*-based [**OVERLAPPED**](/windows/win32/api/minwinbase/ns-minwinbase-overlapped) structure where the event can be passed to the [**SetThreadpoolWait**](/windows/win32/api/threadpoolapiset/nf-threadpoolapiset-setthreadpoolwait) function.</span></span>

## <a name="synchronization-internals"></a><span data-ttu-id="f2ae4-122">Synchronisierungs internale</span><span class="sxs-lookup"><span data-stu-id="f2ae4-122">Synchronization Internals</span></span>

<span data-ttu-id="f2ae4-123">Wenn eine e/a-Anforderung ausgegeben wird, wird eine Struktur zugeordnet, um die Anforderung darzustellen.</span><span class="sxs-lookup"><span data-stu-id="f2ae4-123">When an I/O request is issued, a structure is allocated to represent the request.</span></span> <span data-ttu-id="f2ae4-124">Diese Struktur wird als e/a-Anforderungspaket bezeichnet.</span><span class="sxs-lookup"><span data-stu-id="f2ae4-124">This structure is called an I/O request packet (IRP).</span></span> <span data-ttu-id="f2ae4-125">Bei synchronen e/a-Vorgängen erstellt der Thread das unp, sendet es an den Geräte Stapel und wartet im Kernel, bis der unp-Vorgang beendet ist.</span><span class="sxs-lookup"><span data-stu-id="f2ae4-125">With synchronous I/O, the thread builds the IRP, sends it to the device stack, and waits in the kernel for the IRP to complete.</span></span> <span data-ttu-id="f2ae4-126">Bei der asynchronen e/a erstellt der Thread das unp und sendet es an den Geräte Stapel.</span><span class="sxs-lookup"><span data-stu-id="f2ae4-126">With asynchronous I/O, the thread builds the IRP and sends it to the device stack.</span></span> <span data-ttu-id="f2ae4-127">Der Stapel kann das unp sofort beenden, oder er gibt möglicherweise einen ausstehenden Status zurück, der angibt, dass die Anforderung ausgeführt wird.</span><span class="sxs-lookup"><span data-stu-id="f2ae4-127">The stack might complete the IRP immediately, or it might return a pending status indicating that the request is in progress.</span></span> <span data-ttu-id="f2ae4-128">Wenn dies der Fall ist, ist das unp noch dem Thread zugeordnet, sodass es abgebrochen wird, wenn der Thread beendet wird oder eine Funktion wie [**CancelIo**](/windows/win32/api/ioapiset/nf-ioapiset-cancelio)aufruft.</span><span class="sxs-lookup"><span data-stu-id="f2ae4-128">When this happens, the IRP is still associated with the thread, so it will be canceled if the thread terminates or calls a function such as [**CancelIo**](/windows/win32/api/ioapiset/nf-ioapiset-cancelio).</span></span> <span data-ttu-id="f2ae4-129">In der Zwischenzeit kann der Thread weiterhin andere Aufgaben durchführen, während der Geräte Stapel die Verarbeitung von "unp" fortsetzt.</span><span class="sxs-lookup"><span data-stu-id="f2ae4-129">In the meantime, the thread can continue to perform other tasks while the device stack continues to process the IRP.</span></span>

<span data-ttu-id="f2ae4-130">Es gibt mehrere Möglichkeiten, wie das System angeben kann, dass das unp abgeschlossen wurde:</span><span class="sxs-lookup"><span data-stu-id="f2ae4-130">There are several ways that the system can indicate that the IRP has completed:</span></span>

-   <span data-ttu-id="f2ae4-131">Aktualisieren Sie die überlappende Struktur durch das Ergebnis des Vorgangs, damit der Thread Abfragen kann, um zu bestimmen, ob der Vorgang abgeschlossen wurde.</span><span class="sxs-lookup"><span data-stu-id="f2ae4-131">Update the overlapped structure with the result of the operation so the thread can poll to determine whether the operation has completed.</span></span>
-   <span data-ttu-id="f2ae4-132">Signalisieren Sie das Ereignis in der überlappenden Struktur, sodass ein Thread für das Ereignis synchronisiert und nach Abschluss des Vorgangs erneut aktiviert werden kann.</span><span class="sxs-lookup"><span data-stu-id="f2ae4-132">Signal the event in the overlapped structure so a thread can synchronize on the event and be woken when the operation completes.</span></span>
-   <span data-ttu-id="f2ae4-133">Fügen Sie das Gerät in die Warteschlange des ausstehenden APC-Threads ein, damit der Thread die APC-Routine ausführt, wenn er in einen warteschlangenwartestatus wechselt und vom warte Vorgang mit einem Status zurückkehrt, der angibt, dass eine oder mehrere APC-Routinen ausgeführt wurden.</span><span class="sxs-lookup"><span data-stu-id="f2ae4-133">Queue the IRP to the thread's pending APC so that the thread will execute the APC routine when it enters an alertable wait state and return from the wait operation with a status indicating that it executed one or more APC routines.</span></span>
-   <span data-ttu-id="f2ae4-134">Stellen Sie den Benutzer in eine Warteschlange für den e/a-Abschlussport, wo er vom nächsten Thread ausgeführt wird, der auf den Abschlussport wartet.</span><span class="sxs-lookup"><span data-stu-id="f2ae4-134">Queue the IRP to an I/O completion port, where it will be executed by the next thread that waits on the completion port.</span></span>

<span data-ttu-id="f2ae4-135">Threads, die auf einen e/a-Abschlussport warten, warten nicht in einem Warn baren Zustand.</span><span class="sxs-lookup"><span data-stu-id="f2ae4-135">Threads that wait on an I/O completion port do not wait in an alertable state.</span></span> <span data-ttu-id="f2ae4-136">Wenn die Threads daher unps ausgeben, die als APCs an den Thread festgelegt sind, werden diese IPC-Vervollständigungen nicht rechtzeitig durchgeführt. Sie treten nur auf, wenn der Thread eine Anforderung vom e/a-Abschlussport abruft und dann eine warterattabellenwartezeit eingibt.</span><span class="sxs-lookup"><span data-stu-id="f2ae4-136">Therefore, if those threads issue IRPs that are set to complete as APCs to the thread, those IPC completions will not occur in a timely manner; they will occur only if the thread picks up a request from the I/O completion port and then happens to enter an alertable wait.</span></span>

## <a name="related-topics"></a><span data-ttu-id="f2ae4-137">Zugehörige Themen</span><span class="sxs-lookup"><span data-stu-id="f2ae4-137">Related topics</span></span>

<dl> <dt>

[<span data-ttu-id="f2ae4-138">Verwenden eines aufnutzbaren Timers mit einem asynchronen Prozedur Befehl</span><span class="sxs-lookup"><span data-stu-id="f2ae4-138">Using a Waitable Timer with an Asynchronous Procedure Call</span></span>](using-a-waitable-timer-with-an-asynchronous-procedure-call.md)
</dt> </dl>

 

 
