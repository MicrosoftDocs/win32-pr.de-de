---
description: Benannte Objekte bieten eine einfache Möglichkeit für Prozesse, Objekt Handles gemeinsam zu nutzen.
ms.assetid: 00a00227-45fc-49a1-8ff5-aeccb172d16a
title: Objektnamen
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: ee746150a41f335a4073cb4b5ba282d17ad706f9
ms.sourcegitcommit: 831e8f3db78ab820e1710cede244553c70e50500
ms.translationtype: MT
ms.contentlocale: de-DE
ms.lasthandoff: 01/08/2021
ms.locfileid: "106368912"
---
# <a name="object-names"></a><span data-ttu-id="e29ac-103">Objektnamen</span><span class="sxs-lookup"><span data-stu-id="e29ac-103">Object Names</span></span>

<span data-ttu-id="e29ac-104">Benannte Objekte bieten eine einfache Möglichkeit für Prozesse, Objekt Handles gemeinsam zu nutzen.</span><span class="sxs-lookup"><span data-stu-id="e29ac-104">Named objects provide an easy way for processes to share object handles.</span></span> <span data-ttu-id="e29ac-105">Nachdem ein Prozess ein benanntes Ereignis, Mutex, Semaphore oder Timer-Objekt erstellt hat, können andere Prozesse den Namen verwenden, um die entsprechende Funktion ( [**OpenEvent**](/windows/win32/api/synchapi/nf-synchapi-openeventa), [**OpenMutex**](/windows/win32/api/synchapi/nf-synchapi-openmutexw), [**opensemaphore**](/windows/win32/api/synchapi/nf-synchapi-opensemaphorew)oder [**openwaitabletimer**](/windows/win32/api/synchapi/nf-synchapi-openwaitabletimerw)) aufzurufen, um ein Handle für das Objekt zu öffnen.</span><span class="sxs-lookup"><span data-stu-id="e29ac-105">After a process has created a named event, mutex, semaphore, or timer object, other processes can use the name to call the appropriate function ( [**OpenEvent**](/windows/win32/api/synchapi/nf-synchapi-openeventa), [**OpenMutex**](/windows/win32/api/synchapi/nf-synchapi-openmutexw), [**OpenSemaphore**](/windows/win32/api/synchapi/nf-synchapi-opensemaphorew), or [**OpenWaitableTimer**](/windows/win32/api/synchapi/nf-synchapi-openwaitabletimerw)) to open a handle to the object.</span></span> <span data-ttu-id="e29ac-106">Beim Namensvergleich wird zwischen Groß-und Kleinschreibung</span><span class="sxs-lookup"><span data-stu-id="e29ac-106">Name comparison is case sensitive.</span></span>

<span data-ttu-id="e29ac-107">Die Namen von Ereignissen, Semaphore, Mutex, wabbarer Timer, Datei Zuordnung und Auftrags Objekten verwenden denselben Namespace.</span><span class="sxs-lookup"><span data-stu-id="e29ac-107">The names of event, semaphore, mutex, waitable timer, file-mapping, and job objects share the same namespace.</span></span> <span data-ttu-id="e29ac-108">Wenn Sie versuchen, ein Objekt mit einem Namen zu erstellen, der von einem Objekt eines anderen Typs verwendet wird, tritt bei der Funktion ein Fehler auf, und [**GetLastError**](/windows/win32/api/errhandlingapi/nf-errhandlingapi-getlasterror) gibt ein **\_ ungültiges \_ handle** zurück.</span><span class="sxs-lookup"><span data-stu-id="e29ac-108">If you try to create an object using a name that is in use by an object of another type, the function fails and [**GetLastError**](/windows/win32/api/errhandlingapi/nf-errhandlingapi-getlasterror) returns **ERROR\_INVALID\_HANDLE**.</span></span> <span data-ttu-id="e29ac-109">Verwenden Sie daher beim Erstellen benannter Objekte eindeutige Namen, und überprüfen Sie die Funktions Rückgabewerte auf Fehler mit doppelten Namen.</span><span class="sxs-lookup"><span data-stu-id="e29ac-109">Therefore, when creating named objects, use unique names and be sure to check function return values for duplicate-name errors.</span></span>

<span data-ttu-id="e29ac-110">Wenn Sie versuchen, ein Objekt mit einem Namen zu erstellen, der von einem Objekt desselben Typs verwendet wird, wird die Funktion erfolgreich ausgeführt, und es wird ein Handle an das vorhandene Objekt zurückgegeben, und [**GetLastError**](/windows/win32/api/errhandlingapi/nf-errhandlingapi-getlasterror) gibt einen Fehler zurück, der **\_ bereits \_ vorhanden** ist.</span><span class="sxs-lookup"><span data-stu-id="e29ac-110">If you try to create an object using a name that is in use by an object of same type, the function succeeds, returning a handle to the existing object, and [**GetLastError**](/windows/win32/api/errhandlingapi/nf-errhandlingapi-getlasterror) returns **ERROR\_ALREADY\_EXISTS**.</span></span> <span data-ttu-id="e29ac-111">Wenn z. b. der in einem Aufrufen der Funktion " [**-Funktion"**](/windows/win32/api/synchapi/nf-synchapi-createmutexa) angegebene Name mit dem Namen eines vorhandenen Mutex-Objekts übereinstimmt, gibt die Funktion ein Handle an das vorhandene Objekt zurück.</span><span class="sxs-lookup"><span data-stu-id="e29ac-111">For example, if the name specified in a call to the [**CreateMutex**](/windows/win32/api/synchapi/nf-synchapi-createmutexa) function matches the name of an existing mutex object, the function returns a handle to the existing object.</span></span> <span data-ttu-id="e29ac-112">In diesem Fall entspricht der aufzurufende Aufrufs von " **kreatemutex** " dem Aufrufen der [**OpenMutex**](/windows/win32/api/synchapi/nf-synchapi-openmutexw) -Funktion.</span><span class="sxs-lookup"><span data-stu-id="e29ac-112">In this case, the call to **CreateMutex** is equivalent to a call to the [**OpenMutex**](/windows/win32/api/synchapi/nf-synchapi-openmutexw) function.</span></span> <span data-ttu-id="e29ac-113">Wenn Sie mehrere Prozesse verwenden, ist die Verwendung von " **kreatemutex** " für denselben Mutex gleichbedeutend mit einem Prozess, bei dem "up- **Mutex** " aufgerufen wird, während die anderen Prozesse **OpenMutex** aufrufen, mit dem Unterschied, dass Sie nicht sicherstellen müssen, dass der Erstellungsprozess</span><span class="sxs-lookup"><span data-stu-id="e29ac-113">Having multiple processes use **CreateMutex** for the same mutex is therefore equivalent to having one process that calls **CreateMutex** while the other processes call **OpenMutex**, except that it eliminates the need to ensure that the creating process is started first.</span></span> <span data-ttu-id="e29ac-114">Wenn Sie diese Technik für Mutex-Objekte verwenden, sollte jedoch keiner der aufrufenden Prozesse den unmittelbaren Besitz des Mutex anfordern.</span><span class="sxs-lookup"><span data-stu-id="e29ac-114">When using this technique for mutex objects, however, none of the calling processes should request immediate ownership of the mutex.</span></span> <span data-ttu-id="e29ac-115">Wenn mehrere Prozesse den unmittelbaren Besitz anfordern, kann es schwierig sein, vorherzusagen, welcher Prozess tatsächlich den anfänglichen Besitz erhält.</span><span class="sxs-lookup"><span data-stu-id="e29ac-115">If multiple processes do request immediate ownership, it can be difficult to predict which process actually gets the initial ownership.</span></span>

<span data-ttu-id="e29ac-116">Eine Terminaldiensteumgebung verfügt über einen globalen Namespace für Ereignisse, Semaphore, Mutexen, wabbare Timer, Datei Mapping-Objekte und Auftrags Objekte.</span><span class="sxs-lookup"><span data-stu-id="e29ac-116">A Terminal Services environment has a global namespace for events, semaphores, mutexes, waitable timers, file-mapping objects, and job objects.</span></span> <span data-ttu-id="e29ac-117">Außerdem verfügt jede Terminal Dienste-Client Sitzung über einen eigenen separaten Namespace für diese Objekte.</span><span class="sxs-lookup"><span data-stu-id="e29ac-117">In addition, each Terminal Services client session has its own separate namespace for these objects.</span></span> <span data-ttu-id="e29ac-118">Terminal Dienste-Client Prozesse können Objektnamen mit einem \\ Präfix "Global" oder "local \\ " verwenden, um explizit ein Objekt im globalen Namespace oder im Sitzungs Namespace zu erstellen.</span><span class="sxs-lookup"><span data-stu-id="e29ac-118">Terminal Services client processes can use object names with a "Global\\" or "Local\\" prefix to explicitly create an object in the global or session namespace.</span></span> <span data-ttu-id="e29ac-119">Weitere Informationen finden Sie unter [Kernel Object Namespaces](../termserv/kernel-object-namespaces.md).</span><span class="sxs-lookup"><span data-stu-id="e29ac-119">For more information, see [Kernel Object Namespaces](../termserv/kernel-object-namespaces.md).</span></span> <span data-ttu-id="e29ac-120">Die schnelle Benutzerumschaltung wird mithilfe von Terminal Dienste-Sitzungen implementiert (jeder Benutzer meldet sich in einer anderen Sitzung an).</span><span class="sxs-lookup"><span data-stu-id="e29ac-120">Fast user switching is implemented using Terminal Services sessions (each user logs into a different session).</span></span> <span data-ttu-id="e29ac-121">Kernel Objektnamen müssen den für Terminal Dienste beschriebenen Richtlinien entsprechen, damit Anwendungen mehrere Benutzer unterstützen können.</span><span class="sxs-lookup"><span data-stu-id="e29ac-121">Kernel object names must follow the guidelines outlined for Terminal Services so that applications can support multiple users.</span></span>

<span data-ttu-id="e29ac-122">Synchronisierungs Objekte können in einem privaten Namespace erstellt werden.</span><span class="sxs-lookup"><span data-stu-id="e29ac-122">Synchronization objects can be created in a private namespace.</span></span> <span data-ttu-id="e29ac-123">Weitere Informationen finden Sie unter [objektnamespaces](object-namespaces.md).</span><span class="sxs-lookup"><span data-stu-id="e29ac-123">For more information, see [Object Namespaces](object-namespaces.md).</span></span>

## <a name="related-topics"></a><span data-ttu-id="e29ac-124">Zugehörige Themen</span><span class="sxs-lookup"><span data-stu-id="e29ac-124">Related topics</span></span>

<dl> <dt>

[<span data-ttu-id="e29ac-125">Verwenden von benannten Objekten</span><span class="sxs-lookup"><span data-stu-id="e29ac-125">Using Named Objects</span></span>](using-named-objects.md)
</dt> </dl>

 

 
