---
description: Sie können synchrone oder asynchrone (auch als überlappende) E/A-Vorgänge für Dateien, Named Pipes und serielle Kommunikationsgeräte ausführen.
ms.assetid: db44990e-5a0f-4153-8ff6-79dd7cda48af
title: Synchronisierung und überlappende Eingabe und Ausgabe
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: 13e462e4c2cffa3f1c9dee9bc33a7c75b910ce8139dbdfab9c190b4691c4b6bc
ms.sourcegitcommit: e6600f550f79bddfe58bd4696ac50dd52cb03d7e
ms.translationtype: MT
ms.contentlocale: de-DE
ms.lasthandoff: 08/11/2021
ms.locfileid: "119975910"
---
# <a name="synchronization-and-overlapped-input-and-output"></a>Synchronisierung und überlappende Eingabe und Ausgabe

Sie können synchrone oder asynchrone (auch als überlappende) E/A-Vorgänge für Dateien, Named Pipes und serielle Kommunikationsgeräte ausführen. Die Funktionen [**WriteFile,**](/windows/win32/api/fileapi/nf-fileapi-writefile) [**ReadFile,**](/windows/win32/api/fileapi/nf-fileapi-readfile) [**DeviceIoControl,**](/windows/win32/api/ioapiset/nf-ioapiset-deviceiocontrol) [**WaitCommEvent,**](/windows/win32/api/winbase/nf-winbase-waitcommevent) [**ConnectNamedPipe**](/windows/win32/api/namedpipeapi/nf-namedpipeapi-connectnamedpipe)und [**TransactNamedPipe**](/windows/win32/api/namedpipeapi/nf-namedpipeapi-transactnamedpipe) können entweder synchron oder asynchron ausgeführt werden. Die [**Funktionen ReadFileEx**](/windows/win32/api/fileapi/nf-fileapi-readfileex) und [**WriteFileEx**](/windows/win32/api/fileapi/nf-fileapi-writefileex) können nur asynchron ausgeführt werden.

Wenn eine Funktion synchron ausgeführt wird, wird sie erst zurückgegeben, nachdem der Vorgang abgeschlossen wurde. Dies bedeutet, dass die Ausführung des aufrufenden Threads für einen unbestimmten Zeitraum blockiert werden kann, während auf den Abschluss eines zeitaufwändigen Vorgangs gewartet wird. Funktionen, die für überlappende Vorgänge aufgerufen werden, können sofort zurückgegeben werden, auch wenn der Vorgang nicht abgeschlossen wurde. Dadurch kann ein zeitaufwändiger E/A-Vorgang im Hintergrund ausgeführt werden, während der aufrufende Thread andere Aufgaben ausführen kann. Beispielsweise kann ein einzelner Thread gleichzeitige E/A-Vorgänge für verschiedene Handles oder sogar gleichzeitige Lese- und Schreibvorgänge für dasselbe Handle ausführen.

Um die Ausführung mit dem Abschluss des überlappenden Vorgangs zu synchronisieren, verwendet der aufrufende Thread die [**GetOverlappedResult-Funktion,**](/windows/win32/api/ioapiset/nf-ioapiset-getoverlappedresult) die [**GetOverlappedResultEx-Funktion**](/windows/desktop/api/Ioapiset/nf-ioapiset-getoverlappedresultex) oder eine der [Wait-Funktionen,](wait-functions.md) um zu bestimmen, wann der überlappende Vorgang abgeschlossen wurde. Sie können auch das [**Makro HasOverlappedIoCompleted**](/windows/desktop/api/WinBase/nf-winbase-hasoverlappediocompleted) verwenden, um den Abschluss abzufragen.

Um alle ausstehenden asynchronen E/A-Vorgänge abzubrechen, verwenden Sie die [**CancelIoEx-Funktion**](/windows/win32/api/ioapiset/nf-ioapiset-cancelioex) und stellen eine [**OVERLAPPED-Struktur**](/windows/win32/api/minwinbase/ns-minwinbase-overlapped) bereit, die die Anforderung zum Abbrechen angibt. Verwenden Sie die [**CancelIo-Funktion,**](/windows/win32/api/ioapiset/nf-ioapiset-cancelio) um ausstehende asynchrone E/A-Vorgänge abzubrechen, die vom aufrufenden Thread für das angegebene Dateihandle ausgegeben werden.

Überlappende Vorgänge erfordern eine Datei, eine Named Pipe oder ein Kommunikationsgerät, die mit dem **FLAG FILE \_ FLAG \_ OVERLAPPED** erstellt wurde. Wenn ein Thread eine Funktion (z. B. die [**ReadFile-Funktion)**](/windows/win32/api/fileapi/nf-fileapi-readfile) aufruft, um einen überlappenden Vorgang auszuführen, muss der aufrufende Thread einen Zeiger auf eine [**OVERLAPPED-Struktur**](/windows/win32/api/minwinbase/ns-minwinbase-overlapped) angeben. (Wenn dieser Zeiger **NULL** ist, gibt der Rückgabewert der Funktion möglicherweise fälschlicherweise an, dass der Vorgang abgeschlossen wurde.) Alle Member der **OVERLAPPED-Struktur** müssen mit 0 (null) initialisiert werden, es sei denn, ein Ereignis wird verwendet, um den Abschluss eines E/A-Vorgangs zu signalisieren. Wenn ein Ereignis verwendet wird, gibt der **hEvent-Member** der **OVERLAPPED-Struktur** ein Handle für das zugeordnete Ereignisobjekt an. Das System legt den Zustand des Ereignisobjekts auf nicht signalisiert fest, wenn ein Aufruf der E/A-Funktion zurückgegeben wird, bevor der Vorgang abgeschlossen wurde. Das System legt den Zustand des Ereignisobjekts so fest, dass er signalisiert wird, wenn der Vorgang abgeschlossen wurde. Ein Ereignis ist nur erforderlich, wenn mehrere ausstehende E/A-Vorgänge gleichzeitig vorhanden sind. Wenn kein Ereignis verwendet wird, signalisiert jeder abgeschlossene E/A-Vorgang die Datei, die Named Pipe oder das Kommunikationsgerät.

Wenn eine Funktion aufgerufen wird, um einen überlappenden Vorgang auszuführen, kann der Vorgang abgeschlossen sein, bevor die Funktion zurückgegeben wird. In diesem Fall werden die Ergebnisse so behandelt, als ob der Vorgang synchron ausgeführt worden wäre. Wenn der Vorgang jedoch nicht abgeschlossen wurde, lautet der Rückgabewert der Funktion **FALSE,** und die [**GetLastError-Funktion**](/windows/win32/api/errhandlingapi/nf-errhandlingapi-getlasterror) gibt **ERROR IO \_ \_ PENDING zurück.**

Ein Thread kann überlappende Vorgänge mit einer von zwei Methoden verwalten:

-   Verwenden Sie die [**GetOverlappedResult-**](/windows/win32/api/ioapiset/nf-ioapiset-getoverlappedresult) oder [**GetOverlappedResultEx-Funktion,**](/windows/desktop/api/Ioapiset/nf-ioapiset-getoverlappedresultex) um auf den Abschluss des überlappenden Vorgangs zu warten. Wenn **GetOverlappedResultEx** verwendet wird, kann der aufrufende Thread ein Timeout für den überlappenden Vorgang angeben oder eine warnungsfähige Wartezeit ausführen.
-   Geben Sie ein Handle für das Ereignisobjekt für manuelles Zurücksetzen der [**OVERLAPPED-Struktur**](/windows/win32/api/minwinbase/ns-minwinbase-overlapped) in einer der [Wartefunktionen](wait-functions.md) an, und rufen Sie dann [**getOverlappedResult**](/windows/win32/api/ioapiset/nf-ioapiset-getoverlappedresult) oder [**GetOverlappedResultEx**](/windows/desktop/api/Ioapiset/nf-ioapiset-getoverlappedresultex)auf, nachdem die Wait-Funktion zurückgegeben wurde. Die Funktion gibt die Ergebnisse des abgeschlossenen überlappenden Vorgangs zurück. Für Funktionen, in denen solche Informationen geeignet sind, meldet sie die tatsächliche Anzahl der übertragenen Bytes.

Wenn mehrere gleichzeitig überlappende Vorgänge für einen einzelnen Thread ausgeführt werden, muss der aufrufende Thread für jeden Vorgang eine [**OVERLAPPED-Struktur**](/windows/win32/api/minwinbase/ns-minwinbase-overlapped) angeben. Jede **OVERLAPPED-Struktur** muss ein Handle für ein anderes Ereignisobjekt mit manueller Zurücksetzung angeben. Um auf den Abschluss eines der überlappenden Vorgänge zu warten, gibt der Thread alle Manuell zurücksetzungsereignishandles als Wartekriterien in einer der [Wartefunktionen mit mehreren Objekten an.](wait-functions.md) Der Rückgabewert der Wait-Funktion mit mehreren Objekten gibt an, welches Ereignisobjekt mit manueller Zurücksetzung signalisiert wurde, sodass der Thread bestimmen kann, welcher überlappende Vorgang den Abschluss des Wartevorgangs verursacht hat.

Es ist sicherer, für jeden überlappende Vorgang ein separates Ereignisobjekt zu verwenden, anstatt kein Ereignisobjekt anzugeben oder dasselbe Ereignisobjekt für mehrere Vorgänge wiederzuverwenden. Wenn in der [**OVERLAPPED-Struktur**](/windows/win32/api/minwinbase/ns-minwinbase-overlapped) kein Ereignisobjekt angegeben ist, signalisiert das System den Zustand der Datei, der Named Pipe oder des Kommunikationsgeräts, wenn der überlappende Vorgang abgeschlossen wurde. Daher können Sie diese Handles als Synchronisierungsobjekte in einer Wartefunktion angeben, obwohl deren Verwendung für diesen Zweck schwierig zu verwalten sein kann, da beim Ausführen gleichzeitig überlappender Vorgänge auf demselben Datei-, Named Pipe- oder Kommunikationsgerät nicht bekannt ist, welcher Vorgang dazu geführt hat, dass der Zustand des Objekts signalisiert wird.

Ein Thread sollte ein Ereignis nicht mit der Annahme wiederverwenden, dass das Ereignis nur durch den überlappenden Vorgang dieses Threads signalisiert wird. Ein Ereignis wird für denselben Thread wie der überlappende Vorgang signalisiert, der abgeschlossen wird. Die Verwendung desselben Ereignisses für mehrere Threads kann zu einer Racebedingung führen, bei der das Ereignis für den Thread, dessen Vorgang zuerst abgeschlossen wird, und vorzeitig für andere Threads, die dieses Ereignis verwenden, ordnungsgemäß signalisiert wird. Wenn dann der nächste überlappende Vorgang abgeschlossen ist, wird das Ereignis für alle Threads, die dieses Ereignis verwenden, erneut signalisiert usw., bis alle überlappenden Vorgänge abgeschlossen sind.

Beispiele, die die Verwendung von überlappenden Vorgängen, Vervollständigungsroutinen und der [**GetOverlappedResult-Funktion**](/windows/win32/api/ioapiset/nf-ioapiset-getoverlappedresult) veranschaulichen, finden Sie unter [Verwenden von Pipes.](../ipc/using-pipes.md)

**Windows Vista, Windows Server 2003 und Windows XP: **

Seien Sie vorsichtig, wenn Sie [**OVERLAPPED-Strukturen**](/windows/win32/api/minwinbase/ns-minwinbase-overlapped) wiederverwenden. Wenn **OVERLAPPED-Strukturen** in mehreren Threads wiederverwendet werden und [**GetOverlappedResult**](/windows/win32/api/ioapiset/nf-ioapiset-getoverlappedresult) mit dem auf **TRUE** festgelegten *bWait-Parameter* aufgerufen wird, muss der aufrufende Thread sicherstellen, dass das zugeordnete Ereignis signalisiert wird, bevor die Struktur wiederverwendet wird. Dies kann erreicht werden, indem die [**WaitForSingleObject-Funktion**](/windows/win32/api/winbase/nf-winbase-registerwaitforsingleobject) nach dem Aufruf von **GetOverlappedResult** verwendet wird, um zu erzwingen, dass der Thread wartet, bis der Vorgang abgeschlossen ist. Beachten Sie, dass das Ereignisobjekt ein Ereignisobjekt mit manueller Zurücksetzung sein muss. Wenn ein autoreset-Ereignisobjekt verwendet wird, führt der Aufruf von **GetOverlappedResult** mit dem auf **TRUE** festgelegten *bWait-Parameter* dazu, dass die Funktion unbegrenzt blockiert wird. Dieses Verhalten hat sich ab Windows 7 und Windows Server 2008 R2 für Anwendungen geändert, die Windows 7 als unterstütztes Betriebssystem im Anwendungsmanifest angeben. Weitere Informationen finden Sie unter [Anwendungsmanifeste.](/previous-versions/windows/desktop/adrms_sdk/application-manifests)

## <a name="related-topics"></a>Zugehörige Themen

<dl> <dt>

[E/A-Konzepte](../fileio/i-o-concepts.md)
</dt> </dl>

 

 
