---
description: Das Erstellen von DLLs stellt Entwicklern eine Reihe von Herausforderungen dar.
ms.assetid: 44EFC4B5-7A2F-43A6-914E-D4EB7446AC35
title: Bewährte Methoden für Dynamic-Link Bibliothek
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: 88aba0999f3d0825c6d2f4df3afe09d766a82232
ms.sourcegitcommit: 831e8f3db78ab820e1710cede244553c70e50500
ms.translationtype: MT
ms.contentlocale: de-DE
ms.lasthandoff: 01/08/2021
ms.locfileid: "106373306"
---
# <a name="dynamic-link-library-best-practices"></a><span data-ttu-id="6dbb3-103">Bewährte Methoden für Dynamic-Link Bibliothek</span><span class="sxs-lookup"><span data-stu-id="6dbb3-103">Dynamic-Link Library Best Practices</span></span>

<span data-ttu-id="6dbb3-104">\* \* Aktualisiert: \* \*</span><span class="sxs-lookup"><span data-stu-id="6dbb3-104">\*\*Updated: \*\*</span></span>

-   <span data-ttu-id="6dbb3-105">17. Mai 2006</span><span class="sxs-lookup"><span data-stu-id="6dbb3-105">May 17, 2006</span></span>

<span data-ttu-id="6dbb3-106">**Wichtige APIs**</span><span class="sxs-lookup"><span data-stu-id="6dbb3-106">**Important APIs**</span></span>

-   [<span data-ttu-id="6dbb3-107">**DllMain**</span><span class="sxs-lookup"><span data-stu-id="6dbb3-107">**DllMain**</span></span>](dllmain.md)
-   [<span data-ttu-id="6dbb3-108">**LoadLibraryEx**</span><span class="sxs-lookup"><span data-stu-id="6dbb3-108">**LoadLibraryEx**</span></span>](/windows/desktop/api/LibLoaderAPI/nf-libloaderapi-loadlibraryexa)
-   [<span data-ttu-id="6dbb3-109">**CreateProcess**</span><span class="sxs-lookup"><span data-stu-id="6dbb3-109">**CreateProcess**</span></span>](/windows/desktop/api/processthreadsapi/nf-processthreadsapi-createprocessa)

<span data-ttu-id="6dbb3-110">Das Erstellen von DLLs stellt Entwicklern eine Reihe von Herausforderungen dar.</span><span class="sxs-lookup"><span data-stu-id="6dbb3-110">Creating DLLs presents a number of challenges for developers.</span></span> <span data-ttu-id="6dbb3-111">DLLs verfügen nicht über eine vom System erzwungene Versionierung.</span><span class="sxs-lookup"><span data-stu-id="6dbb3-111">DLLs do not have system-enforced versioning.</span></span> <span data-ttu-id="6dbb3-112">Wenn mehrere Versionen einer DLL auf einem System vorhanden sind, werden durch die einfache Übersetzung mit dem fehlenden Schema der Versionsverwaltung Abhängigkeiten und API-Konflikte erzeugt.</span><span class="sxs-lookup"><span data-stu-id="6dbb3-112">When multiple versions of a DLL exist on a system, the ease of being overwritten coupled with the lack of a versioning schema creates dependency and API conflicts.</span></span> <span data-ttu-id="6dbb3-113">Die Komplexität in der Entwicklungsumgebung, der Lade Lade Implementierung und den DLL-Abhängigkeiten hat eine Anfälligkeit in der Lade Reihenfolge und dem Anwendungsverhalten verursacht.</span><span class="sxs-lookup"><span data-stu-id="6dbb3-113">Complexity in the development environment, the loader implementation, and the DLL dependencies has created fragility in load order and application behavior.</span></span> <span data-ttu-id="6dbb3-114">Schließlich basieren viele Anwendungen auf DLLs und verfügen über komplexe Sätze von Abhängigkeiten, die berücksichtigt werden müssen, damit die Anwendungen ordnungsgemäß funktionieren.</span><span class="sxs-lookup"><span data-stu-id="6dbb3-114">Lastly, many applications rely on DLLs and have complex sets of dependencies that must be honored for the applications to function properly.</span></span> <span data-ttu-id="6dbb3-115">Dieses Dokument enthält Richtlinien für dll-Entwickler, die beim Aufbau stabiler, portabler und erweiterbarer DLLs helfen.</span><span class="sxs-lookup"><span data-stu-id="6dbb3-115">This document provides guidelines for DLL developers to help in building more robust, portable, and extensible DLLs.</span></span>

<span data-ttu-id="6dbb3-116">Eine nicht ordnungsgemäße Synchronisierung in [**DllMain**](dllmain.md) kann dazu führen, dass eine Anwendung in einer nicht initialisierten dll Deadlocks oder auf Daten oder Code zugreift.</span><span class="sxs-lookup"><span data-stu-id="6dbb3-116">Improper synchronization within [**DllMain**](dllmain.md) can cause an application to deadlock or access data or code in an uninitialized DLL.</span></span> <span data-ttu-id="6dbb3-117">Durch das Aufrufen bestimmter Funktionen innerhalb von **DllMain** werden solche Probleme verursacht.</span><span class="sxs-lookup"><span data-stu-id="6dbb3-117">Calling certain functions from within **DllMain** causes such problems.</span></span>

![Was geschieht, wenn eine Bibliothek geladen wird](images/fig1.png)

## <a name="general-best-practices"></a><span data-ttu-id="6dbb3-119">Allgemeine bewährte Methoden</span><span class="sxs-lookup"><span data-stu-id="6dbb3-119">General Best Practices</span></span>

<span data-ttu-id="6dbb3-120">[**DllMain**](dllmain.md) wird aufgerufen, während die Loadersperre aufrechterhalten wird.</span><span class="sxs-lookup"><span data-stu-id="6dbb3-120">[**DllMain**](dllmain.md) is called while the loader-lock is held.</span></span> <span data-ttu-id="6dbb3-121">Daher gelten für die Funktionen, die innerhalb von **DllMain** aufgerufen werden können, bedeutende Einschränkungen.</span><span class="sxs-lookup"><span data-stu-id="6dbb3-121">Therefore, significant restrictions are imposed on the functions that can be called within **DllMain**.</span></span> <span data-ttu-id="6dbb3-122">**DllMain** ist daher für die Durchführung minimaler Initialisierungs Aufgaben konzipiert, indem eine kleine Teilmenge der Microsoft® Windows®-API verwendet wird.</span><span class="sxs-lookup"><span data-stu-id="6dbb3-122">As such, **DllMain** is designed to perform minimal initialization tasks, by using a small subset of the Microsoft® Windows® API.</span></span> <span data-ttu-id="6dbb3-123">Sie können keine Funktion in **DllMain** aufgerufen werden, die direkt oder indirekt versucht, die Loadersperre abzurufen.</span><span class="sxs-lookup"><span data-stu-id="6dbb3-123">You cannot call any function in **DllMain** that directly or indirectly tries to acquire the loader lock.</span></span> <span data-ttu-id="6dbb3-124">Andernfalls wird die Möglichkeit eingeführt, dass Ihre Anwendung Deadlocks oder abstürzt.</span><span class="sxs-lookup"><span data-stu-id="6dbb3-124">Otherwise, you will introduce the possibility that your application deadlocks or crashes.</span></span> <span data-ttu-id="6dbb3-125">Ein Fehler in einer **DllMain** -Implementierung kann den gesamten Prozess und alle zugehörigen Threads gefährden.</span><span class="sxs-lookup"><span data-stu-id="6dbb3-125">An error in a **DllMain** implementation can jeopardize the entire process and all of its threads.</span></span>

<span data-ttu-id="6dbb3-126">Der ideale [**DllMain**](dllmain.md) -Wert ist nur ein leerer Stub.</span><span class="sxs-lookup"><span data-stu-id="6dbb3-126">The ideal [**DllMain**](dllmain.md) would be just an empty stub.</span></span> <span data-ttu-id="6dbb3-127">Aufgrund der Komplexität vieler Anwendungen ist dies jedoch im Allgemeinen zu restriktiv.</span><span class="sxs-lookup"><span data-stu-id="6dbb3-127">However, given the complexity of many applications, this is generally too restrictive.</span></span> <span data-ttu-id="6dbb3-128">Eine gute Faustregel für **DllMain** besteht darin, so viele Initialisierungen wie möglich zu verschieben.</span><span class="sxs-lookup"><span data-stu-id="6dbb3-128">A good rule of thumb for **DllMain** is to postpone as much initialization as possible.</span></span> <span data-ttu-id="6dbb3-129">Die verzögerte Initialisierung erhöht die Stabilität der Anwendung, da diese Initialisierung nicht durchgeführt wird, während die Loadersperre aufrechterhalten wird.</span><span class="sxs-lookup"><span data-stu-id="6dbb3-129">Lazy initialization increases robustness of the application because this initialization is not performed while the loader lock is held.</span></span> <span data-ttu-id="6dbb3-130">Außerdem können Sie mit der verzögerten Initialisierung viel mehr von der Windows-API verwenden.</span><span class="sxs-lookup"><span data-stu-id="6dbb3-130">Also, lazy initialization enables you to safely use much more of the Windows API.</span></span>

<span data-ttu-id="6dbb3-131">Einige Initialisierungs Tasks können nicht verschoben werden.</span><span class="sxs-lookup"><span data-stu-id="6dbb3-131">Some initialization tasks cannot be postponed.</span></span> <span data-ttu-id="6dbb3-132">Beispielsweise sollte eine DLL, die von einer Konfigurationsdatei abhängt, nicht geladen werden, wenn die Datei falsch formatiert ist oder eine Garbage Collection enthält.</span><span class="sxs-lookup"><span data-stu-id="6dbb3-132">For example, a DLL that depends on a configuration file should fail to load if the file is malformed or contains garbage.</span></span> <span data-ttu-id="6dbb3-133">Bei dieser Art der Initialisierung sollte die dll die Aktion durchführen und schnell einen Fehler erzeugen, anstatt Ressourcen durch Abschließen anderer Aufgaben zu verschwenden.</span><span class="sxs-lookup"><span data-stu-id="6dbb3-133">For this type of initialization, the DLL should attempt the action and fail quickly rather than waste resources by completing other work.</span></span>

<span data-ttu-id="6dbb3-134">Sie sollten die folgenden Aufgaben niemals innerhalb von [**DllMain**](dllmain.md)ausführen:</span><span class="sxs-lookup"><span data-stu-id="6dbb3-134">You should never perform the following tasks from within [**DllMain**](dllmain.md):</span></span>

-   <span data-ttu-id="6dbb3-135">Aufrufen von [**LoadLibrary**](/windows/win32/api/libloaderapi/nf-libloaderapi-loadlibrarya) oder [**LoadLibraryEx**](/windows/desktop/api/LibLoaderAPI/nf-libloaderapi-loadlibraryexa) (entweder direkt oder indirekt).</span><span class="sxs-lookup"><span data-stu-id="6dbb3-135">Call [**LoadLibrary**](/windows/win32/api/libloaderapi/nf-libloaderapi-loadlibrarya) or [**LoadLibraryEx**](/windows/desktop/api/LibLoaderAPI/nf-libloaderapi-loadlibraryexa) (either directly or indirectly).</span></span> <span data-ttu-id="6dbb3-136">Dies kann zu einem Deadlock oder einem Absturz führen.</span><span class="sxs-lookup"><span data-stu-id="6dbb3-136">This can cause a deadlock or a crash.</span></span>
-   <span data-ttu-id="6dbb3-137">Aufrufen von [**getstringtypea**](/windows/desktop/api/winnls/nf-winnls-getstringtypea), [**getstringtypeex**](/windows/win32/api/stringapiset/nf-stringapiset-getstringtypeexw)oder [**getstringtypew**](/windows/desktop/api/stringapiset/nf-stringapiset-getstringtypew) (entweder direkt oder indirekt).</span><span class="sxs-lookup"><span data-stu-id="6dbb3-137">Call [**GetStringTypeA**](/windows/desktop/api/winnls/nf-winnls-getstringtypea), [**GetStringTypeEx**](/windows/win32/api/stringapiset/nf-stringapiset-getstringtypeexw), or [**GetStringTypeW**](/windows/desktop/api/stringapiset/nf-stringapiset-getstringtypew) (either directly or indirectly).</span></span> <span data-ttu-id="6dbb3-138">Dies kann zu einem Deadlock oder einem Absturz führen.</span><span class="sxs-lookup"><span data-stu-id="6dbb3-138">This can cause a deadlock or a crash.</span></span>
-   <span data-ttu-id="6dbb3-139">Mit anderen Threads synchronisieren.</span><span class="sxs-lookup"><span data-stu-id="6dbb3-139">Synchronize with other threads.</span></span> <span data-ttu-id="6dbb3-140">Dies kann zu einem Deadlock führen.</span><span class="sxs-lookup"><span data-stu-id="6dbb3-140">This can cause a deadlock.</span></span>
-   <span data-ttu-id="6dbb3-141">Rufen Sie ein Synchronisierungs Objekt ab, das im Besitz von Code ist, der darauf wartet, die Loadersperre abzurufen.</span><span class="sxs-lookup"><span data-stu-id="6dbb3-141">Acquire a synchronization object that is owned by code that is waiting to acquire the loader lock.</span></span> <span data-ttu-id="6dbb3-142">Dies kann zu einem Deadlock führen.</span><span class="sxs-lookup"><span data-stu-id="6dbb3-142">This can cause a deadlock.</span></span>
-   <span data-ttu-id="6dbb3-143">Initialisieren Sie com-Threads mithilfe von [**CoInitializeEx**](/windows/desktop/api/combaseapi/nf-combaseapi-coinitializeex).</span><span class="sxs-lookup"><span data-stu-id="6dbb3-143">Initialize COM threads by using [**CoInitializeEx**](/windows/desktop/api/combaseapi/nf-combaseapi-coinitializeex).</span></span> <span data-ttu-id="6dbb3-144">Unter bestimmten Bedingungen kann diese Funktion [**LoadLibraryEx**](/windows/desktop/api/LibLoaderAPI/nf-libloaderapi-loadlibraryexa)aufrufen.</span><span class="sxs-lookup"><span data-stu-id="6dbb3-144">Under certain conditions, this function can call [**LoadLibraryEx**](/windows/desktop/api/LibLoaderAPI/nf-libloaderapi-loadlibraryexa).</span></span>
-   <span data-ttu-id="6dbb3-145">Aufrufe der Registrierungsfunktionen.</span><span class="sxs-lookup"><span data-stu-id="6dbb3-145">Call the registry functions.</span></span> <span data-ttu-id="6dbb3-146">Diese Funktionen werden in Advapi32.dll implementiert.</span><span class="sxs-lookup"><span data-stu-id="6dbb3-146">These functions are implemented in Advapi32.dll.</span></span> <span data-ttu-id="6dbb3-147">Wenn Advapi32.dll nicht vor der DLL initialisiert wird, kann die dll auf nicht initialisierten Speicher zugreifen und den Prozess abstürzen.</span><span class="sxs-lookup"><span data-stu-id="6dbb3-147">If Advapi32.dll is not initialized before your DLL, the DLL can access uninitialized memory and cause the process to crash.</span></span>
-   <span data-ttu-id="6dbb3-148">Aufrufen von " [**kreateprocess**](/windows/desktop/api/processthreadsapi/nf-processthreadsapi-createprocessa)".</span><span class="sxs-lookup"><span data-stu-id="6dbb3-148">Call [**CreateProcess**](/windows/desktop/api/processthreadsapi/nf-processthreadsapi-createprocessa).</span></span> <span data-ttu-id="6dbb3-149">Beim Erstellen eines Prozesses kann eine andere DLL geladen werden.</span><span class="sxs-lookup"><span data-stu-id="6dbb3-149">Creating a process can load another DLL.</span></span>
-   <span data-ttu-id="6dbb3-150">[**ExitThread**](/windows/win32/api/libloaderapi/nf-libloaderapi-freelibraryandexitthread)aufzurufen.</span><span class="sxs-lookup"><span data-stu-id="6dbb3-150">Call [**ExitThread**](/windows/win32/api/libloaderapi/nf-libloaderapi-freelibraryandexitthread).</span></span> <span data-ttu-id="6dbb3-151">Wenn Sie einen Thread beim Trennen der dll beenden, kann dies dazu führen, dass die Loadersperre erneut abgerufen wird, was zu einem Deadlock oder einem Absturz führt.</span><span class="sxs-lookup"><span data-stu-id="6dbb3-151">Exiting a thread during DLL detach can cause the loader lock to be acquired again, causing a deadlock or a crash.</span></span>
-   <span data-ttu-id="6dbb3-152">Aufrufen von " [**foratethread**](/windows/desktop/api/processthreadsapi/nf-processthreadsapi-createthread)".</span><span class="sxs-lookup"><span data-stu-id="6dbb3-152">Call [**CreateThread**](/windows/desktop/api/processthreadsapi/nf-processthreadsapi-createthread).</span></span> <span data-ttu-id="6dbb3-153">Das Erstellen eines Threads kann funktionieren, wenn Sie nicht mit anderen Threads synchronisieren, aber es ist riskant.</span><span class="sxs-lookup"><span data-stu-id="6dbb3-153">Creating a thread can work if you do not synchronize with other threads, but it is risky.</span></span>
-   <span data-ttu-id="6dbb3-154">Erstellen Sie eine Named Pipe oder ein anderes benanntes Objekt (nur Windows 2000).</span><span class="sxs-lookup"><span data-stu-id="6dbb3-154">Create a named pipe or other named object (Windows 2000 only).</span></span> <span data-ttu-id="6dbb3-155">In Windows 2000 werden benannte Objekte von der Terminal Dienste-dll bereitgestellt.</span><span class="sxs-lookup"><span data-stu-id="6dbb3-155">In Windows 2000, named objects are provided by the Terminal Services DLL.</span></span> <span data-ttu-id="6dbb3-156">Wenn diese DLL nicht initialisiert ist, können Aufrufe der dll zu einem Absturz des Prozesses führen.</span><span class="sxs-lookup"><span data-stu-id="6dbb3-156">If this DLL is not initialized, calls to the DLL can cause the process to crash.</span></span>
-   <span data-ttu-id="6dbb3-157">Verwenden Sie die Speicher Verwaltungsfunktion aus dem dynamischen C-Run-Time (CRT).</span><span class="sxs-lookup"><span data-stu-id="6dbb3-157">Use the memory management function from the dynamic C Run-Time (CRT).</span></span> <span data-ttu-id="6dbb3-158">Wenn die CRT-DLL nicht initialisiert ist, können Aufrufe dieser Funktionen dazu führen, dass der Prozess abstürzt.</span><span class="sxs-lookup"><span data-stu-id="6dbb3-158">If the CRT DLL is not initialized, calls to these functions can cause the process to crash.</span></span>
-   <span data-ttu-id="6dbb3-159">Aufrufe von Funktionen in User32.dll oder Gdi32.dll.</span><span class="sxs-lookup"><span data-stu-id="6dbb3-159">Call functions in User32.dll or Gdi32.dll.</span></span> <span data-ttu-id="6dbb3-160">Einige Funktionen laden eine andere dll, die möglicherweise nicht initialisiert wird.</span><span class="sxs-lookup"><span data-stu-id="6dbb3-160">Some functions load another DLL, which may not be initialized.</span></span>
-   <span data-ttu-id="6dbb3-161">Verwenden Sie verwalteten Code.</span><span class="sxs-lookup"><span data-stu-id="6dbb3-161">Use managed code.</span></span>

<span data-ttu-id="6dbb3-162">Die folgenden Aufgaben können in **DllMain** sicher ausgeführt werden:</span><span class="sxs-lookup"><span data-stu-id="6dbb3-162">The following tasks are safe to perform within **DllMain**:</span></span>

-   <span data-ttu-id="6dbb3-163">Initialisieren statischer Datenstrukturen und Member zum Zeitpunkt der Kompilierung.</span><span class="sxs-lookup"><span data-stu-id="6dbb3-163">Initialize static data structures and members at compile time.</span></span>
-   <span data-ttu-id="6dbb3-164">Hiermit werden Synchronisierungs Objekte erstellt und initialisiert.</span><span class="sxs-lookup"><span data-stu-id="6dbb3-164">Create and initialize synchronization objects.</span></span>
-   <span data-ttu-id="6dbb3-165">Zuweisen von Speicher und initialisieren dynamischer Datenstrukturen (vermeiden der oben aufgeführten Funktionen)</span><span class="sxs-lookup"><span data-stu-id="6dbb3-165">Allocate memory and initialize dynamic data structures (avoiding the functions listed above.)</span></span>
-   <span data-ttu-id="6dbb3-166">Einrichten von lokalem Thread Speicher (TLS).</span><span class="sxs-lookup"><span data-stu-id="6dbb3-166">Set up thread local storage (TLS).</span></span>
-   <span data-ttu-id="6dbb3-167">Öffnen, Lesen von und Schreiben in Dateien.</span><span class="sxs-lookup"><span data-stu-id="6dbb3-167">Open, read from, and write to files.</span></span>
-   <span data-ttu-id="6dbb3-168">Aufrufe von Funktionen in Kernel32.dll (außer den oben aufgeführten Funktionen).</span><span class="sxs-lookup"><span data-stu-id="6dbb3-168">Call functions in Kernel32.dll (except the functions that are listed above).</span></span>
-   <span data-ttu-id="6dbb3-169">Legen Sie globale Zeiger auf NULL fest, und legen Sie die Initialisierung dynamischer Member ab.</span><span class="sxs-lookup"><span data-stu-id="6dbb3-169">Set global pointers to NULL, putting off the initialization of dynamic members.</span></span> <span data-ttu-id="6dbb3-170">In der™ von Microsoft Windows Vista können Sie die einmaligen Initialisierungs Funktionen verwenden, um sicherzustellen, dass ein Codeblock nur einmal in einer Multithread-Umgebung ausgeführt wird.</span><span class="sxs-lookup"><span data-stu-id="6dbb3-170">In Microsoft Windows Vista™, you can use the one-time initialization functions to ensure that a block of code is executed only once in a multithreaded environment.</span></span>

## <a name="deadlocks-caused-by-lock-order-inversion"></a><span data-ttu-id="6dbb3-171">Deadlocks, die durch eine Sperr Reihenfolge verursacht werden</span><span class="sxs-lookup"><span data-stu-id="6dbb3-171">Deadlocks Caused by Lock Order Inversion</span></span>

<span data-ttu-id="6dbb3-172">Wenn Sie Code implementieren, der mehrere Synchronisierungs Objekte verwendet, z. b. sperren, ist es wichtig, die Sperr Reihenfolge zu berücksichtigen.</span><span class="sxs-lookup"><span data-stu-id="6dbb3-172">When you are implementing code that uses multiple synchronization objects such as locks, it is vital to respect lock order.</span></span> <span data-ttu-id="6dbb3-173">Wenn mehr als eine Sperre gleichzeitig abgerufen werden muss, müssen Sie eine explizite Rangfolge definieren, die als Sperr Hierarchie oder Sperr Reihenfolge bezeichnet wird.</span><span class="sxs-lookup"><span data-stu-id="6dbb3-173">When it is necessary to acquire more than one lock at a time, you must define an explicit precedence that is called a lock hierarchy or lock order.</span></span> <span data-ttu-id="6dbb3-174">Wenn z. b. Sperre a vor Sperre an einer beliebigen Stelle im Code abgerufen wird und Lock b vor der Sperre C an anderer Stelle im Code abgerufen wird, ist die Sperr Reihenfolge a, B, C, und diese Reihenfolge sollte im gesamten Code befolgt werden.</span><span class="sxs-lookup"><span data-stu-id="6dbb3-174">For example, if lock A is acquired before lock B somewhere in the code, and lock B is acquired before lock C elsewhere in the code, then the lock order is A, B, C and this order should be followed throughout the code.</span></span> <span data-ttu-id="6dbb3-175">Die Inversion der Sperre tritt auf, wenn die Sperr Reihenfolge nicht eingehalten wird, z. –. Wenn Sperre B vor Sperre a abgerufen wird. die Sperr Reihenfolge Inversion kann Deadlocks verursachen, die schwer zu Debuggen sind</span><span class="sxs-lookup"><span data-stu-id="6dbb3-175">Lock order inversion occurs when the locking order is not followed—for example, if lock B is acquired before lock A. Lock order inversion can cause deadlocks that are difficult to debug.</span></span> <span data-ttu-id="6dbb3-176">Um solche Probleme zu vermeiden, müssen alle Threads Sperren in derselben Reihenfolge erhalten.</span><span class="sxs-lookup"><span data-stu-id="6dbb3-176">To avoid such problems, all threads must acquire locks in the same order.</span></span>

<span data-ttu-id="6dbb3-177">Beachten Sie, dass das Lade Modul [**DllMain**](dllmain.md) mit der bereits erworbenen Lade Lade Sperre aufruft, sodass die Loadersperre in der Sperr Hierarchie die höchste Priorität haben sollte.</span><span class="sxs-lookup"><span data-stu-id="6dbb3-177">It is important to note that the loader calls [**DllMain**](dllmain.md) with the loader lock already acquired, so the loader lock should have the highest precedence in the locking hierarchy.</span></span> <span data-ttu-id="6dbb3-178">Beachten Sie außerdem, dass Code nur die Sperren abrufen muss, die für die ordnungsgemäße Synchronisierung erforderlich sind. Es muss nicht jede einzelne Sperre abgerufen werden, die in der Hierarchie definiert ist.</span><span class="sxs-lookup"><span data-stu-id="6dbb3-178">Also note that code only has to acquire the locks it requires for proper synchronization; it does not have to acquire every single lock that is defined in the hierarchy.</span></span> <span data-ttu-id="6dbb3-179">Wenn z. b. für einen Code Abschnitt nur die Sperren a und c für die ordnungsgemäße Synchronisierung erforderlich sind, sollte der Code lock a abrufen, bevor er die Sperre C übernimmt. Es ist nicht erforderlich, dass der Code auch Lock B erhält. Außerdem kann der DLL-Code die Loadersperre nicht explizit abrufen.</span><span class="sxs-lookup"><span data-stu-id="6dbb3-179">For example, if a section of code requires only locks A and C for proper synchronization, then the code should acquire lock A before it acquires lock C; it is not necessary for the code to also acquire lock B. Furthermore, DLL code cannot explicitly acquire the loader lock.</span></span> <span data-ttu-id="6dbb3-180">Wenn der Code eine API wie z. b. [**GetModuleFileName**](/windows/win32/api/libloaderapi/nf-libloaderapi-getmodulefilenamea) aufrufen muss, die indirekt die Loadersperre abrufen kann, und der Code außerdem eine private Sperre erhalten muss, sollte der Code **GetModuleFileName** aufrufen, bevor er Lock P erhält. Dadurch wird sichergestellt, dass die Lade Reihenfolge eingehalten wird.</span><span class="sxs-lookup"><span data-stu-id="6dbb3-180">If the code must call an API such as [**GetModuleFileName**](/windows/win32/api/libloaderapi/nf-libloaderapi-getmodulefilenamea) that can indirectly acquire the loader lock and the code must also acquire a private lock, then the code should call **GetModuleFileName** before it acquires lock P, thus ensuring that load order is respected.</span></span>

<span data-ttu-id="6dbb3-181">Abbildung 2 zeigt ein Beispiel, das die Inversion der Sperr Reihenfolge veranschaulicht.</span><span class="sxs-lookup"><span data-stu-id="6dbb3-181">Figure 2 is an example that illustrates lock order inversion.</span></span> <span data-ttu-id="6dbb3-182">Ziehen Sie eine DLL in Erwägung, deren Hauptthread [**DllMain**](dllmain.md)enthält.</span><span class="sxs-lookup"><span data-stu-id="6dbb3-182">Consider a DLL whose main thread contains [**DllMain**](dllmain.md).</span></span> <span data-ttu-id="6dbb3-183">Das Bibliotheks Lade Modul erhält die Loadersperre L und ruft dann **DllMain** auf.</span><span class="sxs-lookup"><span data-stu-id="6dbb3-183">The library loader acquires the loader lock L and then calls into **DllMain**.</span></span> <span data-ttu-id="6dbb3-184">Der Haupt Thread erstellt die Synchronisierungs Objekte A, B und G, um den Zugriff auf seine Datenstrukturen zu serialisieren, und versucht dann, Lock G abzurufen. Ein Arbeits Thread, der Lock G bereits erfolgreich abgerufen hat, ruft dann eine Funktion wie z. b. GetModuleHandle auf, die versucht, die Loadersperre zu erhalten. Daher wird der Arbeits Thread in L blockiert, und der Haupt Thread wird auf G blockiert, was zu einem Deadlock führt.</span><span class="sxs-lookup"><span data-stu-id="6dbb3-184">The main thread creates synchronization objects A, B, and G to serialize access to its data structures and then tries to acquire lock G. A worker thread that has already successfully acquired lock G then calls a function such as GetModuleHandle that attempts to acquire the loader lock L. Thus, the worker thread is blocked on L and the main thread is blocked on G, resulting in a deadlock.</span></span>

![Deadlocks aufgrund von Sperr Reihenfolge-Inversion](images/fig2.png)

<span data-ttu-id="6dbb3-186">Um Deadlocks zu verhindern, die durch die Inversion der Sperr Reihenfolge verursacht werden, sollten alle Threads jederzeit versuchen, Synchronisierungs Objekte in der definierten Lade Reihenfolge zu erhalten.</span><span class="sxs-lookup"><span data-stu-id="6dbb3-186">To prevent deadlocks that are caused by lock order inversion, all threads should attempt to acquire synchronization objects in the defined load order at all times.</span></span>

## <a name="best-practices-for-synchronization"></a><span data-ttu-id="6dbb3-187">Bewährte Methoden für die Synchronisierung</span><span class="sxs-lookup"><span data-stu-id="6dbb3-187">Best Practices for Synchronization</span></span>

<span data-ttu-id="6dbb3-188">Angenommen, eine DLL erstellt Arbeitsthreads im Rahmen der Initialisierung.</span><span class="sxs-lookup"><span data-stu-id="6dbb3-188">Consider a DLL that creates worker threads as part of its initialization.</span></span> <span data-ttu-id="6dbb3-189">Bei der dll-Bereinigung ist es erforderlich, eine Synchronisierung mit allen Arbeitsthreads durchzusetzen, um sicherzustellen, dass sich die Datenstrukturen in einem konsistenten Zustand befinden, und dann die Arbeitsthreads zu beenden.</span><span class="sxs-lookup"><span data-stu-id="6dbb3-189">Upon DLL cleanup, it is necessary to synchronize with all the worker threads to ensure that the data structures are in a consistent state and then terminate the worker threads.</span></span> <span data-ttu-id="6dbb3-190">Heute gibt es keine einfache Möglichkeit, das Problem der ordnungsgemäßen Synchronisierung und des herunter Fahrens von DLLs in einer Multithread-Umgebung vollständig zu lösen.</span><span class="sxs-lookup"><span data-stu-id="6dbb3-190">Today, there is no straightforward way to completely solve the problem of cleanly synchronizing and shutting down DLLs in a multithreaded environment.</span></span> <span data-ttu-id="6dbb3-191">In diesem Abschnitt werden die aktuellen bewährten Methoden für die Synchronisierung von Threads beim Herunterfahren der dll beschrieben.</span><span class="sxs-lookup"><span data-stu-id="6dbb3-191">This section describes the current best practices for thread synchronizing during DLL shutdown.</span></span>

<span data-ttu-id="6dbb3-192">Thread Synchronisierung in [**DllMain**](dllmain.md) beim Prozess beenden</span><span class="sxs-lookup"><span data-stu-id="6dbb3-192">Thread Synchronization in [**DllMain**](dllmain.md) during Process Exit</span></span>

-   <span data-ttu-id="6dbb3-193">Wenn [**DllMain**](dllmain.md) beim Prozess beenden aufgerufen wird, wurden alle Threads des Prozesses zwangsweise bereinigt, und es besteht die Möglichkeit, dass der Adressraum inkonsistent ist.</span><span class="sxs-lookup"><span data-stu-id="6dbb3-193">By the time [**DllMain**](dllmain.md) is called at process exit, all the process’s threads have been forcibly cleaned up and there is a chance that the address space is inconsistent.</span></span> <span data-ttu-id="6dbb3-194">Die Synchronisierung ist in diesem Fall nicht erforderlich.</span><span class="sxs-lookup"><span data-stu-id="6dbb3-194">Synchronization is not required in this case.</span></span> <span data-ttu-id="6dbb3-195">Das heißt, der ideale dll- \_ Prozess Trennungs \_ Handler ist leer.</span><span class="sxs-lookup"><span data-stu-id="6dbb3-195">In other words, the ideal DLL\_PROCESS\_DETACH handler is empty.</span></span>
-   <span data-ttu-id="6dbb3-196">Windows Vista stellt sicher, dass die Kern Datenstrukturen (Umgebungsvariablen, Aktuelles Verzeichnis, Prozess Heap usw.) in einem konsistenten Zustand sind.</span><span class="sxs-lookup"><span data-stu-id="6dbb3-196">Windows Vista ensures that core data structures (environment variables, current directory, process heap, and so on) are in a consistent state.</span></span> <span data-ttu-id="6dbb3-197">Allerdings können andere Datenstrukturen beschädigt werden, sodass das Bereinigen des Speichers nicht sicher ist.</span><span class="sxs-lookup"><span data-stu-id="6dbb3-197">However, other data structures can be corrupted, so cleaning memory is not safe.</span></span>
-   <span data-ttu-id="6dbb3-198">Der persistente Zustand, der gespeichert werden muss, muss in einen permanenten Speicher geleert werden.</span><span class="sxs-lookup"><span data-stu-id="6dbb3-198">Persistent state that needs to be saved must be flushed to permanent storage.</span></span>

<span data-ttu-id="6dbb3-199">Thread Synchronisierung in **DllMain** für DLL- \_ Thread Trennung \_ beim Entladen der dll</span><span class="sxs-lookup"><span data-stu-id="6dbb3-199">Thread Synchronization in **DllMain** for DLL\_THREAD\_DETACH during DLL Unload</span></span>

-   <span data-ttu-id="6dbb3-200">Wenn die DLL entladen wird, wird der Adressraum nicht entfernt.</span><span class="sxs-lookup"><span data-stu-id="6dbb3-200">When the DLL is unloaded, the address space is not thrown away.</span></span> <span data-ttu-id="6dbb3-201">Daher wird erwartet, dass die dll ein sauberes Herunterfahren durchführt.</span><span class="sxs-lookup"><span data-stu-id="6dbb3-201">Therefore, the DLL is expected to perform a clean shutdown.</span></span> <span data-ttu-id="6dbb3-202">Dies umfasst die Thread Synchronisierung, geöffnete Handles, den persistenten Zustand und zugeordnete Ressourcen.</span><span class="sxs-lookup"><span data-stu-id="6dbb3-202">This includes thread synchronization, open handles, persistent state, and allocated resources.</span></span>
-   <span data-ttu-id="6dbb3-203">Die Thread Synchronisierung ist schwierig, da das warten auf Threads zum Beenden in [**DllMain**](dllmain.md) einen Deadlock verursachen kann.</span><span class="sxs-lookup"><span data-stu-id="6dbb3-203">Thread synchronization is tricky because waiting on threads to exit in [**DllMain**](dllmain.md) can cause a deadlock.</span></span> <span data-ttu-id="6dbb3-204">Beispielsweise enthält dll A die Loadersperre.</span><span class="sxs-lookup"><span data-stu-id="6dbb3-204">For example, DLL A holds the loader lock.</span></span> <span data-ttu-id="6dbb3-205">Es signalisiert Thread T, zu beenden und zu warten, bis der Thread beendet wird.</span><span class="sxs-lookup"><span data-stu-id="6dbb3-205">It signals thread T to exit and waits for the thread to exit.</span></span> <span data-ttu-id="6dbb3-206">Thread T wird beendet, und das Lade Modul versucht, die Loadersperre zu erhalten, um den **DllMain** von dll A mit dll-Thread Trennung aufzurufen \_ \_ .</span><span class="sxs-lookup"><span data-stu-id="6dbb3-206">Thread T exits and the loader tries to acquire the loader lock to call into DLL A’s **DllMain** with DLL\_THREAD\_DETACH.</span></span> <span data-ttu-id="6dbb3-207">Dies führt zu einem Deadlock.</span><span class="sxs-lookup"><span data-stu-id="6dbb3-207">This causes a deadlock.</span></span> <span data-ttu-id="6dbb3-208">So minimieren Sie das Risiko eines Deadlocks:</span><span class="sxs-lookup"><span data-stu-id="6dbb3-208">To minimize the risk of a deadlock:</span></span>
    -   <span data-ttu-id="6dbb3-209">Dll a Ruft eine DLL \_ -Thread Trennungs \_ Nachricht in seiner [**DllMain**](dllmain.md) -Datei ab und legt ein Ereignis für Thread T fest, das den Vorgang zum Beenden signalisiert.</span><span class="sxs-lookup"><span data-stu-id="6dbb3-209">DLL A gets a DLL\_THREAD\_DETACH message in its [**DllMain**](dllmain.md) and sets an event for thread T, signaling it to exit.</span></span>
    -   <span data-ttu-id="6dbb3-210">Thread T schließt seinen aktuellen Task ab, bringt ihn in einen konsistenten Zustand, signalisiert dll a und wartet unendlich.</span><span class="sxs-lookup"><span data-stu-id="6dbb3-210">Thread T finishes its current task, brings itself to a consistent state, signals DLL A, and waits infinitely.</span></span> <span data-ttu-id="6dbb3-211">Beachten Sie, dass die Konsistenz Prüfungsroutinen dieselben Einschränkungen wie [**DllMain**](dllmain.md) einhalten müssen, um Deadlocks zu vermeiden.</span><span class="sxs-lookup"><span data-stu-id="6dbb3-211">Note that the consistency-checking routines should follow the same restrictions as [**DllMain**](dllmain.md) to avoid deadlocking.</span></span>
    -   <span data-ttu-id="6dbb3-212">DLL A beendet T und weiß, dass es sich in einem konsistenten Zustand befindet.</span><span class="sxs-lookup"><span data-stu-id="6dbb3-212">DLL A terminates T, knowing that it is in a consistent state.</span></span>

<span data-ttu-id="6dbb3-213">Wenn eine DLL entladen wird, nachdem alle Threads erstellt wurden, aber bevor Sie mit der Ausführung beginnen, stürzt der Thread möglicherweise ab.</span><span class="sxs-lookup"><span data-stu-id="6dbb3-213">If a DLL is unloaded after all its threads have been created, but before they begin executing, the threads may crash.</span></span> <span data-ttu-id="6dbb3-214">Wenn die dll im Rahmen der Initialisierung Threads im zugehörigen **DllMain** -Element erstellt hat, ist die Initialisierung einiger Threads möglicherweise nicht abgeschlossen, und die zugehörige DLL- \_ Thread \_ Anfüge Nachricht wartet immer noch auf die Übermittlung an die dll.</span><span class="sxs-lookup"><span data-stu-id="6dbb3-214">If the DLL created threads in its **DllMain** as part of its initialization, some threads may not have finished initialization and their DLL\_THREAD\_ATTACH message is still waiting to be delivered to the DLL.</span></span> <span data-ttu-id="6dbb3-215">Wenn die dll in dieser Situation entladen wird, beginnt Sie mit dem Beenden von Threads.</span><span class="sxs-lookup"><span data-stu-id="6dbb3-215">In this situation, if the DLL is unloaded, it will begin terminating threads.</span></span> <span data-ttu-id="6dbb3-216">Einige Threads werden jedoch möglicherweise hinter der Loadersperre blockiert.</span><span class="sxs-lookup"><span data-stu-id="6dbb3-216">However, some threads may be blocked behind the loader lock.</span></span> <span data-ttu-id="6dbb3-217">Ihre DLL- \_ Thread \_ Anfüge Nachrichten werden verarbeitet, nachdem die Zuordnung der dll aufgehoben wurde, wodurch der Prozess abstürzt.</span><span class="sxs-lookup"><span data-stu-id="6dbb3-217">Their DLL\_THREAD\_ATTACH messages are processed after the DLL has been unmapped, causing the process to crash.</span></span>

## <a name="recommendations"></a><span data-ttu-id="6dbb3-218">Empfehlungen</span><span class="sxs-lookup"><span data-stu-id="6dbb3-218">Recommendations</span></span>

<span data-ttu-id="6dbb3-219">Folgende Richtlinien werden empfohlen:</span><span class="sxs-lookup"><span data-stu-id="6dbb3-219">The following are recommended guidelines:</span></span>

-   <span data-ttu-id="6dbb3-220">Verwenden Sie Application Verifier, um die häufigsten Fehler in [**DllMain**](dllmain.md)abzufangen.</span><span class="sxs-lookup"><span data-stu-id="6dbb3-220">Use Application Verifier to catch the most common errors in [**DllMain**](dllmain.md).</span></span>
-   <span data-ttu-id="6dbb3-221">Wenn Sie in [**DllMain**](dllmain.md)eine private Sperre verwenden, definieren Sie eine Sperr Hierarchie, und verwenden Sie sie einheitlich.</span><span class="sxs-lookup"><span data-stu-id="6dbb3-221">If using a private lock inside [**DllMain**](dllmain.md), define a locking hierarchy and use it consistently.</span></span> <span data-ttu-id="6dbb3-222">Die Loadersperre muss sich am Ende der Hierarchie befinden.</span><span class="sxs-lookup"><span data-stu-id="6dbb3-222">The loader lock must be at the bottom of this hierarchy.</span></span>
-   <span data-ttu-id="6dbb3-223">Vergewissern Sie sich, dass keine Aufrufe von einer anderen dll abhängen, die möglicherweise noch nicht vollständig geladen wurde.</span><span class="sxs-lookup"><span data-stu-id="6dbb3-223">Verify that no calls depend on another DLL that may not have been fully loaded yet.</span></span>
-   <span data-ttu-id="6dbb3-224">Führen Sie einfache Initialisierungen statisch zum Zeitpunkt der Kompilierung anstelle von [**DllMain**](dllmain.md)aus.</span><span class="sxs-lookup"><span data-stu-id="6dbb3-224">Perform simple initializations statically at compile time, rather than in [**DllMain**](dllmain.md).</span></span>
-   <span data-ttu-id="6dbb3-225">Stellen Sie alle Aufrufe in [**DllMain**](dllmain.md) zurück, die bis zu einem späteren Zeitpunkt warten können.</span><span class="sxs-lookup"><span data-stu-id="6dbb3-225">Defer any calls in [**DllMain**](dllmain.md) that can wait until later.</span></span>
-   <span data-ttu-id="6dbb3-226">Verzögert Initialisierungs Tasks, die bis zu einem späteren Zeitpunkt warten können.</span><span class="sxs-lookup"><span data-stu-id="6dbb3-226">Defer initialization tasks that can wait until later.</span></span> <span data-ttu-id="6dbb3-227">Bestimmte Fehlerbedingungen müssen früh erkannt werden, damit die Anwendung Fehler ordnungsgemäß behandeln kann.</span><span class="sxs-lookup"><span data-stu-id="6dbb3-227">Certain error conditions must be detected early so that the application can handle errors gracefully.</span></span> <span data-ttu-id="6dbb3-228">Es gibt jedoch Kompromisse zwischen dieser frühen Erkennung und dem Verlust der Stabilität, die daraus resultieren können.</span><span class="sxs-lookup"><span data-stu-id="6dbb3-228">However, there are tradeoffs between this early detection and the loss of robustness that can result from it.</span></span> <span data-ttu-id="6dbb3-229">Das Verzögern der Initialisierung ist häufig am besten geeignet.</span><span class="sxs-lookup"><span data-stu-id="6dbb3-229">Deferring initialization is often best.</span></span>

 

 
