---
title: Überlegungen zur Eigenschaften Speicherung
description: IPropertyStorage-Lesegeräte Lesevorgänge wie viele der im rgpspec-Array angegebenen Eigenschaften, wie Sie im Eigenschaften Satz enthalten sind.
ms.assetid: 7540966f-a3b2-46c9-9e04-b15133a517eb
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: 2aad6aabf8b22a7c01f91a090136e6cc8156c791
ms.sourcegitcommit: 592c9bbd22ba69802dc353bcb5eb30699f9e9403
ms.translationtype: MT
ms.contentlocale: de-DE
ms.lasthandoff: 08/20/2020
ms.locfileid: "106339887"
---
# <a name="property-storage-considerations"></a>Überlegungen zur Eigenschaften Speicherung

[**IPropertyStorage:: Read Multiple**](/windows/desktop/api/Propidl/nf-propidl-ipropertystorage-readmultiple) liest, wie viele der im *rgpspec* -Array angegebenen Eigenschaften wie im Eigenschaften Satz enthalten sind. Solange eine der angeforderten Eigenschaften gelesen wird, ist eine Anforderung zum Abrufen einer Eigenschaft, die nicht vorhanden ist, kein Fehler. Stattdessen muss dies dazu führen, \_ dass für diese Eigenschaft bei Rückgabe "VT Empty" in das *rgvar* -Array geschrieben wird \[ \] . Wenn keine der angeforderten Eigenschaften vorhanden ist, sollte die Methode "S false" zurückgeben \_ und \_ in jeder [**PROPVARIANT**](/windows/win32/api/propidlbase/ns-propidlbase-propvariant)"VT Empty" festlegen. Wenn ein anderer Fehler zurückgegeben wird, werden keine Eigenschaftswerte abgerufen, und der Aufrufer muss sich nicht darum kümmern, Sie freizugeben.

Der *rgpspec* -Parameter ist ein Array von [**PROPSPEC**](/windows/win32/api/propidlbase/ns-propidlbase-propspec) -Strukturen, die für jede Eigenschaft entweder ihren Eigenschafts Bezeichner oder, wenn eine zugewiesen ist, einen Zeichen folgen Bezeichner angeben. Sie können eine Zeichenfolge einem Eigenschaften Bezeichner zuordnen, indem Sie [**IPropertyStorage:: Beschreib tepropertynames**](/windows/desktop/api/Propidl/nf-propidl-ipropertystorage-writepropertynames)aufrufen. Die Verwendung von Eigenschafts bezeichgern ist jedoch wahrscheinlich wesentlich effizienter als die Verwendung von Zeichen folgen.

Eigenschaften, die durch den Zeichen folgen Namen (prspec \_ LPWSTR) angefordert werden, werden für Eigenschafts Bezeichner (IDs), wie Sie im aktuellen Eigenschaften Satz angegeben sind (und entsprechend dem aktuellen System Gebiets Schema), als nicht sensibel zugeordnet.

Wenn der Eigenschaftentyp VT \_ LPSTR ist und die Eigenschaft aus einem ANSI-Eigenschaften Satz gelesen wird, d. h. die Codepage für den Eigenschaften Satz wird auf einen anderen Wert als Unicode festgelegt, verwendet der Wert der Eigenschaft dieselbe Codepage wie der Eigenschaften Satz. Wenn eine VT \_ LPSTR-Eigenschaft aus einem Unicode-Eigenschaften Satz gelesen wird, verwendet der Wert der-Eigenschaft die aktuelle Standard-ANSI-Codepage des Systems, d. h. die Codepage, die von der **GetACP-** Funktion zurückgegeben wird.

Eine [**PROPVARIANT**](/windows/win32/api/propidlbase/ns-propidlbase-propvariant), mit Ausnahme derer, die Zeiger auf Streams und Storages sind, wird als einfaches **PROPVARIANT** bezeichnet. Diese einfachen **PROPVARIANT**-e empfangen Daten nach Wert, sodass ein Aufruf von [**IPropertyStorage:: infomultiple**](/windows/desktop/api/Propidl/nf-propidl-ipropertystorage-readmultiple) eine Kopie der Daten bereitstellt, die der Aufrufer dann besitzt. Um diese Eigenschaften zu erstellen oder zu aktualisieren, rufen Sie [**IPropertyStorage:: Write-Multiple**](/windows/desktop/api/Propidl/nf-propidl-ipropertystorage-writemultiple)auf.

Im Gegensatz dazu sind die Variant-Typen VT \_ -Stream, VT \_ -Stream \_ -Objekt, VT \_ -Speicher und VT \_ \_ -gespeicherte Objekte nicht einfache Eigenschaften, denn anstelle eines Werts wird von der Methode ein Zeiger auf die festgestellte Schnittstelle abgerufen, von der die Daten dann gelesen werden können. Diese Typen ermöglichen es, große Mengen von Informationen über eine einzelne Eigenschaft zu speichern. Es gibt mehrere Probleme, die bei der Verwendung nicht einfacher Eigenschaften auftreten können.

Um diese Eigenschaften zu erstellen, wie für die anderen Eigenschaften, rufen Sie [**IPropertyStorage:: Write-Multiple**](/windows/desktop/api/Propidl/nf-propidl-ipropertystorage-writemultiple)auf. Anstatt dieselbe Methode zum Aktualisieren aufzurufen, ist es effizienter, zuerst [**IPropertyStorage:: Read Multiple**](/windows/desktop/api/Propidl/nf-propidl-ipropertystorage-readmultiple) aufzurufen, um den Schnittstellen Zeiger auf den Stream oder Speicher zu erhalten, und dann Daten mithilfe der [**IStream**](/windows/desktop/api/Objidl/nn-objidl-istream) -oder [**IStorage**](/windows/desktop/api/Objidl/nn-objidl-istorage) -Methoden zu schreiben. Ein Stream oder Speicher, der über eine Eigenschaft geöffnet wird, wird immer im direkten Modus geöffnet, sodass keine zusätzliche Ebene der untergeordneten Transaktion eingeführt wird. Es kann jedoch sein, dass nach wie vor eine Transaktion für die Eigenschaft als Ganzes festgelegt wird, je nachdem, wie Sie mithilfe von [**IPropertySetStorage**](/windows/desktop/api/Propidl/nn-propidl-ipropertysetstorage)geöffnet oder erstellt wurde. Außerdem werden die Tags für den Zugriffs-und Freigabemodus, die beim Öffnen oder Erstellen des Eigenschaften Satzes angegeben werden, an Eigenschaften basierte Streams oder Storages weitergeleitet.

Die Lebensdauer von Eigenschaften basierten Datenstrom-oder Speicher Zeigern, obwohl theoretisch unabhängig von ihren zugeordneten [**IPropertyStorage**](/windows/desktop/api/Propidl/nn-propidl-ipropertystorage) -und [**IPropertySetStorage**](/windows/desktop/api/Propidl/nn-propidl-ipropertysetstorage) -Zeigern tatsächlich von Ihnen abhängig ist. Die Daten, die durch den Stream oder Speicher sichtbar sind, beziehen sich auf die Transaktion im Eigenschaften Speicher Objekt, aus dem Sie abgerufen wird, ebenso wie bei einem Speicher Objekt (unterstützender [**IStorage**](/windows/desktop/api/Objidl/nn-objidl-istorage)) mit enthaltenen Datenstrom-und Speicher untergeordneten Objekten. Wenn die Transaktion für das übergeordnete Objekt abgebrochen wird, sind vorhandene [**IStream**](/windows/desktop/api/Objidl/nn-objidl-istream) -und **IStorage** -Zeiger, die diesem Objekt untergeordnet sind, nicht mehr zugänglich. Da **IPropertyStorage** die einzige Schnittstelle für das Eigenschaften Speicher Objekt ist, wird die nützliche Lebensdauer der enthaltenen **IStream** -und **IStorage** -Zeiger durch die Lebensdauer der **IPropertyStorage** -Schnittstelle begrenzt.

Die Implementierung muss auch die Situation behandeln, in der dieselbe Stream-oder Speicher Wert Eigenschaft mehrmals durch dieselbe Instanz der [**IPropertyStorage**](/windows/desktop/api/Propidl/nn-propidl-ipropertystorage) -Schnittstelle angefordert wird. Beispielsweise ist in der Implementierung der com-Verbund Datei der offene Vorgang abhängig davon, ob die Eigenschaft bereits geöffnet ist, erfolgreich oder fehlerhaft.

Ein weiteres Problem besteht darin, dass mehrere im transaktiven Modus geöffnet werden. Das Ergebnis hängt von der Isolationsstufe ab, die durch einen Aufruf von [**IPropertySetStorage**](/windows/desktop/api/Propidl/nn-propidl-ipropertysetstorage) -Methoden (entweder die [**Open**](/windows/desktop/api/Propidl/nf-propidl-ipropertysetstorage-open) -Methode oder die [**Create**](/windows/desktop/api/Propidl/nf-propidl-ipropertysetstorage-create) -Methode über die STGM-Flags) zum Zeitpunkt des Öffnens des Eigenschaften Speichers angegeben wurde.

Wenn der aufzurufende Befehl zum Öffnen des Eigenschaften Satzes Lese-/Schreibzugriff angibt, werden [**IStorage**](/windows/desktop/api/Objidl/nn-objidl-istorage) -und [**IStream**](/windows/desktop/api/Objidl/nn-objidl-istream)-Wert-Eigenschaften immer mit Lese-/Schreibzugriff geöffnet. Daten können dann über diese Schnittstellen geschrieben werden, wobei der Wert der Eigenschaft geändert wird. Dies ist die effizienteste Methode, um diese Eigenschaften zu aktualisieren. Der Eigenschafts Wert selbst weist keine zusätzliche Transaktions Schachtelungs Ebene auf, sodass Änderungen im Eigenschaften Speicher Objekt unter der Transaktion (sofern vorhanden) festgelegt werden.

## <a name="storage-and-stream-properties"></a>Speicher-und streameigenschaften

Um einen Stream oder ein Speicher Objekt in einen Eigenschaften Satz zu schreiben, muss der Eigenschaften Satz als nicht einfach erstellt werden. Weitere Informationen zu einfachen und nicht einfachen Eigenschafts Sätzen finden Sie im Abschnitt [Speicher-und Streamobjekte für einen Eigenschaften Satz](storage-vs--stream-for-a-property-set.md). Die folgenden Eigenschafts Typen, die im Feld *VT* der *rgvar* -Array Elemente angegeben sind, sind Stream-oder Speichertypen: VT \_ Stream, VT \_ Storage, VT- \_ Streaming- \_ Objekt, \_ gespeichertes VT- \_ Objekt.

Um einen Stream oder ein Speicher Objekt als Eigenschaft in einem nicht einfachen Eigenschaften Satz zu schreiben, nennen Sie [**IPropertyStorage:: Write-Multiple**](/windows/desktop/api/Propidl/nf-propidl-ipropertystorage-writemultiple). Obwohl Sie diese Methode auch zum Aktualisieren einfacher Eigenschaften aufzurufen, ist es keine effiziente Möglichkeit, Stream-und Speicher Objekte in einem Eigenschaften Satz zu aktualisieren. Dies liegt daran, dass durch das Aktualisieren einer dieser Eigenschaften durch einen Aufrufe von " **Write-Multiple** " im Eigenschaften Speicher Objekt eine Kopie der eingehenden Daten erstellt wird und die [**IStorage**](/windows/desktop/api/Objidl/nn-objidl-istorage) -oder [**IStream**](/windows/desktop/api/Objidl/nn-objidl-istream) -Zeiger nicht über die Dauer dieses Aufrufes hinaus aufbewahrt werden. Es ist in der Regel effizienter, Stream-oder Speicher Objekte direkt zu aktualisieren, indem zuerst [**IPropertyStorage:: Read Multiple**](/windows/desktop/api/Propidl/nf-propidl-ipropertystorage-readmultiple) aufgerufen wird, um den Schnittstellen Zeiger auf den Stream oder den Speicher zu erhalten, und dann Daten über die **IStream** -oder **IStorage** -Methode zu schreiben.

Beispielsweise können Sie [**IPropertyStorage:: Write-Multiple**](/windows/desktop/api/Propidl/nf-propidl-ipropertystorage-writemultiple) aufrufen, um einen **null** -Stream oder ein Speicher Objekt zu schreiben. Die-Implementierung erstellt dann ein leeres-Objekt im Eigenschaften Satz. Sie können dann durch Aufrufen von [**IPropertyStorage:: Read Multiple**](/windows/desktop/api/Propidl/nf-propidl-ipropertystorage-readmultiple)Zugriff auf dieses Objekt erhalten. Wenn Sie mit dem Aktualisieren dieses Objekts fertig sind, müssen Sie es nicht in den Eigenschaften Satz schreiben, da die Updates direkt in den Eigenschaften Satz überlaufen wurden.

Ein Stream oder Speicher, der über eine Eigenschaft geöffnet wird, wird immer im direkten Modus geöffnet, sodass keine zusätzliche Ebene der untergeordneten Transaktion eingeführt wird. Möglicherweise gibt es eine Transaktion für die Eigenschaft, die als Ganzes festgelegt ist. (Z. b. Wenn [**IPropertyStorage**](/windows/desktop/api/Propidl/nn-propidl-ipropertystorage) durch Aufrufen von [**IPropertySetStorage:: Open**](/windows/desktop/api/Propidl/nf-propidl-ipropertysetstorage-open) mit dem STGM \_ abgerufen wurde. Ein transaktives Flag, das im *grsmode* -Parameter festgelegt ist.) Außerdem wird ein Eigenschaften basierter Stream oder Speicher, sofern möglich, im Lese-/Schreibmodus geöffnet, wenn der Modus für den Eigenschaften Satz angegeben wird. Andernfalls wird der Lesemodus verwendet.

Wie bereits erwähnt, wird eine Kopie des-Objekts erstellt, wenn ein Stream-oder Speicher Objekt in einen Eigenschaften Satz geschrieben wird, der mit der " [**Write Multiple**](/windows/desktop/api/Propidl/nf-propidl-ipropertystorage-writemultiple) "-Methode festgelegt wurde. Wenn eine solche Kopie für ein Streamobjekt erstellt wird, wird der Kopiervorgang an der aktuellen Suchposition der Quelle gestartet. Die Suchposition ist bei einem Fehler nicht definiert, aber bei Erfolg befindet Sie sich am Ende des Streams. der Seek-Zeiger wird nicht an seiner ursprünglichen Position wieder hergestellt.

Wenn ein Datenstrom oder eine Speicher Eigenschaft aus einem Eigenschaften Satz gelesen wurde **, der mit** "read [**Multiple**](/windows/desktop/api/Propidl/nf-propidl-ipropertystorage-readmultiple)" festgelegt wurde, bleibt weiterhin geöffnet, und für dieselbe Eigenschaft wird ein nachfolgende Aufrufe von " [**Write Multiple**](/windows/desktop/api/Propidl/nf-propidl-ipropertystorage-writemultiple) " durchgeführt. Die zuvor geöffnete Stream-oder Storage-Eigenschaft wird in den Zustand "wieder hergestellt" versetzt (bei allen Aufrufen an Sie wird "STG E-Fehler zurückgesetzt" zurückgegeben \_ \_ ).

Wenn die [**WriteMultiple**](/windows/desktop/api/Propidl/nf-propidl-ipropertystorage-writemultiple) -Methode einen Fehler zurückgibt, wenn ein Array von Eigenschaften geschrieben wird, oder auch einzelne nicht einfache Eigenschaften, ist die tatsächlich geschriebene Datenmenge nicht definiert.

## <a name="reference-properties"></a>Verweiseigenschaften

Wenn eine angegebene [**PROPVARIANT**](/windows/win32/api/propidlbase/ns-propidlbase-propvariant) -Struktur das VT- \_ ByRef-Flag in das **VT** -Element einschließt, ist die zugehörige Eigenschaft eine Verweis Eigenschaft. Eine Verweis Eigenschaft wird automatisch dereferenziert, bevor der Wert in den Eigenschaften Satz geschrieben wird. Wenn der **VT** -Member der **PROPVARIANT** -Struktur beispielsweise einen Wert vom Typ VT \_ ByRef \| VT I4 angibt \_ , ist der tatsächlich geschriebene Wert ein VT \_ I4-Typ. Bei einem nachfolgenden Aufrufen der [**IPropertyStorage:: Read Multiple**](/windows/desktop/api/Propidl/nf-propidl-ipropertystorage-readmultiple) -Methode wird ein Wert als VT I4 zurückgegeben \_ . Die Verwendung von Verweis Eigenschaften ähnelt dem Aufrufen der [variantcopyind](/windows/win32/api/oleauto/nf-oleauto-variantcopyind) -Funktion. [Variantcopyind](/windows/win32/api/oleauto/nf-oleauto-variantcopyind) gibt die Ziel Variante frei und erstellt eine Kopie der Quelle VARIANTARG. dabei wird die erforderliche Dereferenzierung durchgeführt, wenn die Quelle als VT- \_ ByRef angegeben wird. Diese Funktion ist nützlich, wenn eine Kopie einer Variante benötigt wird, und um sicherzustellen, dass es sich nicht um VT- \_ ByRef handelt, z. b. bei der Handhabung von Argumenten in einer Implementierung von [**IDispatch:: Aufrufen**](/windows/win32/api/oaidl/nf-oaidl-idispatch-invoke).

## <a name="notes-to-callers"></a>Hinweise für Aufrufer

Es wird empfohlen, dass Eigenschaften Sätze als Unicode erstellt werden, indem das propsetflag- \_ ANSI-Flag nicht im *grfFlags* -Parameter von [**IPropertySetStorage:: Create**](/windows/desktop/api/Propidl/nf-propidl-ipropertysetstorage-create)festgelegt wird. Es wird außerdem empfohlen, die Verwendung von VT \_ LPSTR-Werten zu vermeiden und \_ stattdessen VT LPWSTR-Werte zu verwenden. Wenn die Eigenschafts Satz-Codepage Unicode ist, \_ werden VT LPSTR-Zeichen folgen Werte bei der Speicherung in Unicode konvertiert und beim Abrufen zu Multibytezeichen-Zeichen folgen Werten zurück. Wenn die Codepage des Eigenschaften Satzes nicht Unicode ist, werden Eigenschaftsnamen, VT \_ BSTR-Zeichen folgen und nicht einfache Eigenschaftswerte in Multibytezeichen-Zeichen folgen konvertiert, wenn Sie gespeichert werden, und beim Abrufen wieder in Unicode konvertiert, wobei alle die aktuelle System-ANSI-Codepage verwenden.

## <a name="notes-to-implementers"></a>Hinweise für Ausführende

Wenn Sie einen Eigenschafts Bezeichner zuordnen, kann die Implementierung alle Werte auswählen, die derzeit nicht in der Eigenschaft für einen Eigenschafts Bezeichner verwendet werden, solange Sie nicht 0 oder 1 oder größer als 0x80000000 ist, die alle reservierte Werte sind. Der Parameter " *propidnamefirst* " legt einen minimalen Wert für Eigenschaften Bezeichner innerhalb des Satzes fest und muss größer als 1 und kleiner als 0x80000000 sein. Siehe den Abschnitt "Hinweise" oben.

## <a name="related-topics"></a>Zugehörige Themen

<dl> <dt>

[IPropertyStorage-Implementierung der Verbund Datei](ipropertystorage-compound-file-implementation.md)
</dt> <dt>

[IPropertyStorage-NTFS-Datei System Implementierung](ipropertystorage-ntfs-file-system-implementation.md)
</dt> <dt>

[IPropertyStorage-eigenständige Implementierung](ipropertystorage-stand-alone-implementation.md)
</dt> </dl>

 

 