---
title: Auflösung von Funktions-/Eigenschaftennamen-Konflikten bei der Automatisierung in Erweiterungen
description: 'In diesem Thema: \ 0034; Object \ 0034; Gibt das-Objekt als Ganzes als ADSI-Client an. Das heißt, ADSI und alle zugehörigen Erweiterungen.'
ms.assetid: 76207326-879e-408b-8004-06d940401a41
ms.tgt_platform: multiple
keywords:
- Auflösung von Funktions-und Eigenschafts Namenskonflikten bei der Automatisierung in Erweiterungen
- Erweiterungen ADSI, Auflösen von Funktions-und Eigenschafts Namenskonflikten in Automation
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: d9a7ac99b99ecdf0ee1b940f066d9e8166a15542
ms.sourcegitcommit: b0ebdefc3dcd5c04bede94091833aa1015a2f95c
ms.translationtype: MT
ms.contentlocale: de-DE
ms.lasthandoff: 08/21/2020
ms.locfileid: "104391009"
---
# <a name="resolution-of-functionproperty-name-conflicts-in-automation-in-extensions"></a><span data-ttu-id="a51b1-106">Auflösung von Funktions-/Eigenschaftennamen-Konflikten bei der Automatisierung in Erweiterungen</span><span class="sxs-lookup"><span data-stu-id="a51b1-106">Resolution of Function/Property Name Conflicts in Automation in Extensions</span></span>

<span data-ttu-id="a51b1-107">In diesem Thema zeigt "Object" das Objekt als Ganzes als ADSI-Client an.</span><span class="sxs-lookup"><span data-stu-id="a51b1-107">In this topic, "object" indicates the object, as a whole, as an ADSI client views it.</span></span> <span data-ttu-id="a51b1-108">Das heißt, ADSI und alle zugehörigen Erweiterungen.</span><span class="sxs-lookup"><span data-stu-id="a51b1-108">That is, ADSI and all its extensions.</span></span>

## <a name="same-function-name-with-the-same-parameters"></a><span data-ttu-id="a51b1-109">Gleicher Funktions Name mit denselben Parametern</span><span class="sxs-lookup"><span data-stu-id="a51b1-109">Same Function Name With the Same Parameters</span></span>

<span data-ttu-id="a51b1-110">Wenn zwei oder mehr Dual- [**IDispatch**](/windows/win32/api/oaidl/nn-oaidl-idispatch) -Schnittstellen in einem Objekt eine Eigenschaft oder Methode mit demselben Namen unterstützen, z. b. **func1**, wird der Aufruf anhand der folgenden Kriterien festgelegt.</span><span class="sxs-lookup"><span data-stu-id="a51b1-110">If two or more dual [**IDispatch**](/windows/win32/api/oaidl/nn-oaidl-idispatch) interfaces in an object support a property or method of the same name, for example, **Func1**, invocation is determined using the following criteria.</span></span> <span data-ttu-id="a51b1-111">Wenn der Client über einen Zeiger auf eine der Dual-Schnittstellen verfügt, die eine Methode mit dem Namen **func1** unterstützen, und wenn die Automatisierungs Umgebung Vtable-Zugriff unterstützt, wird **func1** direkt über den ADSI Vtable-Zugriff aufgerufen.</span><span class="sxs-lookup"><span data-stu-id="a51b1-111">If the client has a pointer to one of the dual interfaces that support a method called **Func1** and if the Automation environment supports vtable access, **Func1** is invoked directly through ADSI vtable access.</span></span>

<span data-ttu-id="a51b1-112">Wenn eine der oben genannten Bedingungen false ist, werden [**IDispatch:: GetIDsOfNames**](/windows/win32/api/oaidl/nf-oaidl-idispatch-getidsofnames) und [**IDispatch:: Aufrufen**](/windows/win32/api/oaidl/nf-oaidl-idispatch-invoke) aufgerufen, um **func1** aufzurufen.</span><span class="sxs-lookup"><span data-stu-id="a51b1-112">If either of the conditions above is false, [**IDispatch::GetIDsOfNames**](/windows/win32/api/oaidl/nf-oaidl-idispatch-getidsofnames) and [**IDispatch::Invoke**](/windows/win32/api/oaidl/nf-oaidl-idispatch-invoke) are called to invoke **Func1**.</span></span>

<span data-ttu-id="a51b1-113">Weitere Informationen und eine kurze Erläuterung darüber, wie ein Client einen Zeiger auf eine duale Schnittstelle und eine Beschreibung der Typen von Umgebungen, die den vtable-Zugriff unterstützen, hinzufügen können, finden Sie unter [späte Bindung im Vergleich zu Vtable-Zugriff im ADSI-Erweiterungs Modell](late-binding-vs--vtable-access-in-the-adsi-extension-model.md).</span><span class="sxs-lookup"><span data-stu-id="a51b1-113">For more information and a brief explanation about how a client can add a pointer to a dual interface, and a description of the types of environments that support vtable access, see [Late Binding versus Vtable Access in the ADSI Extension Model](late-binding-vs--vtable-access-in-the-adsi-extension-model.md).</span></span>

<span data-ttu-id="a51b1-114">Da alle Erweiterungs Objekte die [**IDispatch**](/windows/win32/api/oaidl/nn-oaidl-idispatch) -Funktionen zurück an den Aggregator umleiten, steuert der Aggregator, welche **func1** aufgerufen wird.</span><span class="sxs-lookup"><span data-stu-id="a51b1-114">Because all extension objects redirect the [**IDispatch**](/windows/win32/api/oaidl/nn-oaidl-idispatch) functions back to the aggregator, the aggregator controls which **Func1** is invoked.</span></span> <span data-ttu-id="a51b1-115">Die Regeln lauten wie folgt:</span><span class="sxs-lookup"><span data-stu-id="a51b1-115">The rules are:</span></span>

-   <span data-ttu-id="a51b1-116">Wenn eine beliebige Schnittstelle vorhanden ist, und wenn eine beliebige Schnittstelle vorhanden ist, unterstützt der Aggregator im Aggregator (ADSI) eine Funktion mit dem Namen **func1**, ruft der Aggregator seinen eigenen **func1** auf.</span><span class="sxs-lookup"><span data-stu-id="a51b1-116">If any interface, and there will be only one, if any, in the aggregator (ADSI) supports a function called **Func1**, the aggregator invokes its own **Func1**.</span></span>
-   <span data-ttu-id="a51b1-117">Andernfalls durchläuft der Aggregator alle seine Erweiterungen in der Reihenfolge, die in der Registrierung aufgeführt ist, und sucht die erste Erweiterung, die eine Funktion mit dem Namen **func1** implementiert.</span><span class="sxs-lookup"><span data-stu-id="a51b1-117">Otherwise, the aggregator goes through each of its extensions, in the order listed in the registry, and finds the first extension that implements a function called **Func1**.</span></span> <span data-ttu-id="a51b1-118">Es ist möglich, aber unwahrscheinlich, dass mehrere Dual- [**IDispatch**](/windows/win32/api/oaidl/nn-oaidl-idispatch) -Schnittstellen in dieser ersten Erweiterung eine Funktion mit dem Namen **func1** haben.</span><span class="sxs-lookup"><span data-stu-id="a51b1-118">It is possible, but unlikely, that multiple dual [**IDispatch**](/windows/win32/api/oaidl/nn-oaidl-idispatch) interfaces in this first extension have a function called **Func1**.</span></span> <span data-ttu-id="a51b1-119">Die Erweiterung muss bestimmen, welche **func1** immer in Automation aufgerufen werden soll.</span><span class="sxs-lookup"><span data-stu-id="a51b1-119">The extension must determine which **Func1** should always be invoked in Automation.</span></span>

## <a name="same-function-name-with-different-parameters"></a><span data-ttu-id="a51b1-120">Gleicher Funktions Name mit unterschiedlichen Parametern</span><span class="sxs-lookup"><span data-stu-id="a51b1-120">Same Function Name With Different Parameters</span></span>

<span data-ttu-id="a51b1-121">Im vorherigen Abschnitt wurde erläutert, wie Funktionsnamen Konflikte aufgelöst werden, d. h. Funktionsnamen, die den gleichen Funktionsnamen und die gleiche Parameterliste aufweisen, wie z. b. Anzahl, Typ und Reihenfolge, wenn Sie in Automation auftritt.</span><span class="sxs-lookup"><span data-stu-id="a51b1-121">The previous section discussed how to resolve function name conflicts, that is, function names that have the same function name and same parameter list, such as number, type and order, when it occurs in Automation.</span></span> <span data-ttu-id="a51b1-122">Was geschieht, wenn zwei Funktionen denselben Namen, aber unterschiedliche Parameter aufweisen?</span><span class="sxs-lookup"><span data-stu-id="a51b1-122">What if two functions have the same name but different parameters?</span></span> <span data-ttu-id="a51b1-123">Wenn ein ADSI-Client die Funktion mithilfe von [**IDispatch:: GetIDsOfNames**](/windows/win32/api/oaidl/nf-oaidl-idispatch-getidsofnames) aufruft, ohne mehrere Namen zum Angeben der Parameter zu verwenden, kann das ADSI-Erweiterungs Modell die Funktionen nicht unterscheiden.</span><span class="sxs-lookup"><span data-stu-id="a51b1-123">If an ADSI client invokes the function using [**IDispatch::GetIDsOfNames**](/windows/win32/api/oaidl/nf-oaidl-idispatch-getidsofnames) without using multiple names to specify the parameters, the ADSI extension model cannot disambiguate the functions.</span></span> <span data-ttu-id="a51b1-124">Basierend auf dem oben beschriebenen Auflösungs Schema ist die erste Erweiterung in der Registrierung, die diese Funktion über eine der Schnittstellen unterstützt, Ihre Version dieser Funktion wird aufgerufen, und der Aufruf schlägt möglicherweise fehl oder liefert falsche Ergebnisse.</span><span class="sxs-lookup"><span data-stu-id="a51b1-124">Based on the resolution scheme discussed in above, the first extension in the registry that supports this function through one of its interfaces has its version of this function invoked, and the call may fail or yield incorrect results.</span></span>

<span data-ttu-id="a51b1-125">Beispiel:</span><span class="sxs-lookup"><span data-stu-id="a51b1-125">For example:</span></span>

-   <span data-ttu-id="a51b1-126">Extn1 (First in der Registrierung unter der Klasse ca – höhere Priorität) unterstützt **IInterface1**.</span><span class="sxs-lookup"><span data-stu-id="a51b1-126">Extn1 (first in the registry under class CA – higher priority) supports **IInterface1**.</span></span>
-   <span data-ttu-id="a51b1-127">Extn2 (drittes in der Registrierung unter Class ca – niedrigere Priorität) unterstützt **IInterface2**.</span><span class="sxs-lookup"><span data-stu-id="a51b1-127">Extn2 (third in the registry under class CA – lower priority) supports **IInterface2**.</span></span>
-   <span data-ttu-id="a51b1-128">**IInterface1** unterstützt **Methode1 (int param1, int param2)**.</span><span class="sxs-lookup"><span data-stu-id="a51b1-128">**IInterface1** supports **Method1(int param1, int param2)**.</span></span>
-   <span data-ttu-id="a51b1-129">**IInterface2** unterstützt **Methode1 (int Param1)**.</span><span class="sxs-lookup"><span data-stu-id="a51b1-129">**IInterface2** supports **Method1(int param1)**.</span></span>

<span data-ttu-id="a51b1-130">Ein ADSI-Client verfügt über einen [**IDispatch**](/windows/win32/api/oaidl/nn-oaidl-idispatch) -Schnittstellen Zeiger auf ein Objekt der Klasse ca.</span><span class="sxs-lookup"><span data-stu-id="a51b1-130">An ADSI client has an [**IDispatch**](/windows/win32/api/oaidl/nn-oaidl-idispatch) interface pointer to an object of class CA.</span></span> <span data-ttu-id="a51b1-131">Er möchte **IInterface2:: Methode1** aufrufen.</span><span class="sxs-lookup"><span data-stu-id="a51b1-131">It wants to invoke **IInterface2::Method1**.</span></span> <span data-ttu-id="a51b1-132">Wenn der Client "pdispatch->GetIDsOfNames (IID null) aufruft \_ , rgsznames, 1, My \_ LCID, rgdispid)" durch einfaches Speichern des Funktionsnamens "Methode1" in *rgsznames \[ 0 \]*, dann **IInterface1:: Methode1** anstelle der gewünschten **IInterface2:: Methode1** wird aufgerufen, und die Funktion schlägt fehl, da die Anzahl der Parameter unterschiedlich ist.</span><span class="sxs-lookup"><span data-stu-id="a51b1-132">If the client calls "pDispatch->GetIDsOfNames(IID\_NULL, rgszNames, 1, MY\_LCID, rgDispId)" by just storing the function name "Method1" in *rgszNames\[0\]*, then **IInterface1::Method1** instead of the desired **IInterface2::Method1** is invoked, and the function fails because the number of parameters are different.</span></span>

<span data-ttu-id="a51b1-133">Um dieses Problem zu minimieren, können Erweiterungs Entwickler ihre Funktionsnamen mit ihren eigenen spezifischen bezeichtern versehen und Schnittstellen Entwürfe vermeiden, die Funktionen mit dem gleichen Namen, aber unterschiedlichen Parametern verwenden.</span><span class="sxs-lookup"><span data-stu-id="a51b1-133">To minimize this problem, extension developers can prefix their function names with their own specific identifiers and avoid interface designs that use functions of the same name, but different parameters.</span></span>

<span data-ttu-id="a51b1-134">Wenn ein namens Konflikt auftritt, können ADSI-Clients das Problem durch direkten Vtable-Zugriff vermeiden, wenn es sich bei der Schnittstelle um eine duale Schnittstelle handelt.</span><span class="sxs-lookup"><span data-stu-id="a51b1-134">If a name conflict does occur, ADSI clients can avoid the problem by direct vtable access if the interface is a dual interface.</span></span> <span data-ttu-id="a51b1-135">Wenn kein direkter Vtable-Zugriff möglich ist, sollten ADSI-Clients [**IDispatch:: GetIDsOfNames**](/windows/win32/api/oaidl/nf-oaidl-idispatch-getidsofnames) mit mehreren Namen aufrufen und dabei die Funktionsnamen sowie die Parameter in dem zuvor beschriebenen Array *rgsznames* angeben.</span><span class="sxs-lookup"><span data-stu-id="a51b1-135">If direct vtable access is not possible, ADSI clients should call [**IDispatch::GetIDsOfNames**](/windows/win32/api/oaidl/nf-oaidl-idispatch-getidsofnames) with multiple names, specifying the function names as well as the parameters in the array *rgszNames* described previously.</span></span>

<span data-ttu-id="a51b1-136">In Visual Basic 5 wird die [**IDispatch:: GetIDsOfNames**](/windows/win32/api/oaidl/nf-oaidl-idispatch-getidsofnames) -Funktion nicht mit mehreren Namen aufgerufen.</span><span class="sxs-lookup"><span data-stu-id="a51b1-136">Visual Basic 5 does not call the [**IDispatch::GetIDsOfNames**](/windows/win32/api/oaidl/nf-oaidl-idispatch-getidsofnames) function with multiple names.</span></span> <span data-ttu-id="a51b1-137">Das heißt, es übergibt nur den Funktionsnamen an **GetIDsOfNames**, aber keine Argumente.</span><span class="sxs-lookup"><span data-stu-id="a51b1-137">That is, it passes only the function name to **GetIDsOfNames**, but not arguments.</span></span> <span data-ttu-id="a51b1-138">Allerdings ermöglicht Visual Basic 5 Benutzern, eine Funktion durch direkten Vtable-Zugriff aufzurufen, anstatt die Funktion **IDispatch:: GetIDsOfNames** aufzurufen, wenn die Schnittstelle eine duale Schnittstelle ist.</span><span class="sxs-lookup"><span data-stu-id="a51b1-138">However, Visual Basic 5 allows users to invoke a function by direct vtable access, instead of invoking the **IDispatch::GetIDsOfNames** function if the interface is a dual interface.</span></span> <span data-ttu-id="a51b1-139">Entwickler sollten, sofern möglich, direkten Vtable-Zugriff verwenden.</span><span class="sxs-lookup"><span data-stu-id="a51b1-139">Developers should use direct vtable access, if possible.</span></span>

<span data-ttu-id="a51b1-140">Weitere Informationen zur Auflösung von Namenskonflikten finden Sie unter [Beispiel für das Auflösen von Funktionsnamen Konflikten](example-for-resolving-function-name-conflicts.md).</span><span class="sxs-lookup"><span data-stu-id="a51b1-140">For more information about name conflict resolution, see [Example for Resolving Function Name Conflicts](example-for-resolving-function-name-conflicts.md).</span></span>

 

 