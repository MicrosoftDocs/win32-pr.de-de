---
title: Behandeln von Trägheit in nicht verwaltetem Code
description: In diesem Abschnitt wird erläutert, wie Sie die IInertiaProcessor-Schnittstelle für die Handhabung von Trägheit in nicht verwaltetem Code verwenden.
ms.assetid: 3261b461-add2-4e92-9a51-b2d46630fb4f
keywords:
- Windows-Fingereingabe, Trägheit
- Windows-Fingereingabe, Manipulations Prozessor
- Trägheit, nicht verwalteter Code
- Trägheit, IInertiaProcessor-Schnittstelle
- Trägheit, Manipulations Prozessor
- Manipulations Prozessor, Trägheit
- IInertiaProcessor-Schnittstelle, nicht verwalteter Code
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: 3de56d06547f426de252a89ef5172df3fe4ca439
ms.sourcegitcommit: 2d531328b6ed82d4ad971a45a5131b430c5866f7
ms.translationtype: MT
ms.contentlocale: de-DE
ms.lasthandoff: 09/16/2019
ms.locfileid: "104036445"
---
# <a name="handling-inertia-in-unmanaged-code"></a><span data-ttu-id="6aec6-110">Behandeln von Trägheit in nicht verwaltetem Code</span><span class="sxs-lookup"><span data-stu-id="6aec6-110">Handling Inertia in Unmanaged Code</span></span>

<span data-ttu-id="6aec6-111">In diesem Abschnitt wird erläutert, wie Sie die [**IInertiaProcessor**](/windows/desktop/api/manipulations/nn-manipulations-iinertiaprocessor) -Schnittstelle für die Handhabung von Trägheit in nicht verwaltetem Code verwenden.</span><span class="sxs-lookup"><span data-stu-id="6aec6-111">This section explains how to use the [**IInertiaProcessor**](/windows/desktop/api/manipulations/nn-manipulations-iinertiaprocessor) interface for handling inertia in unmanaged code.</span></span>

## <a name="overview"></a><span data-ttu-id="6aec6-112">Übersicht</span><span class="sxs-lookup"><span data-stu-id="6aec6-112">Overview</span></span>

<span data-ttu-id="6aec6-113">Um Trägheit in nicht verwaltetem Code zu verwenden, müssen Sie sowohl für den Manipulations Prozessor als auch für den Trägheits Prozessor Ereignis senken implementieren.</span><span class="sxs-lookup"><span data-stu-id="6aec6-113">To use inertia in unmanaged code, you must implement event sinks both for the manipulation processor and the inertia processor.</span></span> <span data-ttu-id="6aec6-114">Beginnen Sie mit dem Hinzufügen von Bearbeitungs Unterstützung zu Ihrer Anwendung, wie im Abschnitt [Hinzufügen von Manipulations Unterstützung zu nicht verwaltetem Code](adding-manipulation-support-in-unmanaged-code.md)beschrieben.</span><span class="sxs-lookup"><span data-stu-id="6aec6-114">Start by adding manipulation support to your application as described in the section [Adding Manipulation Support to Unmanaged Code](adding-manipulation-support-in-unmanaged-code.md).</span></span> <span data-ttu-id="6aec6-115">Beachten Sie, dass die Bearbeitungs Unterstützung erfordert, dass Sie touchnachrichten anstelle von Gesten Nachrichten verwenden, um Ereignisdaten an den Manipulations Prozessor zu senden.</span><span class="sxs-lookup"><span data-stu-id="6aec6-115">Note that manipulation support requires that you use touch messages rather than gesture messages to feed event data to the manipulation processor.</span></span> <span data-ttu-id="6aec6-116">Nachdem Sie die Bearbeitung bearbeitet haben, müssen Sie auch eine zweite Ereignis Senke für die Ereignisse implementieren, die von der [**IInertiaProcessor**](/windows/desktop/api/manipulations/nn-manipulations-iinertiaprocessor) -Schnittstelle generiert werden, oder Sie müssen die vorhandene Ereignis Senke ändern, damit die von den **IInertiaProcessor** -und [**IManipulationProcessor**](/windows/desktop/api/manipulations/nn-manipulations-imanipulationprocessor) -Schnittstellen generierten Ereignisse berücksichtigt werden.</span><span class="sxs-lookup"><span data-stu-id="6aec6-116">After you have manipulation working, you must also implement a second event sink for the events that the [**IInertiaProcessor**](/windows/desktop/api/manipulations/nn-manipulations-iinertiaprocessor) interface will be generating or will need to modify your existing event sink to accommodate both the events generated by the **IInertiaProcessor** and the [**IManipulationProcessor**](/windows/desktop/api/manipulations/nn-manipulations-imanipulationprocessor) interfaces.</span></span> <span data-ttu-id="6aec6-117">Im Rahmen dieses Beispiels ist es einfacher, von der Ereignis Senke zu starten, die für den Abschnitt Hinzufügen von Manipulations Unterstützung zu nicht verwaltetem Code erstellt wurde, und einen zweiten Konstruktor hinzuzufügen, der mit dem Trägheits Prozessor anstelle des Manipulations Prozessors funktioniert.</span><span class="sxs-lookup"><span data-stu-id="6aec6-117">For the purposes of this example, it is easier to start from the event sink created for the section Adding Manipulation Support to Unmanaged Code and add a second constructor that works with the inertia processor instead of the manipulation processor.</span></span> <span data-ttu-id="6aec6-118">Auf diese Weise kann die Implementierung der Ereignis Senke entweder für den Bearbeitungs Prozessor oder den Trägheits Prozessor funktionieren.</span><span class="sxs-lookup"><span data-stu-id="6aec6-118">This way, the event sink implementation can function for either the manipulation processor or the inertia processor.</span></span> <span data-ttu-id="6aec6-119">Zusätzlich zum Hinzufügen eines zweiten Konstruktors hat die Ereignis Senke eine Variable, die angibt, ob die Vorgänge auf der Grundlage von Trägheit-Eingaben anstelle von Bearbeitungs Eingaben durchgeführt werden.</span><span class="sxs-lookup"><span data-stu-id="6aec6-119">In addition to adding a second constructor, the event sink will have a variable indicating whether it will perform the operations based on inertia input rather than manipulation input.</span></span>

### <a name="add-inertia-support-to-a-manipulation-processor-event-sink"></a><span data-ttu-id="6aec6-120">Hinzufügen der trägheitunterstützung zu einer Bearbeitungs Prozessor-Ereignis</span><span class="sxs-lookup"><span data-stu-id="6aec6-120">Add Inertia Support to a Manipulation Processor Event Sink</span></span>

<span data-ttu-id="6aec6-121">Der folgende Code zeigt den neuen ereignisenkenkonstruktor, neue Member-Variablen für eine [**IInertiaProcessor**](/windows/desktop/api/manipulations/nn-manipulations-iinertiaprocessor) -Schnittstelle und ein Flag, das angibt, ob die Senke für Trägheit extrapoliert.</span><span class="sxs-lookup"><span data-stu-id="6aec6-121">The following code shows the new event sink constructor, new member variables for an [**IInertiaProcessor**](/windows/desktop/api/manipulations/nn-manipulations-iinertiaprocessor) interface, and a flag indicating whether the sink is extrapolating for inertia.</span></span>


```C++
    CManipulationEventSink(IManipulationProcessor *pManip, IInertiaProcessor *pInert, HWND hWnd);
    CManipulationEventSink(IInertiaProcessor *pInert, HWND hWnd);
```




```C++
    IInertiaProcessor*      m_pInert;
    BOOL fExtrapolating; 
```



<span data-ttu-id="6aec6-122">Nachdem der Klassen Header über die neuen Konstruktoren und ein Flag verfügt, das angibt, ob Sie die Extrapolierung durchführen, können Sie die Ereignis Senke implementieren, um separate Verarbeitungsblöcke für die [**IManipulationProcessor**](/windows/desktop/api/manipulations/nn-manipulations-imanipulationprocessor) -Ereignisse und [**IInertiaProcessor**](/windows/desktop/api/manipulations/nn-manipulations-iinertiaprocessor) -Ereignisse zu verwenden.</span><span class="sxs-lookup"><span data-stu-id="6aec6-122">After your class header has the new constructors and a flag indicating whether you're extrapolating, you can implement your event sink to have separate handling blocks for the [**IManipulationProcessor**](/windows/desktop/api/manipulations/nn-manipulations-imanipulationprocessor) events and [**IInertiaProcessor**](/windows/desktop/api/manipulations/nn-manipulations-iinertiaprocessor) events.</span></span> <span data-ttu-id="6aec6-123">Der Konstruktor, der einen **IManipulationProcessor** und einen **IInertiaProcessor** akzeptiert, sollte das **fextrapolierungsflag** auf false festlegen, was darauf hinweist, dass es sich hierbei um einen **IManipulationProcessor** -Ereignishandler handelt.</span><span class="sxs-lookup"><span data-stu-id="6aec6-123">The constructor that accepts an **IManipulationProcessor** and an **IInertiaProcessor** should set the **fExtrapolating** flag to false, which indicates that this is a **IManipulationProcessor** event handler.</span></span> <span data-ttu-id="6aec6-124">Der folgende Code zeigt, wie der Konstruktor für eine Ereignis Senke, die den **IManipulationProcessor** verwendet, implementiert werden kann.</span><span class="sxs-lookup"><span data-stu-id="6aec6-124">The following code shows how the constructor for an event sink that uses the **IManipulationProcessor** could be implemented.</span></span>


```C++
CManipulationEventSink::CManipulationEventSink(IManipulationProcessor *pManip, IInertiaProcessor *pInert, HWND hWnd)
{
    m_hWnd = hWnd;

    //Set initial ref count to 1.
    m_cRefCount = 1;

    fExtrapolating=FALSE;

    m_pManip = pManip;
    
    m_pInert = pInert;
    
    m_pManip->put_PivotRadius(-1);

    m_cStartedEventCount = 0;
    m_cDeltaEventCount = 0;
    m_cCompletedEventCount = 0;

    HRESULT hr = S_OK;

    //Get the container with the connection points.
    IConnectionPointContainer* spConnectionContainer;
    
    hr = pManip->QueryInterface(
      IID_IConnectionPointContainer, 
          (LPVOID*) &spConnectionContainer
        );
    //hr = manip->QueryInterface(&spConnectionContainer);
    if (spConnectionContainer == NULL){
        // something went wrong, try to gracefully quit
        
    }

    //Get a connection point.
    hr = spConnectionContainer->FindConnectionPoint(__uuidof(_IManipulationEvents), &m_pConnPoint);
    if (m_pConnPoint == NULL){
        // something went wrong, try to gracefully quit
    }

    DWORD dwCookie;

    //Advise.
    hr = m_pConnPoint->Advise(this, &dwCookie);
}
```



<span data-ttu-id="6aec6-125">Der folgende Code zeigt, wie der Konstruktor für eine Ereignis Senke, die den [**IInertiaProcessor**](/windows/desktop/api/manipulations/nn-manipulations-iinertiaprocessor) verwendet, implementiert werden kann.</span><span class="sxs-lookup"><span data-stu-id="6aec6-125">The following code shows how the constructor for an event sink that uses the [**IInertiaProcessor**](/windows/desktop/api/manipulations/nn-manipulations-iinertiaprocessor) could be implemented.</span></span> <span data-ttu-id="6aec6-126">Dieser Konstruktor legt das **fextraktions** Flag auf true fest und gibt an, dass diese Instanz der Ereignis Senkenklasse eine extra Polierung ausführt und alle Verschiebungs Vorgänge ausführt, die zuvor von den Manipulations Prozessor Ereignissen durchgeführt wurden.</span><span class="sxs-lookup"><span data-stu-id="6aec6-126">This constructor sets the **fExtrapolating** flag to true, indicating that this instance of the event sink class will be performing extrapolation and will perform any movement operations that were performed previously by the manipulation processor events.</span></span>


```C++
CManipulationEventSink::CManipulationEventSink(IInertiaProcessor *pInert, HWND hWnd)
{
    m_hWnd = hWnd;

    m_pInert = pInert;
    //Set initial ref count to 1.
    m_cRefCount = 1;

    fExtrapolating=TRUE;

    m_cStartedEventCount = 0;
    m_cDeltaEventCount = 0;
    m_cCompletedEventCount = 0;

    HRESULT hr = S_OK;

    //Get the container with the connection points.
    IConnectionPointContainer* spConnectionContainer;
    
    hr = pInert->QueryInterface(
      IID_IConnectionPointContainer, 
          (LPVOID*) &spConnectionContainer
        );
    //hr = manip->QueryInterface(&spConnectionContainer);
    if (spConnectionContainer == NULL){
        // something went wrong, try to gracefully quit        
    }

    //Get a connection point.
    hr = spConnectionContainer->FindConnectionPoint(__uuidof(_IManipulationEvents), &m_pConnPoint);
    if (m_pConnPoint == NULL){
        // something went wrong, try to gracefully quit
    }
    DWORD dwCookie;

    //Advise.
    hr = m_pConnPoint->Advise(this, &dwCookie);
}   
```



> [!Note]  
> <span data-ttu-id="6aec6-127">Die Implementierung der Implementierung der Ereignis Senke von der Manipulations Prozessor-Ereignis Senke wird als Ereignis Senke für den Trägheits Prozessor wieder verwendet</span><span class="sxs-lookup"><span data-stu-id="6aec6-127">The event sink class implementation from the manipulation processor event sink is reused as an event sink for the inertia processor.</span></span>

 

<span data-ttu-id="6aec6-128">Wenn Sie diese Klasse ( **CManipulationEventSink**) erstellen, kann Sie nun entweder als Ereignis Senke für einen Bearbeitungs Prozessor oder als Ereignis Senke für einen Trägheits Prozessor erstellt werden.</span><span class="sxs-lookup"><span data-stu-id="6aec6-128">Now when you construct this class, **CManipulationEventSink**, it can either be constructed as an event sink for a manipulation processor or as an event sink for an inertia processor.</span></span> <span data-ttu-id="6aec6-129">Wenn Sie als Trägheits-Prozessor-Ereignis Senke erstellt wird, wird das **fextrahierende** Flag auf true festgelegt, um anzugeben, dass Manipulations Ereignisse extrapoliert werden sollen.</span><span class="sxs-lookup"><span data-stu-id="6aec6-129">When it's constructed as an inertia processor event sink, it will have the **fExtrapolating** flag set to true, indicating that manipulation events should be extrapolated.</span></span>

> [!Note]  
> <span data-ttu-id="6aec6-130">[**ManipulationStarted**](/windows/win32/api/manipulations/nf-manipulations-_imanipulationevents-manipulationstarted) wird von den Schnittstellen [**IManipulationProcessor**](/windows/desktop/api/manipulations/nn-manipulations-imanipulationprocessor) und [**IInertiaProcessor**](/windows/desktop/api/manipulations/nn-manipulations-iinertiaprocessor) ausgelöst.</span><span class="sxs-lookup"><span data-stu-id="6aec6-130">[**ManipulationStarted**](/windows/win32/api/manipulations/nf-manipulations-_imanipulationevents-manipulationstarted) will be raised by both the [**IManipulationProcessor**](/windows/desktop/api/manipulations/nn-manipulations-imanipulationprocessor) and [**IInertiaProcessor**](/windows/desktop/api/manipulations/nn-manipulations-iinertiaprocessor) interfaces.</span></span>

 

<span data-ttu-id="6aec6-131">Wenn die Manipulation gestartet wird, werden die Eigenschaften der [**IInertiaProcessor**](/windows/desktop/api/manipulations/nn-manipulations-iinertiaprocessor) -Schnittstelle festgelegt.</span><span class="sxs-lookup"><span data-stu-id="6aec6-131">When manipulation starts, the [**IInertiaProcessor**](/windows/desktop/api/manipulations/nn-manipulations-iinertiaprocessor) interface properties are set.</span></span> <span data-ttu-id="6aec6-132">Der folgende Code zeigt, wie das gestartete Ereignis behandelt wird.</span><span class="sxs-lookup"><span data-stu-id="6aec6-132">The following code shows how the started event is handled.</span></span>


```C++
HRESULT STDMETHODCALLTYPE CManipulationEventSink::ManipulationStarted( 
    /* [in] */ FLOAT x,
    /* [in] */ FLOAT y)
{
    m_cStartedEventCount ++;       

    // set origins in manipulation processor
    m_pInert->put_InitialOriginX(x);
    m_pInert->put_InitialOriginY(y);
    
    RECT screenRect;

    HWND desktop = GetDesktopWindow();
    GetClientRect(desktop, &screenRect);

    // physics settings
    // deceleration is units per square millisecond
    m_pInert->put_DesiredDeceleration(.1f);

    // set the boundaries        
    screenRect.left-= 1024;
    m_pInert->put_BoundaryLeft  ( static_cast<float>(screenRect.left   * 100));
    m_pInert->put_BoundaryTop   ( static_cast<float>(screenRect.top    * 100));
    m_pInert->put_BoundaryRight ( static_cast<float>(screenRect.right  * 100));
    m_pInert->put_BoundaryBottom( static_cast<float>(screenRect.bottom * 100));
    
    
    // Elastic boundaries - I set these to 90% of the screen 
    // so... 5% at left, 95% right, 5% top,  95% bottom
    // Values are whole numbers because units are in centipixels
    m_pInert->put_ElasticMarginLeft  (static_cast<float>(screenRect.left   * 5));
    m_pInert->put_ElasticMarginTop   (static_cast<float>(screenRect.top    * 5));
    m_pInert->put_ElasticMarginRight (static_cast<float>(screenRect.right  * 95));
    m_pInert->put_ElasticMarginBottom(static_cast<float>(screenRect.bottom * 95));
    
    
    return S_OK;
}
```



<span data-ttu-id="6aec6-133">In diesem Beispiel werden Manipulations Delta Vorgänge verwendet, um das Fenster zu verschieben.</span><span class="sxs-lookup"><span data-stu-id="6aec6-133">In this example, manipulation deltas are used to move the window around.</span></span> <span data-ttu-id="6aec6-134">Der folgende Code zeigt, wie das Delta Ereignis behandelt wird.</span><span class="sxs-lookup"><span data-stu-id="6aec6-134">The following code shows how the delta event is handled.</span></span>


```C++
HRESULT STDMETHODCALLTYPE CManipulationEventSink::ManipulationDelta( 
    /* [in] */ FLOAT x,
    /* [in] */ FLOAT y,
    /* [in] */ FLOAT translationDeltaX,
    /* [in] */ FLOAT translationDeltaY,
    /* [in] */ FLOAT scaleDelta,
    /* [in] */ FLOAT expansionDelta,
    /* [in] */ FLOAT rotationDelta,
    /* [in] */ FLOAT cumulativeTranslationX,
    /* [in] */ FLOAT cumulativeTranslationY,
    /* [in] */ FLOAT cumulativeScale,
    /* [in] */ FLOAT cumulativeExpansion,
    /* [in] */ FLOAT cumulativeRotation)
{
    m_cDeltaEventCount ++;
        
    RECT rect;
            
    GetWindowRect(m_hWnd, &rect);
        
    int oldWidth =  rect.right-rect.left;
    int oldHeight = rect.bottom-rect.top;            

    // scale and translate the window size / position    
    MoveWindow(m_hWnd,                                              // the window to move
        static_cast<int>(rect.left + (translationDeltaX / 100.0f)), // the x position
        static_cast<int>(rect.top + (translationDeltaY/100.0f)),    // the y position
        static_cast<int>(oldWidth * scaleDelta),                    // width
        static_cast<int>(oldHeight * scaleDelta),                   // height
        TRUE);                                                      // redraw
                     
    return S_OK;
}
```



<span data-ttu-id="6aec6-135">In diesem Beispiel wird durch die Bearbeitung von abgeschlossenen Ereignissen entweder ein Timer gestartet oder angehalten, der [**Process**](/windows/desktop/api/manipulations/nf-manipulations-iinertiaprocessor-process) für die [**IInertiaProcessor**](/windows/desktop/api/manipulations/nn-manipulations-iinertiaprocessor) -Schnittstelle aufruft.</span><span class="sxs-lookup"><span data-stu-id="6aec6-135">In this example, manipulation completed events either start or stop a timer that will call [**Process**](/windows/desktop/api/manipulations/nf-manipulations-iinertiaprocessor-process) on the [**IInertiaProcessor**](/windows/desktop/api/manipulations/nn-manipulations-iinertiaprocessor) interface.</span></span> <span data-ttu-id="6aec6-136">Der folgende Code zeigt, wie das abgeschlossene Manipulations Ereignis behandelt wird.</span><span class="sxs-lookup"><span data-stu-id="6aec6-136">The following code shows how the completed manipulation event is handled.</span></span>


```C++
HRESULT STDMETHODCALLTYPE CManipulationEventSink::ManipulationCompleted( 
    /* [in] */ FLOAT x,
    /* [in] */ FLOAT y,
    /* [in] */ FLOAT cumulativeTranslationX,
    /* [in] */ FLOAT cumulativeTranslationY,
    /* [in] */ FLOAT cumulativeScale,
    /* [in] */ FLOAT cumulativeExpansion,
    /* [in] */ FLOAT cumulativeRotation)
{
    m_cCompletedEventCount ++;

    m_fX = x;
    m_fY = y;

    // place your code handler here to do any operations based on the manipulation   
    
    if (fExtrapolating){
        //Inertia Complete, stop the timer used for processing      
        KillTimer(m_hWnd,0);        
    }else{ 
        // setup velocities for inertia processor
        float vX = 0.0f;
        float vY = 0.0f;
        float vA = 0.0f;
        m_pManip->GetVelocityX(&vX);
        m_pManip->GetVelocityY(&vY);
        m_pManip->GetAngularVelocity(&vA);

        // complete any previous processing
        m_pInert->Complete();
        
        // Reset sets the  initial timestamp
        m_pInert->Reset();
                
        // 
        m_pInert->put_InitialVelocityX(vX);
        m_pInert->put_InitialVelocityY(vY);        
        
        m_pInert->put_InitialOriginX(x);
        m_pInert->put_InitialOriginY(y);
        
           
        // Start a timer
        SetTimer(m_hWnd,0, 50, 0);        
    }

    return S_OK;
}
```



<span data-ttu-id="6aec6-137">Der folgende Code zeigt, wie Sie die **WM \_** -Zeit Geber Meldungen in **WndProc** interpretieren können, um Aufrufe für die [**Verarbeitung**](/windows/desktop/api/manipulations/nf-manipulations-iinertiaprocessor-process) auf der [**IInertiaProcessor**](/windows/desktop/api/manipulations/nn-manipulations-iinertiaprocessor) -Schnittstelle auszuführen.</span><span class="sxs-lookup"><span data-stu-id="6aec6-137">The following code shows how you could interpret **WM\_TIMER** messages in **WndProc** to perform calls to [**Process**](/windows/desktop/api/manipulations/nf-manipulations-iinertiaprocessor-process) on the [**IInertiaProcessor**](/windows/desktop/api/manipulations/nn-manipulations-iinertiaprocessor) interface.</span></span>


```C++
case WM_TIMER:       
  if (g_pIInertProc){
    BOOL b;       
    g_pIInertProc->Process(&b);        
  }
  break;
```



### <a name="coinitialize-the-inertia-processor-and-manipulation-processor-and-initialize-the-event-sinks"></a><span data-ttu-id="6aec6-138">Coinitialisieren des Trägheits Prozessor-und Bearbeitungs Prozessors und Initialisieren der Ereignis senken</span><span class="sxs-lookup"><span data-stu-id="6aec6-138">CoInitialize the Inertia Processor and Manipulation Processor and Initialize the Event Sinks</span></span>

<span data-ttu-id="6aec6-139">Nachdem Sie die Ereignis Senke so geändert haben, dass Sie sowohl [**IManipulationProcessor**](/windows/desktop/api/manipulations/nn-manipulations-imanipulationprocessor) als auch [**IInertiaProcessor**](/windows/desktop/api/manipulations/nn-manipulations-iinertiaprocessor)unterstützt, können Sie die Ereignis senken initialisieren und Sie so einrichten, dass Sie von der Anwendung ausgeführt werden.</span><span class="sxs-lookup"><span data-stu-id="6aec6-139">After you have your event sink modified to support both the [**IManipulationProcessor**](/windows/desktop/api/manipulations/nn-manipulations-imanipulationprocessor) and the [**IInertiaProcessor**](/windows/desktop/api/manipulations/nn-manipulations-iinertiaprocessor), you are ready to initialize the event sinks and set them up to run from your application.</span></span> <span data-ttu-id="6aec6-140">Der folgende Code zeigt, wie die Schnittstellen Zeiger zugeordnet werden.</span><span class="sxs-lookup"><span data-stu-id="6aec6-140">The following code shows how the interface pointers are allocated.</span></span>


```C++
//Include windows.h for touch events
#include "windows.h"  

// Manipulation implementation file
#include <manipulations_i.c>
    
// Smart Pointer to a global reference of a manipulation processor, event sink
IManipulationProcessor* g_pIManipProc;
IInertiaProcessor*      g_pIInertProc;
```



<span data-ttu-id="6aec6-141">Im folgenden Codebeispiel wird gezeigt, wie Sie die Schnittstellen instanziieren.</span><span class="sxs-lookup"><span data-stu-id="6aec6-141">The following code example shows how to instantiate your interfaces.</span></span>


```C++
   HRESULT hr = CoInitialize(0);
        
   hr = CoCreateInstance(CLSID_ManipulationProcessor,
       NULL,
       CLSCTX_INPROC_SERVER,
       IID_IUnknown,
       (VOID**)(&g_pIManipProc)
   );
   
   hr = CoCreateInstance(CLSID_InertiaProcessor,
       NULL,
       CLSCTX_INPROC_SERVER,
       IID_IUnknown,
       (VOID**)(&g_pIInertProc)
   );
```



<span data-ttu-id="6aec6-142">Im folgenden Codebeispiel wird gezeigt, wie Sie die Ereignis senken anhand der Schnittstellen Zeiger erstellen und das Fenster für die Berührungs Eingabe registrieren.</span><span class="sxs-lookup"><span data-stu-id="6aec6-142">The following code example shows how to construct your event sinks given the interface pointers and register the window for touch input.</span></span>


```C++
   g_pManipulationEventSink = new CManipulationEventSink(g_pIManipProc, g_pIInertProc, hWnd);
   g_pManipulationEventSink = new CManipulationEventSink(g_pIInertProc, hWnd);


   RegisterTouchWindow(hWnd, 0);  
```



## <a name="related-topics"></a><span data-ttu-id="6aec6-143">Zugehörige Themen</span><span class="sxs-lookup"><span data-stu-id="6aec6-143">Related topics</span></span>

<dl> <dt>

[<span data-ttu-id="6aec6-144">Trägheit</span><span class="sxs-lookup"><span data-stu-id="6aec6-144">Inertia</span></span>](getting-started-with-inertia.md)
</dt> </dl>

 

 




