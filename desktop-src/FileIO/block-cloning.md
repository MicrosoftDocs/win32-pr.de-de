---
description: Ein Block Klon Vorgang weist das Dateisystem an, einen Bereich von Datei Bytes für eine Anwendung zu kopieren.
ms.assetid: E18E8D79-3985-40B8-A4C5-A73A21E5C527
title: Klonen blockieren
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: b33aa1c1eee693b6ed4b502aedc6da6176ece3e9
ms.sourcegitcommit: 831e8f3db78ab820e1710cede244553c70e50500
ms.translationtype: MT
ms.contentlocale: de-DE
ms.lasthandoff: 01/08/2021
ms.locfileid: "104530008"
---
# <a name="block-cloning"></a><span data-ttu-id="f7b6e-103">Klonen blockieren</span><span class="sxs-lookup"><span data-stu-id="f7b6e-103">Block Cloning</span></span>

<span data-ttu-id="f7b6e-104">Ein *Block Klon* Vorgang weist das Dateisystem an, einen Bereich von Datei Bytes für eine Anwendung zu kopieren.</span><span class="sxs-lookup"><span data-stu-id="f7b6e-104">A *block clone* operation instructs the file system to copy a range of file bytes on behalf of an application.</span></span> <span data-ttu-id="f7b6e-105">Die Zieldatei ist möglicherweise mit der Quelldatei identisch oder unterschiedlich.</span><span class="sxs-lookup"><span data-stu-id="f7b6e-105">The destination file may be the same as, or different from, the source file.</span></span>

<span data-ttu-id="f7b6e-106">Ein Dateisystem verwaltet die Zuordnungen von [Clustern und Blöcken](clusters-and-extents.md)und kann möglicherweise die Kopie durchführen, indem die VCN-Zuordnungen (Virtual Cluster Number) zu logischen Cluster Nummern (LCN) als kostengünstiger Metadatenvorgang geändert werden, anstatt die zugrunde liegenden Datei Daten zu lesen und zu schreiben.</span><span class="sxs-lookup"><span data-stu-id="f7b6e-106">A file system manages the mappings of [Clusters and Extents](clusters-and-extents.md), and may be able to perform the copy by altering the virtual cluster number (VCN) to logical cluster number (LCN) mappings as a low-cost metadata operation, rather than reading and writing the underlying file data.</span></span> <span data-ttu-id="f7b6e-107">Dadurch kann die Kopie schneller ausgeführt werden, und es werden weniger e/a-Vorgänge für den zugrunde liegenden Speicher generiert.</span><span class="sxs-lookup"><span data-stu-id="f7b6e-107">This allows the copy to complete faster and generates less I/O to the underlying storage.</span></span> <span data-ttu-id="f7b6e-108">Darüber hinaus können nach dem Block Klon mehrere Dateien nun logische Cluster gemeinsam nutzen. Dadurch wird die Kapazität eingespart, weil identische Cluster nicht mehrmals auf dem Datenträger gespeichert werden.</span><span class="sxs-lookup"><span data-stu-id="f7b6e-108">Moreover, multiple files may now share logical clusters after the block clone, saving capacity by not storing identical clusters multiple times on disk.</span></span>

<span data-ttu-id="f7b6e-109">Ein Block Klon Vorgang führt nicht zu einer Unterbrechung der von Dateien bereitgestellten Isolation.</span><span class="sxs-lookup"><span data-stu-id="f7b6e-109">A block clone operation does not break the isolation provided between files.</span></span> <span data-ttu-id="f7b6e-110">Wenn ein Block Klon abgeschlossen ist, werden Schreibvorgänge in die Quelldatei nicht im Ziel angezeigt (oder umgekehrt).</span><span class="sxs-lookup"><span data-stu-id="f7b6e-110">After a block clone completes, writes to the source file do not appear in the destination, or vice versa.</span></span>

<span data-ttu-id="f7b6e-111">Block Klon ist nur für den [Refs-Dateisystemtyp](/windows/desktop/w8cookbook/resilient-file-system--refs-) verfügbar, beginnend mit Windows Server 2016.</span><span class="sxs-lookup"><span data-stu-id="f7b6e-111">Block cloning is available only on the [ReFS file system](/windows/desktop/w8cookbook/resilient-file-system--refs-) type beginning with Windows Server 2016.</span></span>

## <a name="block-cloning-on-refs"></a><span data-ttu-id="f7b6e-112">Blockieren des Klonens von refs</span><span class="sxs-lookup"><span data-stu-id="f7b6e-112">Block Cloning on ReFS</span></span>

<span data-ttu-id="f7b6e-113">Refs unter Windows Server 2016 implementiert das Klonen von Blöcken, indem logische Cluster (also physische Speicherorte auf einem Volume) der Quellregion der Zielregion neu zugeordnet werden.</span><span class="sxs-lookup"><span data-stu-id="f7b6e-113">ReFS on Windows Server 2016 implements block cloning by remapping logical clusters (that is, physical locations on a volume) from the source region to the destination region.</span></span> <span data-ttu-id="f7b6e-114">Anschließend wird ein Mechanismus zum Zuweisen bei Schreibzugriff verwendet, um die Isolation zwischen diesen Regionen sicherzustellen.</span><span class="sxs-lookup"><span data-stu-id="f7b6e-114">It then uses an allocate-on-write mechanism to ensure isolation between those regions.</span></span> <span data-ttu-id="f7b6e-115">Die Quell-und Zielregionen können sich in derselben oder in unterschiedlichen Dateien befinden.</span><span class="sxs-lookup"><span data-stu-id="f7b6e-115">The source and destination regions may be in the same, or different, files.</span></span>

<span data-ttu-id="f7b6e-116">Diese Implementierung erfordert, dass die Dateioffsets für das Start-und das Ende an den Cluster Grenzen ausgerichtet sind.</span><span class="sxs-lookup"><span data-stu-id="f7b6e-116">This implementation requires that the starting and ending file offsets be aligned to cluster boundaries.</span></span> <span data-ttu-id="f7b6e-117">In Refs unter Windows Server 2016 sind Cluster standardmäßig 4 KB groß, Sie können jedoch optional auf 64 KB festgelegt werden.</span><span class="sxs-lookup"><span data-stu-id="f7b6e-117">In ReFS on Windows Server 2016, clusters are 4KB in size by default, but can optionally be set to 64KB.</span></span> <span data-ttu-id="f7b6e-118">Bei der Clustergröße handelt es sich um einen volumeweiten Parametersatz zur Formatierungs Zeit.</span><span class="sxs-lookup"><span data-stu-id="f7b6e-118">The cluster size is a volume-wide parameter set at format time.</span></span>

## <a name="restrictions-and-remarks"></a><span data-ttu-id="f7b6e-119">Einschränkungen und Hinweise</span><span class="sxs-lookup"><span data-stu-id="f7b6e-119">Restrictions and Remarks</span></span>

-   <span data-ttu-id="f7b6e-120">Die Quell-und Zielregionen müssen an einer Cluster Grenze beginnen und enden.</span><span class="sxs-lookup"><span data-stu-id="f7b6e-120">The source and destination regions must begin and end at a cluster boundary.</span></span>
-   <span data-ttu-id="f7b6e-121">Die geklonte Region muss kleiner als 4 GB lang sein.</span><span class="sxs-lookup"><span data-stu-id="f7b6e-121">The cloned region must be less than 4GB in length.</span></span>
-   <span data-ttu-id="f7b6e-122">Die Zielregion darf nicht über das Dateiende hinaus erweitert werden.</span><span class="sxs-lookup"><span data-stu-id="f7b6e-122">The destination region must not extend past the end of file.</span></span> <span data-ttu-id="f7b6e-123">Wenn die Anwendung das Ziel mit geklonten Daten erweitern möchte, muss zuerst [**SetEndOfFile**](/windows/desktop/api/FileAPI/nf-fileapi-setendoffile)aufgerufen werden.</span><span class="sxs-lookup"><span data-stu-id="f7b6e-123">If the application wishes to extend the destination with cloned data, it must first call [**SetEndOfFile**](/windows/desktop/api/FileAPI/nf-fileapi-setendoffile).</span></span>
-   <span data-ttu-id="f7b6e-124">Wenn sich die Quell- und Zielregionen in derselben Datei befinden, dürfen diese nicht überlappen.</span><span class="sxs-lookup"><span data-stu-id="f7b6e-124">If the source and destination regions are in the same file, they must not overlap.</span></span> <span data-ttu-id="f7b6e-125">(Die Anwendung kann fortfahren, indem Sie den Block Klon Vorgang in mehrere Block Klone aufteilen, die sich nicht mehr überlappen.)</span><span class="sxs-lookup"><span data-stu-id="f7b6e-125">(The application may able to proceed by splitting up the block clone operation into multiple block clones that no longer overlap.)</span></span>
-   <span data-ttu-id="f7b6e-126">Die Quell- und Zieldateien müssen sich auf demselben Volume ReFS befinden.</span><span class="sxs-lookup"><span data-stu-id="f7b6e-126">The source and destination files must be on the same ReFS volume.</span></span>
-   <span data-ttu-id="f7b6e-127">Die Quell-und Zieldateien müssen dieselbe Einstellung für [**Integritäts Datenströme**](file-attribute-constants.md) aufweisen (d. h., Integritäts Datenströme müssen in beiden Dateien aktiviert oder in beiden Dateien deaktiviert werden).</span><span class="sxs-lookup"><span data-stu-id="f7b6e-127">The source and destination files must have the same [**Integrity Streams**](file-attribute-constants.md) setting (that is, Integrity Streams must be enabled in both files, or disabled in both files).</span></span>
-   <span data-ttu-id="f7b6e-128">Hat die Quelldatei eine geringe Datendichte, muss die Zieldatei ebenfalls eine geringe Datendichte aufweisen.</span><span class="sxs-lookup"><span data-stu-id="f7b6e-128">If the source file is sparse, the destination file must also be sparse.</span></span>
-   <span data-ttu-id="f7b6e-129">Durch den Block Klon Vorgang werden freigegebene opportunistische Sperren (auch als [opportunistische Sperren der Ebene 2](types-of-opportunistic-locks.md)bezeichnet) unterbricht.</span><span class="sxs-lookup"><span data-stu-id="f7b6e-129">The block clone operation will break Shared Opportunistic Locks (also known as [Level 2 Opportunistic Locks](types-of-opportunistic-locks.md)).</span></span>
-   <span data-ttu-id="f7b6e-130">Das Refs-Volume muss mit Windows Server 2016 formatiert sein, und wenn Windows-Failoverclustering verwendet wird, muss die Clustering-Funktionsebene zur Formatierungs Zeit Windows Server 2016 oder höher aufweisen.</span><span class="sxs-lookup"><span data-stu-id="f7b6e-130">The ReFS volume must have been formatted with Windows Server 2016, and if Windows Failover Clustering is in use, the Clustering Functional Level must have been Windows Server 2016 or later at format time.</span></span>

## <a name="example"></a><span data-ttu-id="f7b6e-131">Beispiel</span><span class="sxs-lookup"><span data-stu-id="f7b6e-131">Example</span></span>

<span data-ttu-id="f7b6e-132">Angenommen, wir haben zwei Dateien: "X" und "Y", wobei jede Datei aus drei unterschiedlichen Regionen besteht.</span><span class="sxs-lookup"><span data-stu-id="f7b6e-132">Suppose we have two files, X and Y, where each file is composed of 3 distinct regions.</span></span> <span data-ttu-id="f7b6e-133">Jeder Datei Bereich wird in einem unterschiedlichen Bereich des Volumes gespeichert.</span><span class="sxs-lookup"><span data-stu-id="f7b6e-133">Each file region is stored on a distinct region of the volume.</span></span> <span data-ttu-id="f7b6e-134">Das Dateisystem speichert die Informationen, auf die in einer Datei Region in den einzelnen volumeregionen verwiesen wird:</span><span class="sxs-lookup"><span data-stu-id="f7b6e-134">The file system stores the knowledge that each of those volume regions is referenced in one file region:</span></span>

![vor dem Klonen](images/before-clone.png)

<span data-ttu-id="f7b6e-136">Angenommen, eine Anwendung gibt einen Block Klon Vorgang aus Datei X, über die Datei Bereiche a und B, um die Datei Y an dem Offset, in dem E aktuell ist, aus.</span><span class="sxs-lookup"><span data-stu-id="f7b6e-136">Now suppose an application issues a block clone operation from File X, over file regions A and B, to File Y at the offset where E currently is.</span></span> <span data-ttu-id="f7b6e-137">Der folgende Dateisystem Status ergibt sich:</span><span class="sxs-lookup"><span data-stu-id="f7b6e-137">The following file system state would result:</span></span>

![nach dem Klonen](images/after-clone.png)

<span data-ttu-id="f7b6e-139">Die Daten in den Regionen A und B wurden durch Ändern der VCN-zu-LCN-Zuordnungen im Refs-Volume effektiv von Datei X in Datei Y dupliziert.</span><span class="sxs-lookup"><span data-stu-id="f7b6e-139">The data in regions A and B were effectively duplicated from File X to File Y by altering the VCN to LCN mappings within the ReFS volume.</span></span> <span data-ttu-id="f7b6e-140">Die Datenträger Blöcke "A" und "B" wurden nicht gelesen, und die Datenträger Blöcke unterstützten die alten Bereiche, die E und F während des Vorgangs überschrieben haben.</span><span class="sxs-lookup"><span data-stu-id="f7b6e-140">The disk extents backing regions A and B were not read, nor were the disk extents backing the old regions E and F overwritten during the operation.</span></span>

<span data-ttu-id="f7b6e-141">Die Dateien X und Y geben nun logische Cluster auf dem Datenträger frei.</span><span class="sxs-lookup"><span data-stu-id="f7b6e-141">Files X and Y now share logical clusters on disk.</span></span> <span data-ttu-id="f7b6e-142">Dies spiegelt sich in den Verweis Zählungen wider, die in der Tabelle angezeigt werden.</span><span class="sxs-lookup"><span data-stu-id="f7b6e-142">This is reflected in the reference counts shown in the table.</span></span> <span data-ttu-id="f7b6e-143">Die Freigabe führt zu einem geringeren Volumen Kapazitäts Verbrauch, als wenn die Regionen A und B auf dem zugrunde liegenden Volume dupliziert wurden.</span><span class="sxs-lookup"><span data-stu-id="f7b6e-143">The sharing results in lower volume capacity consumption than if regions A and B were duplicated on the underlying volume.</span></span>

<span data-ttu-id="f7b6e-144">Angenommen, die Anwendung überschreibt Region a in der Datei x. Refs erstellt eine duplizierte Kopie von, die wir jetzt als "g. Refs" bezeichnen und dann "g" in Datei x zuordnen und die Änderung anwenden.</span><span class="sxs-lookup"><span data-stu-id="f7b6e-144">Now, suppose the application overwrites region A in File X. ReFS makes a duplicate copy of A, which we’ll now call G. ReFS then maps G into File X, and applies the modification.</span></span> <span data-ttu-id="f7b6e-145">Dadurch wird sichergestellt, dass die Isolation zwischen den Dateien beibehalten wird.</span><span class="sxs-lookup"><span data-stu-id="f7b6e-145">This ensures that isolation between the files is preserved.</span></span> <span data-ttu-id="f7b6e-146">Verweis Zähler werden entsprechend aktualisiert:</span><span class="sxs-lookup"><span data-stu-id="f7b6e-146">Reference counts are updated appropriately:</span></span>

![nach dem Ändern von Write](images/after-modifying-write.png)

<span data-ttu-id="f7b6e-148">Nach dem Ändern des Schreibzugriffs wird Region B weiterhin auf dem Datenträger freigegeben.</span><span class="sxs-lookup"><span data-stu-id="f7b6e-148">After the modifying write, region B is still shared on disk.</span></span> <span data-ttu-id="f7b6e-149">Falls Region A größer als ein Cluster wäre, würde nur der geänderte Cluster dupliziert und der verbleibende Teil würde freigegeben.</span><span class="sxs-lookup"><span data-stu-id="f7b6e-149">Note that if region A were larger than a cluster, only the modified cluster would have been duplicated, and the remaining portion would have remained shared.</span></span>

## <a name="related-topics"></a><span data-ttu-id="f7b6e-150">Zugehörige Themen</span><span class="sxs-lookup"><span data-stu-id="f7b6e-150">Related topics</span></span>

<dl> <dt>

[<span data-ttu-id="f7b6e-151">**doppelte \_ Datenblöcke \_**</span><span class="sxs-lookup"><span data-stu-id="f7b6e-151">**DUPLICATE\_EXTENTS\_DATA**</span></span>](/windows/desktop/api/WinIoCtl/ns-winioctl-duplicate_extents_data)
</dt> <dt>

[<span data-ttu-id="f7b6e-152">**Datei Blöcke mit doppelter FSCTL- \_ \_ \_ \_ Datei**</span><span class="sxs-lookup"><span data-stu-id="f7b6e-152">**FSCTL\_DUPLICATE\_EXTENTS\_TO\_FILE**</span></span>](/windows/win32/api/winioctl/ni-winioctl-fsctl_duplicate_extents_to_file)
</dt> </dl>

 

 
