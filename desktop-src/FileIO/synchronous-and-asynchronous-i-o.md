---
description: 'Es gibt zwei Arten der Eingabe-/ausgabesynchronisierung (e/a): Synchrone e/a-Vorgänge und asynchrone e/a-Vorgänge. Asynchrone e/a-Vorgänge werden auch als überlappende e/a-Vorgänge bezeichnet.'
ms.assetid: ade51d98-cc9d-4b33-9c52-559a9cb14707
title: Synchrone und asynchrone e/a
ms.topic: article
ms.date: 05/31/2018
ms.custom: project-verbatim
ms.openlocfilehash: 071dd2943537dcb6aff67a95cb5e2c3d514f4c1a
ms.sourcegitcommit: af120ad5c30da2fc5eb717ca2a1c4c45878efd71
ms.translationtype: MT
ms.contentlocale: de-DE
ms.lasthandoff: 03/20/2021
ms.locfileid: "106355251"
---
# <a name="synchronous-and-asynchronous-io"></a><span data-ttu-id="3682a-104">Synchrone und asynchrone e/a</span><span class="sxs-lookup"><span data-stu-id="3682a-104">Synchronous and Asynchronous I/O</span></span>

<span data-ttu-id="3682a-105">Siehe auch e [/a-bezogene Beispielanwendungen](https://github.com/microsoft/Windows-classic-samples/tree/master/Samples/Win7Samples/winbase/io).</span><span class="sxs-lookup"><span data-stu-id="3682a-105">Also see [I/O-related sample applications](https://github.com/microsoft/Windows-classic-samples/tree/master/Samples/Win7Samples/winbase/io).</span></span>

<span data-ttu-id="3682a-106">Es gibt zwei Arten der Eingabe-/ausgabesynchronisierung (e/a): Synchrone e/a-Vorgänge und asynchrone e/a-Vorgänge.</span><span class="sxs-lookup"><span data-stu-id="3682a-106">There are two types of input/output (I/O) synchronization: synchronous I/O and asynchronous I/O.</span></span> <span data-ttu-id="3682a-107">Asynchrone e/a-Vorgänge werden auch als überlappende e/a-Vorgänge bezeichnet.</span><span class="sxs-lookup"><span data-stu-id="3682a-107">Asynchronous I/O is also referred to as overlapped I/O.</span></span>

<span data-ttu-id="3682a-108">In *synchronen Datei-e/* a startet ein Thread einen e/a-Vorgang und wechselt sofort in den Wartezustand, bis die e/a-Anforderung abgeschlossen ist.</span><span class="sxs-lookup"><span data-stu-id="3682a-108">In *synchronous file I/O*, a thread starts an I/O operation and immediately enters a wait state until the I/O request has completed.</span></span> <span data-ttu-id="3682a-109">Ein Thread, der *asynchrone Datei-e/* a-Vorgänge ausführt, sendet eine e/a-Anforderung an den Kernel, indem eine entsprechende Funktion aufgerufen wird.</span><span class="sxs-lookup"><span data-stu-id="3682a-109">A thread performing *asynchronous file I/O* sends an I/O request to the kernel by calling an appropriate function.</span></span> <span data-ttu-id="3682a-110">Wenn die Anforderung vom Kernel akzeptiert wird, setzt der aufrufende Thread die Verarbeitung eines anderen Auftrags fort, bis der Kernel dem Thread signalisiert, dass der e/a-Vorgang beendet ist.</span><span class="sxs-lookup"><span data-stu-id="3682a-110">If the request is accepted by the kernel, the calling thread continues processing another job until the kernel signals to the thread that the I/O operation is complete.</span></span> <span data-ttu-id="3682a-111">Er unterbricht dann seinen aktuellen Auftrag und verarbeitet die Daten aus dem e/a-Vorgang bei Bedarf.</span><span class="sxs-lookup"><span data-stu-id="3682a-111">It then interrupts its current job and processes the data from the I/O operation as necessary.</span></span>

<span data-ttu-id="3682a-112">Die zwei Synchronisierungs Typen sind in der folgenden Abbildung dargestellt.</span><span class="sxs-lookup"><span data-stu-id="3682a-112">The two synchronization types are illustrated in the following figure.</span></span>

![synchrone und asynchrone e/a](images/fig2bedit.png)

<span data-ttu-id="3682a-114">Wenn erwartet wird, dass eine e/a-Anforderung sehr lange dauert, wie z. b. eine Aktualisierung oder Sicherung einer großen Datenbank oder einer langsamen Kommunikationsverbindung, ist asynchrone e/a-Vorgänge im Allgemeinen eine gute Möglichkeit zur Optimierung der Verarbeitungseffizienz.</span><span class="sxs-lookup"><span data-stu-id="3682a-114">In situations where an I/O request is expected to take a large amount of time, such as a refresh or backup of a large database or a slow communications link, asynchronous I/O is generally a good way to optimize processing efficiency.</span></span> <span data-ttu-id="3682a-115">Bei relativ schnellen e/a-Vorgängen kann der Aufwand für die Verarbeitung von Kernel-e/a-Anforderungen und Kernel Signalen jedoch dazu führen, dass asynchrone e/a-Vorgänge weniger vorteilhaft sind, insbesondere, wenn viele schnelle e/a-Vorgänge durchgeführt werden müssen.</span><span class="sxs-lookup"><span data-stu-id="3682a-115">However, for relatively fast I/O operations, the overhead of processing kernel I/O requests and kernel signals may make asynchronous I/O less beneficial, particularly if many fast I/O operations need to be made.</span></span> <span data-ttu-id="3682a-116">In diesem Fall wäre die synchrone e/a besser.</span><span class="sxs-lookup"><span data-stu-id="3682a-116">In this case, synchronous I/O would be better.</span></span> <span data-ttu-id="3682a-117">Die Mechanismen und Implementierungsdetails zum Ausführen dieser Aufgaben hängen von der Art des verwendeten Geräte Handles und den speziellen Anforderungen der Anwendung ab.</span><span class="sxs-lookup"><span data-stu-id="3682a-117">The mechanisms and implementation details of how to accomplish these tasks vary depending on the type of device handle that is used and the particular needs of the application.</span></span> <span data-ttu-id="3682a-118">Anders ausgedrückt, gibt es in der Regel mehrere Möglichkeiten, um das Problem zu beheben.</span><span class="sxs-lookup"><span data-stu-id="3682a-118">In other words, there are usually multiple ways to solve the problem.</span></span>

## <a name="synchronous-and-asynchronous-io-considerations"></a><span data-ttu-id="3682a-119">Synchrone und asynchrone e/a-Überlegungen</span><span class="sxs-lookup"><span data-stu-id="3682a-119">Synchronous and Asynchronous I/O Considerations</span></span>

<span data-ttu-id="3682a-120">Wenn eine Datei oder ein Gerät für synchrone e/a-Vorgänge geöffnet ist (d. h., das überlappende **\_ Dateiflag \_** ist nicht angegeben), können nachfolgende Aufrufe von Funktionen wie z. b. " [**Write File**](/windows/desktop/api/FileAPI/nf-fileapi-writefile) " die Ausführung des aufrufenden Threads blockieren, bis eines der folgenden Ereignisse eintritt:</span><span class="sxs-lookup"><span data-stu-id="3682a-120">If a file or device is opened for synchronous I/O (that is, **FILE\_FLAG\_OVERLAPPED** is not specified), subsequent calls to functions such as [**WriteFile**](/windows/desktop/api/FileAPI/nf-fileapi-writefile) can block execution of the calling thread until one of the following events occurs:</span></span>

-   <span data-ttu-id="3682a-121">Der e/a-Vorgang wird abgeschlossen (in diesem Beispiel ein Daten Schreibvorgang).</span><span class="sxs-lookup"><span data-stu-id="3682a-121">The I/O operation completes (in this example, a data write).</span></span>
-   <span data-ttu-id="3682a-122">Ein E/A-Fehler tritt auf.</span><span class="sxs-lookup"><span data-stu-id="3682a-122">An I/O error occurs.</span></span> <span data-ttu-id="3682a-123">(Die Pipe wird z. b. vom anderen Ende geschlossen.)</span><span class="sxs-lookup"><span data-stu-id="3682a-123">(For example, the pipe is closed from the other end.)</span></span>
-   <span data-ttu-id="3682a-124">Fehler im eigentlichen Rückruf (z. b. mindestens ein Parameter ist ungültig).</span><span class="sxs-lookup"><span data-stu-id="3682a-124">An error was made in the call itself (for example, one or more parameters are not valid).</span></span>
-   <span data-ttu-id="3682a-125">Ein anderer Thread im Prozess ruft die Funktion [**CancelSynchronousIo**](cancelsynchronousio-func.md) mithilfe des Thread Handles des blockierten Threads auf, der die e/a-Vorgänge für diesen Thread beendet und den e/a-Vorgang nicht ausführt.</span><span class="sxs-lookup"><span data-stu-id="3682a-125">Another thread in the process calls the [**CancelSynchronousIo**](cancelsynchronousio-func.md) function using the blocked thread's thread handle, which terminates I/O for that thread, failing the I/O operation.</span></span>
-   <span data-ttu-id="3682a-126">Der blockierte Thread wird vom System beendet. der Prozess selbst wird z. b. beendet, oder ein anderer Thread ruft die [**TerminateThread**](/windows/desktop/api/processthreadsapi/nf-processthreadsapi-terminatethread) -Funktion mit dem Handle des blockierten Threads auf.</span><span class="sxs-lookup"><span data-stu-id="3682a-126">The blocked thread is terminated by the system; for example, the process itself is terminated, or another thread calls the [**TerminateThread**](/windows/desktop/api/processthreadsapi/nf-processthreadsapi-terminatethread) function using the blocked thread's handle.</span></span> <span data-ttu-id="3682a-127">(Dies wird im Allgemeinen als letztes Mittel und nicht als geeignetes Anwendungsdesign angesehen.)</span><span class="sxs-lookup"><span data-stu-id="3682a-127">(This is generally considered a last resort and not good application design.)</span></span>

<span data-ttu-id="3682a-128">In einigen Fällen kann diese Verzögerung für den Entwurf und Zweck der Anwendung nicht akzeptabel sein. Daher sollten Anwendungsentwickler die Verwendung asynchroner e/a-Vorgänge mit entsprechenden Thread Synchronisierungs Objekten wie z. b. e [/a-Abschlussports](i-o-completion-ports.md)in Erwägung ziehen.</span><span class="sxs-lookup"><span data-stu-id="3682a-128">In some cases, this delay may be unacceptable to the application's design and purpose, so application designers should consider using asynchronous I/O with appropriate thread synchronization objects such as [I/O completion ports](i-o-completion-ports.md).</span></span> <span data-ttu-id="3682a-129">Weitere Informationen zur Synchronisierung von Threads finden Sie unter Informationen [zur Synchronisierung](/windows/desktop/Sync/about-synchronization).</span><span class="sxs-lookup"><span data-stu-id="3682a-129">For more information about thread synchronization, see [About Synchronization](/windows/desktop/Sync/about-synchronization).</span></span>

<span data-ttu-id="3682a-130">Ein Prozess öffnet eine Datei für asynchrone e/a-Vorgänge in seinem Aufrufen von " [**anatefile**](/windows/desktop/api/FileAPI/nf-fileapi-createfilea) " durch Angabe des überlappenden Flag " **\_ Dateiflag \_** " im Parameter " *dwflagsandattributs* ".</span><span class="sxs-lookup"><span data-stu-id="3682a-130">A process opens a file for asynchronous I/O in its call to [**CreateFile**](/windows/desktop/api/FileAPI/nf-fileapi-createfilea) by specifying the **FILE\_FLAG\_OVERLAPPED** flag in the *dwFlagsAndAttributes* parameter.</span></span> <span data-ttu-id="3682a-131">Wenn das überlappende **\_ Dateiflag \_** nicht angegeben ist, wird die Datei für die synchrone e/a-Vorgänge geöffnet.</span><span class="sxs-lookup"><span data-stu-id="3682a-131">If **FILE\_FLAG\_OVERLAPPED** is not specified, the file is opened for synchronous I/O.</span></span> <span data-ttu-id="3682a-132">Wenn die Datei für asynchrone e/a-Vorgänge geöffnet wurde, wird ein Zeiger auf eine überlappende Struktur an den-Aufrufe von "read [**File**](/windows/desktop/api/FileAPI/nf-fileapi-readfile) " und " [**Write File**](/windows/desktop/api/FileAPI/nf-fileapi-writefile)" [**über**](/windows/desktop/api/MinWinBase/ns-minwinbase-overlapped_entry) mittelt.</span><span class="sxs-lookup"><span data-stu-id="3682a-132">When the file has been opened for asynchronous I/O, a pointer to an [**OVERLAPPED**](/windows/desktop/api/MinWinBase/ns-minwinbase-overlapped_entry) structure is passed into the call to [**ReadFile**](/windows/desktop/api/FileAPI/nf-fileapi-readfile) and [**WriteFile**](/windows/desktop/api/FileAPI/nf-fileapi-writefile).</span></span> <span data-ttu-id="3682a-133">Wenn synchrone e/a-Vorgänge durchgeführt werden, ist diese Struktur in Aufrufen von "read **File** " und " **Write File**" nicht erforderlich.</span><span class="sxs-lookup"><span data-stu-id="3682a-133">When performing synchronous I/O, this structure is not required in calls to **ReadFile** and **WriteFile**.</span></span>

> [!Note]  
> <span data-ttu-id="3682a-134">Wenn eine Datei oder ein Gerät für asynchrone e/a-Vorgänge geöffnet wird, geben nachfolgende Aufrufe von Funktionen wie z. b. " [**Write File**](/windows/desktop/api/FileAPI/nf-fileapi-writefile) " mit diesem Handle in der Regel sofort zurück, können sich jedoch auch synchron in Bezug auf die blockierte Ausführung Verhalten</span><span class="sxs-lookup"><span data-stu-id="3682a-134">If a file or device is opened for asynchronous I/O, subsequent calls to functions such as [**WriteFile**](/windows/desktop/api/FileAPI/nf-fileapi-writefile) using that handle generally return immediately but can also behave synchronously with respect to blocked execution.</span></span> <span data-ttu-id="3682a-135">Weitere Informationen finden Sie unter [https://support.microsoft.com/kb/156932](https://support.microsoft.com/kb/156932).</span><span class="sxs-lookup"><span data-stu-id="3682a-135">For more information, see [https://support.microsoft.com/kb/156932](https://support.microsoft.com/kb/156932).</span></span>

 

<span data-ttu-id="3682a-136">Obwohl " [**anatefile**](/windows/desktop/api/FileAPI/nf-fileapi-createfilea) " die gängigste Funktion für das Öffnen von Dateien, Datenträgervolumes, anonymen Pipes und anderen ähnlichen Geräten ist, können e/a-Vorgänge auch mithilfe eines Handle- *Typumwandlung* aus anderen System Objekten, wie z. b. einem durch die [**Socket**](/windows/desktop/api/winsock2/nf-winsock2-socket) -oder [**Accept**](/windows/desktop/api/winsock2/nf-winsock2-accept) -Funktionen erstellten Socket, ausgeführt werden.</span><span class="sxs-lookup"><span data-stu-id="3682a-136">Although [**CreateFile**](/windows/desktop/api/FileAPI/nf-fileapi-createfilea) is the most common function to use for opening files, disk volumes, anonymous pipes, and other similar devices, I/O operations can also be performed using a handle *typecast* from other system objects such as a socket created by the [**socket**](/windows/desktop/api/winsock2/nf-winsock2-socket) or [**accept**](/windows/desktop/api/winsock2/nf-winsock2-accept) functions.</span></span>

<span data-ttu-id="3682a-137">Handles zu Verzeichnis Objekten werden durch Aufrufen der [**CreateFile**](/windows/desktop/api/FileAPI/nf-fileapi-createfilea) -Funktion mit dem **\_ Dateiflag \_ Sicherungs \_ Semantik** Attribut abgerufen.</span><span class="sxs-lookup"><span data-stu-id="3682a-137">Handles to directory objects are obtained by calling the [**CreateFile**](/windows/desktop/api/FileAPI/nf-fileapi-createfilea) function with the **FILE\_FLAG\_BACKUP\_SEMANTICS** attribute.</span></span> <span data-ttu-id="3682a-138">Verzeichnis Handles werden fast nie verwendet – bei Sicherungs Anwendungen handelt es sich um eine der wenigen Anwendungen, die Sie normalerweise verwenden.</span><span class="sxs-lookup"><span data-stu-id="3682a-138">Directory handles are almost never used—backup applications are one of the few applications that will typically use them.</span></span>

<span data-ttu-id="3682a-139">Nachdem das Datei Objekt für asynchrone e/a-Vorgänge geöffnet wurde, muss eine [**über**](/windows/desktop/api/minwinbase/ns-minwinbase-overlapped) Lapp Ende Struktur ordnungsgemäß erstellt, initialisiert und an jeden Aufrufe von Funktionen wie " [**Infofile**](/windows/desktop/api/FileAPI/nf-fileapi-readfile) " und " [**Write File**](/windows/desktop/api/FileAPI/nf-fileapi-writefile)" übermittelt werden.</span><span class="sxs-lookup"><span data-stu-id="3682a-139">After opening the file object for asynchronous I/O, an [**OVERLAPPED**](/windows/desktop/api/minwinbase/ns-minwinbase-overlapped) structure must be properly created, initialized, and passed into each call to functions such as [**ReadFile**](/windows/desktop/api/FileAPI/nf-fileapi-readfile) and [**WriteFile**](/windows/desktop/api/FileAPI/nf-fileapi-writefile).</span></span> <span data-ttu-id="3682a-140">Beachten Sie Folgendes, wenn Sie die [**über**](/windows/desktop/api/MinWinBase/ns-minwinbase-overlapped_entry) Lapp Ende Struktur in asynchronen Lese-und Schreibvorgängen verwenden:</span><span class="sxs-lookup"><span data-stu-id="3682a-140">Keep the following in mind when using the [**OVERLAPPED**](/windows/desktop/api/MinWinBase/ns-minwinbase-overlapped_entry) structure in asynchronous read and write operations:</span></span>

-   <span data-ttu-id="3682a-141">Sie dürfen die [**über**](/windows/desktop/api/minwinbase/ns-minwinbase-overlapped) Lapp Ende Struktur oder den Datenpuffer erst dann erneut zuweisen oder ändern, wenn alle asynchronen e/a-Vorgänge für das Datei Objekt abgeschlossen wurden.</span><span class="sxs-lookup"><span data-stu-id="3682a-141">Do not deallocate or modify the [**OVERLAPPED**](/windows/desktop/api/minwinbase/ns-minwinbase-overlapped) structure or the data buffer until all asynchronous I/O operations to the file object have been completed.</span></span>
-   <span data-ttu-id="3682a-142">Wenn Sie den Zeiger auf die [**über**](/windows/desktop/api/minwinbase/ns-minwinbase-overlapped) Lapp Ende Struktur als lokale Variable deklarieren, beenden Sie die lokale Funktion erst, wenn alle asynchronen e/a-Vorgänge für das Datei Objekt abgeschlossen wurden.</span><span class="sxs-lookup"><span data-stu-id="3682a-142">If you declare your pointer to the [**OVERLAPPED**](/windows/desktop/api/minwinbase/ns-minwinbase-overlapped) structure as a local variable, do not exit the local function until all asynchronous I/O operations to the file object have been completed.</span></span> <span data-ttu-id="3682a-143">Wenn die lokale Funktion vorzeitig beendet wird, wechselt die **über** Lapp Ende Struktur in den Gültigkeitsbereich, und es ist nicht mehr auf die Funktionen von "read [**File**](/windows/desktop/api/FileAPI/nf-fileapi-readfile) " und " [**Write File**](/windows/desktop/api/FileAPI/nf-fileapi-writefile) ", die außerhalb dieser Funktion gefunden werden, zugänglich.</span><span class="sxs-lookup"><span data-stu-id="3682a-143">If the local function is exited prematurely, the **OVERLAPPED** structure will go out of scope and it will be inaccessible to any [**ReadFile**](/windows/desktop/api/FileAPI/nf-fileapi-readfile) or [**WriteFile**](/windows/desktop/api/FileAPI/nf-fileapi-writefile) functions it encounters outside of that function.</span></span>

<span data-ttu-id="3682a-144">Sie können auch ein Ereignis erstellen und das Handle in die [**über**](/windows/desktop/api/minwinbase/ns-minwinbase-overlapped) Lapp Ende Struktur einfügen. die [Wait-Funktionen](/windows/desktop/Sync/wait-functions) können dann verwendet werden, um auf den Abschluss des e/a-Vorgangs zu warten, indem auf das Ereignis handle gewartet wird.</span><span class="sxs-lookup"><span data-stu-id="3682a-144">You can also create an event and put the handle in the [**OVERLAPPED**](/windows/desktop/api/minwinbase/ns-minwinbase-overlapped) structure; the [wait functions](/windows/desktop/Sync/wait-functions) can then be used to wait for the I/O operation to complete by waiting on the event handle.</span></span>

<span data-ttu-id="3682a-145">Wie bereits erwähnt, sollten Anwendungen beim Arbeiten mit einem asynchronen handle sorgfältig vorgehen, wenn Sie bestimmen möchten, wann Ressourcen freigegeben werden sollen, die einem angegebenen e/a-Vorgang für dieses Handle zugeordnet sind.</span><span class="sxs-lookup"><span data-stu-id="3682a-145">As previously stated, when working with an asynchronous handle, applications should use care when making determinations about when to free resources associated with a specified I/O operation on that handle.</span></span> <span data-ttu-id="3682a-146">Wenn die Zuordnung des Handles vorzeitig aufgehoben wird, meldet "read [**File**](/windows/desktop/api/FileAPI/nf-fileapi-readfile) " oder " [**Write File**](/windows/desktop/api/FileAPI/nf-fileapi-writefile) " fälschlicherweise, dass der e/a-Vorgang beendet ist.</span><span class="sxs-lookup"><span data-stu-id="3682a-146">If the handle is deallocated prematurely, [**ReadFile**](/windows/desktop/api/FileAPI/nf-fileapi-readfile) or [**WriteFile**](/windows/desktop/api/FileAPI/nf-fileapi-writefile) may incorrectly report that the I/O operation is complete.</span></span> <span data-ttu-id="3682a-147">Außerdem gibt die Funktion " **Write File** " manchmal " **true** " zurück, wenn der Wert " [**GetLastError**](/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror) " den Wert " **Fehler \_ erfolgreich**" hat, obwohl Sie ein asynchrones Handle verwendet (das ebenfalls " **false** " zurückgeben kann, wenn die **Fehler \_ \_**-e/a</span><span class="sxs-lookup"><span data-stu-id="3682a-147">Further, the **WriteFile** function will sometimes return **TRUE** with a [**GetLastError**](/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror) value of **ERROR\_SUCCESS**, even though it is using an asynchronous handle (which can also return **FALSE** with **ERROR\_IO\_PENDING**).</span></span> <span data-ttu-id="3682a-148">Programmierer, die mit dem synchronen e/a-Entwurf vertraut sind, geben in der Regel Datenpuffer Ressourcen frei, da **true** und **Fehler \_ Erfolg** darauf hinweisen, dass der Vorgang abgeschlossen ist.</span><span class="sxs-lookup"><span data-stu-id="3682a-148">Programmers accustomed to synchronous I/O design will usually release data buffer resources at this point because **TRUE** and **ERROR\_SUCCESS** signify the operation is complete.</span></span> <span data-ttu-id="3682a-149">Wenn jedoch e [/a-Abschlussports](i-o-completion-ports.md) mit diesem asynchronen Handle verwendet werden, wird auch dann ein abschlusspaket gesendet, wenn der e/a-Vorgang sofort abgeschlossen ist.</span><span class="sxs-lookup"><span data-stu-id="3682a-149">However, if [I/O completion ports](i-o-completion-ports.md) are being used with this asynchronous handle, a completion packet will also be sent even though the I/O operation completed immediately.</span></span> <span data-ttu-id="3682a-150">Anders ausgedrückt: Wenn die Anwendung Ressourcen freigibt, nachdem " **Write File** " den Wert " **true** " zurückgegeben hat, zusätzlich zu der e/a-Abschluss Port Routine, tritt ein Fehler auf, der einen doppelten freien Fehler enthält. **\_**</span><span class="sxs-lookup"><span data-stu-id="3682a-150">In other words, if the application frees resources after **WriteFile** returns **TRUE** with **ERROR\_SUCCESS** in addition to in the I/O completion port routine, it will have a double-free error condition.</span></span> <span data-ttu-id="3682a-151">In diesem Beispiel empfiehlt es sich, die Vervollständigungs Port Routine ausschließlich für alle Freigabe Vorgänge für solche Ressourcen zu übernehmen.</span><span class="sxs-lookup"><span data-stu-id="3682a-151">In this example, the recommendation would be to allow the completion port routine to be solely responsible for all freeing operations for such resources.</span></span>

<span data-ttu-id="3682a-152">Das System behält den Dateizeiger für asynchrone Handles nicht für Dateien und Geräte bei, die Dateizeiger unterstützen (d. h. Geräte suchen). Daher muss die Dateiposition an die Lese-und Schreibfunktionen in den zugehörigen Offset Datenmembern der [**über**](/windows/desktop/api/minwinbase/ns-minwinbase-overlapped) Lapp enden Struktur weitergegeben werden.</span><span class="sxs-lookup"><span data-stu-id="3682a-152">The system does not maintain the file pointer on asynchronous handles to files and devices that support file pointers (that is, seeking devices), therefore the file position must be passed to the read and write functions in the related offset data members of the [**OVERLAPPED**](/windows/desktop/api/minwinbase/ns-minwinbase-overlapped) structure.</span></span> <span data-ttu-id="3682a-153">Weitere Informationen finden Sie unter " [**Write File**](/windows/desktop/api/FileAPI/nf-fileapi-writefile) " und " [**Infofile**](/windows/desktop/api/FileAPI/nf-fileapi-readfile)".</span><span class="sxs-lookup"><span data-stu-id="3682a-153">For more information, see [**WriteFile**](/windows/desktop/api/FileAPI/nf-fileapi-writefile) and [**ReadFile**](/windows/desktop/api/FileAPI/nf-fileapi-readfile).</span></span>

<span data-ttu-id="3682a-154">Die Dateizeiger Position eines synchronen Handles wird vom System beibehalten, wenn Daten gelesen oder geschrieben werden, und kann auch mit der Funktion " [**SetFilePointer**](/windows/desktop/api/FileAPI/nf-fileapi-setfilepointer) " oder " [**setfilepointerex**](/windows/desktop/api/FileAPI/nf-fileapi-setfilepointerex) " aktualisiert werden.</span><span class="sxs-lookup"><span data-stu-id="3682a-154">File pointer position for a synchronous handle is maintained by the system as data is read or written and can also be updated using the [**SetFilePointer**](/windows/desktop/api/FileAPI/nf-fileapi-setfilepointer) or [**SetFilePointerEx**](/windows/desktop/api/FileAPI/nf-fileapi-setfilepointerex) function.</span></span>

<span data-ttu-id="3682a-155">Eine Anwendung kann auch auf das Datei Handle warten, um den Abschluss eines e/a-Vorgangs zu synchronisieren. Dies erfordert jedoch eine extrem Vorsicht.</span><span class="sxs-lookup"><span data-stu-id="3682a-155">An application can also wait on the file handle to synchronize the completion of an I/O operation, but doing so requires extreme caution.</span></span> <span data-ttu-id="3682a-156">Jedes Mal, wenn ein e/a-Vorgang gestartet wird, legt das Betriebssystem das Datei Handle auf den nicht signalisierten Zustand fest.</span><span class="sxs-lookup"><span data-stu-id="3682a-156">Each time an I/O operation is started, the operating system sets the file handle to the nonsignaled state.</span></span> <span data-ttu-id="3682a-157">Jedes Mal, wenn ein e/a-Vorgang abgeschlossen ist, legt das Betriebssystem das Datei Handle auf den signalisierten Zustand fest.</span><span class="sxs-lookup"><span data-stu-id="3682a-157">Each time an I/O operation is completed, the operating system sets the file handle to the signaled state.</span></span> <span data-ttu-id="3682a-158">Wenn eine Anwendung also zwei e/a-Vorgänge startet und auf das Datei Handle wartet, gibt es keine Möglichkeit, den Vorgang zu bestimmen, der abgeschlossen wird, wenn das Handle auf den signalisierten Zustand festgelegt ist.</span><span class="sxs-lookup"><span data-stu-id="3682a-158">Therefore, if an application starts two I/O operations and waits on the file handle, there is no way to determine which operation is finished when the handle is set to the signaled state.</span></span> <span data-ttu-id="3682a-159">Wenn eine Anwendung mehrere asynchrone e/a-Vorgänge für eine einzelne Datei ausführen muss, sollte Sie auf das Ereignis Handle in der spezifischen [**über**](/windows/desktop/api/minwinbase/ns-minwinbase-overlapped) Lapp enden Struktur für jeden e/a-Vorgang und nicht auf das Common File Handle warten.</span><span class="sxs-lookup"><span data-stu-id="3682a-159">If an application must perform multiple asynchronous I/O operations on a single file, it should wait on the event handle in the specific [**OVERLAPPED**](/windows/desktop/api/minwinbase/ns-minwinbase-overlapped) structure for each I/O operation, rather than on the common file handle.</span></span>

<span data-ttu-id="3682a-160">Um alle ausstehenden asynchronen e/a-Vorgänge abzubrechen, verwenden Sie Folgendes:</span><span class="sxs-lookup"><span data-stu-id="3682a-160">To cancel all pending asynchronous I/O operations, use either:</span></span>

-   <span data-ttu-id="3682a-161">[**CancelIo**](cancelio.md)– diese Funktion bricht nur Vorgänge ab, die vom aufrufenden Thread für das angegebene Datei Handle ausgegeben werden.</span><span class="sxs-lookup"><span data-stu-id="3682a-161">[**CancelIo**](cancelio.md)—this function only cancels operations issued by the calling thread for the specified file handle.</span></span>
-   <span data-ttu-id="3682a-162">[**CancelIoEx**](cancelioex-func.md)– diese Funktion bricht alle Vorgänge ab, die von den Threads für das angegebene Datei Handle ausgegeben werden.</span><span class="sxs-lookup"><span data-stu-id="3682a-162">[**CancelIoEx**](cancelioex-func.md)—this function cancels all operations issued by the threads for the specified file handle.</span></span>

<span data-ttu-id="3682a-163">Verwenden Sie [**CancelSynchronousIo**](cancelsynchronousio-func.md) , um ausstehende synchrone e/a-Vorgänge abzubrechen.</span><span class="sxs-lookup"><span data-stu-id="3682a-163">Use [**CancelSynchronousIo**](cancelsynchronousio-func.md) to cancel pending synchronous I/O operations.</span></span>

<span data-ttu-id="3682a-164">Mit den Funktionen "read [**fileex**](/windows/desktop/api/FileAPI/nf-fileapi-readfileex) " und " [**Write fileex**](/windows/desktop/api/FileAPI/nf-fileapi-writefileex) " kann eine Anwendung eine auszuführende Routine angeben (siehe [**fileiocompletionroutine**](/windows/win32/api/minwinbase/nc-minwinbase-lpoverlapped_completion_routine)), wenn die asynchrone e/a-Anforderung abgeschlossen ist.</span><span class="sxs-lookup"><span data-stu-id="3682a-164">The [**ReadFileEx**](/windows/desktop/api/FileAPI/nf-fileapi-readfileex) and [**WriteFileEx**](/windows/desktop/api/FileAPI/nf-fileapi-writefileex) functions enable an application to specify a routine to execute (see [**FileIOCompletionRoutine**](/windows/win32/api/minwinbase/nc-minwinbase-lpoverlapped_completion_routine)) when the asynchronous I/O request is completed.</span></span>

 

 
