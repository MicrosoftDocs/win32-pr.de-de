---
description: Beschreibt Überlegungen zur Anwendungssteuerung der Datei Pufferung, auch bekannt als nicht gepufferte Dateieingabe/-Ausgabe (e/a).
ms.assetid: ae1e5d0f-9b55-4aae-8402-b9c8e33d9363
title: Dateipufferung
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: a44f6724622b2c3116fa24a6109efb6c0d9f1d9f
ms.sourcegitcommit: 831e8f3db78ab820e1710cede244553c70e50500
ms.translationtype: MT
ms.contentlocale: de-DE
ms.lasthandoff: 01/08/2021
ms.locfileid: "104218014"
---
# <a name="file-buffering"></a><span data-ttu-id="54017-103">Dateipufferung</span><span class="sxs-lookup"><span data-stu-id="54017-103">File Buffering</span></span>

<span data-ttu-id="54017-104">In diesem Thema werden die verschiedenen Überlegungen zur Anwendungssteuerung der Datei Pufferung behandelt, auch bekannt als nicht gepufferte Dateieingabe/-Ausgabe (e/a).</span><span class="sxs-lookup"><span data-stu-id="54017-104">This topic covers the various considerations for application control of file buffering, also known as unbuffered file input/output (I/O).</span></span> <span data-ttu-id="54017-105">Die Datei Pufferung wird in der Regel vom System im Hintergrund verarbeitet und als Teil der Zwischenspeicherung von [Dateien](file-caching.md) innerhalb des Windows-Betriebssystems betrachtet, sofern nicht anders angegeben.</span><span class="sxs-lookup"><span data-stu-id="54017-105">File buffering is usually handled by the system behind the scenes and is considered part of [file caching](file-caching.md) within the Windows operating system unless otherwise specified.</span></span> <span data-ttu-id="54017-106">Obwohl *die Begriffe zwischen* Speicherung und *Pufferung* manchmal synonym verwendet werden, wird in diesem Thema der Begriff *Pufferung* speziell in dem Kontext erläutert, in dem erläutert wird, wie mit Daten interagiert wird, die nicht vom System zwischengespeichert (gepuffert) werden, da Sie ansonsten größtenteils nicht direkt von der direkten Steuerung der Benutzermodusanwendungen betroffen sind.</span><span class="sxs-lookup"><span data-stu-id="54017-106">Although the terms *caching* and *buffering* are sometimes used interchangeably, this topic uses the term *buffering* specifically in the context of explaining how to interact with data that is not being cached (buffered) by the system, where it is otherwise largely out of the direct control of user-mode applications.</span></span>

<span data-ttu-id="54017-107">Beim Öffnen oder Erstellen einer Datei mit der [**Funktion "**](/windows/desktop/api/FileAPI/nf-fileapi-createfilea) -Funktion" kann **das \_ Dateiflag " \_ kein \_ pufferungsflag** " angegeben werden, um das Zwischenspeichern von Daten, die aus der Datei gelesen oder in die Datei geschrieben werden, zu deaktivieren.</span><span class="sxs-lookup"><span data-stu-id="54017-107">When opening or creating a file with the [**CreateFile**](/windows/desktop/api/FileAPI/nf-fileapi-createfilea) function, the **FILE\_FLAG\_NO\_BUFFERING** flag can be specified to disable system caching of data being read from or written to the file.</span></span> <span data-ttu-id="54017-108">Obwohl dies eine umfassende und direkte Kontrolle über die Daten-e/a-Pufferung bietet, müssen im Fall von Dateien und ähnlichen Geräten Daten Ausrichtungs Anforderungen berücksichtigt werden.</span><span class="sxs-lookup"><span data-stu-id="54017-108">Although this gives complete and direct control over data I/O buffering, in the case of files and similar devices there are data alignment requirements that must be considered.</span></span>

> [!Note]  
> <span data-ttu-id="54017-109">Diese Ausrichtungs Informationen gelten für e/a-Vorgänge auf Geräten wie Dateien, die Suchvorgänge unterstützen, und das Konzept von Datei Positions Zeigern (oder *Offsets*).</span><span class="sxs-lookup"><span data-stu-id="54017-109">This alignment information applies to I/O on devices such as files that support seeking and the concept of file position pointers (or *offsets*).</span></span> <span data-ttu-id="54017-110">Bei Geräten, die nicht suchen, z. b. Named Pipes oder Kommunikationsgeräte, ist für das Ausschalten der Pufferung möglicherweise keine bestimmte Ausrichtung erforderlich.</span><span class="sxs-lookup"><span data-stu-id="54017-110">For devices that do not seek, such as named pipes or communications devices, turning off buffering may not require any particular alignment.</span></span> <span data-ttu-id="54017-111">Alle Einschränkungen oder Effizienz, die in diesem Fall durch die Ausrichtung erzielt werden können, sind von der zugrunde liegenden Technologie abhängig.</span><span class="sxs-lookup"><span data-stu-id="54017-111">Any limitations or efficiencies that may be gained by alignment in that case are dependent on the underlying technology.</span></span>

 

<span data-ttu-id="54017-112">In einem einfachen Beispiel öffnet die Anwendung eine Datei für den Schreibzugriff mit dem **\_ Dateiflag \_ kein \_ pufferungsflag** und führt dann einen Aufrufen der Funktion "Write [**File**](/windows/desktop/api/FileAPI/nf-fileapi-writefile) " mithilfe eines Daten Puffers aus, der in der Anwendung definiert ist.</span><span class="sxs-lookup"><span data-stu-id="54017-112">In a simple example, the application would open a file for write access with the **FILE\_FLAG\_NO\_BUFFERING** flag and then perform a call to the [**WriteFile**](/windows/desktop/api/FileAPI/nf-fileapi-writefile) function using a data buffer defined within the application.</span></span> <span data-ttu-id="54017-113">Dieser lokale Puffer ist in diesen Fällen tatsächlich der einzige Datei Puffer, der für diesen Vorgang vorhanden ist.</span><span class="sxs-lookup"><span data-stu-id="54017-113">This local buffer is, in these circumstances, effectively the only file buffer that exists for this operation.</span></span> <span data-ttu-id="54017-114">Aufgrund des physischen Datenträger Layouts, des Dateisystem-Speicher Layouts und der Dateizeiger-Positions Nachverfolgung auf Systemebene schlägt dieser Schreibvorgang fehl, es sei denn, die lokal definierten Datenpuffer erfüllen bestimmte Ausrichtungs Kriterien, die im folgenden Abschnitt erläutert werden.</span><span class="sxs-lookup"><span data-stu-id="54017-114">Because of physical disk layout, file system storage layout, and system-level file pointer position tracking, this write operation will fail unless the locally-defined data buffers meet certain alignment criteria, discussed in the following section.</span></span>

> [!Note]  
> <span data-ttu-id="54017-115">Bei der Erörterung der Zwischenspeicherung wird das Zwischenspeichern von Hardware auf dem physischen Datenträger selbst nicht berücksichtigt, da es in jedem Fall nicht unbedingt innerhalb der direkten Kontrolle des Systems ist.</span><span class="sxs-lookup"><span data-stu-id="54017-115">Discussion of caching does not consider any hardware caching on the physical disk itself, which is not guaranteed to be within the direct control of the system in any case.</span></span> <span data-ttu-id="54017-116">Dies hat keine Auswirkung auf die in diesem Thema angegebenen Anforderungen.</span><span class="sxs-lookup"><span data-stu-id="54017-116">This has no effect on the requirements specified in this topic.</span></span>

 

<span data-ttu-id="54017-117">Weitere Informationen darüber, wie **das \_ Dateiflag \_ keine \_ Pufferung** mit anderen Cache bezogenen Flags interagiert, finden Sie unter " [**kreatefile**](/windows/desktop/api/FileAPI/nf-fileapi-createfilea)".</span><span class="sxs-lookup"><span data-stu-id="54017-117">For more information on how **FILE\_FLAG\_NO\_BUFFERING** interacts with other cache-related flags, see [**CreateFile**](/windows/desktop/api/FileAPI/nf-fileapi-createfilea).</span></span>

## <a name="alignment-and-file-access-requirements"></a><span data-ttu-id="54017-118">Anforderungen an Ausrichtung und Dateizugriff</span><span class="sxs-lookup"><span data-stu-id="54017-118">Alignment and File Access Requirements</span></span>

<span data-ttu-id="54017-119">Wie bereits erwähnt, muss eine Anwendung bestimmte Anforderungen erfüllen, wenn Sie mit Dateien arbeiten, die mit dem **\_ Dateiflag \_ keine \_ Pufferung** geöffnet wurden.</span><span class="sxs-lookup"><span data-stu-id="54017-119">As previously discussed, an application must meet certain requirements when working with files opened with **FILE\_FLAG\_NO\_BUFFERING**.</span></span> <span data-ttu-id="54017-120">Es gelten die folgenden Besonderheiten:</span><span class="sxs-lookup"><span data-stu-id="54017-120">The following specifics apply:</span></span>

-   <span data-ttu-id="54017-121">Datei zugriffsgrößen, einschließlich des optionalen Dateioffsets in der [**über**](/windows/desktop/api/minwinbase/ns-minwinbase-overlapped) Lapp enden Struktur, müssen für eine Anzahl von Bytes sein, bei der es sich um ein ganzzahliges Vielfaches der volumesektorgröße handelt.</span><span class="sxs-lookup"><span data-stu-id="54017-121">File access sizes, including the optional file offset in the [**OVERLAPPED**](/windows/desktop/api/minwinbase/ns-minwinbase-overlapped) structure, if specified, must be for a number of bytes that is an integer multiple of the volume sector size.</span></span> <span data-ttu-id="54017-122">Wenn die Sektorgröße z. b. 512 Bytes beträgt, kann eine Anwendung Lese-und Schreibvorgänge von 512, 1.024, 1.536 oder 2.048 bytes, jedoch nicht von 335, 981 oder 7.171 bytes anfordern.</span><span class="sxs-lookup"><span data-stu-id="54017-122">For example, if the sector size is 512 bytes, an application can request reads and writes of 512, 1,024, 1,536, or 2,048 bytes, but not of 335, 981, or 7,171 bytes.</span></span>
-   <span data-ttu-id="54017-123">Datei Zugriffs Puffer-Adressen für Lese-und Schreibvorgänge sollten physisch sektororientiert sein, was bedeutet, dass Adressen im Arbeitsspeicher ausgerichtet sind, bei denen es sich um ganzzahlige Vielfache der physischen Sektorgröße des Volumes handelt.</span><span class="sxs-lookup"><span data-stu-id="54017-123">File access buffer addresses for read and write operations should be physical sector-aligned, which means aligned on addresses in memory that are integer multiples of the volume's physical sector size.</span></span> <span data-ttu-id="54017-124">Abhängig vom Datenträger wird diese Anforderung möglicherweise nicht erzwungen.</span><span class="sxs-lookup"><span data-stu-id="54017-124">Depending on the disk, this requirement may not be enforced.</span></span>

<span data-ttu-id="54017-125">Anwendungsentwickler sollten die neuen Typen von Speichergeräten notieren, die auf dem Markt mit einer physischen Medien Sektorgröße von 4.096 Bytes eingeführt werden.</span><span class="sxs-lookup"><span data-stu-id="54017-125">Application developers should take note of new types of storage devices being introduced into the market with a physical media sector size of 4,096 bytes.</span></span> <span data-ttu-id="54017-126">Der Branchen Name für diese Geräte ist "Erweitertes Format".</span><span class="sxs-lookup"><span data-stu-id="54017-126">The industry name for these devices is "Advanced Format".</span></span> <span data-ttu-id="54017-127">Da es möglicherweise Kompatibilitätsprobleme bei der direkten Einführung von 4.096 Bytes als Einheit der Adressierung für das Medium gibt, besteht eine temporäre Kompatibilitäts Lösung darin, Geräte einzuführen, die ein reguläres 512-Byte-sektorspeichergerät emulieren, aber über standardmäßige ATA-und SCSI-Befehle Informationen über die tatsächliche Sektorgröße bereitstellen.</span><span class="sxs-lookup"><span data-stu-id="54017-127">As there may be compatibility issues with directly introducing 4,096 bytes as the unit of addressing for the media, a temporary compatibility solution is to introduce devices that emulate a regular 512-byte sector storage device but make available information about the true sector size through standard ATA and SCSI commands.</span></span>

<span data-ttu-id="54017-128">Aufgrund dieser Emulation gibt es im Wesentlichen zwei Sektorgrößen, die Entwickler verstehen müssen:</span><span class="sxs-lookup"><span data-stu-id="54017-128">As a result of this emulation, there are in essence two sector sizes that developers will need to understand:</span></span>

-   <span data-ttu-id="54017-129">Logischer Sektor: die Einheit, die für die logische Block Adressierung für das Medium verwendet wird.</span><span class="sxs-lookup"><span data-stu-id="54017-129">Logical Sector: The unit that is used for logical block addressing for the media.</span></span> <span data-ttu-id="54017-130">Wir können uns dies auch als kleinste Schreibeinheit vorstellen, die der Speicher annehmen kann.</span><span class="sxs-lookup"><span data-stu-id="54017-130">We can also think of it as the smallest unit of write that the storage can accept.</span></span> <span data-ttu-id="54017-131">Dies ist die "Emulation".</span><span class="sxs-lookup"><span data-stu-id="54017-131">This is the "emulation".</span></span>
-   <span data-ttu-id="54017-132">Physischer Sektor: die Einheit, für die Lese-und Schreibvorgänge auf dem Gerät in einem einzelnen Vorgang abgeschlossen werden.</span><span class="sxs-lookup"><span data-stu-id="54017-132">Physical Sector: The unit for which read and write operations to the device are completed in a single operation.</span></span> <span data-ttu-id="54017-133">Dies ist die Einheit des atomaren Schreibzugriffs und die nicht gepufferte e/a, die für die optimale Leistung und Zuverlässigkeit von Merkmalen ausgerichtet werden muss.</span><span class="sxs-lookup"><span data-stu-id="54017-133">This is the unit of atomic write, and what unbuffered I/O will need to be aligned to in order to have optimal performance and reliability characteristics.</span></span>

<span data-ttu-id="54017-134">Die meisten aktuellen Windows-APIs, wie z. b. [**IOCTL \_ Disk \_ get \_ Drive \_ Geometry**](/windows/desktop/api/WinIoCtl/ni-winioctl-ioctl_disk_get_drive_geometry) und [**GetDiskFreeSpace**](/windows/desktop/api/FileAPI/nf-fileapi-getdiskfreespacea), geben die logische Sektorgröße zurück, aber die physische Sektorgröße kann über den [**IOCTL \_ Storage \_ Query- \_ Eigenschafts**](/windows/desktop/api/WinIoCtl/ni-winioctl-ioctl_storage_query_property) Steuerungs Code abgerufen werden, wobei die relevanten Informationen im **bytesperphysicalsektor-** Member in der-Struktur der [**Speicher \_ Zugriffs \_ Ausrichtung \_**](/windows/desktop/api/WinIoCtl/ns-winioctl-storage_access_alignment_descriptor) angezeigt werden.</span><span class="sxs-lookup"><span data-stu-id="54017-134">Most current Windows APIs, such as [**IOCTL\_DISK\_GET\_DRIVE\_GEOMETRY**](/windows/desktop/api/WinIoCtl/ni-winioctl-ioctl_disk_get_drive_geometry) and [**GetDiskFreeSpace**](/windows/desktop/api/FileAPI/nf-fileapi-getdiskfreespacea), will return the logical sector size, but the physical sector size can be retrieved through the [**IOCTL\_STORAGE\_QUERY\_PROPERTY**](/windows/desktop/api/WinIoCtl/ni-winioctl-ioctl_storage_query_property) control code, with the relevant information contained in the **BytesPerPhysicalSector** member in the [**STORAGE\_ACCESS\_ALIGNMENT\_DESCRIPTOR**](/windows/desktop/api/WinIoCtl/ns-winioctl-storage_access_alignment_descriptor) structure.</span></span> <span data-ttu-id="54017-135">Ein Beispiel finden Sie im Beispielcode unter [**Speicher \_ Zugriffs- \_ Ausrichtungs \_ Deskriptor**](/windows/desktop/api/WinIoCtl/ns-winioctl-storage_access_alignment_descriptor).</span><span class="sxs-lookup"><span data-stu-id="54017-135">For an example, see the sample code at [**STORAGE\_ACCESS\_ALIGNMENT\_DESCRIPTOR**](/windows/desktop/api/WinIoCtl/ns-winioctl-storage_access_alignment_descriptor).</span></span> <span data-ttu-id="54017-136">Microsoft empfiehlt dringend, dass Entwickler nicht gepufferte e/a-Vorgänge an die physische Sektorgröße ausrichten, wie vom Steuercode der **IOCTL \_ Storage \_ Query- \_ Eigenschaft** gemeldet, um sicherzustellen, dass Ihre Anwendungen für diesen Sektorgrößen Übergang vorbereitet werden.</span><span class="sxs-lookup"><span data-stu-id="54017-136">Microsoft strongly recommends that developers align unbuffered I/O to the physical sector size as reported by the **IOCTL\_STORAGE\_QUERY\_PROPERTY** control code to help ensure their applications are prepared for this sector size transition.</span></span>

<span data-ttu-id="54017-137">**Windows Server 2003 und Windows XP:** Die [**\_ \_ \_ deskriptorstruktur der Speicherzugriffs Ausrichtung**](/windows/desktop/api/WinIoCtl/ns-winioctl-storage_access_alignment_descriptor) ist nicht verfügbar.</span><span class="sxs-lookup"><span data-stu-id="54017-137">**Windows Server 2003 and Windows XP:** The [**STORAGE\_ACCESS\_ALIGNMENT\_DESCRIPTOR**](/windows/desktop/api/WinIoCtl/ns-winioctl-storage_access_alignment_descriptor) structure is not available.</span></span> <span data-ttu-id="54017-138">Es wurde mit Windows Vista und Windows Server 2008 eingeführt.</span><span class="sxs-lookup"><span data-stu-id="54017-138">It was introduced with Windows Vista and Windows Server 2008.</span></span>

<span data-ttu-id="54017-139">Da Puffer Adressen für Lese-und Schreibvorgänge sektororientiert sein müssen, muss die Anwendung direkt steuern können, wie diese Puffer zugewiesen werden.</span><span class="sxs-lookup"><span data-stu-id="54017-139">Because buffer addresses for read and write operations must be sector-aligned, the application must have direct control of how these buffers are allocated.</span></span> <span data-ttu-id="54017-140">Eine Möglichkeit, Puffer in Sektoren auszurichten, ist die Verwendung der [**VirtualAlloc**](/windows/desktop/api/memoryapi/nf-memoryapi-virtualalloc) -Funktion, um die Puffer zuzuordnen.</span><span class="sxs-lookup"><span data-stu-id="54017-140">One way to sector-align buffers is to use the [**VirtualAlloc**](/windows/desktop/api/memoryapi/nf-memoryapi-virtualalloc) function to allocate the buffers.</span></span> <span data-ttu-id="54017-141">Beachten Sie Folgendes:</span><span class="sxs-lookup"><span data-stu-id="54017-141">Consider the following:</span></span>

-   <span data-ttu-id="54017-142">[**Virtualbelegc**](/windows/desktop/api/memoryapi/nf-memoryapi-virtualalloc) ordnet Arbeitsspeicher zu, bei dem es sich um ganzzahlige Vielfache der Seitengröße des Systems handelt.</span><span class="sxs-lookup"><span data-stu-id="54017-142">[**VirtualAlloc**](/windows/desktop/api/memoryapi/nf-memoryapi-virtualalloc) allocates memory that is aligned on addresses that are integer multiples of the system's page size.</span></span> <span data-ttu-id="54017-143">Die Seitengröße beträgt 4.096 Bytes auf x64-und x86-oder 8.192-Bytes für Itanium-basierte Systeme.</span><span class="sxs-lookup"><span data-stu-id="54017-143">Page size is 4,096 bytes on x64 and x86 or 8,192 bytes for Itanium-based systems.</span></span> <span data-ttu-id="54017-144">Weitere Informationen finden Sie unter der [**GetSystemInfo**](/windows/desktop/api/sysinfoapi/nf-sysinfoapi-getsysteminfo) -Funktion.</span><span class="sxs-lookup"><span data-stu-id="54017-144">For additional information, see the [**GetSystemInfo**](/windows/desktop/api/sysinfoapi/nf-sysinfoapi-getsysteminfo) function.</span></span>
-   <span data-ttu-id="54017-145">Die Sektorgröße beträgt in der Regel 512 bis 4.096 Bytes für direkt Zugriff auf Speichergeräte (Festplatten) und 2.048 Bytes für CD-ROMs.</span><span class="sxs-lookup"><span data-stu-id="54017-145">Sector size is typically 512 to 4,096 bytes for direct-access storage devices (hard drives) and 2,048 bytes for CD-ROMs.</span></span>
-   <span data-ttu-id="54017-146">Sowohl die Seiten-als auch die Sektorgröße sind die Kräfte 2.</span><span class="sxs-lookup"><span data-stu-id="54017-146">Both page and sector sizes are powers of 2.</span></span>

<span data-ttu-id="54017-147">In den meisten Fällen wird der Seiten basierte Speicher auch sektororientiert, da der Fall, in dem die Sektorgröße größer ist als die Seitengröße, selten vorkommt.</span><span class="sxs-lookup"><span data-stu-id="54017-147">Therefore, in most situations, page-aligned memory will also be sector-aligned, because the case where the sector size is larger than the page size is rare.</span></span>

<span data-ttu-id="54017-148">Eine weitere Möglichkeit zum Abrufen von manuell ausgerichteten Speicher Puffern ist die Verwendung der [ \_ ausgerichteten \_ malloc](/cpp/c-runtime-library/reference/aligned-malloc?view=vs-2019) -Funktion aus der C-Run-Time-Bibliothek.</span><span class="sxs-lookup"><span data-stu-id="54017-148">Another way to obtain manually-aligned memory buffers is to use the [\_aligned\_malloc](/cpp/c-runtime-library/reference/aligned-malloc?view=vs-2019) function from the C Run-Time library.</span></span> <span data-ttu-id="54017-149">Ein Beispiel für die manuelle Steuerung der Puffer Ausrichtung finden Sie im C++-Sprachcode Beispiel im Beispielcode Abschnitt von " [**Write File**](/windows/desktop/api/FileAPI/nf-fileapi-writefile)".</span><span class="sxs-lookup"><span data-stu-id="54017-149">For an example of how to manually control buffer alignment, see the C++ language code example in the Example Code section of [**WriteFile**](/windows/desktop/api/FileAPI/nf-fileapi-writefile).</span></span>

 

 
