---
title: Codierung für Multicore auf Xbox 360 und Windows
description: Dieses Thema enthält eine Anleitung für die ersten Schritte bei der Multithreadprogrammierung.
ms.assetid: 661f13a6-c73d-8513-2bad-0ef9d1a361a0
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: 75899dacdfba829fc1a83e9393e6aa58574c9f30
ms.sourcegitcommit: 89f99926f946dc6c5ea600fb7c41f6b19ceac516
ms.translationtype: MT
ms.contentlocale: de-DE
ms.lasthandoff: 10/21/2020
ms.locfileid: "104391206"
---
# <a name="coding-for-multicore-on-xbox-360-and-windows"></a><span data-ttu-id="cb6e1-103">Codierung für Multicore auf Xbox 360 und Windows</span><span class="sxs-lookup"><span data-stu-id="cb6e1-103">Coding for multicore on Xbox 360 and Windows</span></span>

<span data-ttu-id="cb6e1-104">Seit Jahren hat sich die Leistung von Prozessoren stetig gesteigert, und Spiele und andere Programme haben die Vorteile dieser zunehmenden Leistung wiederholt, ohne dass Sie etwas Besonderes tun müssen.</span><span class="sxs-lookup"><span data-stu-id="cb6e1-104">For years the performance of processors has increased steadily, and games and other programs have reaped the benefits of this increasing power without having to do anything special.</span></span>

<span data-ttu-id="cb6e1-105">Die Regeln wurden geändert.</span><span class="sxs-lookup"><span data-stu-id="cb6e1-105">The rules have changed.</span></span> <span data-ttu-id="cb6e1-106">Die Leistung einzelner Prozessorkerne steigt jetzt sehr langsam, wenn überhaupt.</span><span class="sxs-lookup"><span data-stu-id="cb6e1-106">The performance of single processor cores is now increasing very slowly, if at all.</span></span> <span data-ttu-id="cb6e1-107">Die computeleistung, die auf einem typischen Computer oder einer typischen Konsole verfügbar ist, wächst jedoch weiter.</span><span class="sxs-lookup"><span data-stu-id="cb6e1-107">However, the computing power available in a typical computer or console continues to grow.</span></span> <span data-ttu-id="cb6e1-108">Der Unterschied besteht darin, dass der größte Teil dieses Leistungs Gewinns nun von mehreren Prozessorkernen auf einem einzelnen Computer (häufig in einem einzigen Chip) stammt.</span><span class="sxs-lookup"><span data-stu-id="cb6e1-108">The difference is that most of this performance gain now comes from having multiple processor cores in a single machine, often in a single chip.</span></span> <span data-ttu-id="cb6e1-109">Die Xbox 360-CPU verfügt über drei Prozessorkerne auf einem Chip, und ungefähr 70 Prozent der 2006 verkauften PC-Prozessoren waren mehrere Kerne.</span><span class="sxs-lookup"><span data-stu-id="cb6e1-109">The Xbox 360 CPU has three processor cores on one chip, and roughly 70 percent of PC processors sold in 2006 were multi-core.</span></span>

<span data-ttu-id="cb6e1-110">Die Zunahme der verfügbaren Verarbeitungsleistung ist genauso dramatisch wie in der Vergangenheit, aber jetzt müssen Entwickler Multithread-Code schreiben, um diese Leistungsfähigkeit zu nutzen.</span><span class="sxs-lookup"><span data-stu-id="cb6e1-110">The increases in available processing power are just as dramatic as in the past, but now developers have to write multithreaded code in order to use this power.</span></span> <span data-ttu-id="cb6e1-111">Die Multithreadprogrammierung bringt neue Entwurfs-und Programmierungs Herausforderungen mit sich.</span><span class="sxs-lookup"><span data-stu-id="cb6e1-111">Multi-threaded programming brings with it new design and programming challenges.</span></span> <span data-ttu-id="cb6e1-112">Dieses Thema enthält eine Anleitung für die ersten Schritte bei der Multithreadprogrammierung.</span><span class="sxs-lookup"><span data-stu-id="cb6e1-112">This topic gives some advice on how to get started with multithreaded programming.</span></span>

## <a name="the-importance-of-good-design"></a><span data-ttu-id="cb6e1-113">Die Wichtigkeit eines guten Entwurfs</span><span class="sxs-lookup"><span data-stu-id="cb6e1-113">The Importance of Good Design</span></span>

<span data-ttu-id="cb6e1-114">Ein guter Multithread-Programmentwurf ist wichtig, kann aber sehr schwierig sein.</span><span class="sxs-lookup"><span data-stu-id="cb6e1-114">Good multithreaded program design is critical, but it can be very difficult.</span></span> <span data-ttu-id="cb6e1-115">Wenn Sie Ihre großen Spielsysteme willkürlich in verschiedene Threads verschieben, werden Sie wahrscheinlich feststellen, dass jeder Thread die meiste Zeit mit dem warten auf die anderen Threads verbringt.</span><span class="sxs-lookup"><span data-stu-id="cb6e1-115">If you haphazardly move your major game systems onto different threads, you will likely find that each thread spends most of its time waiting on the other threads.</span></span> <span data-ttu-id="cb6e1-116">Diese Art von Entwurf führt zu einer verbesserten Komplexität und einem erheblichen debuggingaufwand, ohne Leistungssteigerung.</span><span class="sxs-lookup"><span data-stu-id="cb6e1-116">This type of design leads to increased complexity and significant debugging effort, with virtually no performance gain.</span></span>

<span data-ttu-id="cb6e1-117">Jedes Mal, wenn Threads Daten synchronisieren oder freigeben müssen, besteht die Möglichkeit, Daten zu beschädigen, den Synchronisierungs Aufwand, Deadlocks und Komplexität zu reduzieren.</span><span class="sxs-lookup"><span data-stu-id="cb6e1-117">Every time that threads have to synchronize or share data there is the potential for data corruption, synchronization overhead, deadlocks, and complexity.</span></span> <span data-ttu-id="cb6e1-118">Daher muss der Multithread-Entwurf alle Synchronisierungs-und Kommunikationspunkte eindeutig dokumentieren, und diese Punkte sollten so weit wie möglich minimiert werden.</span><span class="sxs-lookup"><span data-stu-id="cb6e1-118">Therefore, your multithreaded design needs to clearly document every synchronization and communication point, and it should minimize such points as much as possible.</span></span> <span data-ttu-id="cb6e1-119">Wenn Threads kommunizieren müssen, erhöht sich der Codierungsaufwand, was die Produktivität verringern kann, wenn sich dieser zu stark auf den Quellcode auswirkt.</span><span class="sxs-lookup"><span data-stu-id="cb6e1-119">Where threads need to communicate, coding effort will increase, which can lower productivity if it affects too much source code.</span></span>

<span data-ttu-id="cb6e1-120">Das einfachste Entwurfs Ziel für Multithreading besteht darin, den Code in große unabhängige Elemente aufzuteilen.</span><span class="sxs-lookup"><span data-stu-id="cb6e1-120">The simplest design goal for multithreading is to break up the code into large independent pieces.</span></span> <span data-ttu-id="cb6e1-121">Wenn Sie diese Teile dann so beschränken, dass Sie nur wenige Male pro Frame kommunizieren, wird eine deutliche Beschleunigung von Multithreading ohne unnötige Komplexität angezeigt.</span><span class="sxs-lookup"><span data-stu-id="cb6e1-121">If you then restrict these pieces to communicating just a few times per frame, you will see significant speedup from multithreading, without undue complexity.</span></span>

## <a name="typical-threaded-tasks"></a><span data-ttu-id="cb6e1-122">Typische Thread Aufgaben</span><span class="sxs-lookup"><span data-stu-id="cb6e1-122">Typical Threaded Tasks</span></span>

<span data-ttu-id="cb6e1-123">Einige Arten von Aufgaben haben sich für das Platzieren von besser eher in separaten Threads bewährt.</span><span class="sxs-lookup"><span data-stu-id="cb6e1-123">A few types of tasks have proven amenable to being put onto separate threads.</span></span> <span data-ttu-id="cb6e1-124">Die folgende Liste ist nicht als vollständig gedacht, sollte jedoch einige Ideen enthalten.</span><span class="sxs-lookup"><span data-stu-id="cb6e1-124">The following list is not intended to be exhaustive, but should give some ideas.</span></span>

### <a name="rendering"></a><span data-ttu-id="cb6e1-125">Darstellung</span><span class="sxs-lookup"><span data-stu-id="cb6e1-125">Rendering</span></span>

<span data-ttu-id="cb6e1-126">Rendering – Dies kann das Durchlaufen des Szenen Diagramms oder möglicherweise nur das Aufrufen von D3D-Funktionen umfassen – zählt häufig 50 Prozent oder mehr CPU-Zeit.</span><span class="sxs-lookup"><span data-stu-id="cb6e1-126">Rendering — which may include walking the scene graph or, possibly, only calling D3D functions — often accounts for 50 percent or more of CPU time.</span></span> <span data-ttu-id="cb6e1-127">Daher kann das Verschieben von Rendering in einen anderen Thread bedeutende Vorteile haben.</span><span class="sxs-lookup"><span data-stu-id="cb6e1-127">Therefore, moving rendering to another thread can have significant benefits.</span></span> <span data-ttu-id="cb6e1-128">Der Aktualisierungs Thread kann eine Art von renderbeschreibungs-Puffer ausfüllen, den der renderinglothread verarbeiten kann.</span><span class="sxs-lookup"><span data-stu-id="cb6e1-128">The update thread can fill in some sort of render description buffer, which the rendering thread can then process.</span></span>

<span data-ttu-id="cb6e1-129">Der spielaktualisierungs Thread ist immer ein Frame vor dem Renderthread, d. h., es werden zwei Frames benötigt, bevor Benutzeraktionen auf dem Bildschirm angezeigt werden.</span><span class="sxs-lookup"><span data-stu-id="cb6e1-129">The game update thread is always one frame ahead of the render thread, which means that it takes two frames before user actions show up on the screen.</span></span> <span data-ttu-id="cb6e1-130">Obwohl diese zunehmende Latenz ein Problem darstellen kann, wird durch die gestiegene Framerate beim Aufteilen der Arbeitsauslastung in der Regel die gesamte Latenzzeit akzeptabel.</span><span class="sxs-lookup"><span data-stu-id="cb6e1-130">Although this increased latency can be a problem, the increased frame rate from splitting up the workload generally keeps the total latency acceptable.</span></span>

<span data-ttu-id="cb6e1-131">In den meisten Fällen werden alle Renderingvorgänge weiterhin in einem einzelnen Thread ausgeführt, aber es handelt sich um einen anderen Thread aus dem Spiel Update.</span><span class="sxs-lookup"><span data-stu-id="cb6e1-131">In most cases all rendering is still done on a single thread, but it is a different thread from the game update.</span></span>

<span data-ttu-id="cb6e1-132">Das D3DCREATE \_ -multithreadflag wird manchmal verwendet, um das Rendering in einer Thread-und Ressourcen Erstellung auf anderen Threads zuzulassen. dieses Flag wird auf Xbox 360 ignoriert, und Sie sollten es nicht unter Windows verwenden.</span><span class="sxs-lookup"><span data-stu-id="cb6e1-132">The D3DCREATE\_MULTITHREADED flag is sometimes used to allow rendering on one thread and resource creation on other threads; this flag is ignored on Xbox 360, and you should avoid using it on Windows.</span></span> <span data-ttu-id="cb6e1-133">Unter Windows zwingt die Angabe dieses Flags, dass D3D eine beträchtliche Zeit für die Synchronisierung verbringt und somit den Renderthread verlangsamt.</span><span class="sxs-lookup"><span data-stu-id="cb6e1-133">On Windows, specifying this flag forces D3D to spend a significant amount of time on synchronization, thus slowing down the render thread.</span></span>

### <a name="file-decompression"></a><span data-ttu-id="cb6e1-134">Datei Dekomprimierung</span><span class="sxs-lookup"><span data-stu-id="cb6e1-134">File Decompression</span></span>

<span data-ttu-id="cb6e1-135">Ladezeiten sind immer zu lang, und das Streamen von Daten in den Arbeitsspeicher, ohne die Framerate zu beeinträchtigen, kann schwierig sein.</span><span class="sxs-lookup"><span data-stu-id="cb6e1-135">Load times are always too long, and streaming data into memory without affecting the frame rate can be challenging.</span></span> <span data-ttu-id="cb6e1-136">Wenn alle Daten auf der Festplatte aggressiv komprimiert werden, ist die Daten Übertragungsgeschwindigkeit von der Festplatte oder der optischen Festplatte weniger wahrscheinlich ein einschränkender Faktor.</span><span class="sxs-lookup"><span data-stu-id="cb6e1-136">If all data is aggressively compressed on disc, then data transfer speed from the hard drive or optical disc is less likely to be a limiting factor.</span></span> <span data-ttu-id="cb6e1-137">Bei einem Single Thread-Prozessor ist in der Regel nicht genügend Prozessorzeit für die Komprimierung verfügbar, um das Laden von Zeiten zu unterstützen.</span><span class="sxs-lookup"><span data-stu-id="cb6e1-137">On a single-threaded processor, there is usually not enough processor time available for compression to help load times.</span></span> <span data-ttu-id="cb6e1-138">Bei einem Multiprozessorsystem verwendet die Datei Dekomprimierung jedoch CPU-Zyklen, die andernfalls verschwendet würden. Es verbessert Ladezeiten und Streaming. und es spart Speicherplatz auf der Festplatte.</span><span class="sxs-lookup"><span data-stu-id="cb6e1-138">On a multiprocessor system, however, file decompression uses CPU cycles that would otherwise be wasted; it improves load times and streaming; and it saves space on the disc.</span></span>

<span data-ttu-id="cb6e1-139">Verwenden Sie die Datei Dekomprimierung nicht als Ersatz für die Verarbeitung, die während der Produktion durchgeführt werden soll.</span><span class="sxs-lookup"><span data-stu-id="cb6e1-139">Do not use file decompression as a replacement for processing that should be done during production.</span></span> <span data-ttu-id="cb6e1-140">Wenn Sie beispielsweise einen zusätzlichen Thread zum Durchlaufen von XML-Daten beim Laden der Ebene verwenden, verwenden Sie Multithreading nicht, um die Benutzeroberflächen zu verbessern.</span><span class="sxs-lookup"><span data-stu-id="cb6e1-140">For instance, if you devote an extra thread to parsing XML data during level loading, you are not using multithreading to improve the player's experience.</span></span>

<span data-ttu-id="cb6e1-141">Wenn Sie einen dateidekomprimierungsthread verwenden, sollten Sie weiterhin asynchrone Datei-e/a-Vorgänge und große Lesevorgänge verwenden, um die Daten Leseeffizienz zu maximieren.</span><span class="sxs-lookup"><span data-stu-id="cb6e1-141">When using a file decompression thread, you should still use asynchronous file I/O and large reads in order to maximize data-reading efficiency.</span></span>

### <a name="graphics-fluff"></a><span data-ttu-id="cb6e1-142">Grafik Fluff</span><span class="sxs-lookup"><span data-stu-id="cb6e1-142">Graphics Fluff</span></span>

<span data-ttu-id="cb6e1-143">Es gibt viele grafische niceties, die das Aussehen des Spiels verbessern, aber nicht unbedingt notwendig sind.</span><span class="sxs-lookup"><span data-stu-id="cb6e1-143">There are many graphical niceties that improve the look of the game but aren't strictly necessary.</span></span> <span data-ttu-id="cb6e1-144">Dazu zählen z. b. Prozeduren mit Prozeduren, die für die prozedurale Generierung von Cloud-Animationen, Tuch-und Haar Simulationen, prozedurale Wellen, prozedurale</span><span class="sxs-lookup"><span data-stu-id="cb6e1-144">These include things like procedurally generated cloud animations, cloth and hair simulations, procedural waves, procedural vegetation, more particles, or non-gameplay physics.</span></span>

<span data-ttu-id="cb6e1-145">Da diese Auswirkungen sich nicht auf das-Spiel-Spiel auswirken, verursachen Sie keine schwierigen Synchronisierungs Probleme – Sie können einmal pro Frame oder seltener mit den anderen Threads synchronisiert werden.</span><span class="sxs-lookup"><span data-stu-id="cb6e1-145">Because these effects don't affect gameplay, they don't cause tricky synchronization problems—they can synchronize with the other threads once per frame or less often.</span></span> <span data-ttu-id="cb6e1-146">Außerdem können diese Effekte bei Spielen für Windows einen Mehrwert für Spieler mit Multikern-CPUs schaffen, während Sie auf Einzel Kern Computern im Hintergrund ausgelassen werden, sodass eine einfache Möglichkeit zur Skalierung über eine Vielzahl von Funktionen bietet.</span><span class="sxs-lookup"><span data-stu-id="cb6e1-146">Additionally, on games for Windows these effects can add value for gamers with multicore CPUs, while silently being omitted on single-core computers, thus giving an easy way of scaling across a wide range of capabilities.</span></span>

### <a name="physics"></a><span data-ttu-id="cb6e1-147">Physische Effekte</span><span class="sxs-lookup"><span data-stu-id="cb6e1-147">Physics</span></span>

<span data-ttu-id="cb6e1-148">Die Physik kann häufig nicht in einem separaten Thread abgelegt werden, sodass Sie parallel zum Spiel Update ausgeführt werden kann, da das Spiel Update in der Regel die Ergebnisse der Physik-Berechnungen sofort erfordert.</span><span class="sxs-lookup"><span data-stu-id="cb6e1-148">Physics often cannot be put onto a separate thread to run in parallel with the game update because the game update usually requires the results of the physics calculations immediately.</span></span> <span data-ttu-id="cb6e1-149">Die Alternative zum Multithreading der Physik besteht darin, Sie auf mehreren Prozessoren auszuführen.</span><span class="sxs-lookup"><span data-stu-id="cb6e1-149">The alternative for multithreading physics is to run it on multiple processors.</span></span> <span data-ttu-id="cb6e1-150">Obwohl dies möglich ist, ist es eine komplexe Aufgabe, die häufigen Zugriff auf freigegebene Datenstrukturen benötigt.</span><span class="sxs-lookup"><span data-stu-id="cb6e1-150">Although this can be done, it is a complex task requiring frequent access to shared data structures.</span></span> <span data-ttu-id="cb6e1-151">Wenn Sie die Arbeitsauslastung der Physik so niedrig halten können, dass Sie in den Haupt Thread passt, ist Ihr Auftrag einfacher.</span><span class="sxs-lookup"><span data-stu-id="cb6e1-151">If you can keep your physics workload low enough to fit on the main thread, your job will be simpler.</span></span>

<span data-ttu-id="cb6e1-152">Bibliotheken, die das Ausführen von Physik in mehreren Threads unterstützen, sind verfügbar.</span><span class="sxs-lookup"><span data-stu-id="cb6e1-152">Libraries that support running physics on multiple threads are available.</span></span> <span data-ttu-id="cb6e1-153">Dies kann jedoch zu einem Problem führen: Wenn das Spiel die Physik betreibt, werden viele Threads verwendet, aber der Rest der Zeit verwendet nur wenige Threads.</span><span class="sxs-lookup"><span data-stu-id="cb6e1-153">However, this can lead to a problem: when your game is running physics, it uses many threads, but the rest of the time it uses few.</span></span> <span data-ttu-id="cb6e1-154">Das Ausführen von Physik in mehreren Threads erfordert dies, damit die Arbeitsauslastung gleichmäßig über den Frame verteilt wird.</span><span class="sxs-lookup"><span data-stu-id="cb6e1-154">Running physics on multiple threads will require addressing this so that the workload is distributed evenly over the frame.</span></span> <span data-ttu-id="cb6e1-155">Wenn Sie eine Multithread-Physik-Engine schreiben, müssen Sie auf alle Datenstrukturen, Synchronisierungs Punkte und den Lastenausgleich achten.</span><span class="sxs-lookup"><span data-stu-id="cb6e1-155">If you write a multithreaded physics engine, you must pay careful attention to all of your data structures, synchronization points, and load balancing.</span></span>

## <a name="example-multithreaded-designs"></a><span data-ttu-id="cb6e1-156">Beispiel für Multithread-Entwürfe</span><span class="sxs-lookup"><span data-stu-id="cb6e1-156">Example Multithreaded Designs</span></span>

<span data-ttu-id="cb6e1-157">Spiele für Windows müssen auf Computern mit einer unterschiedlichen Anzahl von CPU-Kernen ausgeführt werden.</span><span class="sxs-lookup"><span data-stu-id="cb6e1-157">Games for Windows need to run on computers with different numbers of CPU cores.</span></span> <span data-ttu-id="cb6e1-158">Die meisten Spielcomputer haben immer noch nur einen Kern, obwohl die Anzahl der Computer mit zwei Kernen schnell zunimmt.</span><span class="sxs-lookup"><span data-stu-id="cb6e1-158">Most game machines still have only one core, although the number of two-core machines is growing rapidly.</span></span> <span data-ttu-id="cb6e1-159">Ein typisches Spiel für Windows kann seine Arbeitsauslastung in einem Thread für Update und Rendering unterbrechen, wobei optionale Arbeitsthreads zum Hinzufügen zusätzlicher Funktionen erforderlich sind.</span><span class="sxs-lookup"><span data-stu-id="cb6e1-159">A typical game for Windows might break its workload into one thread for update and rendering, with optional worker threads for adding extra functionality.</span></span> <span data-ttu-id="cb6e1-160">Außerdem werden wahrscheinlich einige Hintergrundthreads für die Datei-e/a und das Netzwerk verwendet.</span><span class="sxs-lookup"><span data-stu-id="cb6e1-160">In addition, some background threads for doing file I/O and networking would probably be used.</span></span> <span data-ttu-id="cb6e1-161">In Abbildung 1 werden die Threads sowie die Haupt Datenübertragungs Punkte angezeigt.</span><span class="sxs-lookup"><span data-stu-id="cb6e1-161">Figure 1 shows the threads, together with the main data transfer points.</span></span>

<span data-ttu-id="cb6e1-162">**Abbildung 1. Threading Design in einem Spiel für Windows**</span><span class="sxs-lookup"><span data-stu-id="cb6e1-162">**Figure 1. Threading design in a game for Windows**</span></span>

![Threading Design in einem Spiel für Windows](images/coding-for-multiple-cores-1.gif)

<span data-ttu-id="cb6e1-164">Ein typisches Xbox 360-Spiel kann zusätzliche CPU-intensive Softwarethreads verwenden, sodass die Arbeitsauslastung möglicherweise in einen Aktualisierungs Thread, einen Renderingthread und drei Arbeitsthreads aufgeteilt wird, wie in Abbildung 2 dargestellt.</span><span class="sxs-lookup"><span data-stu-id="cb6e1-164">A typical Xbox 360 game can use additional CPU-intensive software threads, so it might break up its workload into an update thread, rendering thread, and three worker threads, as shown in Figure 2.</span></span>

<span data-ttu-id="cb6e1-165">**Abbildung 2. Threading Design in einem Spiel für Xbox 360**</span><span class="sxs-lookup"><span data-stu-id="cb6e1-165">**Figure 2. Threading design in a game for Xbox 360**</span></span>

![Threading Design in einem Spiel für Xbox 360](images/coding-for-multiple-cores-2.gif)

<span data-ttu-id="cb6e1-167">Mit Ausnahme von Datei-e/a und Netzwerk können diese Aufgaben CPU-intensiv genug sein, um davon zu profitieren, dass Sie sich in einem eigenen Hardware Thread befinden.</span><span class="sxs-lookup"><span data-stu-id="cb6e1-167">With the exception of file I/O and networking, these tasks all have the potential to be CPU-intensive enough to benefit from being on their own hardware thread.</span></span> <span data-ttu-id="cb6e1-168">Diese Tasks können auch unabhängig voneinander unabhängig sein, dass Sie für einen gesamten Frame ausgeführt werden können, ohne zu kommunizieren.</span><span class="sxs-lookup"><span data-stu-id="cb6e1-168">These tasks also have the potential to be independent enough that they can run for an entire frame without communicating.</span></span>

<span data-ttu-id="cb6e1-169">Der spielaktualisierungs Thread verwaltet Controller Eingaben, Ki und Physik und bereitet Anweisungen für die anderen vier Threads vor.</span><span class="sxs-lookup"><span data-stu-id="cb6e1-169">The game update thread manages controller input, AI, and physics, and prepares instructions for the other four threads.</span></span> <span data-ttu-id="cb6e1-170">Diese Anweisungen werden in Puffer abgelegt, die sich im Besitz des Spiel Update Threads befinden, sodass keine Synchronisierung erforderlich ist, wenn die Anweisungen generiert werden.</span><span class="sxs-lookup"><span data-stu-id="cb6e1-170">These instructions are placed into buffers owned by the game update thread, so no synchronization is required as the instructions are generated.</span></span>

<span data-ttu-id="cb6e1-171">Am Ende des Frames übergibt der Spiel Update Thread die Anweisungs Puffer an die vier anderen Threads und beginnt dann mit der Arbeit am nächsten Frame, wobei ein anderer Satz von Anweisungs Puffern ausgefüllt wird.</span><span class="sxs-lookup"><span data-stu-id="cb6e1-171">At the end of the frame, the game update thread hands off the instruction buffers to the four other threads, and then starts working on the next frame, filling in another set of instruction buffers.</span></span>

<span data-ttu-id="cb6e1-172">Da die Aktualisierungs-und renderingthreads in Gleichschritt zueinander funktionieren, werden Ihre Kommunikationspuffer einfach doppelt gepuffert: der Update Thread füllt zu jedem Zeitpunkt einen Puffer, während der Renderthread aus dem anderen liest.</span><span class="sxs-lookup"><span data-stu-id="cb6e1-172">Because the update and rendering threads work in lockstep with each other, their communication buffers are simply double buffered: at any given time, the update thread is filling one buffer while the render thread is reading from the other.</span></span>

<span data-ttu-id="cb6e1-173">Die anderen Arbeitsthreads sind nicht notwendigerweise an die Framerate gebunden.</span><span class="sxs-lookup"><span data-stu-id="cb6e1-173">The other worker threads are not necessarily tied to the frame rate.</span></span> <span data-ttu-id="cb6e1-174">Das Entfernen eines Daten Teils kann wesentlich kleiner als ein Frame sein, oder es kann viele Frames in Anspruch nehmen.</span><span class="sxs-lookup"><span data-stu-id="cb6e1-174">Decompressing a piece of data may take much less than a frame, or it may take many frames.</span></span> <span data-ttu-id="cb6e1-175">Selbst die Tuch-und Haar Simulationen müssen möglicherweise nicht exakt an der Framerate ausgeführt werden, da seltener Updates möglicherweise durchaus akzeptabel sind.</span><span class="sxs-lookup"><span data-stu-id="cb6e1-175">Even the cloth and hair simulation may not need to run exactly at the frame rate because less frequent updates may be quite acceptable.</span></span> <span data-ttu-id="cb6e1-176">Daher benötigen diese drei Threads unterschiedliche Datenstrukturen, um mit dem Aktualisierungs Thread und dem Renderthread zu kommunizieren.</span><span class="sxs-lookup"><span data-stu-id="cb6e1-176">Therefore, these three threads need different data structures to communicate with the update thread and the render thread.</span></span> <span data-ttu-id="cb6e1-177">Beide benötigen eine Eingabe Warteschlange, die Arbeitsanforderungen aufnehmen kann, und der Renderthread benötigt eine Daten Warteschlange, die die von den Threads erzeugten Ergebnisse aufnehmen kann.</span><span class="sxs-lookup"><span data-stu-id="cb6e1-177">They each need an input queue that can hold work requests, and the render thread needs a data queue that can hold the results produced by the threads.</span></span> <span data-ttu-id="cb6e1-178">Am Ende jedes Frames fügt der Update Thread einen Arbeitsspeicher Block zu den Warteschlangen von Arbeitsthreads hinzu.</span><span class="sxs-lookup"><span data-stu-id="cb6e1-178">At the end of each frame the update thread will add a block of work requests to worker threads' queues.</span></span> <span data-ttu-id="cb6e1-179">Wenn Sie die Liste nur einmal pro Frame hinzufügen, wird sichergestellt, dass der Synchronisierungs Aufwand durch den Update Thread minimiert</span><span class="sxs-lookup"><span data-stu-id="cb6e1-179">Adding to the list just once per frame ensures that the update thread minimizes the synchronization overhead.</span></span> <span data-ttu-id="cb6e1-180">Jede der Arbeitsthreads ruft so schnell wie möglich Zuweisungen aus der Arbeits Warteschlange ab, indem eine Schleife verwendet wird, die etwa wie folgt aussieht:</span><span class="sxs-lookup"><span data-stu-id="cb6e1-180">Each of the worker threads pulls assignments from the work queue as quickly as it can, using a loop that looks something like this:</span></span>


```C++
for(;;)
{
    while( WorkQueueNotEmpty() )
    {
        RemoveWorkItemFromWorkQueue();
        ProcessWorkItem();
        PutResultInDataQueue();
    }
    WaitForSingleObject( hWorkSemaphore ); 
}
```



<span data-ttu-id="cb6e1-181">Da die Daten aus den updatethreads in die Arbeitsthreads und dann in den Renderthread fließen, kann es eine Verzögerung von drei oder mehr Frames geben, bevor einige Aktionen Sie auf den Bildschirm übernehmen.</span><span class="sxs-lookup"><span data-stu-id="cb6e1-181">Because the data goes from the update threads to the worker threads and then to the render thread, there can be a delay of three or more frames before some actions make it to the screen.</span></span> <span data-ttu-id="cb6e1-182">Wenn Sie den Arbeitsthreads jedoch Latenz tolerante Aufgaben zuweisen, sollte dies kein Problem darstellen.</span><span class="sxs-lookup"><span data-stu-id="cb6e1-182">However, if you assign latency-tolerant tasks to the worker threads, then this should not be a problem.</span></span>

<span data-ttu-id="cb6e1-183">Ein alternatives Design besteht darin, mehrere Arbeitsthreads zu erstellen, die alle aus derselben Arbeits Warteschlange zeichnen.</span><span class="sxs-lookup"><span data-stu-id="cb6e1-183">An alternate design would be to have several worker threads all drawing from the same work queue.</span></span> <span data-ttu-id="cb6e1-184">Dies würde einen automatischen Lastenausgleich ermöglichen und es wahrscheinlicher machen, dass alle Arbeitsthreads ausgelastet sind.</span><span class="sxs-lookup"><span data-stu-id="cb6e1-184">This would give automatic load balancing and would make it more likely that all of the worker threads would stay busy.</span></span>

<span data-ttu-id="cb6e1-185">Der spielaktualisierungs Thread muss darauf achten, dass die Arbeitsthreads nicht zu viel Arbeit haben. andernfalls können die Arbeits Warteschlangen ständig zunehmen.</span><span class="sxs-lookup"><span data-stu-id="cb6e1-185">The game update thread must take care to not give too much work to the worker threads, or else the work queues may continuously grow.</span></span> <span data-ttu-id="cb6e1-186">Wie der Update Thread dies verwaltet, hängt von der Art der Aufgaben ab, die von den Arbeitsthreads ausgeführt werden.</span><span class="sxs-lookup"><span data-stu-id="cb6e1-186">How the update thread manages this depends on what sort of tasks the worker threads are doing.</span></span>

## <a name="simultaneous-multithreading-and-number-of-threads"></a><span data-ttu-id="cb6e1-187">Gleichzeitiges Multithreading und Anzahl von Threads</span><span class="sxs-lookup"><span data-stu-id="cb6e1-187">Simultaneous Multithreading and Number of Threads</span></span>

<span data-ttu-id="cb6e1-188">Alle Threads werden nicht gleich erstellt.</span><span class="sxs-lookup"><span data-stu-id="cb6e1-188">All threads are not created equal.</span></span> <span data-ttu-id="cb6e1-189">Zwei Hardwarethreads befinden sich möglicherweise auf separaten Chips, auf dem gleichen Chip oder sogar auf demselben Kern.</span><span class="sxs-lookup"><span data-stu-id="cb6e1-189">Two hardware threads might be on separate chips, on the same chip, or even on the same core.</span></span> <span data-ttu-id="cb6e1-190">Die wichtigste Konfiguration für Spiel Programmierer ist es, zwei Hardwarethreads auf einem Kern – gleichzeitige Multithreading (SMT) oder Hyper-Threading Technologie (HT-Technologie) zu beachten.</span><span class="sxs-lookup"><span data-stu-id="cb6e1-190">The most important configuration for game programmers to be aware of is two hardware threads on one core—Simultaneous Multi-Threading (SMT) or Hyper-Threading Technology (HT Technology).</span></span>

<span data-ttu-id="cb6e1-191">SMT-oder HT-technologiethreads nutzen die Ressourcen des CPU-Kerns gemeinsam.</span><span class="sxs-lookup"><span data-stu-id="cb6e1-191">SMT or HT Technology threads share the resources of the CPU core.</span></span> <span data-ttu-id="cb6e1-192">Da Sie die Ausführungs Einheiten gemeinsam nutzen, liegt die maximale Beschleunigung bei der Ausführung von zwei Threads anstelle eines Werts in der Regel bei 10 bis 20 Prozent, anstatt bei 100 Prozent, die aus zwei unabhängigen Hardwarethreads möglich sind.</span><span class="sxs-lookup"><span data-stu-id="cb6e1-192">Because they share the execution units, the maximum speedup from running two threads instead of one is typically 10 to 20 percent, instead of the 100 percent that is possible from two independent hardware threads.</span></span>

<span data-ttu-id="cb6e1-193">Noch wichtiger ist, dass SMT-oder HT-technologiethreads die L1-Anweisung und Daten Caches gemeinsam nutzen.</span><span class="sxs-lookup"><span data-stu-id="cb6e1-193">More significantly, SMT or HT Technology threads share the L1 instruction and data caches.</span></span> <span data-ttu-id="cb6e1-194">Wenn Ihre Speicherzugriffsmuster nicht kompatibel sind, können Sie über den Cache hinaus kämpfen und viele Cache Fehler verursachen.</span><span class="sxs-lookup"><span data-stu-id="cb6e1-194">If their memory access patterns are incompatible, they can end up fighting over the cache and causing many cache misses.</span></span> <span data-ttu-id="cb6e1-195">Im schlimmsten Fall kann sich die Gesamtleistung für den CPU-Kern tatsächlich verringern, wenn ein zweiter Thread ausgeführt wird.</span><span class="sxs-lookup"><span data-stu-id="cb6e1-195">In the worst case, the total performance for the CPU core can actually decrease when a second thread is run.</span></span> <span data-ttu-id="cb6e1-196">Auf Xbox 360 ist dies ein relativ einfaches Problem.</span><span class="sxs-lookup"><span data-stu-id="cb6e1-196">On Xbox 360, this is a fairly simple problem.</span></span> <span data-ttu-id="cb6e1-197">Die Konfiguration der Xbox 360 ist bekannt – drei CPU-Kerne mit jeweils zwei Hardwarethreads – und Entwickler weisen ihren Softwarethreads bestimmte CPU-Threads zu und können Messen, ob Ihr Threading Entwurf zusätzliche Leistung liefert.</span><span class="sxs-lookup"><span data-stu-id="cb6e1-197">The configuration of the Xbox 360 is known—three CPU cores each with two hardware threads—and developers assign their software threads to specific CPU threads and can measure to see whether their threading design gives them extra performance.</span></span>

<span data-ttu-id="cb6e1-198">Unter Windows ist die Situation komplizierter.</span><span class="sxs-lookup"><span data-stu-id="cb6e1-198">On Windows, the situation is more complicated.</span></span> <span data-ttu-id="cb6e1-199">Die Anzahl von Threads und deren Konfiguration variiert von Computer zu Computer, und das Ermitteln der Konfiguration ist kompliziert.</span><span class="sxs-lookup"><span data-stu-id="cb6e1-199">The number of threads and their configuration will vary from computer to computer, and determining the configuration is complicated.</span></span> <span data-ttu-id="cb6e1-200">Die Funktion [**GetLogicalProcessorInformation**](/windows/win32/api/sysinfoapi/nf-sysinfoapi-getlogicalprocessorinformation) enthält Informationen über die Beziehung zwischen verschiedenen Hardwarethreads. diese Funktion ist unter Windows Vista, Windows 7 und Windows XP SP3 verfügbar.</span><span class="sxs-lookup"><span data-stu-id="cb6e1-200">The function [**GetLogicalProcessorInformation**](/windows/win32/api/sysinfoapi/nf-sysinfoapi-getlogicalprocessorinformation) gives information about the relationship between different hardware threads, and this function is available on Windows Vista, Windows 7, and Windows XP SP3.</span></span> <span data-ttu-id="cb6e1-201">Daher müssen Sie derzeit die CPUID-Anweisung und die von Intel und AMD angegebenen Algorithmen verwenden, um zu entscheiden, wie viele "echte" Threads verfügbar sind.</span><span class="sxs-lookup"><span data-stu-id="cb6e1-201">Therefore, for now you have to use the CPUID instruction and the algorithms given by Intel and AMD in order to decide how many "real" threads you have available.</span></span> <span data-ttu-id="cb6e1-202">Weitere Informationen finden Sie unter "Verweise".</span><span class="sxs-lookup"><span data-stu-id="cb6e1-202">See the references for more information.</span></span>

<span data-ttu-id="cb6e1-203">Das coreerkennungs-Beispiel im DirectX SDK enthält Beispielcode, der die [**GetLogicalProcessorInformation**](/windows/win32/api/sysinfoapi/nf-sysinfoapi-getlogicalprocessorinformation) -Funktion oder die CPUID-Anweisung verwendet, um die CPU-Kern Topologie zurückzugeben.</span><span class="sxs-lookup"><span data-stu-id="cb6e1-203">The CoreDetection sample in the DirectX SDK contains sample code that uses the [**GetLogicalProcessorInformation**](/windows/win32/api/sysinfoapi/nf-sysinfoapi-getlogicalprocessorinformation) function or the CPUID instruction to return the CPU core topology.</span></span> <span data-ttu-id="cb6e1-204">Die CPUID-Anweisung wird verwendet, wenn **GetLogicalProcessorInformation** auf der aktuellen Plattform nicht unterstützt wird.</span><span class="sxs-lookup"><span data-stu-id="cb6e1-204">The CPUID instruction is used if **GetLogicalProcessorInformation** is not supported on the current platform.</span></span> <span data-ttu-id="cb6e1-205">Coreerkennungen finden Sie an den folgenden Speicherorten:</span><span class="sxs-lookup"><span data-stu-id="cb6e1-205">CoreDetection can be found in the following locations:</span></span>

<dl> <dt>

<span data-ttu-id="cb6e1-206"><span id="Source_"></span><span id="source_"></span><span id="SOURCE_"></span>Quelle:</span><span class="sxs-lookup"><span data-stu-id="cb6e1-206"><span id="Source_"></span><span id="source_"></span><span id="SOURCE_"></span>Source:</span></span>
</dt> <dd>

<span data-ttu-id="cb6e1-207">*DirectX-SDK* \\ -Stamm Beispiele \\ C++ Verschiedenes \\ \\ coreerkennung</span><span class="sxs-lookup"><span data-stu-id="cb6e1-207">*DirectX SDK root*\\Samples\\C++\\Misc\\CoreDetection</span></span>

</dd> <dt>

<span data-ttu-id="cb6e1-208"><span id="Executable_"></span><span id="executable_"></span><span id="EXECUTABLE_"></span>Bares</span><span class="sxs-lookup"><span data-stu-id="cb6e1-208"><span id="Executable_"></span><span id="executable_"></span><span id="EXECUTABLE_"></span>Executable:</span></span>
</dt> <dd>

<span data-ttu-id="cb6e1-209">*DirectX-SDK* \\ -Stamm Beispiele \\ C++ \\ misc \\ bin \\CoreDetection.exe</span><span class="sxs-lookup"><span data-stu-id="cb6e1-209">*DirectX SDK root*\\Samples\\C++\\Misc\\Bin\\CoreDetection.exe</span></span>

</dd> </dl>

<span data-ttu-id="cb6e1-210">Die sicherste Annahme besteht darin, dass nicht mehr als ein CPU-intensiver Thread pro CPU-Kern vorhanden ist.</span><span class="sxs-lookup"><span data-stu-id="cb6e1-210">The safest assumption is to have no more than one CPU-intensive thread per CPU core.</span></span> <span data-ttu-id="cb6e1-211">Die Verwendung von mehr CPU-intensiven Threads als CPU-Kerne bietet wenig oder keinen Vorteil und erhöht den zusätzlichen Aufwand und die Komplexität zusätzlicher Threads.</span><span class="sxs-lookup"><span data-stu-id="cb6e1-211">Having more CPU-intensive threads than CPU cores gives little or no benefits, and brings the extra overhead and complexity of additional threads.</span></span>

## <a name="creating-threads"></a><span data-ttu-id="cb6e1-212">Erstellen von Threads</span><span class="sxs-lookup"><span data-stu-id="cb6e1-212">Creating Threads</span></span>

<span data-ttu-id="cb6e1-213">Das Erstellen von Threads ist ein relativ einfacher Vorgang, aber es gibt viele mögliche Fehler.</span><span class="sxs-lookup"><span data-stu-id="cb6e1-213">Creating threads is a fairly simple operation, but there are many potential errors.</span></span> <span data-ttu-id="cb6e1-214">Der folgende Code zeigt die ordnungsgemäße Methode zum Erstellen eines Threads, zum warten auf die Beendigung und zum anschließenden bereinigen.</span><span class="sxs-lookup"><span data-stu-id="cb6e1-214">The code below shows the proper way of creating a thread, waiting for it to terminate, and then cleaning up.</span></span>


```C++
const int stackSize = 65536;
HANDLE hThread = (HANDLE)_beginthreadex( 0, stackSize,
            ThreadFunction, 0, 0, 0 );
// Do work on main thread here.
// Wait for child thread to complete
WaitForSingleObject( hThread, INFINITE );
CloseHandle( hThread );

...

unsigned __stdcall ThreadFunction( void* data )
{
#if _XBOX_VER >= 200
    // On Xbox 360 you must explicitly assign
    // software threads to hardware threads.
    XSetThreadProcessor( GetCurrentThread(), 2 );
#endif
    // Do child thread work here.
    return 0;
}
```



<span data-ttu-id="cb6e1-215">Wenn Sie einen Thread erstellen, haben Sie die Möglichkeit, die Stapelgröße für den untergeordneten Thread anzugeben oder NULL anzugeben. in diesem Fall erbt der untergeordnete Thread die Stapelgröße des übergeordneten Threads.</span><span class="sxs-lookup"><span data-stu-id="cb6e1-215">When you create a thread, you have the option to specify the stack size for the child thread, or specify zero, in which case the child thread will inherit the parent thread's stack size.</span></span> <span data-ttu-id="cb6e1-216">Auf Xbox 360, bei dem Stapel beim Start des Threads vollständig committet werden, kann durch die Angabe von NULL ein erheblicher Speicher verschwendet werden, da viele untergeordnete Threads nicht so viel Stapel wie das übergeordnete Element benötigen.</span><span class="sxs-lookup"><span data-stu-id="cb6e1-216">On Xbox 360, where stacks are fully committed when the thread starts, specifying zero can waste significant memory, because many child threads will not need as much stack as the parent.</span></span> <span data-ttu-id="cb6e1-217">Auf Xbox 360 ist es auch wichtig, dass die Stapelgröße ein Vielfaches von 64 KB ist.</span><span class="sxs-lookup"><span data-stu-id="cb6e1-217">On Xbox 360 it is also important that the stack size be a multiple of 64-KB.</span></span>

<span data-ttu-id="cb6e1-218">Wenn Sie zum Erstellen von Threads die Funktion "up [**Thread**](/windows/win32/api/processthreadsapi/nf-processthreadsapi-createthread) " verwenden, wird die C/C++-Laufzeit (CRT) unter Windows nicht ordnungsgemäß initialisiert.</span><span class="sxs-lookup"><span data-stu-id="cb6e1-218">If you use the [**CreateThread**](/windows/win32/api/processthreadsapi/nf-processthreadsapi-createthread) function to create threads, then the C/C++ runtime (CRT) will not get properly initialized on Windows.</span></span> <span data-ttu-id="cb6e1-219">Es wird empfohlen, stattdessen die CRT [**\_ beginthreadex**](https://msdn.microsoft.com/library/ms397047(v=VS.70).aspx) -Funktion zu verwenden.</span><span class="sxs-lookup"><span data-stu-id="cb6e1-219">We recommend that you use the CRT [**\_beginthreadex**](https://msdn.microsoft.com/library/ms397047(v=VS.70).aspx) function instead.</span></span>

<span data-ttu-id="cb6e1-220">Der Rückgabewert von " [**kreatethread**](/windows/win32/api/processthreadsapi/nf-processthreadsapi-createthread) " oder " [**\_ beginthreadex**](https://msdn.microsoft.com/library/ms397047(v=VS.70).aspx) " ist ein Thread handle.</span><span class="sxs-lookup"><span data-stu-id="cb6e1-220">The return value from [**CreateThread**](/windows/win32/api/processthreadsapi/nf-processthreadsapi-createthread) or [**\_beginthreadex**](https://msdn.microsoft.com/library/ms397047(v=VS.70).aspx) is a thread handle.</span></span> <span data-ttu-id="cb6e1-221">Dieser Thread kann verwendet werden, um zu warten, bis der untergeordnete Thread beendet wird. Dies ist viel einfacher und effizienter als das Drehen in einer Schleife, die den Thread Status überprüft.</span><span class="sxs-lookup"><span data-stu-id="cb6e1-221">This thread can be used to wait for the child thread to terminate, which is much simpler and much more efficient than spinning in a loop checking the thread status.</span></span> <span data-ttu-id="cb6e1-222">Um zu warten, bis der Thread beendet wird, können Sie einfach [**WaitForSingleObject**](/windows/win32/api/synchapi/nf-synchapi-waitforsingleobject) mit dem Thread handle aufzurufen.</span><span class="sxs-lookup"><span data-stu-id="cb6e1-222">To wait for the thread to terminate, simply call [**WaitForSingleObject**](/windows/win32/api/synchapi/nf-synchapi-waitforsingleobject) with the thread handle.</span></span>

<span data-ttu-id="cb6e1-223">Die Ressourcen für den Thread werden erst freigegeben, wenn der Thread beendet und das Thread Handle geschlossen wurde.</span><span class="sxs-lookup"><span data-stu-id="cb6e1-223">The resources for the thread will not be freed until the thread has terminated and the thread handle has been closed.</span></span> <span data-ttu-id="cb6e1-224">Daher ist es wichtig, das Thread Handle mit [**CloseHandle**](/windows/win32/api/handleapi/nf-handleapi-closehandle) zu schließen, wenn Sie damit fertig sind.</span><span class="sxs-lookup"><span data-stu-id="cb6e1-224">Therefore, it is important to close the thread handle with [**CloseHandle**](/windows/win32/api/handleapi/nf-handleapi-closehandle) when you are finished with it.</span></span> <span data-ttu-id="cb6e1-225">Wenn Sie darauf warten, dass der Thread mit [**WaitForSingleObject**](/windows/win32/api/synchapi/nf-synchapi-waitforsingleobject)beendet wird, achten Sie darauf, den Handle erst zu schließen, nachdem der Warte Vorgang abgeschlossen wurde.</span><span class="sxs-lookup"><span data-stu-id="cb6e1-225">If you will be waiting for the thread to terminate with [**WaitForSingleObject**](/windows/win32/api/synchapi/nf-synchapi-waitforsingleobject), be sure to not close the handle until after the wait has completed.</span></span>

<span data-ttu-id="cb6e1-226">Auf Xbox 360 müssen Sie mithilfe von **xsetthreadprocessor** Software Threads einem bestimmten Hardware Thread explizit zuweisen.</span><span class="sxs-lookup"><span data-stu-id="cb6e1-226">On Xbox 360, you must explicitly assign software threads to a particular hardware thread by using **XSetThreadProcessor**.</span></span> <span data-ttu-id="cb6e1-227">Andernfalls bleiben alle untergeordneten Threads auf demselben Hardware Thread wie das übergeordnete-Objekt.</span><span class="sxs-lookup"><span data-stu-id="cb6e1-227">Otherwise, all child threads will stay on the same hardware thread as the parent.</span></span> <span data-ttu-id="cb6e1-228">Unter Windows können Sie mit [**SetThreadAffinityMask**](/windows/win32/api/winbase/nf-winbase-setthreadaffinitymask) dem Betriebssystem dringend vorschlagen, auf welchen Hardwarethreads der Thread ausgeführt werden soll.</span><span class="sxs-lookup"><span data-stu-id="cb6e1-228">On Windows, you can use [**SetThreadAffinityMask**](/windows/win32/api/winbase/nf-winbase-setthreadaffinitymask) to strongly suggest to the operating system which hardware threads your thread should run on.</span></span> <span data-ttu-id="cb6e1-229">Diese Technik sollte in Windows im allgemeinen vermieden werden, da Sie nicht wissen, welche anderen Prozesse möglicherweise auf dem System ausgeführt werden.</span><span class="sxs-lookup"><span data-stu-id="cb6e1-229">This technique should generally be avoided on Windows since you don't know what other processes might be running on the system.</span></span> <span data-ttu-id="cb6e1-230">Es ist in der Regel besser, den Windows-Scheduler die Zuweisung von Threads zu inaktiven Hardwarethreads zuzulassen.</span><span class="sxs-lookup"><span data-stu-id="cb6e1-230">It is typically better to let the Windows scheduler assign your threads to idle hardware threads.</span></span>

<span data-ttu-id="cb6e1-231">Das Erstellen von Threads ist ein kostspieliger Vorgang.</span><span class="sxs-lookup"><span data-stu-id="cb6e1-231">Creating threads is an expensive operation.</span></span> <span data-ttu-id="cb6e1-232">Threads sollten nur selten erstellt und zerstört werden.</span><span class="sxs-lookup"><span data-stu-id="cb6e1-232">Threads should be created and destroyed rarely.</span></span> <span data-ttu-id="cb6e1-233">Wenn Sie erkennen möchten, dass Threads häufig erstellt und zerstört werden, verwenden Sie stattdessen einen Thread Pool, der auf die Arbeit wartet.</span><span class="sxs-lookup"><span data-stu-id="cb6e1-233">If you find yourself wanting to create and destroy threads frequently, use a pool of threads that wait around for work instead.</span></span>

## <a name="synchronizing-threads"></a><span data-ttu-id="cb6e1-234">Synchronisieren von Threads</span><span class="sxs-lookup"><span data-stu-id="cb6e1-234">Synchronizing Threads</span></span>

<span data-ttu-id="cb6e1-235">Damit mehrere Threads zusammenarbeiten können, müssen Sie in der Lage sein, Threads zu synchronisieren, Nachrichten zu übergeben und exklusiven Zugriff auf Ressourcen anzufordern.</span><span class="sxs-lookup"><span data-stu-id="cb6e1-235">For multiple threads to work together, you must be able to synchronize threads, pass messages, and request exclusive access to resources.</span></span> <span data-ttu-id="cb6e1-236">Windows und Xbox 360 verfügen über einen umfangreichen Satz von Synchronisierungs primitiven.</span><span class="sxs-lookup"><span data-stu-id="cb6e1-236">Windows and Xbox 360 come with a rich set of synchronization primitives.</span></span> <span data-ttu-id="cb6e1-237">Ausführliche Informationen zu diesen Synchronisierungs primitiven finden Sie in der Dokumentation zur Plattform.</span><span class="sxs-lookup"><span data-stu-id="cb6e1-237">For full details on these synchronization primitives, see the platform documentation.</span></span>

### <a name="exclusive-access"></a><span data-ttu-id="cb6e1-238">Exklusiver Zugriff</span><span class="sxs-lookup"><span data-stu-id="cb6e1-238">Exclusive Access</span></span>

<span data-ttu-id="cb6e1-239">Es ist eine häufige Notwendigkeit, exklusiven Zugriff auf eine Ressource, eine Datenstruktur oder einen Codepfad zu erhalten.</span><span class="sxs-lookup"><span data-stu-id="cb6e1-239">Gaining exclusive access to a resource, data structure, or code path is a common need.</span></span> <span data-ttu-id="cb6e1-240">Eine Möglichkeit, exklusiven Zugriff zu erhalten, ist ein Mutex, dessen typischer Gebrauch hier angezeigt wird.</span><span class="sxs-lookup"><span data-stu-id="cb6e1-240">One option for gaining exclusive access is a mutex, whose typical usage is shown here.</span></span>


```C++
// Initialize
HANDLE mutex = CreateMutex( 0, FALSE, 0 );

// Use
void ManipulateSharedData()
{
    WaitForSingleObject( mutex, INFINITE );
    // Manipulate stuff...
    ReleaseMutex( mutex );
}

// Destroy
CloseHandle( mutex );
The kernel guarantees that, for a particular mutex, only one thread at a time can 
acquire it.
The main disadvantage to mutexes is that they are relatively expensive to acquire 
and release. A faster alternative is a critical section.
// Initialize
CRITICAL_SECTION cs;
InitializeCriticalSection( &cs );

// Use
void ManipulateSharedData()
{
    EnterCriticalSection( &cs );
    // Manipulate stuff...
    LeaveCriticalSection( &cs );
}

// Destroy
DeleteCriticalSection( &cs );
```



<span data-ttu-id="cb6e1-241">Kritische Abschnitte haben eine ähnliche Semantik wie Mutexen, Sie können jedoch nur innerhalb eines Prozesses und nicht zwischen Prozessen synchronisiert werden.</span><span class="sxs-lookup"><span data-stu-id="cb6e1-241">Critical sections have similar semantics to mutexes, but they can be used to synchronize only within a process, not between processes.</span></span> <span data-ttu-id="cb6e1-242">Der Hauptvorteil besteht darin, dass Sie ungefähr zwanzig mal schneller als Mutexes ausgeführt werden.</span><span class="sxs-lookup"><span data-stu-id="cb6e1-242">Their main advantage is that they execute roughly twenty times faster than mutexes.</span></span>

### <a name="events"></a><span data-ttu-id="cb6e1-243">Ereignisse</span><span class="sxs-lookup"><span data-stu-id="cb6e1-243">Events</span></span>

<span data-ttu-id="cb6e1-244">Wenn zwei Threads – vielleicht ein Aktualisierungs Thread und ein Renderthread – mit einem Paar von renderbeschreibungs Puffern verwendet werden, benötigen Sie eine Möglichkeit, anzugeben, wann Sie mit dem jeweiligen Puffer ausgeführt werden.</span><span class="sxs-lookup"><span data-stu-id="cb6e1-244">If two threads—perhaps an update thread and a render thread—are taking turns using a pair of render description buffers, they need a way to indicate when they are done with their particular buffer.</span></span> <span data-ttu-id="cb6e1-245">Dies kann erreicht werden, indem ein Ereignis (das mit " [**forateevent**](/windows/win32/api/synchapi/nf-synchapi-createeventa)" zugeordnet wird) jedem Puffer zugeordnet wird.</span><span class="sxs-lookup"><span data-stu-id="cb6e1-245">This can be done by associating an event (allocated with [**CreateEvent**](/windows/win32/api/synchapi/nf-synchapi-createeventa)) with each buffer.</span></span> <span data-ttu-id="cb6e1-246">Wenn ein Thread mit einem Puffer ausgeführt wird, kann er mithilfe von [**SetEvent**](/windows/win32/api/synchapi/nf-synchapi-setevent) signalisiert werden, und dann kann [**WaitForSingleObject**](/windows/win32/api/synchapi/nf-synchapi-waitforsingleobject) für das Ereignis des anderen Puffers aufgerufen werden.</span><span class="sxs-lookup"><span data-stu-id="cb6e1-246">When a thread is done with a buffer, it can use [**SetEvent**](/windows/win32/api/synchapi/nf-synchapi-setevent) to signal this, and can then call [**WaitForSingleObject**](/windows/win32/api/synchapi/nf-synchapi-waitforsingleobject) on the other buffer's event.</span></span> <span data-ttu-id="cb6e1-247">Mit dieser Methode können Sie problemlos eine dreifache Pufferung von Ressourcen durchlaufen.</span><span class="sxs-lookup"><span data-stu-id="cb6e1-247">This technique extrapolates easily to triple buffering of resources.</span></span>

### <a name="semaphores"></a><span data-ttu-id="cb6e1-248">Semaphoren</span><span class="sxs-lookup"><span data-stu-id="cb6e1-248">Semaphores</span></span>

<span data-ttu-id="cb6e1-249">Ein Semaphor wird verwendet, um zu steuern, wie viele Threads ausgeführt werden können, und wird häufig verwendet, um Arbeits Warteschlangen zu implementieren.</span><span class="sxs-lookup"><span data-stu-id="cb6e1-249">A semaphore is used to control how many threads can be running and is commonly used to implement work queues.</span></span> <span data-ttu-id="cb6e1-250">Ein Thread fügt einer Warteschlange Arbeit hinzu und verwendet [**ReleaseSemaphore**](/windows/win32/api/synchapi/nf-synchapi-releasesemaphore) , wenn der Warteschlange ein neues Element hinzugefügt wird.</span><span class="sxs-lookup"><span data-stu-id="cb6e1-250">One thread adds work to a queue and uses [**ReleaseSemaphore**](/windows/win32/api/synchapi/nf-synchapi-releasesemaphore) whenever it adds a new item to the queue.</span></span> <span data-ttu-id="cb6e1-251">Dadurch kann ein Arbeits Thread aus dem Pool der wartenden Threads freigegeben werden.</span><span class="sxs-lookup"><span data-stu-id="cb6e1-251">This allows one worker thread to be released from the pool of waiting threads.</span></span> <span data-ttu-id="cb6e1-252">Die Arbeitsthreads nennen nur [**WaitForSingleObject**](/windows/win32/api/synchapi/nf-synchapi-waitforsingleobject), und wenn Sie zurückgegeben wird, wissen Sie, dass ein Arbeits Element in der Warteschlange vorhanden ist.</span><span class="sxs-lookup"><span data-stu-id="cb6e1-252">The worker threads just call [**WaitForSingleObject**](/windows/win32/api/synchapi/nf-synchapi-waitforsingleobject), and when it returns they know there is a work item in the queue for them.</span></span> <span data-ttu-id="cb6e1-253">Außerdem muss ein kritischer Abschnitt oder eine andere Synchronisierungs Technik verwendet werden, um den sicheren Zugriff auf die freigegebene Arbeits Warteschlange zu gewährleisten.</span><span class="sxs-lookup"><span data-stu-id="cb6e1-253">In addition, a critical section or other synchronization technique must be used in order to guarantee safe access to the shared work queue.</span></span>

### <a name="avoid-suspendthread"></a><span data-ttu-id="cb6e1-254">SuspendThread vermeiden</span><span class="sxs-lookup"><span data-stu-id="cb6e1-254">Avoid SuspendThread</span></span>

<span data-ttu-id="cb6e1-255">Wenn Sie möchten, dass ein Thread den Vorgang beendet, ist es manchmal verlockend, [**SuspendThread**](/windows/win32/api/processthreadsapi/nf-processthreadsapi-suspendthread) anstelle der richtigen Synchronisierungs primitiven zu verwenden.</span><span class="sxs-lookup"><span data-stu-id="cb6e1-255">Sometimes when you want a thread to stop what it is doing, it is tempting to use [**SuspendThread**](/windows/win32/api/processthreadsapi/nf-processthreadsapi-suspendthread) instead of the correct synchronization primitives.</span></span> <span data-ttu-id="cb6e1-256">Dies ist immer eine gute Idee und kann problemlos zu Deadlocks und anderen Problemen führen.</span><span class="sxs-lookup"><span data-stu-id="cb6e1-256">This is always a bad idea and can easily lead to deadlocks and other problems.</span></span> <span data-ttu-id="cb6e1-257">**SuspendThread** interagiert auch mit dem Visual Studio-Debugger nicht.</span><span class="sxs-lookup"><span data-stu-id="cb6e1-257">**SuspendThread** also interacts badly with the Visual Studio debugger.</span></span> <span data-ttu-id="cb6e1-258">Vermeiden Sie **SuspendThread**.</span><span class="sxs-lookup"><span data-stu-id="cb6e1-258">Avoid **SuspendThread**.</span></span> <span data-ttu-id="cb6e1-259">Verwenden Sie stattdessen " [**WaitForSingleObject**](/windows/win32/api/synchapi/nf-synchapi-waitforsingleobject) ".</span><span class="sxs-lookup"><span data-stu-id="cb6e1-259">Use [**WaitForSingleObject**](/windows/win32/api/synchapi/nf-synchapi-waitforsingleobject) instead.</span></span>

### <a name="waitforsingleobject-and-waitformultipleobjects"></a><span data-ttu-id="cb6e1-260">WaitForSingleObject und WaitForMultipleObjects</span><span class="sxs-lookup"><span data-stu-id="cb6e1-260">WaitForSingleObject and WaitForMultipleObjects</span></span>

<span data-ttu-id="cb6e1-261">Die Funktion " [**WaitForSingleObject**](/windows/win32/api/synchapi/nf-synchapi-waitforsingleobject) " ist die am häufigsten verwendete Synchronisierungs Funktion.</span><span class="sxs-lookup"><span data-stu-id="cb6e1-261">The function [**WaitForSingleObject**](/windows/win32/api/synchapi/nf-synchapi-waitforsingleobject) is the most commonly used synchronization function.</span></span> <span data-ttu-id="cb6e1-262">Manchmal möchten Sie jedoch, dass ein Thread wartet, bis mehrere Bedingungen gleichzeitig erfüllt sind oder einer der Bedingungen erfüllt ist.</span><span class="sxs-lookup"><span data-stu-id="cb6e1-262">However, sometimes you want a thread to wait until several conditions are simultaneously satisfied, or until one of a set of conditions are satisfied.</span></span> <span data-ttu-id="cb6e1-263">In diesem Fall sollten Sie [**WaitForMultipleObjects**](/windows/win32/api/synchapi/nf-synchapi-waitformultipleobjects)verwenden.</span><span class="sxs-lookup"><span data-stu-id="cb6e1-263">In this case, you should use [**WaitForMultipleObjects**](/windows/win32/api/synchapi/nf-synchapi-waitformultipleobjects).</span></span>

### <a name="interlocked-functions-and-lockless-programming"></a><span data-ttu-id="cb6e1-264">Interlocked-Funktionen und Sperr lose Programmierung</span><span class="sxs-lookup"><span data-stu-id="cb6e1-264">Interlocked Functions and Lockless Programming</span></span>

<span data-ttu-id="cb6e1-265">Es gibt eine Reihe von Funktionen zum Ausführen einfacher Thread sicherer Vorgänge, ohne Sperren zu verwenden.</span><span class="sxs-lookup"><span data-stu-id="cb6e1-265">There is a family of functions for performing simple thread-safe operations without using locks.</span></span> <span data-ttu-id="cb6e1-266">Dabei handelt es sich um die Interlocked-Funktions Familie, z. b. [**interlockedinkrement**](/windows/win32/api/winnt/nf-winnt-interlockedincrement).</span><span class="sxs-lookup"><span data-stu-id="cb6e1-266">These are the Interlocked family of functions, such as [**InterlockedIncrement**](/windows/win32/api/winnt/nf-winnt-interlockedincrement).</span></span> <span data-ttu-id="cb6e1-267">Diese Funktionen und andere Techniken, die die sorgfältige Festlegung von Flags verwenden, werden zusammen als Lock less Programming bezeichnet.</span><span class="sxs-lookup"><span data-stu-id="cb6e1-267">These functions, plus other techniques using careful setting of flags, are together known as lockless programming.</span></span> <span data-ttu-id="cb6e1-268">Die sperlocklose Programmierung kann sehr kompliziert sein, und Sie ist auf Xbox 360 erheblich schwieriger als unter Windows.</span><span class="sxs-lookup"><span data-stu-id="cb6e1-268">Lockless programming can be extremely tricky to do correctly, and is substantially more difficult on Xbox 360 than on Windows.</span></span>

<span data-ttu-id="cb6e1-269">Weitere Informationen zum Programmieren ohne Sperren finden Sie unter [Überlegungen zur Sperr losen Programmierung für Xbox 360 und Microsoft Windows](./lockless-programming.md).</span><span class="sxs-lookup"><span data-stu-id="cb6e1-269">For more information about programming without locks, see [Lockless Programming Considerations for Xbox 360 and Microsoft Windows](./lockless-programming.md).</span></span>

### <a name="minimizing-synchronization"></a><span data-ttu-id="cb6e1-270">Minimierung der Synchronisierung</span><span class="sxs-lookup"><span data-stu-id="cb6e1-270">Minimizing Synchronization</span></span>

<span data-ttu-id="cb6e1-271">Einige Synchronisierungs Methoden sind schneller als andere.</span><span class="sxs-lookup"><span data-stu-id="cb6e1-271">Some synchronization methods are faster than others.</span></span> <span data-ttu-id="cb6e1-272">Anstatt den Code durch Auswahl der schnellsten Synchronisierungs Verfahren zu optimieren, ist es in der Regel besser, weniger häufig zu synchronisieren.</span><span class="sxs-lookup"><span data-stu-id="cb6e1-272">However, rather than optimizing your code by choosing the fastest synchronization techniques possible, it is usually better to synchronize less often.</span></span> <span data-ttu-id="cb6e1-273">Dies ist schneller als die Synchronisierung zu häufig, und vereinfacht den Code, der einfacher zu Debuggen ist.</span><span class="sxs-lookup"><span data-stu-id="cb6e1-273">This is faster than synchronizing too frequently, and it makes for simpler code that is easier to debug.</span></span>

<span data-ttu-id="cb6e1-274">Einige Vorgänge, z. b. Speicher Belegung, müssen möglicherweise Synchronisierungs primitive verwenden, damit Sie ordnungsgemäß funktionieren.</span><span class="sxs-lookup"><span data-stu-id="cb6e1-274">Some operations, such as memory allocation, may have to use synchronization primitives in order to work correctly.</span></span> <span data-ttu-id="cb6e1-275">Daher führt das Durchführen von häufigen Zuordnungen aus dem freigegebenen Standard Heap zu einer häufigen Synchronisierung, wodurch die Leistung beeinträchtigt wird.</span><span class="sxs-lookup"><span data-stu-id="cb6e1-275">Therefore, doing frequent allocations from the default shared heap will result in frequent synchronization, which will waste some performance.</span></span> <span data-ttu-id="cb6e1-276">Die Vermeidung von häufigen Zuordnungen oder die Verwendung von Thread spezifischen Heaps (bei Verwendung von \_ HeapCreate mithilfe von Heap No \_ Serialize) kann diese verborgene Synchronisierung vermeiden.</span><span class="sxs-lookup"><span data-stu-id="cb6e1-276">Avoiding frequent allocations or using per-thread heaps (using HEAP\_NO\_SERIALIZE if you use HeapCreate) can avoid this hidden synchronization.</span></span>

<span data-ttu-id="cb6e1-277">Eine weitere Ursache für die verborgene Synchronisierung ist D3DCREATE \_ Multithreaded, was dazu führt, dass D3D unter Windows die Synchronisierung für viele Vorgänge verwendet.</span><span class="sxs-lookup"><span data-stu-id="cb6e1-277">Another cause of hidden synchronization is D3DCREATE\_MULTITHREADED, which causes D3D on Windows to use synchronization on many operations.</span></span> <span data-ttu-id="cb6e1-278">(Das Flag wird auf Xbox 360 ignoriert.)</span><span class="sxs-lookup"><span data-stu-id="cb6e1-278">(The flag is ignored on Xbox 360.)</span></span>

<span data-ttu-id="cb6e1-279">Thread spezifische Daten, die auch als Thread lokaler Speicher bezeichnet werden, können eine wichtige Möglichkeit zum Vermeiden von Synchronisierungen sein.</span><span class="sxs-lookup"><span data-stu-id="cb6e1-279">Per-thread data, also known as thread local storage, can be an important way of avoiding synchronization.</span></span> <span data-ttu-id="cb6e1-280">Visual C++ ermöglicht es Ihnen, globale Variablen mit der **\_ \_ declspec-Syntax (Thread)** als pro Thread zu deklarieren.</span><span class="sxs-lookup"><span data-stu-id="cb6e1-280">Visual C++ allows you to declare global variables as being per-thread with the **\_\_declspec(thread)** syntax.</span></span>


```C++
__declspec( thread ) int tls_i = 1;
```



<span data-ttu-id="cb6e1-281">Dadurch erhält jeder Thread im Prozess eine eigene Kopie von TLS \_ i, auf die sicher und effizient verwiesen werden kann, ohne dass eine Synchronisierung erforderlich ist.</span><span class="sxs-lookup"><span data-stu-id="cb6e1-281">This gives each thread in the process its own copy of tls\_i, which can be referenced safely and efficiently without requiring synchronization.</span></span>

<span data-ttu-id="cb6e1-282">Die Methode " **\_ \_ declspec (Thread)** " funktioniert nicht mit dynamisch geladenen DLLs.</span><span class="sxs-lookup"><span data-stu-id="cb6e1-282">The **\_\_declspec(thread)** technique does not work with dynamically loaded DLLs.</span></span> <span data-ttu-id="cb6e1-283">Wenn Sie dynamisch geladene DLLs verwenden, müssen Sie die TlsAlloc-Funktions Familie verwenden, um lokalen Thread Speicher zu implementieren.</span><span class="sxs-lookup"><span data-stu-id="cb6e1-283">If you use dynamically loaded DLLs, you will need to use the TLSAlloc family of functions to implement thread local storage.</span></span>

## <a name="destroying-threads"></a><span data-ttu-id="cb6e1-284">Zerstören von Threads</span><span class="sxs-lookup"><span data-stu-id="cb6e1-284">Destroying Threads</span></span>

<span data-ttu-id="cb6e1-285">Der einzige sichere Weg, einen Thread zu zerstören, besteht darin, den Thread selbst zu beenden, indem er entweder von der Haupt Thread Funktion zurückgegeben wird oder der Thread [**ExitThread**](/windows/win32/api/processthreadsapi/nf-processthreadsapi-exitthread) oder [**\_ endthreadex**](https://msdn.microsoft.com/library/hw264s73(v=VS.71).aspx)aufruft.</span><span class="sxs-lookup"><span data-stu-id="cb6e1-285">The only safe way to destroy a thread is to have the thread itself exit, either by returning from the main thread function or by having the thread call [**ExitThread**](/windows/win32/api/processthreadsapi/nf-processthreadsapi-exitthread) or [**\_endthreadex**](https://msdn.microsoft.com/library/hw264s73(v=VS.71).aspx).</span></span> <span data-ttu-id="cb6e1-286">Wenn ein Thread mit [**\_ beginthreadex**](https://msdn.microsoft.com/library/ms397047(v=VS.70).aspx)erstellt wird, sollte er **\_ endthreadex** verwenden oder von der Haupt Thread Funktion zurückkehren, da die Verwendung von **ExitThread** keine ordnungsgemäße kostenlose CRT-Ressourcen bereitstellt.</span><span class="sxs-lookup"><span data-stu-id="cb6e1-286">If a thread is created with [**\_beginthreadex**](https://msdn.microsoft.com/library/ms397047(v=VS.70).aspx), then it should use **\_endthreadex** or return from the main thread function, since using **ExitThread** won't properly free CRT resources.</span></span> <span data-ttu-id="cb6e1-287">Aufrufen der Funktion [**TerminateThread**](/windows/win32/api/processthreadsapi/nf-processthreadsapi-terminatethread) nie, da der Thread nicht ordnungsgemäß bereinigt wird.</span><span class="sxs-lookup"><span data-stu-id="cb6e1-287">Never call the [**TerminateThread**](/windows/win32/api/processthreadsapi/nf-processthreadsapi-terminatethread) function, because the thread will not be properly cleaned up.</span></span> <span data-ttu-id="cb6e1-288">Threads sollten immer einen Commit für Suizide durchsetzen – Sie sollten niemals ermordet werden.</span><span class="sxs-lookup"><span data-stu-id="cb6e1-288">Threads should always commit suicide—they should never be murdered.</span></span>

## <a name="openmp"></a><span data-ttu-id="cb6e1-289">OpenMP</span><span class="sxs-lookup"><span data-stu-id="cb6e1-289">OpenMP</span></span>

<span data-ttu-id="cb6e1-290">OpenMP ist eine Spracherweiterung zum Hinzufügen von Multithreading zum Programm, indem Pragmas verwendet werden, um den Compiler in parallelisierungsschleifen zu unterstützen.</span><span class="sxs-lookup"><span data-stu-id="cb6e1-290">OpenMP is a language extension for adding multithreading to your program by using pragmas to guide the compiler in parallelizing loops.</span></span> <span data-ttu-id="cb6e1-291">OpenMP wird von Visual C++ 2005 unter Windows und Xbox 360 unterstützt und kann in Verbindung mit der manuellen Thread Verwaltung verwendet werden.</span><span class="sxs-lookup"><span data-stu-id="cb6e1-291">OpenMP is supported by Visual C++ 2005 on Windows and Xbox 360 and can be used in conjunction with manual thread management.</span></span> <span data-ttu-id="cb6e1-292">OpenMP kann eine bequeme Möglichkeit zum Multithread von Teilen Ihres Codes sein, ist jedoch unwahrscheinlich, dass es sich um die ideale Lösung handelt, insbesondere bei spielen.</span><span class="sxs-lookup"><span data-stu-id="cb6e1-292">OpenMP can be a convenient way to multithread parts of your code, but is unlikely to be the ideal solution, especially for games.</span></span> <span data-ttu-id="cb6e1-293">OpenMP ist möglicherweise besser auf Produktionsaufgaben mit längerer Laufzeit wie z. b. die Verarbeitung von Grafiken und anderen Ressourcen anwendbar.</span><span class="sxs-lookup"><span data-stu-id="cb6e1-293">OpenMP may be more applicable to longer-running production tasks such as processing art and other resources.</span></span> <span data-ttu-id="cb6e1-294">Weitere Informationen finden Sie in der Visual C++-Dokumentation, oder besuchen Sie die [Website](https://www.openmp.org/)von OpenMP.</span><span class="sxs-lookup"><span data-stu-id="cb6e1-294">For more information, see the Visual C++ documentation or go to the OpenMP [website](https://www.openmp.org/).</span></span>

## <a name="profiling"></a><span data-ttu-id="cb6e1-295">Profilerstellung</span><span class="sxs-lookup"><span data-stu-id="cb6e1-295">Profiling</span></span>

<span data-ttu-id="cb6e1-296">Die Multithread-Profilerstellung ist wichtig.</span><span class="sxs-lookup"><span data-stu-id="cb6e1-296">Multithreaded profiling is important.</span></span> <span data-ttu-id="cb6e1-297">Es ist ganz einfach, lange Zeiten zu finden, in denen Threads aufeinander warten.</span><span class="sxs-lookup"><span data-stu-id="cb6e1-297">It is easy to end up with long stalls where threads are waiting on each other.</span></span> <span data-ttu-id="cb6e1-298">Diese Unterbrechungen können schwer zu finden und zu diagnostizieren sein.</span><span class="sxs-lookup"><span data-stu-id="cb6e1-298">These stalls can be difficult to find and diagnose.</span></span> <span data-ttu-id="cb6e1-299">Um Sie leichter zu identifizieren, können Sie Ihren Synchronisierungs aufrufen Instrumentierungen hinzufügen.</span><span class="sxs-lookup"><span data-stu-id="cb6e1-299">To help identify them, consider adding instrumentation to your synchronization calls.</span></span> <span data-ttu-id="cb6e1-300">Ein Samplingprofiler kann auch helfen, diese Probleme zu identifizieren, da er Zeit Steuerungsinformationen aufzeichnen kann, ohne ihn erheblich zu ändern.</span><span class="sxs-lookup"><span data-stu-id="cb6e1-300">A sampling profiler can also help identify these problems because it can record timing information without substantially altering it.</span></span>

## <a name="timing"></a><span data-ttu-id="cb6e1-301">Zeitliche Steuerung</span><span class="sxs-lookup"><span data-stu-id="cb6e1-301">Timing</span></span>

<span data-ttu-id="cb6e1-302">Die RDTSC-Anweisung ist eine Möglichkeit, um genaue Zeit Steuerungsinformationen unter Windows zu erhalten.</span><span class="sxs-lookup"><span data-stu-id="cb6e1-302">The rdtsc instruction is one way to get accurate timing information on Windows.</span></span> <span data-ttu-id="cb6e1-303">Leider weist RDTSC mehrere Probleme auf, die eine schlechte Wahl für Ihren Versand Titel machen.</span><span class="sxs-lookup"><span data-stu-id="cb6e1-303">Unfortunately, rdtsc has multiple problems that make it a poor choice for your shipping title.</span></span> <span data-ttu-id="cb6e1-304">Die RDTSC-Leistungsindikatoren werden nicht zwangsläufig zwischen CPUs synchronisiert. Wenn also der Thread zwischen den Hardwarethreads verschoben wird, treten möglicherweise große positive oder negative Unterschiede auf.</span><span class="sxs-lookup"><span data-stu-id="cb6e1-304">The rdtsc counters are not necessarily synchronized between CPUs, so when your thread moves between hardware threads you may get large positive or negative differences.</span></span> <span data-ttu-id="cb6e1-305">Abhängig von den Energie Verwaltungs Einstellungen kann sich die Häufigkeit, mit der die RDTSC-Leistungs-Counter-Vorgänge erhöht werden, bei der Ausführung des Spiels ändern.</span><span class="sxs-lookup"><span data-stu-id="cb6e1-305">Depending on power management settings, the frequency at which the rdtsc counter increments may also change as your game runs.</span></span> <span data-ttu-id="cb6e1-306">Um diese Probleme zu vermeiden, sollten Sie [**QueryPerformanceCounter**](/windows/win32/api/profileapi/nf-profileapi-queryperformancecounter) und [**QueryPerformanceFrequency**](/windows/win32/api/profileapi/nf-profileapi-queryperformancefrequency) für die zeitliche Steuerung mit hoher Genauigkeit in Ihrem Liefer Spiel bevorzugen.</span><span class="sxs-lookup"><span data-stu-id="cb6e1-306">To avoid these difficulties, you should prefer [**QueryPerformanceCounter**](/windows/win32/api/profileapi/nf-profileapi-queryperformancecounter) and [**QueryPerformanceFrequency**](/windows/win32/api/profileapi/nf-profileapi-queryperformancefrequency) for high-precision timing in your shipping game.</span></span> <span data-ttu-id="cb6e1-307">Weitere Informationen zur zeitlichen Steuerung finden Sie unter [Game Timing und Multicore-Prozessoren](./game-timing-and-multicore-processors.md).</span><span class="sxs-lookup"><span data-stu-id="cb6e1-307">For more information about timing, see [Game Timing and Multicore Processors](./game-timing-and-multicore-processors.md).</span></span>

## <a name="debugging"></a><span data-ttu-id="cb6e1-308">Debuggen</span><span class="sxs-lookup"><span data-stu-id="cb6e1-308">Debugging</span></span>

<span data-ttu-id="cb6e1-309">Visual Studio unterstützt das Multithread-Debugging für Windows und Xbox 360 vollständig.</span><span class="sxs-lookup"><span data-stu-id="cb6e1-309">Visual Studio fully supports multithreaded debugging for Windows and Xbox 360.</span></span> <span data-ttu-id="cb6e1-310">Im Fenster "Visual Studio-Threads" können Sie zwischen Threads wechseln, um die verschiedenen Aufruf Listen und lokalen Variablen anzuzeigen.</span><span class="sxs-lookup"><span data-stu-id="cb6e1-310">The Visual Studio threads window lets you switch between threads in order to see the different call stacks and local variables.</span></span> <span data-ttu-id="cb6e1-311">Im Fenster Threads können Sie auch bestimmte Threads fixieren und durch ein-und auslassen.</span><span class="sxs-lookup"><span data-stu-id="cb6e1-311">The threads window also lets you freeze and thaw particular threads.</span></span>

<span data-ttu-id="cb6e1-312">Auf Xbox 360 können Sie die **\@ hwthread** -Metavariable im Überwachungs Fenster verwenden, um den Hardware Thread anzuzeigen, in dem der derzeit ausgewählte Software Thread ausgeführt wird.</span><span class="sxs-lookup"><span data-stu-id="cb6e1-312">On Xbox 360, you can use the **\@hwthread** meta-variable in the watch window to show the hardware thread on which the currently selected software thread is running.</span></span>

<span data-ttu-id="cb6e1-313">Das Fenster Threads ist einfacher zu verwenden, wenn Sie Ihre Threads als sinnvoll benennen.</span><span class="sxs-lookup"><span data-stu-id="cb6e1-313">The threads window is easier to use if you name your threads meaningfully.</span></span> <span data-ttu-id="cb6e1-314">Mit Visual Studio und anderen Microsoft-Debuggern können Sie Ihre Threads benennen.</span><span class="sxs-lookup"><span data-stu-id="cb6e1-314">Visual Studio and other Microsoft debuggers allow you to name your threads.</span></span> <span data-ttu-id="cb6e1-315">Implementieren Sie die folgende **SetThreadName** -Funktion, und nennen Sie Sie von jedem Thread aus, während Sie gestartet wird.</span><span class="sxs-lookup"><span data-stu-id="cb6e1-315">Implement the following **SetThreadName** function and call it from each thread as it starts up.</span></span>


```C++
typedef struct tagTHREADNAME_INFO
{
    DWORD dwType;     // must be 0x1000
    LPCSTR szName;    // pointer to name (in user address space)
    DWORD dwThreadID; // thread ID (-1 = caller thread)
    DWORD dwFlags;    // reserved for future use, must be zero
} THREADNAME_INFO;

void SetThreadName( DWORD dwThreadID, LPCSTR szThreadName )
{
    THREADNAME_INFO info;
    info.dwType = 0x1000;
    info.szName = szThreadName;
    info.dwThreadID = dwThreadID;
    info.dwFlags = 0;

    __try
    {
        RaiseException( 0x406D1388, 0,
                    sizeof(info) / sizeof(DWORD),
            (DWORD*)&info );
    }
    __except( EXCEPTION_CONTINUE_EXECUTION ) {
    }
}

// Example usage:
SetThreadName(-1, "Main thread");
```



<span data-ttu-id="cb6e1-316">Der Kernel Debugger (KD) und WinDbg unterstützen auch Multithread-Debuggen.</span><span class="sxs-lookup"><span data-stu-id="cb6e1-316">The kernel debugger (KD) and WinDBG also support multithreaded debugging.</span></span>

## <a name="testing"></a><span data-ttu-id="cb6e1-317">Test</span><span class="sxs-lookup"><span data-stu-id="cb6e1-317">Testing</span></span>

<span data-ttu-id="cb6e1-318">Die Multithreadprogrammierung kann knifflig sein, und einige multithreadfehler werden nur selten angezeigt, sodass Sie schwer zu finden und zu beheben sind.</span><span class="sxs-lookup"><span data-stu-id="cb6e1-318">Multithreaded programming can be tricky, and some multithreaded bugs show up only rarely, making them difficult to find and fix.</span></span> <span data-ttu-id="cb6e1-319">Eine der besten Möglichkeiten, Sie zu leeren, besteht darin, eine Vielzahl von Computern zu testen, insbesondere solche mit vier oder mehr Prozessoren.</span><span class="sxs-lookup"><span data-stu-id="cb6e1-319">One of the best ways to flush them out is to test on a wide range of computers, particularly those with four or more processors.</span></span> <span data-ttu-id="cb6e1-320">Multithread-Code, der auf einem Computer mit einem einzigen Thread einwandfrei funktioniert, kann auf einem Computer mit vier Prozessoren sofort fehlschlagen.</span><span class="sxs-lookup"><span data-stu-id="cb6e1-320">Multithreaded code that works perfectly on a single-threaded computer may fail instantly on a four-processor computer.</span></span> <span data-ttu-id="cb6e1-321">Die Leistungs-und Zeit Steuerungsmerkmale von AMD-und Intel-CPUs können erheblich variieren. Achten Sie daher darauf, auf Multiprozessorcomputern auf der Grundlage von CPUs beider Hersteller zu testen.</span><span class="sxs-lookup"><span data-stu-id="cb6e1-321">The performance and timing characteristics of AMD and Intel CPUs can vary substantially, so be sure to test on multiprocessor computers based on CPUs from both vendors.</span></span>

## <a name="windows-vista-and-windows-7-improvements"></a><span data-ttu-id="cb6e1-322">Verbesserungen für Windows Vista und Windows 7</span><span class="sxs-lookup"><span data-stu-id="cb6e1-322">Windows Vista and Windows 7 Improvements</span></span>

<span data-ttu-id="cb6e1-323">Für Spiele, die auf die neueren Versionen von Windows abzielen, gibt es eine Reihe von APIs, die das Erstellen skalierbarer Multithreadanwendungen vereinfachen.</span><span class="sxs-lookup"><span data-stu-id="cb6e1-323">For games targeting the newer versions of Windows, there are a number of APIs that can simplify the creation of scalable multithreaded applications.</span></span> <span data-ttu-id="cb6e1-324">Dies gilt insbesondere für die neue Thread Pool-API und einige zusätzliche syncrhonziationprimitiv (Bedingungs Variablen, schlanke Lese-/Schreibsperre und einmalige Initialisierung).</span><span class="sxs-lookup"><span data-stu-id="cb6e1-324">This is particularly true with the new ThreadPool API and some additional syncrhonziation primitives (condition variables, the slim read/writer lock, and one-time initialization).</span></span> <span data-ttu-id="cb6e1-325">Einen Überblick über diese Technologien finden Sie in den folgenden MSDN Magazine-Artikeln:</span><span class="sxs-lookup"><span data-stu-id="cb6e1-325">You can find an overview of these technologies in the following MSDN Magazine articles:</span></span>

-   [<span data-ttu-id="cb6e1-326">Verbessern der Skalierbarkeit mit neuen Thread Pool-APIs</span><span class="sxs-lookup"><span data-stu-id="cb6e1-326">Improve Scalability With New Thread Pool APIs</span></span>](/archive/msdn-magazine/2007/october/pooled-threads-improve-scalability-with-new-thread-pool-apis)
-   [<span data-ttu-id="cb6e1-327">Neue Synchronisierungs primitive in Windows Vista</span><span class="sxs-lookup"><span data-stu-id="cb6e1-327">Synchronization Primitives New To Windows Vista</span></span>](/archive/msdn-magazine/2007/june/concurrency-synchronization-primitives-new-to-windows-vista)

<span data-ttu-id="cb6e1-328">Anwendungen, die [Direct3D 11-Features](../direct3d11/direct3d-11-features.md) auf diesen Betriebssystemen verwenden, können auch den neuen Entwurf für die gleichzeitige Objekt Erstellung und verzögerte Kontext Befehlslisten nutzen, um eine bessere Skalierbarkeit für multithreadrendering zu erzielen.</span><span class="sxs-lookup"><span data-stu-id="cb6e1-328">Applications using [Direct3D 11 Features](../direct3d11/direct3d-11-features.md) on these operating systems can also take advantage of the new design for concurrent object creation and deferred context command lists for better scalability for multithreaded rendering.</span></span>

## <a name="summary"></a><span data-ttu-id="cb6e1-329">Zusammenfassung</span><span class="sxs-lookup"><span data-stu-id="cb6e1-329">Summary</span></span>

<span data-ttu-id="cb6e1-330">Dank eines sorgfältigen Entwurfs, bei dem die Interaktionen zwischen Threads minimiert werden, können Sie mit der Multithreadprogrammierung beträchtliche Leistungssteigerungen erzielen, ohne Ihren Code übermäßig Komplex zu gestalten.</span><span class="sxs-lookup"><span data-stu-id="cb6e1-330">With careful design that minimizes the interactions between threads, you can get substantial performance gains from multithreaded programming without adding excessive complexity to your code.</span></span> <span data-ttu-id="cb6e1-331">Dadurch kann Ihr Spiel Code die nächste Generation von Prozessor Verbesserungen erreichen und immer mehr überzeugende Spiele Umgebungen bereitzustellen.</span><span class="sxs-lookup"><span data-stu-id="cb6e1-331">This will let your game code ride the next wave of processor improvements and deliver ever more compelling gaming experiences.</span></span>

## <a name="references"></a><span data-ttu-id="cb6e1-332">References</span><span class="sxs-lookup"><span data-stu-id="cb6e1-332">References</span></span>

-   <span data-ttu-id="cb6e1-333">Jim Beveridge & Robert Weiner, *Multithreading Anwendungen in Win32*, Addison-Wesley, 1997</span><span class="sxs-lookup"><span data-stu-id="cb6e1-333">Jim Beveridge & Robert Weiner, *Multithreading Applications in Win32*, Addison-Wesley, 1997</span></span>
-   <span data-ttu-id="cb6e1-334">Chuck walbourn, [Game Timing und Multicore-Prozessoren](./game-timing-and-multicore-processors.md), Microsoft Corporation, 2005</span><span class="sxs-lookup"><span data-stu-id="cb6e1-334">Chuck Walbourn, [Game Timing and Multicore Processors](./game-timing-and-multicore-processors.md), Microsoft Corporation, 2005</span></span>
-   <span data-ttu-id="cb6e1-335">MSDN Library: [ **GetLogicalProcessorInformation**](/windows/win32/api/sysinfoapi/nf-sysinfoapi-getlogicalprocessorinformation)</span><span class="sxs-lookup"><span data-stu-id="cb6e1-335">MSDN Library: [**GetLogicalProcessorInformation**](/windows/win32/api/sysinfoapi/nf-sysinfoapi-getlogicalprocessorinformation)</span></span>
-   [<span data-ttu-id="cb6e1-336">OpenMP</span><span class="sxs-lookup"><span data-stu-id="cb6e1-336">OpenMP</span></span>](https://www.openmp.org/)

 

 