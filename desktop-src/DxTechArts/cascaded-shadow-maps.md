---
title: Überlappende Schattenkarten
description: Cascaded Shadow Maps (CSMS) sind die beste Möglichkeit, einen der am häufigsten auftretenden Fehler mit Shadowing-Aliasing zu bekämpfen.
ms.assetid: d3570d0a-74e0-5b9c-6586-c933f630c4ee
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: ae70433f97f33c3cc28af8e282b14ea1f513cf4d
ms.sourcegitcommit: 54db9e6a00a5c8f68e7c1a16b8c6d4943374498c
ms.translationtype: MT
ms.contentlocale: de-DE
ms.lasthandoff: 04/01/2021
ms.locfileid: "106372802"
---
# <a name="cascaded-shadow-maps"></a><span data-ttu-id="92ae7-103">Überlappende Schattenkarten</span><span class="sxs-lookup"><span data-stu-id="92ae7-103">Cascaded Shadow Maps</span></span>

<span data-ttu-id="92ae7-104">Cascaded Shadow Maps (CSMS) sind die beste Möglichkeit, einen der am häufigsten auftretenden Fehler mit Shadowing: Perspective Aliasing zu bekämpfen.</span><span class="sxs-lookup"><span data-stu-id="92ae7-104">Cascaded shadow maps (CSMs) are the best way to combat one of the most prevalent errors with shadowing: perspective aliasing.</span></span> <span data-ttu-id="92ae7-105">In diesem technischen Artikel, bei dem davon ausgegangen wird, dass der Reader mit der Schatten Zuordnung vertraut ist, wird das Thema CSMS behandelt.</span><span class="sxs-lookup"><span data-stu-id="92ae7-105">This technical article, which assumes the reader is familiar with shadow mapping, tackles the topic of CSMs.</span></span> <span data-ttu-id="92ae7-106">Diese Parameter:</span><span class="sxs-lookup"><span data-stu-id="92ae7-106">Specifically, it:</span></span>

-   <span data-ttu-id="92ae7-107">erläutert die Komplexität von CSMS.</span><span class="sxs-lookup"><span data-stu-id="92ae7-107">explains the complexity of CSMs;</span></span>
-   <span data-ttu-id="92ae7-108">Gibt Details zu den möglichen Variationen der CSM-Algorithmen an.</span><span class="sxs-lookup"><span data-stu-id="92ae7-108">gives details on the possible variations of the CSM algorithms;</span></span>
-   <span data-ttu-id="92ae7-109">Beschreibt die beiden gängigsten Filtertechniken – PCF-Filter (Prozent) und das Filtern mit Varianz Schatten Maps (VSMs).</span><span class="sxs-lookup"><span data-stu-id="92ae7-109">describes the two most common filtering techniques—percentage closer filtering (PCF) and filtering with variance shadow maps (VSMs);</span></span>
-   <span data-ttu-id="92ae7-110">identifiziert und behandelt einige der häufigen Fehler beim Hinzufügen von Filtern zu CSMS. immer</span><span class="sxs-lookup"><span data-stu-id="92ae7-110">identifies and addresses some of the common pitfalls associated with adding filtering to CSMs; and</span></span>
-   <span data-ttu-id="92ae7-111">zeigt, wie CSMS Direct3D 10 bis Direct3D 11-Hardware zugeordnet wird.</span><span class="sxs-lookup"><span data-stu-id="92ae7-111">shows how to map CSMs to Direct3D 10 through Direct3D 11 hardware.</span></span>

<span data-ttu-id="92ae7-112">Den in diesem Artikel verwendeten Code finden Sie im DirectX Software Development Kit (SDK) in den CascadedShadowMaps11-und VarianceShadows11-Beispielen.</span><span class="sxs-lookup"><span data-stu-id="92ae7-112">The code used in this article can be found in the DirectX Software Development Kit (SDK) in the CascadedShadowMaps11 and VarianceShadows11 samples.</span></span> <span data-ttu-id="92ae7-113">Dieser Artikel erweist sich nach der Implementierung der Techniken, die im technischen Artikel [zum Verbessern von Schatten tiefen Maps](/windows/desktop/DxTechArts/common-techniques-to-improve-shadow-depth-maps)behandelt werden, am nützlichsten.</span><span class="sxs-lookup"><span data-stu-id="92ae7-113">This article will prove most useful after implementing the techniques covered in the technical article, [Common Techniques to Improve Shadow Depth Maps](/windows/desktop/DxTechArts/common-techniques-to-improve-shadow-depth-maps), are implemented.</span></span>

## <a name="cascaded-shadow-maps-and-perspective-aliasing"></a><span data-ttu-id="92ae7-114">Kaskadierbare Schatten Zuordnungen und perspektivische Aliasing</span><span class="sxs-lookup"><span data-stu-id="92ae7-114">Cascaded Shadow Maps and Perspective Aliasing</span></span>

<span data-ttu-id="92ae7-115">Perspektiven Aliasing in einer Schatten Zuordnung ist eines der schwierigsten Probleme, die gelöst werden müssen.</span><span class="sxs-lookup"><span data-stu-id="92ae7-115">Perspective aliasing in a shadow map is one of the most difficult problems to overcome.</span></span> <span data-ttu-id="92ae7-116">Im technischen Artikel werden allgemeine Techniken zum Verbessern von Schatten tiefen Zuordnungen, Perspektiven Aliasing und einige Ansätze zum Beheben des Problems identifiziert.</span><span class="sxs-lookup"><span data-stu-id="92ae7-116">In the technical article, Common Techniques to Improve Shadow Depth Maps, perspective aliasing is described and some approaches to mitigate the problem are identified.</span></span> <span data-ttu-id="92ae7-117">In der Praxis sind CSMS tendenziell die beste Lösung und werden häufig in modernen Spielen eingesetzt.</span><span class="sxs-lookup"><span data-stu-id="92ae7-117">In practice, CSMs tend to be the best solution, and are commonly employed in modern games.</span></span>

<span data-ttu-id="92ae7-118">Das grundlegende Konzept von CSMS ist leicht verständlich.</span><span class="sxs-lookup"><span data-stu-id="92ae7-118">The basic concept of CSMs is easy to understand.</span></span> <span data-ttu-id="92ae7-119">Für verschiedene Bereiche der Kamera "Frustum" sind Schatten Zuordnungen mit unterschiedlichen Auflösungen erforderlich.</span><span class="sxs-lookup"><span data-stu-id="92ae7-119">Different areas of the camera frustum require shadow maps with different resolutions.</span></span> <span data-ttu-id="92ae7-120">Objekte, die sich in der Nähe des Auges befinden, erfordern eine höhere Auflösung als mehr entfernte Objekte.</span><span class="sxs-lookup"><span data-stu-id="92ae7-120">Objects nearest the eye require a higher resolution than do more distant objects.</span></span> <span data-ttu-id="92ae7-121">Wenn sich das Auge sehr nahe an der Geometrie bewegt, kann es sein, dass die Pixel, die dem Augenblick am nächsten sind, so viel Auflösung erfordern, dass auch eine 4096 × 4096-Schatten Zuordnung unzureichend ist.</span><span class="sxs-lookup"><span data-stu-id="92ae7-121">In fact, when the eye moves very close to the geometry, the pixels nearest the eye can require so much resolution that even a 4096 × 4096 shadow map is insufficient.</span></span>

<span data-ttu-id="92ae7-122">Die grundlegende Idee von CSMS besteht darin, die Frustration in mehrere frusta zu partitionieren.</span><span class="sxs-lookup"><span data-stu-id="92ae7-122">The basic idea of CSMs is to partition the frustum into multiple frusta.</span></span> <span data-ttu-id="92ae7-123">Für jede subfrustum wird eine schattenkarte gerendert. der Pixel-Shader gibt dann eine Stichprobe aus der Zuordnung aus, die am ehesten mit der erforderlichen Auflösung übereinstimmt (Abbildung 2).</span><span class="sxs-lookup"><span data-stu-id="92ae7-123">A shadow map is rendered for each subfrustum; the pixel shader then samples from the map that most closely matches the required resolution (Figure 2).</span></span>

<span data-ttu-id="92ae7-124">**Abbildung 1. Schattenkarten Abdeckung**</span><span class="sxs-lookup"><span data-stu-id="92ae7-124">**Figure 1. Shadow map coverage**</span></span>

![schattenkarten Abdeckung](images/shadow-map-coverage.png)

<span data-ttu-id="92ae7-126">In Abbildung 1 wird die Qualität (von links nach rechts) von der höchsten zur niedrigsten angezeigt.</span><span class="sxs-lookup"><span data-stu-id="92ae7-126">In Figure 1, quality is shown (left to right) from highest to lowest.</span></span> <span data-ttu-id="92ae7-127">Die Reihe der Raster, die Schatten Zuordnungen mit einer Ansicht "Frustum" (umgekehrter Kegel in rot) darstellen, zeigt, wie die Pixel Abdeckung von unterschiedlichen Auflösungs schattenkarten betroffen ist.</span><span class="sxs-lookup"><span data-stu-id="92ae7-127">The series of grids representing shadow maps with a view frustum (inverted cone in red) shows how pixel coverage is affected with different resolution shadow maps.</span></span> <span data-ttu-id="92ae7-128">Schatten sind von der höchsten Qualität (weiße Pixel), wenn ein 1:1-Verhältnis für die Zuordnung von Pixeln in einem hellen Raum zu texeln in der schattenkarte vorhanden ist.</span><span class="sxs-lookup"><span data-stu-id="92ae7-128">Shadows are of the highest quality (white pixels) when there is a 1:1 ratio mapping pixels in light space to texels in the shadow map.</span></span> <span data-ttu-id="92ae7-129">Perspektivische Aliasing erfolgt in Form von großen Blocktextur Zuordnungen (linkes Bild), wenn zu viele Pixel dem gleichen Schatten Texel zugeordnet werden.</span><span class="sxs-lookup"><span data-stu-id="92ae7-129">Perspective aliasing occurs in the form of large, blocky texture maps (left image) when too many pixels map to the same shadow texel.</span></span> <span data-ttu-id="92ae7-130">Wenn die Schatten Zuordnung zu groß ist, wird Sie untersucht.</span><span class="sxs-lookup"><span data-stu-id="92ae7-130">When the shadow map is too large, it is under sampled.</span></span> <span data-ttu-id="92ae7-131">In diesem Fall werden texeln übersprungen, schimmernde Artefakte werden eingeführt, und die Leistung ist beeinträchtigt.</span><span class="sxs-lookup"><span data-stu-id="92ae7-131">In this case, texels are skipped, shimmering artifacts are introduced, and performance is affected.</span></span>

<span data-ttu-id="92ae7-132">**Abbildung 2. CSM-Schatten Qualität**</span><span class="sxs-lookup"><span data-stu-id="92ae7-132">**Figure 2. CSM shadow quality**</span></span>

![CSM-Schatten Qualität](images/csm-shadow-quality.png)

<span data-ttu-id="92ae7-134">Abbildung 2 zeigt Ausschnitte aus dem Abschnitt mit der höchsten Qualität in den einzelnen schattenkarten in Abbildung 1.</span><span class="sxs-lookup"><span data-stu-id="92ae7-134">Figure 2 shows cutouts from the highest quality section in each shadow map in Figure 1.</span></span> <span data-ttu-id="92ae7-135">Die Schatten Zuordnung mit den am weitesten links positionierte Pixel (auf der Spitze) ist das nächste Auge.</span><span class="sxs-lookup"><span data-stu-id="92ae7-135">The shadow map with the most closely placed pixels (at the apex) is nearest the eye.</span></span> <span data-ttu-id="92ae7-136">Technisch gesehen handelt es sich hierbei um Zuordnungen derselben Größe, wobei weiß und grau verwendet werden, um den Erfolg der kaskadierenden schattenkarte zu veranschaulichen.</span><span class="sxs-lookup"><span data-stu-id="92ae7-136">Technically, these are maps of the same size, with white and grey used to exemplify the success of the cascaded shadow map.</span></span> <span data-ttu-id="92ae7-137">Weiß ist ideal, da es eine gute Abdeckung anzeigt – ein 1:1-Verhältnis für die Augen Raum Pixel und schattenkarten texeln.</span><span class="sxs-lookup"><span data-stu-id="92ae7-137">White is ideal because it shows good coverage—a 1:1 ratio for eye-space pixels and shadow-map texels.</span></span>

<span data-ttu-id="92ae7-138">CSMS erfordert die folgenden Schritte pro Frame.</span><span class="sxs-lookup"><span data-stu-id="92ae7-138">CSMs require the following steps per frame.</span></span>

1.  <span data-ttu-id="92ae7-139">Partitionieren Sie den Frustum in subfrusta.</span><span class="sxs-lookup"><span data-stu-id="92ae7-139">Partition the frustum into subfrusta.</span></span>
2.  <span data-ttu-id="92ae7-140">Berechnen Sie eine orthografische Projektion für jede subfrustum.</span><span class="sxs-lookup"><span data-stu-id="92ae7-140">Compute an orthographic projection for each subfrustum.</span></span>
3.  <span data-ttu-id="92ae7-141">Rendering einer Schatten Zuordnung für jede subfrustum.</span><span class="sxs-lookup"><span data-stu-id="92ae7-141">Render a shadow map for each subfrustum.</span></span>
4.  <span data-ttu-id="92ae7-142">Rendering der Szene.</span><span class="sxs-lookup"><span data-stu-id="92ae7-142">Render the scene.</span></span>

    1.  <span data-ttu-id="92ae7-143">Binden der Schatten Zuordnungen und Rendering.</span><span class="sxs-lookup"><span data-stu-id="92ae7-143">Bind the shadow maps and render.</span></span>
    2.  <span data-ttu-id="92ae7-144">Der Vertex-Shader führt Folgendes aus:</span><span class="sxs-lookup"><span data-stu-id="92ae7-144">The vertex shader does the following:</span></span>

        -   <span data-ttu-id="92ae7-145">Berechnet Texturkoordinaten für die einzelnen hellen subfrustum (es sei denn, die erforderliche Textur Koordinate wird im Pixelshader berechnet).</span><span class="sxs-lookup"><span data-stu-id="92ae7-145">Computes texture coordinates for each light subfrustum (unless the needed texture coordinate is calculated in the pixel shader).</span></span>
        -   <span data-ttu-id="92ae7-146">Transformiert und beleuchtet den Scheitelpunkt usw.</span><span class="sxs-lookup"><span data-stu-id="92ae7-146">Transforms and lights the vertex, and so on.</span></span>

    3.  <span data-ttu-id="92ae7-147">Der Pixelshader führt Folgendes aus:</span><span class="sxs-lookup"><span data-stu-id="92ae7-147">The pixel shader does the following:</span></span>

        -   <span data-ttu-id="92ae7-148">Bestimmt die richtige Schatten Zuordnung.</span><span class="sxs-lookup"><span data-stu-id="92ae7-148">Determines the proper shadow map.</span></span>
        -   <span data-ttu-id="92ae7-149">Transformiert die Texturkoordinaten bei Bedarf.</span><span class="sxs-lookup"><span data-stu-id="92ae7-149">Transforms the texture coordinates if necessary.</span></span>
        -   <span data-ttu-id="92ae7-150">Gibt eine Stichprobenentnahme aus.</span><span class="sxs-lookup"><span data-stu-id="92ae7-150">Samples the cascade.</span></span>
        -   <span data-ttu-id="92ae7-151">Leuchtet das Pixel.</span><span class="sxs-lookup"><span data-stu-id="92ae7-151">Lights the pixel.</span></span>

## <a name="partitioning-the-frustum"></a><span data-ttu-id="92ae7-152">Partitionierung von Frustum</span><span class="sxs-lookup"><span data-stu-id="92ae7-152">Partitioning the Frustum</span></span>

<span data-ttu-id="92ae7-153">Die Partitionierung von "Frustum" ist das Erstellen von "subfrusta".</span><span class="sxs-lookup"><span data-stu-id="92ae7-153">Partitioning the frustum is the act of creating subfrusta.</span></span> <span data-ttu-id="92ae7-154">Ein Verfahren zum Aufteilen der Frustration besteht darin, Intervalle zwischen 0 und 100 Prozent in der Z-Richtung zu berechnen.</span><span class="sxs-lookup"><span data-stu-id="92ae7-154">One technique for splitting the frustum is to calculate intervals from zero percent to one hundred percent in the Z-direction.</span></span> <span data-ttu-id="92ae7-155">Jedes Intervall stellt dann eine nahe Ebene und eine weite Ebene als Prozentsatz der Z-Achse dar.</span><span class="sxs-lookup"><span data-stu-id="92ae7-155">Each interval then represents a near plane and a far plane as a percentage of the Z-axis.</span></span>

<span data-ttu-id="92ae7-156">**Abbildung 3. Willkürlich partitionierte Frustums anzeigen**</span><span class="sxs-lookup"><span data-stu-id="92ae7-156">**Figure 3. View frustums partitioned arbitrarily**</span></span>

![willkürlich partitionierte Frustums anzeigen](images/view-frustums-partitioned-arbitrarily.png)

<span data-ttu-id="92ae7-158">In der Praxis bewirkt das Neuberechnen der Frustum-Teilungen pro Frame, dass Schatten Ränder zu Shimmer werden.</span><span class="sxs-lookup"><span data-stu-id="92ae7-158">In practice, recalculating the frustum splits per frame causes shadow edges to shimmer.</span></span> <span data-ttu-id="92ae7-159">Im Allgemeinen wird die Verwendung eines statischen Satzes von kaskadierenden Intervallen pro Szenario empfohlen.</span><span class="sxs-lookup"><span data-stu-id="92ae7-159">The generally accepted practice is to use a static set of cascade intervals per scenario.</span></span> <span data-ttu-id="92ae7-160">In diesem Szenario wird das Intervall entlang der Z-Achse verwendet, um einen subfrustum zu beschreiben, der beim Partitionieren von Frustum auftritt.</span><span class="sxs-lookup"><span data-stu-id="92ae7-160">In this scenario, the interval along the Z-axis is used to describe a subfrustum that occurs when partitioning the frustum.</span></span> <span data-ttu-id="92ae7-161">Das Bestimmen der richtigen Größen Intervalle für eine bestimmte Szene hängt von mehreren Faktoren ab.</span><span class="sxs-lookup"><span data-stu-id="92ae7-161">Determining the correct size intervals for a given scene depends upon several factors.</span></span>

### <a name="orientation-of-the-scene-geometry"></a><span data-ttu-id="92ae7-162">Ausrichtung der Szene Geometrie</span><span class="sxs-lookup"><span data-stu-id="92ae7-162">Orientation of the Scene Geometry</span></span>

<span data-ttu-id="92ae7-163">In Bezug auf die Szenen Geometrie wirkt sich die Kameraausrichtung auf die Auswahl der Cascade Interval aus.</span><span class="sxs-lookup"><span data-stu-id="92ae7-163">With respect to scene geometry, camera orientation affects cascade interval selection.</span></span> <span data-ttu-id="92ae7-164">Beispielsweise hat eine Kamera, wie z. b. eine Boden Kamera in einem Fußballspiel, einen anderen statischen Satz an kaskadierenden Intervallen als eine Kamera im Himmel.</span><span class="sxs-lookup"><span data-stu-id="92ae7-164">For example, a camera very near the ground, such as a ground camera in a football game, has a different static set of cascade intervals than a camera in the sky.</span></span>

<span data-ttu-id="92ae7-165">Abbildung 4 zeigt einige verschiedene Kameras und die jeweiligen Partitionen.</span><span class="sxs-lookup"><span data-stu-id="92ae7-165">Figure 4 shows some different cameras and their respective partitions.</span></span> <span data-ttu-id="92ae7-166">Wenn der Z-Bereich der Szene sehr groß ist, sind mehr geteilte Ebenen erforderlich.</span><span class="sxs-lookup"><span data-stu-id="92ae7-166">When the scene's Z-range is very large, more split planes are required.</span></span> <span data-ttu-id="92ae7-167">Wenn sich das Auge z. b. sehr nahe der Grundebene befindet, aber entfernte Objekte weiterhin sichtbar sind, können mehrere kaskadierende erforderlich sein.</span><span class="sxs-lookup"><span data-stu-id="92ae7-167">For example, when the eye is very near the ground plane, but distant objects are still visible, multiple cascades can be necessary.</span></span> <span data-ttu-id="92ae7-168">Die Unterteilung der Frustum-Klasse, sodass sich mehr Teilungen in naher Nähe befinden (wobei Perspektiven Aliasing den schnellsten ändert), ist ebenfalls wertvoll.</span><span class="sxs-lookup"><span data-stu-id="92ae7-168">Dividing the frustum so that more splits are near the eye (where perspective aliasing is changing the fastest) is also valuable.</span></span> <span data-ttu-id="92ae7-169">Wenn der größte Teil der Geometrie in einen kleinen Abschnitt (z. b. eine Verwaltungs Ansicht oder ein Flugsimulator) der Ansicht "Frustum" gepuffert wird, sind weniger kaskadierende erforderlich.</span><span class="sxs-lookup"><span data-stu-id="92ae7-169">When most of the geometry is clumped into a small section (such as an overhead view or a flight simulator) of the view frustum, fewer cascades are necessary.</span></span>

<span data-ttu-id="92ae7-170">**Abbildung 4. Für verschiedene Konfigurationen sind unterschiedliche Frustum-Teilungen erforderlich**</span><span class="sxs-lookup"><span data-stu-id="92ae7-170">**Figure 4. Different configurations require different frustum splits**</span></span>

![für verschiedene Konfigurationen sind unterschiedliche Frustum-Teilungen erforderlich](images/different-configurations-require-different-frustum-splits.png)

<span data-ttu-id="92ae7-172">Linken Wenn Geometry einen hohen dynamischen Bereich in Z hat, sind viele kaskadierende erforderlich.</span><span class="sxs-lookup"><span data-stu-id="92ae7-172">(Left) When geometry has a high dynamic range in Z, lots of cascades are required.</span></span> <span data-ttu-id="92ae7-173">Tagesstätte Wenn die Geometrie einen niedrigen dynamischen Bereich in Z aufweist, gibt es nur wenig Vorteile von mehreren Frustums.</span><span class="sxs-lookup"><span data-stu-id="92ae7-173">(Center) When the geometry has low dynamic range in Z, there is little benefit from multiple frustums.</span></span> <span data-ttu-id="92ae7-174">Rechten Wenn der dynamische Bereich Mittel ist, werden nur drei Partitionen benötigt.</span><span class="sxs-lookup"><span data-stu-id="92ae7-174">(Right) Only three partitions are needed when the dynamic range is medium.</span></span>

### <a name="orientation-of-the-light-and-the-camera"></a><span data-ttu-id="92ae7-175">Ausrichtung des Lichts und der Kamera</span><span class="sxs-lookup"><span data-stu-id="92ae7-175">Orientation of the Light and the Camera</span></span>

<span data-ttu-id="92ae7-176">Die Projektions Matrix der einzelnen kaskadieren ist eng um die zugehörige subfrustum-Klasse abgestimmt.</span><span class="sxs-lookup"><span data-stu-id="92ae7-176">Each cascade's projection matrix is fit tightly around its corresponding subfrustum.</span></span> <span data-ttu-id="92ae7-177">In Konfigurationen, in denen die Ansichts Kamera und die Licht Richtungen orthogonal sind, kann das kaskadierende-Objekt eng mit geringem Überlappungs Aufwand angepasst werden.</span><span class="sxs-lookup"><span data-stu-id="92ae7-177">In configurations where the view camera and the light directions are orthogonal, the cascades can be fit tightly with little overlap.</span></span> <span data-ttu-id="92ae7-178">Die Überlappung wird größer, wenn sich das Licht und die Ansichts Kamera in eine parallele Ausrichtung bewegen (Abbildung 5).</span><span class="sxs-lookup"><span data-stu-id="92ae7-178">The overlap becomes larger as the light and the view camera move into parallel alignment (Figure 5).</span></span> <span data-ttu-id="92ae7-179">Wenn das Licht und die Ansichts Kamera fast parallel sind, wird es als "Dueling frusta" bezeichnet und ist ein sehr hartes Szenario für die meisten shadodown-Algorithmen.</span><span class="sxs-lookup"><span data-stu-id="92ae7-179">When the light and the view camera are nearly parallel, it is called a "dueling frusta," and is a very hard scenario for most shadowing algorithms.</span></span> <span data-ttu-id="92ae7-180">Es ist nicht ungewöhnlich, das Licht und die Kamera einzuschränken, damit dieses Szenario nicht auftritt.</span><span class="sxs-lookup"><span data-stu-id="92ae7-180">It is not uncommon to constrain the light and camera so that this scenario does not occur.</span></span> <span data-ttu-id="92ae7-181">CSMS sind jedoch viel besser als viele andere Algorithmen in diesem Szenario.</span><span class="sxs-lookup"><span data-stu-id="92ae7-181">CSMs, however, perform much better than many other algorithms in this scenario.</span></span>

<span data-ttu-id="92ae7-182">**Abbildung 5. Die kaskadierte Überlappung nimmt zu, wenn die Richtung der Kamera parallel verläuft**</span><span class="sxs-lookup"><span data-stu-id="92ae7-182">**Figure 5. Cascade overlap increases as light direction becomes parallel with camera direction**</span></span>

![die kaskadierte Überlappung nimmt zu, wenn die Richtung der Kamera parallel verläuft](images/cascade-overlap-increases-as-light-direction-becomes.jpg)

<span data-ttu-id="92ae7-184">Viele CSM-Implementierungen verwenden "frusta" mit fester Größe.</span><span class="sxs-lookup"><span data-stu-id="92ae7-184">Many CSM implementations use fixed-size frusta.</span></span> <span data-ttu-id="92ae7-185">Der Pixelshader kann die Z-Tiefe verwenden, um in das Bytearray zu indizieren, wenn die Frustum in Intervallen fester Größe aufgeteilt wird.</span><span class="sxs-lookup"><span data-stu-id="92ae7-185">The pixel shader can use the Z-depth to index into the array of cascades when the frustum is split in fixed-size intervals.</span></span>

## <a name="calculating-a-view-frustum-bound"></a><span data-ttu-id="92ae7-186">Berechnen einer View-Frustum gebundenen</span><span class="sxs-lookup"><span data-stu-id="92ae7-186">Calculating a View-Frustum Bound</span></span>

<span data-ttu-id="92ae7-187">Nachdem die Frustum-Intervalle ausgewählt wurden, wird der subfrusta mit einem von zwei Werten erstellt: an Szene anpassen und an Cascade anpassen.</span><span class="sxs-lookup"><span data-stu-id="92ae7-187">Once the frustum intervals are selected, the subfrusta are created using one of two: fit to scene and fit to cascade.</span></span>

### <a name="fit-to-scene"></a><span data-ttu-id="92ae7-188">An Szene anpassen</span><span class="sxs-lookup"><span data-stu-id="92ae7-188">Fit to Scene</span></span>

<span data-ttu-id="92ae7-189">Alle Frustrationen können mit der gleichen Nähe erstellt werden.</span><span class="sxs-lookup"><span data-stu-id="92ae7-189">All of the frusta can be created with the same near plane.</span></span> <span data-ttu-id="92ae7-190">Dies erzwingt eine Überschneidung der kaskadiert.</span><span class="sxs-lookup"><span data-stu-id="92ae7-190">This forces the cascades to overlap.</span></span> <span data-ttu-id="92ae7-191">Mit dem CascadedShadowMaps11-Beispiel wird diese Technik an Scene angepasst.</span><span class="sxs-lookup"><span data-stu-id="92ae7-191">The CascadedShadowMaps11 sample calls this technique fit to scene.</span></span>

### <a name="fit-to-cascade"></a><span data-ttu-id="92ae7-192">An Cascade anpassen</span><span class="sxs-lookup"><span data-stu-id="92ae7-192">Fit to Cascade</span></span>

<span data-ttu-id="92ae7-193">Alternativ kann frusta mit dem tatsächlichen Partitions Intervall erstellt werden, das als near-und Far-Plane verwendet wird.</span><span class="sxs-lookup"><span data-stu-id="92ae7-193">Alternatively, frusta can be created with the actual partition interval being used as near and far planes.</span></span> <span data-ttu-id="92ae7-194">Dies führt zu einer engeren Anpassung, aber degeneriert, damit Sie im Fall von Dueling frusta an die Szene angepasst wird.</span><span class="sxs-lookup"><span data-stu-id="92ae7-194">This causes a tighter fit, but degenerates to fit to scene in the case of dueling frusta.</span></span> <span data-ttu-id="92ae7-195">Mit den CascadedShadowMaps11-Beispielen wird diese Technik an Cascade (CASCADE) angepasst.</span><span class="sxs-lookup"><span data-stu-id="92ae7-195">The CascadedShadowMaps11 samples calls this technique fit to cascade.</span></span>

<span data-ttu-id="92ae7-196">Diese beiden Methoden sind in Abbildung 6 dargestellt.</span><span class="sxs-lookup"><span data-stu-id="92ae7-196">These two methods are shown in Figure 6.</span></span> <span data-ttu-id="92ae7-197">An Cascade anpassen verschwendet weniger Auflösung.</span><span class="sxs-lookup"><span data-stu-id="92ae7-197">Fit to cascade wastes less resolution.</span></span> <span data-ttu-id="92ae7-198">Das Problem bei der kaskadierenden Verwendung besteht darin, dass die orthografische Projektion basierend auf der Ausrichtung der Ansicht Frust vergrößert und verkleinert wird.</span><span class="sxs-lookup"><span data-stu-id="92ae7-198">The problem with fit to cascade is that the orthographic projection grows and shrinks based on the orientation of the view frustum.</span></span> <span data-ttu-id="92ae7-199">Die Methode an Szene anpassen füllt die orthografische Projektion um die maximale Größe der Ansicht aus, um die Artefakte zu entfernen, die beim Verschieben der Ansichts Kamera angezeigt werden.</span><span class="sxs-lookup"><span data-stu-id="92ae7-199">The fit to scene technique pads the orthographic projection by the max size of the view frustum removing the artifacts that appear when the view-camera moves.</span></span> <span data-ttu-id="92ae7-200">[Häufig auftretende Techniken zum Verbessern von Schatten tiefen](/windows/desktop/DxTechArts/common-techniques-to-improve-shadow-depth-maps) Zuordnungen adressiert die Elemente, die angezeigt werden, wenn sich das Licht im Abschnitt "Verschieben des Lichts in in Textteil größeren Schritten" bewegt.</span><span class="sxs-lookup"><span data-stu-id="92ae7-200">[Common Techniques to Improve Shadow Depth Maps](/windows/desktop/DxTechArts/common-techniques-to-improve-shadow-depth-maps) addresses the artifacts that appear when the light moves in the section "Moving the light in texel sized increments."</span></span>

<span data-ttu-id="92ae7-201">**Abbildung 6. An Szene anpassen und an Cascade anpassen**</span><span class="sxs-lookup"><span data-stu-id="92ae7-201">**Figure 6. Fit to scene vs. fit to cascade**</span></span>

![an Szene anpassen und an Cascade anpassen](images/fit-to-scene-vs-fit-to-cascade.png)

## <a name="render-the-shadow-map"></a><span data-ttu-id="92ae7-203">Schattenmap</span><span class="sxs-lookup"><span data-stu-id="92ae7-203">Render the Shadow Map</span></span>

<span data-ttu-id="92ae7-204">Das CascadedShadowMaps11-Beispiel rendert die Schatten Zuordnungen in einem großen Puffer.</span><span class="sxs-lookup"><span data-stu-id="92ae7-204">The CascadedShadowMaps11 sample renders the shadow maps into one large buffer.</span></span> <span data-ttu-id="92ae7-205">Dies liegt daran, dass PCF für Textur Arrays eine Direct3D 10,1-Funktion ist.</span><span class="sxs-lookup"><span data-stu-id="92ae7-205">This is because PCF on texture arrays is a Direct3D 10.1 feature.</span></span> <span data-ttu-id="92ae7-206">Für jede Cascade wird ein Viewport erstellt, der den Abschnitt des tiefen Puffers abdeckt, der dieser Cascade-Komponente entspricht.</span><span class="sxs-lookup"><span data-stu-id="92ae7-206">For every cascade, a viewport is created that covers the section of the depth buffer corresponding to that cascade.</span></span> <span data-ttu-id="92ae7-207">Ein NULL-Pixelshader ist gebunden, da nur die Tiefe benötigt wird.</span><span class="sxs-lookup"><span data-stu-id="92ae7-207">A null pixel shader is bound because only the depth is needed.</span></span> <span data-ttu-id="92ae7-208">Zum Schluss werden die richtigen Viewports und Schatten Matrizen für jede Cascade festgelegt, da die tiefen Zuordnungen nacheinander in den Haupt Schatten Puffer gerendert werden.</span><span class="sxs-lookup"><span data-stu-id="92ae7-208">Finally, the correct viewport and shadow matrix are set for each cascade as the depth maps are rendered one at a time into the main shadow buffer.</span></span>

## <a name="render-the-scene"></a><span data-ttu-id="92ae7-209">Szene Rendering</span><span class="sxs-lookup"><span data-stu-id="92ae7-209">Render the Scene</span></span>

<span data-ttu-id="92ae7-210">Der Puffer, der die Schatten enthält, ist nun an den Pixelshader gebunden.</span><span class="sxs-lookup"><span data-stu-id="92ae7-210">The buffer containing the shadows is now bound to the pixel shader.</span></span> <span data-ttu-id="92ae7-211">Es gibt zwei Methoden, um die im CascadedShadowMaps11-Beispiel implementierte Cascade auszuwählen.</span><span class="sxs-lookup"><span data-stu-id="92ae7-211">There are two methods for selecting the cascade implemented in the CascadedShadowMaps11 sample.</span></span> <span data-ttu-id="92ae7-212">Diese beiden Methoden werden mit Shader-Code erläutert.</span><span class="sxs-lookup"><span data-stu-id="92ae7-212">These two methods are explained with shader code.</span></span>

### <a name="interval-based-cascade-selection"></a><span data-ttu-id="92ae7-213">Interval-Based Cascade-Auswahl</span><span class="sxs-lookup"><span data-stu-id="92ae7-213">Interval-Based Cascade Selection</span></span>

<span data-ttu-id="92ae7-214">**Abbildung 7: Intervall basierte Cascade-Auswahl**</span><span class="sxs-lookup"><span data-stu-id="92ae7-214">**Figure 7. Interval-based cascade selection**</span></span>

![Intervall basierte Cascade-Auswahl](images/interval-based-cascade-selection.jpg)

<span data-ttu-id="92ae7-216">In der Intervall basierten Auswahl (Abbildung 7) berechnet der Vertexshader die Position im Raum des Scheitel Punkts.</span><span class="sxs-lookup"><span data-stu-id="92ae7-216">In interval-based selection (Figure 7), the vertex shader computes the position in world-space of the vertex.</span></span>


```C++
Output.vDepth = mul( Input.vPosition, m_mWorldView ).z;
```



<span data-ttu-id="92ae7-217">Der Pixelshader empfängt die interinterpolierte Tiefe.</span><span class="sxs-lookup"><span data-stu-id="92ae7-217">The pixel shader receives the interpolated depth.</span></span>


```C++
fCurrentPixelDepth = Input.vDepth;
```



<span data-ttu-id="92ae7-218">Bei der Intervall basierten kaskadierenden Auswahl werden ein Vektor Vergleich und ein Punktprodukt verwendet, um die richtige cacade zu bestimmen.</span><span class="sxs-lookup"><span data-stu-id="92ae7-218">Interval-based cascade selection uses a vector comparison and a dot product to determine the correct cacade.</span></span> <span data-ttu-id="92ae7-219">Das \_ Flag Cascade Count \_ gibt die Anzahl der Cascades an.</span><span class="sxs-lookup"><span data-stu-id="92ae7-219">The CASCADE\_COUNT\_FLAG specifies the number of cascades.</span></span> <span data-ttu-id="92ae7-220">Mit den m-Werten für die Datei "f" wird \_ \_ die Ansicht "Frustum-Partitionen" eingeschränkt.</span><span class="sxs-lookup"><span data-stu-id="92ae7-220">The m\_fCascadeFrustumsEyeSpaceDepths\_data constrains the view frustum partitions.</span></span> <span data-ttu-id="92ae7-221">Nach dem Vergleich enthält der-Vergleichswert den Wert 1, wobei das aktuelle Pixel größer als die Barriere und der Wert 0 ist, wenn die aktuelle Cascade kleiner ist.</span><span class="sxs-lookup"><span data-stu-id="92ae7-221">After the comparison, the fComparison contains a value of 1 where the current pixel is larger than the barrier, and a value of 0 when the current cascade is smaller.</span></span> <span data-ttu-id="92ae7-222">Ein Punktprodukt fasst diese Werte in einem Array Index zusammen.</span><span class="sxs-lookup"><span data-stu-id="92ae7-222">A dot product sums these values into an array index.</span></span>


```C++
        float4 vCurrentPixelDepth = Input.vDepth;
        float4 fComparison = ( vCurrentPixelDepth > m_fCascadeFrustumsEyeSpaceDepths_data[0]);
        float fIndex = dot(
        float4( CASCADE_COUNT_FLAG > 0,
        CASCADE_COUNT_FLAG > 1,
        CASCADE_COUNT_FLAG > 2,
        CASCADE_COUNT_FLAG > 3)
        , fComparison );

        fIndex = min( fIndex, CASCADE_COUNT_FLAG );
        iCurrentCascadeIndex = (int)fIndex;
```



<span data-ttu-id="92ae7-223">Nachdem die CASCADE-Option ausgewählt wurde, muss die Textur Koordinate in die korrekte kaskadierte Transformation transformiert werden.</span><span class="sxs-lookup"><span data-stu-id="92ae7-223">Once the cascade is selected, the texture coordinate must be transformed to the correct cascade.</span></span>


```C++
vShadowTexCoord = mul( InterpolatedPosition, m_mShadow[iCascadeIndex] );
```



<span data-ttu-id="92ae7-224">Diese Textur Koordinate wird dann verwendet, um eine Stichprobe der Textur mit der X-Koordinate und der Y-Koordinate zu verwenden.</span><span class="sxs-lookup"><span data-stu-id="92ae7-224">This texture coordinate is then used to sample the texture with the X-coordinate and the Y-coordinate.</span></span> <span data-ttu-id="92ae7-225">Die Z-Koordinate wird für den abschließenden tiefen Vergleich verwendet.</span><span class="sxs-lookup"><span data-stu-id="92ae7-225">The Z-coordinate is used to do the final depth comparison.</span></span>

### <a name="map-based-cascade-selection"></a><span data-ttu-id="92ae7-226">Map-Based Cascade-Auswahl</span><span class="sxs-lookup"><span data-stu-id="92ae7-226">Map-Based Cascade Selection</span></span>

<span data-ttu-id="92ae7-227">Kartenbasierte Auswahl (Abbildung 8) testet die vier Seiten des kaskaders, um die enge Zuordnung zu finden, die das jeweilige Pixel abdeckt.</span><span class="sxs-lookup"><span data-stu-id="92ae7-227">Map-based selection (Figure 8) tests against the four sides of the cascades to find the tightest map that covers the specific pixel.</span></span> <span data-ttu-id="92ae7-228">Anstatt die Position im Raum der Welt zu berechnen, berechnet der Vertexshader die Position des Ansichts Raums für jede Cascade.</span><span class="sxs-lookup"><span data-stu-id="92ae7-228">Instead of calculating the position in world space, the vertex shader calculates the view-space position for every cascade.</span></span> <span data-ttu-id="92ae7-229">Der Pixelshader durchläuft die kaskadierende, um die Texturkoordinaten zu skalieren und zu verschieben, damit Sie die aktuelle Cascade-Elemente indizieren.</span><span class="sxs-lookup"><span data-stu-id="92ae7-229">The pixel shader iterates over the cascades in order to scale and shift the texture coordinates so that they index the current cascade.</span></span> <span data-ttu-id="92ae7-230">Die Textur Koordinate wird dann anhand der Textur Begrenzungen getestet.</span><span class="sxs-lookup"><span data-stu-id="92ae7-230">The texture coordinate is then tested against the texture bounds.</span></span> <span data-ttu-id="92ae7-231">Wenn die X-und Y-Werte der Textur Koordinate in eine Cascade-Struktur fallen, werden Sie verwendet, um eine Stichprobe der Textur zu verwenden.</span><span class="sxs-lookup"><span data-stu-id="92ae7-231">When the X and Y values of the texture coordinate fall inside a cascade, they are used to sample the texture.</span></span> <span data-ttu-id="92ae7-232">Die Z-Koordinate wird für den abschließenden tiefen Vergleich verwendet.</span><span class="sxs-lookup"><span data-stu-id="92ae7-232">The Z-coordinate is used to do the final depth comparison.</span></span>

<span data-ttu-id="92ae7-233">**Abbildung 8. Kartenbasierte Cascade-Auswahl**</span><span class="sxs-lookup"><span data-stu-id="92ae7-233">**Figure 8. Map-based cascade selection**</span></span>

![kartenbasierte Cascade-Auswahl](images/map-based-cascade-selection.jpg)

### <a name="interval-based-selection-vs-map-based-selection"></a><span data-ttu-id="92ae7-235">Interval-Based Auswahl und Map-Based Auswahl</span><span class="sxs-lookup"><span data-stu-id="92ae7-235">Interval-Based Selection vs. Map-Based Selection</span></span>

<span data-ttu-id="92ae7-236">Die Intervall basierte Auswahl ist etwas schneller als die kartenbasierte Auswahl, da die kaskadierte Auswahl direkt erfolgen kann.</span><span class="sxs-lookup"><span data-stu-id="92ae7-236">Interval-based selection is slightly faster than map-based selection because the cascade selection can be done directly.</span></span> <span data-ttu-id="92ae7-237">Die kartenbasierte Auswahl muss die Textur Koordinate mit den kaskadierenden Begrenzungen überschneiden.</span><span class="sxs-lookup"><span data-stu-id="92ae7-237">Map-based selection must intersect the texture coordinate with the cascade bounds.</span></span>

<span data-ttu-id="92ae7-238">Bei der kartenbasierten Auswahl wird die Cascade-Funktion effizienter verwendet, wenn Schatten Zuordnungen nicht perfekt ausgerichtet werden (siehe Abbildung 8).</span><span class="sxs-lookup"><span data-stu-id="92ae7-238">Map-based selection uses the cascade more efficiently when shadow maps do not align perfectly (see Figure 8).</span></span>

## <a name="blend-between-cascades"></a><span data-ttu-id="92ae7-239">Blend zwischen Cascades</span><span class="sxs-lookup"><span data-stu-id="92ae7-239">Blend between Cascades</span></span>

<span data-ttu-id="92ae7-240">VSMs (später in diesem Artikel erläutert) und Filtertechniken wie PCF können mit Low-Resolution-CSMS verwendet werden, um weiche Schatten zu schaffen.</span><span class="sxs-lookup"><span data-stu-id="92ae7-240">VSMs (discussed later in this article) and filtering techniques such as PCF can be used with low-resolution CSMs to produce soft shadows.</span></span> <span data-ttu-id="92ae7-241">Leider führt dies zu einer sichtbaren Naht (Abbildung 9) zwischen kaskadierenden Ebenen, da die Auflösung nicht entspricht.</span><span class="sxs-lookup"><span data-stu-id="92ae7-241">Unfortunately, this results in a visible seam (Figure 9) between cascade layers because the resolution does not match.</span></span> <span data-ttu-id="92ae7-242">Die Lösung besteht darin, ein Band zwischen schattenkarten zu erstellen, bei denen der Schatten Test für beide Cascades ausgeführt wird.</span><span class="sxs-lookup"><span data-stu-id="92ae7-242">The solution is to create a band between shadow maps where the shadow test is performed for both cascades.</span></span> <span data-ttu-id="92ae7-243">Der Shader interpoliert dann linear zwischen den beiden Werten, basierend auf der Position des Pixels im Blend-Band.</span><span class="sxs-lookup"><span data-stu-id="92ae7-243">The shader then linearly interpolates between the two values based on the pixel's location in the blend band.</span></span> <span data-ttu-id="92ae7-244">Die Beispiele CascadedShadowMaps11 und VarianceShadows11 bieten einen GUI-Schieberegler, der zum Vergrößern und verkleinern dieses weichzeichenbandes verwendet werden kann.</span><span class="sxs-lookup"><span data-stu-id="92ae7-244">The samples CascadedShadowMaps11 and VarianceShadows11 provide a GUI slider that can be used to increase and decrease this blur band.</span></span> <span data-ttu-id="92ae7-245">Der Shader führt einen dynamischen Branch aus, sodass die überwiegende Mehrheit der Pixel nur aus der aktuellen Cascade-Datei gelesen wird.</span><span class="sxs-lookup"><span data-stu-id="92ae7-245">The shader performs a dynamic branch so that the vast majority of pixels only read from the current cascade.</span></span>

<span data-ttu-id="92ae7-246">**Abbildung 9. Kaskadierende Nähte**</span><span class="sxs-lookup"><span data-stu-id="92ae7-246">**Figure 9. Cascade seams**</span></span>

![kaskadierende Nähte](images/cascade-seams.jpg)

<span data-ttu-id="92ae7-248">Linken Eine sichtbare Naht kann angezeigt werden, wenn sich die kaskame überlappen.</span><span class="sxs-lookup"><span data-stu-id="92ae7-248">(Left) A visible seam can be seen where cascades overlap.</span></span> <span data-ttu-id="92ae7-249">Rechten Wenn die kaskadierende zwischen gemischt werden, erfolgt keine Naht.</span><span class="sxs-lookup"><span data-stu-id="92ae7-249">(Right) When the cascades are blended between, no seam occurs.</span></span>

## <a name="filtering-shadow-maps"></a><span data-ttu-id="92ae7-250">Filtern von Schatten Zuordnungen</span><span class="sxs-lookup"><span data-stu-id="92ae7-250">Filtering Shadow Maps</span></span>

### <a name="pcf"></a><span data-ttu-id="92ae7-251">PCF</span><span class="sxs-lookup"><span data-stu-id="92ae7-251">PCF</span></span>

<span data-ttu-id="92ae7-252">Das Filtern normaler Schatten Zuordnungen erzeugt keine weichen, unscharfen Schatten.</span><span class="sxs-lookup"><span data-stu-id="92ae7-252">Filtering ordinary shadow maps does not produce soft, blurred shadows.</span></span> <span data-ttu-id="92ae7-253">Die Filter Hardware blzte die tiefen Werte aus und vergleicht dann diese verschwommene Werte mit dem Leerraum Texel.</span><span class="sxs-lookup"><span data-stu-id="92ae7-253">The filtering hardware blurs the depth values, and then compares those blurred values to the light space texel.</span></span> <span data-ttu-id="92ae7-254">Der aus dem bestanden/Fail-Test resultierende hardedge ist weiterhin vorhanden.</span><span class="sxs-lookup"><span data-stu-id="92ae7-254">The hard edge resulting from the pass/fail test still exists.</span></span> <span data-ttu-id="92ae7-255">Das verwischen von Schatten Zuordnungen dient nur zum irrtümlich bewegen des fest Kanten.</span><span class="sxs-lookup"><span data-stu-id="92ae7-255">Blurring shadow maps only serves to erroneously move the hard edge.</span></span> <span data-ttu-id="92ae7-256">PCF ermöglicht das Filtern von Schatten Zuordnungen.</span><span class="sxs-lookup"><span data-stu-id="92ae7-256">PCF enables filtering on shadow maps.</span></span> <span data-ttu-id="92ae7-257">Die allgemeine Idee von PCF besteht darin, einen Prozentsatz des Pixels im Schatten zu berechnen, der auf der Anzahl von unter Beispielen basiert, die den tiefen Test über die Gesamtzahl von unter Beispielen bestehen.</span><span class="sxs-lookup"><span data-stu-id="92ae7-257">The general idea of PCF is to calculate a percentage of the pixel in shadow based on the number of subsamples that pass the depth test over the total number of subsamples.</span></span>

<span data-ttu-id="92ae7-258">Mit der Hardware Direct3D 10 und Direct3D 11 kann PCF durchgeführt werden.</span><span class="sxs-lookup"><span data-stu-id="92ae7-258">Direct3D 10 and Direct3D 11 hardware can perform PCF.</span></span> <span data-ttu-id="92ae7-259">Die Eingabe für einen PCF-Sampler besteht aus der Textur Koordinate und einem Wert für die Vergleichs Tiefe.</span><span class="sxs-lookup"><span data-stu-id="92ae7-259">The input to a PCF sampler consists of the texture-coordinate and a comparison depth value.</span></span> <span data-ttu-id="92ae7-260">Der Einfachheit halber wird PCF mit einem vier-tippen-Filter erläutert.</span><span class="sxs-lookup"><span data-stu-id="92ae7-260">For simplicity, PCF is explained with a four-tap filter.</span></span> <span data-ttu-id="92ae7-261">Der Textur Sampler liest die Textur vier Mal, ähnlich wie ein Standardfilter.</span><span class="sxs-lookup"><span data-stu-id="92ae7-261">The texture sampler reads the texture four times, similar to a standard filter.</span></span> <span data-ttu-id="92ae7-262">Das zurückgegebene Ergebnis ist jedoch ein Prozentsatz der Pixel, die den tiefen Test überschritten haben.</span><span class="sxs-lookup"><span data-stu-id="92ae7-262">However, the returned result is a percentage of the pixels that passed the depth test.</span></span> <span data-ttu-id="92ae7-263">Abbildung 10 zeigt, wie ein Pixel, das einen der vier tiefen Tests übergibt, im Schatten 25 Prozent ist.</span><span class="sxs-lookup"><span data-stu-id="92ae7-263">Figure 10 shows how a pixel that passes one of the four depth tests is 25 percent in shadow.</span></span> <span data-ttu-id="92ae7-264">Der tatsächliche zurückgegebene Wert ist eine lineare interpolung, die auf den subtexkoordinaten der Textur Lesevorgänge basiert, um einen glatten Farbverlauf zu schaffen.</span><span class="sxs-lookup"><span data-stu-id="92ae7-264">The actual value returned is a linear interpolation based on the subtexel coordinates of the texture reads to produce a smooth gradient.</span></span> <span data-ttu-id="92ae7-265">Ohne diese lineare interpolung kann der vier-tippen-PCF nur fünf Werte zurückgeben: {0,0, 0,25, 0,5, 0,75, 1,0}.</span><span class="sxs-lookup"><span data-stu-id="92ae7-265">Without this linear interpolation, the four-tap PCF would only be able to return five values: { 0.0, 0.25, 0.5, 0.75, 1.0 }.</span></span>

<span data-ttu-id="92ae7-266">**Abbildung 10. PCF-gefiltertes Bild mit 25 Prozent des ausgewählten Pixels**</span><span class="sxs-lookup"><span data-stu-id="92ae7-266">**Figure 10. PCF filtered image, with 25 percent of the selected pixel covered**</span></span>

![PCF-gefiltertes Bild mit 25 Prozent des ausgewählten Pixels](images/pcf-filtered-image.png)

<span data-ttu-id="92ae7-268">Es ist auch möglich, PCF ohne Hardwareunterstützung durchzuführen oder PCF auf größere Kernel auszuweiten.</span><span class="sxs-lookup"><span data-stu-id="92ae7-268">It is also possible to do PCF without hardware support or extend PCF to larger kernels.</span></span> <span data-ttu-id="92ae7-269">Einige Techniken sind sogar mit einem gewichteten Kernel Stichprobe.</span><span class="sxs-lookup"><span data-stu-id="92ae7-269">Some techniques even sample with a weighted kernel.</span></span> <span data-ttu-id="92ae7-270">Erstellen Sie zu diesem Zweck einen Kernel (z. b. eine gausische) für ein N × n-Raster.</span><span class="sxs-lookup"><span data-stu-id="92ae7-270">To do this, create a kernel (such as a Gaussian) for an N × N grid.</span></span> <span data-ttu-id="92ae7-271">Die Gewichtungen müssen bis zu 1 addieren.</span><span class="sxs-lookup"><span data-stu-id="92ae7-271">The weights must add up to 1.</span></span> <span data-ttu-id="92ae7-272">Die Textur wird dann mit den N2-Zeiten abgefragt.</span><span class="sxs-lookup"><span data-stu-id="92ae7-272">The texture is then sampled N2 times.</span></span> <span data-ttu-id="92ae7-273">Jede Stichprobe wird durch die entsprechenden Gewichtungen im Kernel skaliert.</span><span class="sxs-lookup"><span data-stu-id="92ae7-273">Each sample is scaled by the corresponding weights in the kernel.</span></span> <span data-ttu-id="92ae7-274">Im CascadedShadowMaps11-Beispiel wird dieser Ansatz verwendet.</span><span class="sxs-lookup"><span data-stu-id="92ae7-274">The CascadedShadowMaps11 sample uses this approach.</span></span>

### <a name="depth-bias"></a><span data-ttu-id="92ae7-275">Tiefenausrichtung</span><span class="sxs-lookup"><span data-stu-id="92ae7-275">Depth Bias</span></span>

<span data-ttu-id="92ae7-276">Die Tiefe Abweichung wird noch wichtiger, wenn große PCF-Kernel verwendet werden.</span><span class="sxs-lookup"><span data-stu-id="92ae7-276">Depth bias becomes even more important when large PCF kernels are used.</span></span> <span data-ttu-id="92ae7-277">Es ist nur gültig, die Leerraum Tiefe eines Pixels mit dem Pixel zu vergleichen, dem es in der tiefen Zuordnung zugeordnet ist.</span><span class="sxs-lookup"><span data-stu-id="92ae7-277">It is only valid to compare a pixel's light-space depth against the pixel it maps to in the depth map.</span></span> <span data-ttu-id="92ae7-278">Die Nachbarn des tiefen Karten texgs verweisen auf eine andere Position.</span><span class="sxs-lookup"><span data-stu-id="92ae7-278">The depth map texel's neighbors refer to a different position.</span></span> <span data-ttu-id="92ae7-279">Diese Tiefe ist wahrscheinlich ähnlich, kann aber abhängig von der Szene sehr unterschiedlich sein.</span><span class="sxs-lookup"><span data-stu-id="92ae7-279">This depth is likely to be similar, but can be very different depending on the scene.</span></span> <span data-ttu-id="92ae7-280">In Abbildung 11 werden die auftretenden Artefakte hervorgehoben.</span><span class="sxs-lookup"><span data-stu-id="92ae7-280">Figure 11 highlights the artifacts that occur.</span></span> <span data-ttu-id="92ae7-281">Eine einzelne Tiefe wird mit drei benachbarten texeln in der Schatten Zuordnung verglichen.</span><span class="sxs-lookup"><span data-stu-id="92ae7-281">A single depth is compared to three neighboring texels in the shadow map.</span></span> <span data-ttu-id="92ae7-282">Einer der tiefen Tests schlägt fälschlicherweise fehl, da seine tiefe nicht mit der berechneten Leerraum Tiefe der aktuellen Geometrie korreliert.</span><span class="sxs-lookup"><span data-stu-id="92ae7-282">One of the depth tests erroneously fails because its depth does not correlate to the computed light-space depth of the current geometry.</span></span> <span data-ttu-id="92ae7-283">Die empfohlene Lösung für dieses Problem ist die Verwendung eines größeren Offsets.</span><span class="sxs-lookup"><span data-stu-id="92ae7-283">The recommended solution to this problem is to use a larger offset.</span></span> <span data-ttu-id="92ae7-284">Eine zu große Abweichung kann jedoch dazu führen, dass Peter schwenken.</span><span class="sxs-lookup"><span data-stu-id="92ae7-284">Too large of an offset, however, can result in Peter Panning.</span></span> <span data-ttu-id="92ae7-285">Durch das Berechnen einer engen Near-und weitem-Ebene werden die Auswirkungen der Verwendung eines Offsets reduziert.</span><span class="sxs-lookup"><span data-stu-id="92ae7-285">Calculating a tight near plane and far plane helps reduce the effects of using an offset.</span></span>

<span data-ttu-id="92ae7-286">**Abbildung 11. Fehlerhafter selbst shadodown**</span><span class="sxs-lookup"><span data-stu-id="92ae7-286">**Figure 11. Erroneous self-shadowing**</span></span>

![fehlerhafter selbst shadodown](images/erroneous-self-shadowing.png)

<span data-ttu-id="92ae7-288">Der fehlerhafte selbst Shadowing ergibt sich aus dem Vergleichen von Pixeln in der Licht leertiefe mit den texeln in der Schatten Zuordnung, die nicht korrelieren.</span><span class="sxs-lookup"><span data-stu-id="92ae7-288">The erroneous self-shadowing results from comparing pixels in the light-space depth to the texels in the shadow map that do not correlate.</span></span> <span data-ttu-id="92ae7-289">Die Tiefe im Leerraum korreliert mit Shadow Texel 2 in der tiefenkarte.</span><span class="sxs-lookup"><span data-stu-id="92ae7-289">The depth in light-space correlates to shadow texel 2 in the depth map.</span></span> <span data-ttu-id="92ae7-290">Texel 1 ist größer als die Tiefe des Leerraums, während 2 gleich und 3 kleiner ist.</span><span class="sxs-lookup"><span data-stu-id="92ae7-290">Texel 1 is greater than the light-space depth while 2 is equal and 3 is less.</span></span> <span data-ttu-id="92ae7-291">Texels 2 und 3 übergeben den tiefen Test, während bei Texel 1 ein Fehler auftritt.</span><span class="sxs-lookup"><span data-stu-id="92ae7-291">Texels 2 and 3 pass the depth test, while Texel 1 fails.</span></span>

### <a name="calculating-a-per-texel-depth-bias-with-ddx-and-ddy-for-large-pcfs"></a><span data-ttu-id="92ae7-292">Berechnen eines Per-Texel tiefen Bias mit DDX und DDY für große PCFS</span><span class="sxs-lookup"><span data-stu-id="92ae7-292">Calculating a Per-Texel Depth Bias with DDX and DDY for Large PCFs</span></span>

<span data-ttu-id="92ae7-293">Das Berechnen eines pro texesequenz mit **DDX** und **ddY** für große PCFS ist eine Technik, die die richtige tiefen Abweichung berechnet – vorausgesetzt, die Oberfläche ist planar – für die angrenzende schattenkarte Texel.</span><span class="sxs-lookup"><span data-stu-id="92ae7-293">Calculating a per texel depth bias with **ddx** and **ddy** for large PCFs is a technique that calculates the correct depth bias—assuming the surface is planar—for the adjacent shadow map texel.</span></span>

<span data-ttu-id="92ae7-294">Diese Technik passt die Vergleichs Tiefe mithilfe der abgeleiteten Informationen auf eine Ebene an.</span><span class="sxs-lookup"><span data-stu-id="92ae7-294">This technique fits the comparison depth to a plane using the derivative information.</span></span> <span data-ttu-id="92ae7-295">Da dieses Verfahren Rechen technisch komplex ist, sollte es nur dann verwendet werden, wenn eine GPU computezyklen zu ersparen hat.</span><span class="sxs-lookup"><span data-stu-id="92ae7-295">Because this technique is computationally complex, it should be used only when a GPU has compute cycles to spare.</span></span> <span data-ttu-id="92ae7-296">Wenn sehr große Kernel verwendet werden, ist dies möglicherweise die einzige Technik, mit der selbst shadonende Artefakte entfernt werden können, ohne dass Peter schwenken.</span><span class="sxs-lookup"><span data-stu-id="92ae7-296">When very large kernels are used, this may be the only technique that works to remove self-shadowing artifacts without causing Peter Panning.</span></span>

<span data-ttu-id="92ae7-297">In Abbildung 12 wird das Problem hervorgehoben.</span><span class="sxs-lookup"><span data-stu-id="92ae7-297">Figure 12 highlights the problem.</span></span> <span data-ttu-id="92ae7-298">Die Tiefe im Leerraum ist für das eine texespace bekannt, das verglichen wird.</span><span class="sxs-lookup"><span data-stu-id="92ae7-298">The depth in light-space is known for the one texel that is being compared.</span></span> <span data-ttu-id="92ae7-299">Die Leerräume, die den benachbarten texeln in der tiefenkarte entsprechen, sind unbekannt.</span><span class="sxs-lookup"><span data-stu-id="92ae7-299">The light-space depths that correspond to the neighboring texels in the depth map are unknown.</span></span>

<span data-ttu-id="92ae7-300">**Abbildung 12. Szene-und tiefen Zuordnung**</span><span class="sxs-lookup"><span data-stu-id="92ae7-300">**Figure 12. Scene and depth map**</span></span>

![Szene-und tiefen Zuordnung](images/scene-and-depth-map.png)

<span data-ttu-id="92ae7-302">Die gerenderte Szene wird auf der linken Seite angezeigt, und die tiefen Zuordnung mit einem Beispiel-Texblock wird auf der rechten Seite angezeigt.</span><span class="sxs-lookup"><span data-stu-id="92ae7-302">The rendered scene is shown at left, and the depth map with a sample texel block is shown at right.</span></span> <span data-ttu-id="92ae7-303">Der Eye Space Texel wird dem Pixel mit der Bezeichnung D in der Mitte des-Blocks zugeordnet.</span><span class="sxs-lookup"><span data-stu-id="92ae7-303">The eye-space texel maps to the pixel labeled D in the center of the block.</span></span> <span data-ttu-id="92ae7-304">Dieser Vergleich ist genau.</span><span class="sxs-lookup"><span data-stu-id="92ae7-304">This comparison is accurate.</span></span> <span data-ttu-id="92ae7-305">Die richtige Tiefe im Auge Bereich korreliert die Pixel, die der benachbarte D unbekannt ist.</span><span class="sxs-lookup"><span data-stu-id="92ae7-305">The correct depth in eye space correlating to the pixels that neighbor D is unknown.</span></span> <span data-ttu-id="92ae7-306">Das zurück ordnen der benachbarten texeln in den Augenbereich ist nur möglich, wenn angenommen wird, dass sich das Pixel auf dasselbe Dreieck wie D bezieht.</span><span class="sxs-lookup"><span data-stu-id="92ae7-306">Mapping the neighboring texels back to eye space is possible only if we assume the pixel pertains to the same triangle as D.</span></span>

<span data-ttu-id="92ae7-307">Die Tiefe ist für den texespace bekannt, der mit der Leerraum Position korreliert.</span><span class="sxs-lookup"><span data-stu-id="92ae7-307">The depth is known for the texel that correlates with the light-space position.</span></span> <span data-ttu-id="92ae7-308">Die Tiefe ist für die benachbarten texeln in der tiefen Zuordnung unbekannt.</span><span class="sxs-lookup"><span data-stu-id="92ae7-308">The depth is unknown for the neighboring texels in the depth map.</span></span>

<span data-ttu-id="92ae7-309">Auf hoher Ebene werden bei dieser Technik die **DDX** -und die **ddY** HLSL-Vorgänge verwendet, um die Ableitung der Leerraum Position zu ermitteln.</span><span class="sxs-lookup"><span data-stu-id="92ae7-309">At a high level, this technique uses the **ddx** and **ddy** HLSL operations to find the derivative of the light-space position.</span></span> <span data-ttu-id="92ae7-310">Dies ist nicht trivial, da die abgeleiteten Vorgänge den Farbverlauf der hellen Raum Tiefe in Bezug auf den Bildschirmbereich zurückgeben.</span><span class="sxs-lookup"><span data-stu-id="92ae7-310">This is nontrivial because the derivative operations return the gradient of the light-space depth with respect to screen space.</span></span> <span data-ttu-id="92ae7-311">Um dies in Bezug auf den Leerraum in einen Farbverlauf der Tiefe des Leerraums zu konvertieren, muss eine Konvertierungs Matrix berechnet werden.</span><span class="sxs-lookup"><span data-stu-id="92ae7-311">To convert this to a gradient of the light-space depth with respect to light space, a conversion matrix must be calculated.</span></span>

### <a name="explanation-with-shader-code"></a><span data-ttu-id="92ae7-312">Erläuterung mit shadercode</span><span class="sxs-lookup"><span data-stu-id="92ae7-312">Explanation with Shader Code</span></span>

<span data-ttu-id="92ae7-313">Die Details des restlichen Algorithmus werden als Erläuterung des Shader-Codes angegeben, der diesen Vorgang ausführt.</span><span class="sxs-lookup"><span data-stu-id="92ae7-313">The details of the rest of the algorithm are given as an explanation of the shader code that performs this operation.</span></span> <span data-ttu-id="92ae7-314">Diesen Code finden Sie im CascadedShadowMaps11-Beispiel.</span><span class="sxs-lookup"><span data-stu-id="92ae7-314">This code can be found in the CascadedShadowMaps11 sample.</span></span> <span data-ttu-id="92ae7-315">In Abbildung 13 wird gezeigt, wie die hell Raum Texturkoordinaten der tiefen Zuordnung zugeordnet werden und wie die Ableitungen in X und Y zum Erstellen einer Transformationsmatrix verwendet werden können.</span><span class="sxs-lookup"><span data-stu-id="92ae7-315">Figure 13 shows how the light-space texture coordinates map to the depth map and how the derivatives in X and Y can be used to create a transformation matrix.</span></span>

<span data-ttu-id="92ae7-316">**Abbildung 13. Bildschirm-zu-Leerraum-Matrix**</span><span class="sxs-lookup"><span data-stu-id="92ae7-316">**Figure 13. Screen-space to light-space matrix**</span></span>

![Bildschirm-zu-Leerraum-Matrix](images/screen-space-to-light-space-matrix.png)

<span data-ttu-id="92ae7-318">Die Ableitungen der Leerraum Position in X und Y werden zum Erstellen dieser Matrix verwendet.</span><span class="sxs-lookup"><span data-stu-id="92ae7-318">The derivatives of the light-space position in X and Y are used to create this matrix.</span></span>

<span data-ttu-id="92ae7-319">Der erste Schritt besteht darin, die Ableitung der Position des hellen Ansichts Raums zu berechnen.</span><span class="sxs-lookup"><span data-stu-id="92ae7-319">The first step is to calculate the derivative of the light-view-space position.</span></span>


```C++
          float3 vShadowTexDDX = ddx (vShadowMapTextureCoordViewSpace);
          float3 vShadowTexDDY = ddy (vShadowMapTextureCoordViewSpace);
```



<span data-ttu-id="92ae7-320">Direct3D 11 Class-GPUs berechnen diese Ableitungen durch gleichzeitige Ausführung von 2 × 2 Quad von Pixeln und Subtrahieren der Texturkoordinaten vom benachbarten in X für **DDX** und vom benachbarten in Y für **ddY**.</span><span class="sxs-lookup"><span data-stu-id="92ae7-320">Direct3D 11 class GPUs calculate these derivatives by running 2 × 2 quad of pixels in parallel and subtracting the texture coordinates from the neighbor in X for **ddx** and from the neighbor in Y for **ddy**.</span></span> <span data-ttu-id="92ae7-321">Diese beiden Ableitungen bilden die Zeilen einer 2 × 2-Matrix.</span><span class="sxs-lookup"><span data-stu-id="92ae7-321">These two derivatives make up the rows of a 2 × 2 matrix.</span></span> <span data-ttu-id="92ae7-322">In der aktuellen Form könnte diese Matrix verwendet werden, um benachbarte Bildschirme auf Leerraum zu konvertieren.</span><span class="sxs-lookup"><span data-stu-id="92ae7-322">In its current form, this matrix could be used to convert screen-space neighboring pixels to light-space slopes.</span></span> <span data-ttu-id="92ae7-323">Allerdings ist die Umkehrung dieser Matrix erforderlich.</span><span class="sxs-lookup"><span data-stu-id="92ae7-323">However, the inverse of this matrix is needed.</span></span> <span data-ttu-id="92ae7-324">Eine Matrix, die benachbarte Leerraum-Pixel in Bildschirm Leerräume transformiert, wird benötigt.</span><span class="sxs-lookup"><span data-stu-id="92ae7-324">A matrix that transforms light-space neighboring pixels to screen-space slopes is needed.</span></span>


```C++
          float2x2 matScreentoShadow = float2x2( vShadowTexDDX.xy, vShadowTexDDY.xy );
          float fInvDeterminant = 1.0f / fDeterminant;

          float2x2 matShadowToScreen = float2x2 (
          matScreentoShadow._22 * fInvDeterminant,
          matScreentoShadow._12 * -fInvDeterminant,
          matScreentoShadow._21 * -fInvDeterminant,
          matScreentoShadow._11 * fInvDeterminant );
```



<span data-ttu-id="92ae7-325">**Abbildung 14. Leerraum bis Bildschirmbereich**</span><span class="sxs-lookup"><span data-stu-id="92ae7-325">**Figure 14. Light-space to screen-space**</span></span>

![Leerraum bis Bildschirmbereich](images/light-space-to-screen-space.png)

<span data-ttu-id="92ae7-327">Diese Matrix wird dann verwendet, um die beiden texeln oberhalb und auf der rechten Seite des aktuellen texeln zu transformieren.</span><span class="sxs-lookup"><span data-stu-id="92ae7-327">This matrix is then used to transform the two texels above and to the right of the current texel.</span></span> <span data-ttu-id="92ae7-328">Diese Nachbarn werden als Offset des aktuellen Texels dargestellt.</span><span class="sxs-lookup"><span data-stu-id="92ae7-328">These neighbors are represented as an offset from the current texel.</span></span>


```C++
          float2 vRightShadowTexelLocation = float2( m_fTexelSize, 0.0f );
          float2 vUpShadowTexelLocation = float2( 0.0f, m_fTexelSize );
          float2 vRightTexelDepthRatio = mul( vRightShadowTexelLocation,
          matShadowToScreen );
          float2 vUpTexelDepthRatio = mul( vUpShadowTexelLocation,
          matShadowToScreen );
```



<span data-ttu-id="92ae7-329">Das von der Matrix erstellte Verhältnis wird schließlich mit den tiefen Ableitungen multipliziert, um die tiefen Offsets für die benachbarten Pixel zu berechnen.</span><span class="sxs-lookup"><span data-stu-id="92ae7-329">The ratio that the matrix creates is finally multiplied by the depth derivatives to calculate the depth offsets for the neighboring pixels.</span></span>


```C++
            float fUpTexelDepthDelta =
            vUpTexelDepthRatio.x * vShadowTexDDX.z
            + vUpTexelDepthRatio.y * vShadowTexDDY.z;
            float fRightTexelDepthDelta =
            vRightTexelDepthRatio.x * vShadowTexDDX.z
            + vRightTexelDepthRatio.y * vShadowTexDDY.z;
```



<span data-ttu-id="92ae7-330">Diese Gewichtungen können jetzt in einer PCF-Schleife verwendet werden, um der Position einen Offset hinzuzufügen.</span><span class="sxs-lookup"><span data-stu-id="92ae7-330">These weights can now be used in a PCF loop to add an offset to the position.</span></span>


```C++
    for( int x = m_iPCFBlurForLoopStart; x < m_iPCFBlurForLoopEnd; ++x ) 
    {
        for( int y = m_iPCFBlurForLoopStart; y < m_iPCFBlurForLoopEnd; ++y )
            {
            if ( USE_DERIVATIVES_FOR_DEPTH_OFFSET_FLAG )
            {
            depthcompare += fRightTexelDepthDelta * ( (float) x ) +
            fUpTexelDepthDelta * ( (float) y );
            }
            // Compare the transformed pixel depth to the depth read
            // from the map.
            fPercentLit += g_txShadow.SampleCmpLevelZero( g_samShadow,
            float2(
            vShadowTexCoord.x + ( ( (float) x ) * m_fNativeTexelSizeInX ) ,
            vShadowTexCoord.y + ( ( (float) y ) * m_fTexelSize )
            ),
            depthcompare
            );
            }
     }
```



## <a name="pcf-and-csms"></a><span data-ttu-id="92ae7-331">PCF und CSMS</span><span class="sxs-lookup"><span data-stu-id="92ae7-331">PCF and CSMs</span></span>

<span data-ttu-id="92ae7-332">PCF funktioniert nicht in Textur Arrays in Direct3D 10.</span><span class="sxs-lookup"><span data-stu-id="92ae7-332">PCF does not work on texture arrays in Direct3D 10.</span></span> <span data-ttu-id="92ae7-333">Zur Verwendung von PCF werden alle kaskadierende in einem großen Textur Atlas gespeichert.</span><span class="sxs-lookup"><span data-stu-id="92ae7-333">To use PCF, all of the cascades are stored in one large texture atlas.</span></span>

### <a name="derivative-based-offset"></a><span data-ttu-id="92ae7-334">Derivative-Based Offset</span><span class="sxs-lookup"><span data-stu-id="92ae7-334">Derivative-Based Offset</span></span>

<span data-ttu-id="92ae7-335">Das Hinzufügen der abgeleiteten Offsets für CSMS stellt einige Herausforderungen dar.</span><span class="sxs-lookup"><span data-stu-id="92ae7-335">Adding the derivative based offsets for CSMs presents some challenges.</span></span> <span data-ttu-id="92ae7-336">Dies ist auf eine abgeleitete Berechnung innerhalb einer abweichenden Fluss Steuerung zurückzuführen.</span><span class="sxs-lookup"><span data-stu-id="92ae7-336">This is due to a derivative calculation within divergent flow control.</span></span> <span data-ttu-id="92ae7-337">Das Problem tritt aufgrund einer grundlegenden Methode auf, die GPUs betreiben.</span><span class="sxs-lookup"><span data-stu-id="92ae7-337">The problem occurs because of a fundamental way that GPUs operate.</span></span> <span data-ttu-id="92ae7-338">Direct3D11-GPUs arbeiten mit 2 × 2 Quads von Pixeln.</span><span class="sxs-lookup"><span data-stu-id="92ae7-338">Direct3D11 GPUs operate on 2 × 2 quads of pixels.</span></span> <span data-ttu-id="92ae7-339">Um eine Ableitung auszuführen, subtrahieren GPUs in der Regel die Kopie einer Variablen des aktuellen Pixels aus der Kopie der gleichen Variablen des benachbarten Pixels.</span><span class="sxs-lookup"><span data-stu-id="92ae7-339">To perform a derivative, GPUs generally subtract the current pixel's copy of a variable from the neighboring pixel's copy of that same variable.</span></span> <span data-ttu-id="92ae7-340">Wie dies geschieht, variiert von GPU zu GPU.</span><span class="sxs-lookup"><span data-stu-id="92ae7-340">How this happens varies from GPU to GPU.</span></span> <span data-ttu-id="92ae7-341">Die Texturkoordinaten werden von der kartenbasierten oder der Intervall basierten kaskadierenden Auswahl bestimmt.</span><span class="sxs-lookup"><span data-stu-id="92ae7-341">The texture coordinates are determined by map-based or interval-based cascade selection.</span></span> <span data-ttu-id="92ae7-342">Einige Pixel in einem Pixel Quad wählen einen anderen kaskadierenden als den restlichen Pixel aus.</span><span class="sxs-lookup"><span data-stu-id="92ae7-342">Some pixels in a pixel quad choose a different cascade than the rest of the pixels.</span></span> <span data-ttu-id="92ae7-343">Dies führt zu sichtbaren Nähten zwischen Schatten Zuordnungen, da die abgeleiteten Offsets nun vollständig falsch sind.</span><span class="sxs-lookup"><span data-stu-id="92ae7-343">This results in visible seams between shadow maps because the derivative-based offsets are now completely wrong.</span></span> <span data-ttu-id="92ae7-344">Die Lösung besteht darin, die Ableitung in Licht Ansichts Raum-Texturkoordinaten auszuführen.</span><span class="sxs-lookup"><span data-stu-id="92ae7-344">The solution is to perform the derivative on light-view space texture coordinates.</span></span> <span data-ttu-id="92ae7-345">Diese Koordinaten sind für jede Cascade identisch.</span><span class="sxs-lookup"><span data-stu-id="92ae7-345">These coordinates are the same for every cascade.</span></span>

### <a name="padding-for-pcf-kernels"></a><span data-ttu-id="92ae7-346">Padding für PCF-Kernel</span><span class="sxs-lookup"><span data-stu-id="92ae7-346">Padding for PCF Kernels</span></span>

<span data-ttu-id="92ae7-347">PCF-Kernel Index außerhalb einer kaskadierenden Partition, wenn der Schatten Puffer nicht aufgefüllt ist.</span><span class="sxs-lookup"><span data-stu-id="92ae7-347">PCF kernels index outside of a cascade partition if the shadow buffer is not padded.</span></span> <span data-ttu-id="92ae7-348">Die Lösung besteht darin, den äußeren Rand der kaskadierenden Ebene um die Hälfte der Größe des PCF-Kernels aufzurufenden.</span><span class="sxs-lookup"><span data-stu-id="92ae7-348">The solution is to pad the outer rim of the cascade by one-half the size of the PCF kernel.</span></span> <span data-ttu-id="92ae7-349">Dies muss im Shader implementiert werden, der die Cascade-und in der Projektions Matrix auswählt, die die Cascade-Darstellung so groß darstellen muss, dass der Rahmen beibehalten wird.</span><span class="sxs-lookup"><span data-stu-id="92ae7-349">This must be implemented in the shader that selects the cascade and in the projection matrix that must render the cascade large enough that the border is preserved.</span></span>

## <a name="variance-shadow-maps"></a><span data-ttu-id="92ae7-350">Varianz Schatten Zuordnungen</span><span class="sxs-lookup"><span data-stu-id="92ae7-350">Variance Shadow Maps</span></span>

<span data-ttu-id="92ae7-351">VSMs (Weitere Informationen finden Sie unter [Varianz Schatten](https://portal.acm.org/citation.cfm?doid=1111411.1111440) Zuordnungen von Donnelly und Lauritzen) aktivieren Sie das Filtern direkter schattenkarten.</span><span class="sxs-lookup"><span data-stu-id="92ae7-351">VSMs (see [Variance shadow maps](https://portal.acm.org/citation.cfm?doid=1111411.1111440) by Donnelly and Lauritzen for more information) enable direct shadow map filtering.</span></span> <span data-ttu-id="92ae7-352">Bei der Verwendung von VSMs kann die gesamte Leistungsfähigkeit der Textur Filterungs Hardware verwendet werden.</span><span class="sxs-lookup"><span data-stu-id="92ae7-352">When using VSMs, all of the power of the texture-filtering hardware can be used.</span></span> <span data-ttu-id="92ae7-353">Die Filter "trlinear" und "anisotrope" (Abbildung 15) können verwendet werden.</span><span class="sxs-lookup"><span data-stu-id="92ae7-353">Trilinear and anisotropic (Figure 15) filtering can be used.</span></span> <span data-ttu-id="92ae7-354">Darüber hinaus können VSMs direkt über die-Übertragung verwischt werden.</span><span class="sxs-lookup"><span data-stu-id="92ae7-354">Additionally, VSMs can be blurred directly through convolution.</span></span> <span data-ttu-id="92ae7-355">VSMs haben einige Nachteile. Es müssen zwei Kanäle von Tiefendaten gespeichert werden (Tiefe und Tiefe quadriert).</span><span class="sxs-lookup"><span data-stu-id="92ae7-355">VSMs do have some drawbacks; two channels of depth data must be stored (depth and depth squared).</span></span> <span data-ttu-id="92ae7-356">Wenn Schatten überlappend sind, kommt es häufig zu Licht Blutungen.</span><span class="sxs-lookup"><span data-stu-id="92ae7-356">When shadows overlap, light-bleeding is common.</span></span> <span data-ttu-id="92ae7-357">Sie funktionieren jedoch mit geringeren Auflösungen und können mit CSMS kombiniert werden.</span><span class="sxs-lookup"><span data-stu-id="92ae7-357">They work well, however, with lower resolutions and can be combined with CSMs.</span></span>

<span data-ttu-id="92ae7-358">**Abbildung 15. Anisotrope Filterung**</span><span class="sxs-lookup"><span data-stu-id="92ae7-358">**Figure 15. Anisotropic filtering**</span></span>

![anisotrope Filterung](images/anisotropic-filtering.png)

### <a name="algorithm-details"></a><span data-ttu-id="92ae7-360">Algorithmusdetails</span><span class="sxs-lookup"><span data-stu-id="92ae7-360">Algorithm Details</span></span>

<span data-ttu-id="92ae7-361">VSMs funktioniert durch das Rendern der Tiefe und des tiefen Quadrats in eine zwei-Kanal-Schatten Zuordnung.</span><span class="sxs-lookup"><span data-stu-id="92ae7-361">VSMs work by rendering the depth and the depth squared to a two-channel shadow map.</span></span> <span data-ttu-id="92ae7-362">Diese zwei-Kanal-Schatten Zuordnung kann dann wie eine normale textur verschwommen und gefiltert werden.</span><span class="sxs-lookup"><span data-stu-id="92ae7-362">This two-channel shadow map can then be blurred and filtered just like a normal texture.</span></span> <span data-ttu-id="92ae7-363">Der Algorithmus verwendet dann die Ungleichheit von Chebychev im Pixelshader, um den Anteil des Pixel Bereichs zu schätzen, der den tiefen Test bestehen würde.</span><span class="sxs-lookup"><span data-stu-id="92ae7-363">The algorithm then uses Chebychev's Inequality in the pixel shader to estimate the fraction of pixel area that would pass the depth test.</span></span>

<span data-ttu-id="92ae7-364">Der Pixelshader Ruft die tiefen Werte und tiefen Quadrat Werte ab.</span><span class="sxs-lookup"><span data-stu-id="92ae7-364">The pixel shader fetches the depth and depth-squared values.</span></span>


```C++
        float  fAvgZ  = mapDepth.x; // Filtered z
        float  fAvgZ2 = mapDepth.y; // Filtered z-squared
```



<span data-ttu-id="92ae7-365">Der tiefen Vergleich wird durchgeführt.</span><span class="sxs-lookup"><span data-stu-id="92ae7-365">The depth comparison is performed.</span></span>


```C++
        if ( fDepth <= fAvgZ )
        {
        fPercentLit = 1;
        }
```



<span data-ttu-id="92ae7-366">Wenn der tiefen Vergleich fehlschlägt, wird der Prozentsatz des beleuchteten Pixels geschätzt.</span><span class="sxs-lookup"><span data-stu-id="92ae7-366">If the depth comparison fails, the percentage of the pixel that is lit is estimated.</span></span> <span data-ttu-id="92ae7-367">Die Varianz wird als durchschnittliche Anzahl von Quadraten abzüglich Quadrat des Durchschnitts berechnet.</span><span class="sxs-lookup"><span data-stu-id="92ae7-367">Variance is calculated as average-of-squares minus square-of-average.</span></span>


```C++
        float variance = ( fAvgZ2 ) − ( fAvgZ * fAvgZ );
        variance = min( 1.0f, max( 0.0f, variance + 0.00001f ) );
```



<span data-ttu-id="92ae7-368">Der Wert für "fprozentulit" wird mit der Ungleichheit von Chebychev geschätzt.</span><span class="sxs-lookup"><span data-stu-id="92ae7-368">The fPercentLit value is estimated with Chebychev's Inequality.</span></span>


```C++
        float mean           = fAvgZ;
        float d              = fDepth - mean;
        float fPercentLit    = variance / ( variance + d*d );
```



## <a name="light-bleeding"></a><span data-ttu-id="92ae7-369">Leichte Blutungen</span><span class="sxs-lookup"><span data-stu-id="92ae7-369">Light Bleeding</span></span>

<span data-ttu-id="92ae7-370">Der größte Nachteil von VSMs ist eine leichte Blutung (Abbildung 16).</span><span class="sxs-lookup"><span data-stu-id="92ae7-370">The biggest drawback to VSMs is light bleeding (Figure 16).</span></span> <span data-ttu-id="92ae7-371">Leichte Blutungen treten auf, wenn mehrere Schatten-Casters nebeneinander nebeneinander verborgen werden.</span><span class="sxs-lookup"><span data-stu-id="92ae7-371">Light bleeding occurs when multiple shadow casters occlude each other along edges.</span></span> <span data-ttu-id="92ae7-372">Die Ränder von Schatten werden von VSMs basierend auf tiefen unterschieden schattiert.</span><span class="sxs-lookup"><span data-stu-id="92ae7-372">VSMs shade the edges of shadows based on depth disparities.</span></span> <span data-ttu-id="92ae7-373">Wenn Schatten einander überlappen, gibt es in der Mitte eines Bereichs, der schattiert werden soll, eine Tiefe Abweichung.</span><span class="sxs-lookup"><span data-stu-id="92ae7-373">When shadows overlap each other, a depth disparity exists in the center of a region that should be shadowed.</span></span> <span data-ttu-id="92ae7-374">Dies ist ein Problem bei der Verwendung des VSM-Algorithmus.</span><span class="sxs-lookup"><span data-stu-id="92ae7-374">This is a problem with using the VSM algorithm.</span></span>

<span data-ttu-id="92ae7-375">**Abbildung 16. VSM-Licht Blutung**</span><span class="sxs-lookup"><span data-stu-id="92ae7-375">**Figure 16. VSM light bleeding**</span></span>

![VSM-Licht Blutung](images/vsm-light-bleeding.png)

<span data-ttu-id="92ae7-377">Eine partielle Lösung für das Problem besteht darin, den fprozentulit auf einen Strom zu erhöhen.</span><span class="sxs-lookup"><span data-stu-id="92ae7-377">A partial solution to the problem is to raise the fPercentLit to a power.</span></span> <span data-ttu-id="92ae7-378">Dies hat den Effekt, dass der weichungs Effekt gedämpft wird. Dies kann zu Artefakten führen, bei denen die tiefe Ungleichheit gering ist.</span><span class="sxs-lookup"><span data-stu-id="92ae7-378">This has the effect of dampening the blur, which can cause artifacts where depth disparity is small.</span></span> <span data-ttu-id="92ae7-379">Manchmal gibt es einen magischen Wert, der das Problem behebt.</span><span class="sxs-lookup"><span data-stu-id="92ae7-379">Sometimes there exists a magical value that alleviates the problem.</span></span>


```C++
fPercentLit = pow( p_max, MAGIC_NUMBER );
```



<span data-ttu-id="92ae7-380">Eine Alternative zum Hervorheben der Stromversorgung in Prozent besteht darin, Konfigurationen zu vermeiden, bei denen sich Schatten überlappen.</span><span class="sxs-lookup"><span data-stu-id="92ae7-380">An alternative to raising the percent lit to a power is to avoid configurations where shadows overlap.</span></span> <span data-ttu-id="92ae7-381">Sogar hochoptimierte Schatten Konfigurationen haben mehrere Einschränkungen in den hellen, Kameras und Geometrie.</span><span class="sxs-lookup"><span data-stu-id="92ae7-381">Even highly tuned shadow configurations have several constraints on light, camera, and geometry.</span></span> <span data-ttu-id="92ae7-382">Leichte Blutungen werden auch durch die Verwendung von Strukturen mit höherer Auflösung verringert.</span><span class="sxs-lookup"><span data-stu-id="92ae7-382">Light bleeding is also lessened by using higher resolution textures.</span></span>

<span data-ttu-id="92ae7-383">Überlappende Varianz Schatten Zuordnungen (lvsms) lösen das Problem, indem Sie die Frustration in Schichten aufteilen, die senkrecht zum Licht stehen.</span><span class="sxs-lookup"><span data-stu-id="92ae7-383">Layered variance shadow maps (LVSMs) solve the problem at the expense of breaking the frustum into layers that are perpendicular to the light.</span></span> <span data-ttu-id="92ae7-384">Die Anzahl erforderlicher Zuordnungen wäre sehr groß, wenn auch CSMS verwendet werden.</span><span class="sxs-lookup"><span data-stu-id="92ae7-384">The number of maps required would be quite large when CSMs are also being used.</span></span>

<span data-ttu-id="92ae7-385">Darüber hinaus hat Andrew Lauritzen, Co-Autor des Artikels auf VSMs, und Autor eines Artikels zu lvsms erläutert, wie exponentielle Schatten Zuordnungen (eSMS) mit VSMs kombiniert werden, um helle Mischungen in einem [Beyond3D-Forum](https://forum.beyond3d.com/showthread.php?t=47427)entgegenzuwirken.</span><span class="sxs-lookup"><span data-stu-id="92ae7-385">Additionally, Andrew Lauritzen, co-author of the paper on VSMs, and author of a paper on LVSMs, discussed combining exponential shadow maps (ESMs) with VSMs to counteract light blending in a [Beyond3D Forum](https://forum.beyond3d.com/showthread.php?t=47427).</span></span>

## <a name="vsms-with-csms"></a><span data-ttu-id="92ae7-386">VSMs mit CSMS</span><span class="sxs-lookup"><span data-stu-id="92ae7-386">VSMs with CSMs</span></span>

<span data-ttu-id="92ae7-387">Im Beispiel VarianceShadow11 werden VSMs und CSMS kombiniert.</span><span class="sxs-lookup"><span data-stu-id="92ae7-387">The sample VarianceShadow11 combines VSMs and CSMs.</span></span> <span data-ttu-id="92ae7-388">Die Kombination ist recht unkompliziert.</span><span class="sxs-lookup"><span data-stu-id="92ae7-388">The combination is fairly straightforward.</span></span> <span data-ttu-id="92ae7-389">Das Beispiel folgt denselben Schritten wie das CascadedShadowMaps11-Beispiel.</span><span class="sxs-lookup"><span data-stu-id="92ae7-389">The sample follows the same steps as the CascadedShadowMaps11 sample.</span></span> <span data-ttu-id="92ae7-390">Da PCF nicht verwendet wird, werden die Schatten in einer trennbaren zwei-und trennbaren zusammen Gabe verschwommen.</span><span class="sxs-lookup"><span data-stu-id="92ae7-390">Because PCF is not used, the shadows are blurred in a two-pass separable convolution.</span></span> <span data-ttu-id="92ae7-391">Wenn Sie PCF nicht verwenden, kann das Beispiel auch Textur Arrays anstelle eines Textur Atlas verwenden.</span><span class="sxs-lookup"><span data-stu-id="92ae7-391">Not using PCF also enables the sample to use texture arrays instead of a texture atlas.</span></span> <span data-ttu-id="92ae7-392">PCF für Textur Arrays ist ein Direct3D 10,1-Feature.</span><span class="sxs-lookup"><span data-stu-id="92ae7-392">PCF on texture arrays is a Direct3D 10.1 feature.</span></span>

### <a name="gradients-with-csms"></a><span data-ttu-id="92ae7-393">Farbverläufe mit CSMS</span><span class="sxs-lookup"><span data-stu-id="92ae7-393">Gradients with CSMs</span></span>

<span data-ttu-id="92ae7-394">Die Verwendung von Farbverläufen mit CSMS kann entlang des Rahmens zwischen zwei Kaskaden, wie in Abbildung 17 dargestellt, zu einer Grenze führen.</span><span class="sxs-lookup"><span data-stu-id="92ae7-394">Using gradients with CSMs can produce a seam along the border between two cascades as seen in Figure 17.</span></span> <span data-ttu-id="92ae7-395">Die Beispiel Anweisung verwendet Ableitungen zwischen Pixeln, um Informationen zu berechnen, z. b. die MipMap-Ebene, die vom Filter benötigt wird.</span><span class="sxs-lookup"><span data-stu-id="92ae7-395">The sample instruction uses derivatives between pixels to calculate information, such as the mipmap level, needed by the filter.</span></span> <span data-ttu-id="92ae7-396">Dies verursacht ein bestimmtes Problem bei der Auswahl von MipMap oder der anisotrope Filterung.</span><span class="sxs-lookup"><span data-stu-id="92ae7-396">This causes a problem in particular for mipmap selection or anisotropic filtering.</span></span> <span data-ttu-id="92ae7-397">Wenn Pixel in einem Quad verschiedene Verzweigungen im Shader annehmen, sind die von der GPU-Hardware berechneten Ableitungen ungültig.</span><span class="sxs-lookup"><span data-stu-id="92ae7-397">When pixels in a quad take different branches in the shader, the derivatives calculated by the GPU hardware are invalid.</span></span> <span data-ttu-id="92ae7-398">Dies führt zu einer verzweigten Naht entlang der schattenkarte.</span><span class="sxs-lookup"><span data-stu-id="92ae7-398">This results in a jagged seam along the shadow map.</span></span>

<span data-ttu-id="92ae7-399">**Abbildung 17. Nähte an kaskadierenden Rahmen aufgrund einer anisotrope Filterung mit abweichender Fluss Steuerung**</span><span class="sxs-lookup"><span data-stu-id="92ae7-399">**Figure 17. Seams on cascade borders due to anisotropic filtering with divergent flow control**</span></span>

![Nähte an kaskadierenden Rahmen aufgrund einer anisotrope Filterung mit abweichender Fluss Steuerung](images/seams-on-cascade-borders-due-to-anisotropic.jpg)

<span data-ttu-id="92ae7-401">Dieses Problem wird gelöst, indem die Ableitungen an der Position im hellen Raum berechnet werden. die hell Ansichts Raum Koordinate ist nicht spezifisch für die ausgewählte CASCADE-Option.</span><span class="sxs-lookup"><span data-stu-id="92ae7-401">This problem is solved by computing the derivatives on the position in light-view space; the light-view space coordinate is not specific to the selected cascade.</span></span> <span data-ttu-id="92ae7-402">Die berechneten Ableitungen können von dem Skalierungs Teil der Projektions Textur Matrix auf die richtige MipMap-Ebene skaliert werden.</span><span class="sxs-lookup"><span data-stu-id="92ae7-402">The computed derivatives can be scaled by the scale portion of the projection-texture matrix to the correct mipmap level.</span></span>


```C++
        float3 vShadowTexCoordDDX = ddx( vShadowMapTextureCoordViewSpace );
        vShadowTexCoordDDX *= m_vCascadeScale[iCascade].xyz;
        float3 vShadowTexCoordDDY = ddy( vShadowMapTextureCoordViewSpace );
        vShadowTexCoordDDY *= m_vCascadeScale[iCascade].xyz;

        mapDepth += g_txShadow.SampleGrad( g_samShadow, vShadowTexCoord.xyz,
        vShadowTexCoordDDX, vShadowTexCoordDDY );
```



## <a name="vsms-compared-to-standard-shadows-with-pcf"></a><span data-ttu-id="92ae7-403">VSMs im Vergleich zu Standard Schatten mit PCF</span><span class="sxs-lookup"><span data-stu-id="92ae7-403">VSMs Compared to Standard Shadows with PCF</span></span>

<span data-ttu-id="92ae7-404">Sowohl VSMs als auch PCF versuchen, den Bruchteil des Pixel Bereichs zu annähern, der den tiefen Test bestanden hat.</span><span class="sxs-lookup"><span data-stu-id="92ae7-404">Both VSMs and PCF attempt to approximate the fraction of pixel area that would pass the depth test.</span></span> <span data-ttu-id="92ae7-405">VSMs funktioniert mit Filterungs Hardware und kann mit trennbaren Kernels verschwommen werden.</span><span class="sxs-lookup"><span data-stu-id="92ae7-405">VSMs work with filtering hardware and can be blurred with separable kernels.</span></span> <span data-ttu-id="92ae7-406">Die Implementierung von trennbaren-und-Kernel-Kernels ist erheblich günstiger als ein vollständiger Kernel.</span><span class="sxs-lookup"><span data-stu-id="92ae7-406">Separable convolution kernels are considerably cheaper to implement than a full kernel.</span></span> <span data-ttu-id="92ae7-407">Außerdem vergleicht VSMs eine Leerraum Tiefe mit einem Wert in der detaillierten Leertaste.</span><span class="sxs-lookup"><span data-stu-id="92ae7-407">Additionally, VSMs compare one light-space depth against one value in the light-space depth map.</span></span> <span data-ttu-id="92ae7-408">Dies bedeutet, dass VSMs nicht die gleichen Offset Probleme wie PCF haben.</span><span class="sxs-lookup"><span data-stu-id="92ae7-408">This means that VSMs do not have the same offset problems as PCF.</span></span> <span data-ttu-id="92ae7-409">Technisch gesehen sind VSMs eine Stichproben Tiefe über einen größeren Bereich und Durchführen einer statistischen Analyse.</span><span class="sxs-lookup"><span data-stu-id="92ae7-409">Technically, VSMs are sampling depth over a greater area, as well as performing a statistical analysis.</span></span> <span data-ttu-id="92ae7-410">Dies ist weniger genau als PCF.</span><span class="sxs-lookup"><span data-stu-id="92ae7-410">This is less precise than PCF.</span></span> <span data-ttu-id="92ae7-411">In der Praxis führt VSMs eine sehr gute Mischung aus, was dazu führt, dass weniger Offset erforderlich ist.</span><span class="sxs-lookup"><span data-stu-id="92ae7-411">In practice, VSMs do a very good job of blending, which results in less offset being necessary.</span></span> <span data-ttu-id="92ae7-412">Wie oben beschrieben, ist die Zahl ein Nachteil von VSMs eine leichte Blutung.</span><span class="sxs-lookup"><span data-stu-id="92ae7-412">As described above, the number one drawback to VSMs is light bleeding.</span></span>

<span data-ttu-id="92ae7-413">VSMs und PCF stellen einen Kompromiss zwischen GPU-computeleistung und GPU-Textur Bandbreite dar.</span><span class="sxs-lookup"><span data-stu-id="92ae7-413">VSMs and PCF represent a trade-off between GPU compute power and GPU texture bandwidth.</span></span> <span data-ttu-id="92ae7-414">VSMs erfordert mehr Berechnungen, um die Varianz zu berechnen.</span><span class="sxs-lookup"><span data-stu-id="92ae7-414">VSMs require more math to be performed to calculate the variance.</span></span> <span data-ttu-id="92ae7-415">PCF erfordert mehr Texturspeicher Bandbreite.</span><span class="sxs-lookup"><span data-stu-id="92ae7-415">PCF requires more texture memory bandwidth.</span></span> <span data-ttu-id="92ae7-416">Große PCF-Kernel können durch Textur Bandbreite schnell zu einem Engpass werden.</span><span class="sxs-lookup"><span data-stu-id="92ae7-416">Large PCF kernels can quickly become bottlenecked by texture bandwidth.</span></span> <span data-ttu-id="92ae7-417">Wenn sich der GPU-Berechnungs Strom schneller als die GPU-Bandbreite vergrößert, werden die beiden Algorithmen von VSMs immer praktischer.</span><span class="sxs-lookup"><span data-stu-id="92ae7-417">With GPU computation power growing more rapidly than GPU bandwidth, VSMs are becoming the more practical of the two algorithms.</span></span> <span data-ttu-id="92ae7-418">VSMs ist auch mit niedrigerer Auflösung von Schatten Zuordnungen aufgrund von Blending und Filterung besser geeignet.</span><span class="sxs-lookup"><span data-stu-id="92ae7-418">VSMs also look better with lower resolution shadow maps due to blending and filtering.</span></span>

## <a name="summary"></a><span data-ttu-id="92ae7-419">Zusammenfassung</span><span class="sxs-lookup"><span data-stu-id="92ae7-419">Summary</span></span>

<span data-ttu-id="92ae7-420">CSMS bieten eine Lösung für das Problem der Perspektiven Aliasing.</span><span class="sxs-lookup"><span data-stu-id="92ae7-420">CSMs offer a solution to the perspective aliasing problem.</span></span> <span data-ttu-id="92ae7-421">Es gibt mehrere mögliche Konfigurationen, um die benötigte visuelle Genauigkeit für einen Titel zu erhalten.</span><span class="sxs-lookup"><span data-stu-id="92ae7-421">There are several possible configurations to get the needed visual fidelity for a title.</span></span> <span data-ttu-id="92ae7-422">PCF und VSMs werden häufig verwendet und sollten mit CSMS kombiniert werden, um das Aliasing zu verringern.</span><span class="sxs-lookup"><span data-stu-id="92ae7-422">PCF and VSMs are widely used and should be combined with CSMs to reduce aliasing.</span></span>

## <a name="references"></a><span data-ttu-id="92ae7-423">References</span><span class="sxs-lookup"><span data-stu-id="92ae7-423">References</span></span>

<span data-ttu-id="92ae7-424">Donnelly, W. und Lauritzen, A. [Varianz Schatten](https://portal.acm.org/citation.cfm?doid=1111411.1111440)Zuordnungen.</span><span class="sxs-lookup"><span data-stu-id="92ae7-424">Donnelly, W. and Lauritzen, A. [Variance shadow maps](https://portal.acm.org/citation.cfm?doid=1111411.1111440).</span></span> <span data-ttu-id="92ae7-425">In SI3D ' 06: das-Verfahren des 2006-Symposiums zu interaktiven 3D-Grafiken und-spielen.</span><span class="sxs-lookup"><span data-stu-id="92ae7-425">In SI3D '06: Proceedings of the 2006 symposium on Interactive 3D graphics and games.</span></span> <span data-ttu-id="92ae7-426">2006.</span><span class="sxs-lookup"><span data-stu-id="92ae7-426">2006.</span></span> <span data-ttu-id="92ae7-427">PP. 161 – 165.</span><span class="sxs-lookup"><span data-stu-id="92ae7-427">pp. 161–165.</span></span> <span data-ttu-id="92ae7-428">New York, NY, USA: ACM Press.</span><span class="sxs-lookup"><span data-stu-id="92ae7-428">New York, NY, USA: ACM Press.</span></span>

<span data-ttu-id="92ae7-429">Lauritzen, Andrew und McCool, Michael.</span><span class="sxs-lookup"><span data-stu-id="92ae7-429">Lauritzen, Andrew and McCool, Michael.</span></span> <span data-ttu-id="92ae7-430">[Überlagerte Varianz schattenkarten](https://portal.acm.org/citation.cfm?id=1375714.1375739&coll=GUIDE&dl=GUIDE&CFID=45360327&CFTOKEN=34578992).</span><span class="sxs-lookup"><span data-stu-id="92ae7-430">[Layered variance shadow maps](https://portal.acm.org/citation.cfm?id=1375714.1375739&coll=GUIDE&dl=GUIDE&CFID=45360327&CFTOKEN=34578992).</span></span> <span data-ttu-id="92ae7-431">Das Verfahren der Grafikschnittstelle 2008, 28. Mai – 30, 2008, Windsor, Ontario, Kanada.</span><span class="sxs-lookup"><span data-stu-id="92ae7-431">Proceedings of graphics interface 2008, May 28–30, 2008, Windsor, Ontario, Canada.</span></span>

<span data-ttu-id="92ae7-432">Engel, woflgang F., Abschnitt 4.</span><span class="sxs-lookup"><span data-stu-id="92ae7-432">Engel, Woflgang F. Section 4.</span></span> <span data-ttu-id="92ae7-433">Kaskadierenden Schatten Zuordnungen.</span><span class="sxs-lookup"><span data-stu-id="92ae7-433">Cascaded Shadow Maps.</span></span> <span data-ttu-id="92ae7-434">ShaderX5, erweiterte renderingtechniken, Wolfgang F. Engel, Ed.</span><span class="sxs-lookup"><span data-stu-id="92ae7-434">ShaderX5 , Advanced Rendering Techniques, Wolfgang F. Engel, Ed.</span></span> <span data-ttu-id="92ae7-435">Charles River Media, Boston, Massachusetts.</span><span class="sxs-lookup"><span data-stu-id="92ae7-435">Charles River Media, Boston, Massachusetts.</span></span> <span data-ttu-id="92ae7-436">2006.</span><span class="sxs-lookup"><span data-stu-id="92ae7-436">2006.</span></span> <span data-ttu-id="92ae7-437">PP. 197 – 206.</span><span class="sxs-lookup"><span data-stu-id="92ae7-437">pp. 197–206.</span></span>

 

 