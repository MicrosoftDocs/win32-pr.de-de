---
title: Überlegungen zur blockierfreien Programmierung für Xbox 360 und Microsoft Windows
description: In diesem Artikel erhalten Sie einen Überblick über einige der Probleme, die bei der Verwendung von lockless-Programmiertechniken zu beachten sind.
ms.assetid: 44700352-a791-7ef7-0858-146214b0e3da
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: 23bf8d66cada8aff00735fe6d6ac2d4f1369bc32
ms.sourcegitcommit: 89f99926f946dc6c5ea600fb7c41f6b19ceac516
ms.translationtype: MT
ms.contentlocale: de-DE
ms.lasthandoff: 10/21/2020
ms.locfileid: "103949214"
---
# <a name="lockless-programming-considerations-for-xbox-360-and-microsoft-windows"></a><span data-ttu-id="8b012-103">Überlegungen zur blockierfreien Programmierung für Xbox 360 und Microsoft Windows</span><span class="sxs-lookup"><span data-stu-id="8b012-103">Lockless Programming Considerations for Xbox 360 and Microsoft Windows</span></span>

<span data-ttu-id="8b012-104">Die sperrenlose Programmierung ist eine Methode, um geänderte Daten sicher zwischen mehreren Threads freizugeben, ohne dass die Kosten für das Abrufen und Freigeben von Sperren anfallen.</span><span class="sxs-lookup"><span data-stu-id="8b012-104">Lockless programming is a way to safely share changing data between multiple threads without the cost of acquiring and releasing locks.</span></span> <span data-ttu-id="8b012-105">Das klingt wie ein Allheilmittel, aber die sperlocklose Programmierung ist komplex und sehr komplex und bietet manchmal nicht die Vorteile, die Sie verspricht.</span><span class="sxs-lookup"><span data-stu-id="8b012-105">This sounds like a panacea, but lockless programming is complex and subtle, and sometimes doesn't give the benefits that it promises.</span></span> <span data-ttu-id="8b012-106">Die sperlocklose Programmierung ist auf Xbox 360 besonders komplex.</span><span class="sxs-lookup"><span data-stu-id="8b012-106">Lockless programming is particularly complex on Xbox 360.</span></span>

<span data-ttu-id="8b012-107">Die sperrenlose Programmierung ist ein gültiges Verfahren für die Multithreadprogrammierung, sollte jedoch nicht auf leichte Weise verwendet werden.</span><span class="sxs-lookup"><span data-stu-id="8b012-107">Lockless programming is a valid technique for multithreaded programming, but it should not be used lightly.</span></span> <span data-ttu-id="8b012-108">Vor der Verwendung müssen Sie sich mit den Komplexitäten vertraut machen, und Sie sollten sorgfältig abwägen, um sicherzustellen, dass Sie die erwarteten Gewinne tatsächlich erhalten.</span><span class="sxs-lookup"><span data-stu-id="8b012-108">Before using it you must understand the complexities, and you should measure carefully to make sure that it is actually giving you the gains that you expect.</span></span> <span data-ttu-id="8b012-109">In vielen Fällen gibt es einfachere und schnellere Lösungen, wie z. b. die seltener Freigabe von Daten, die stattdessen verwendet werden sollten.</span><span class="sxs-lookup"><span data-stu-id="8b012-109">In many cases, there are simpler and faster solutions, such as sharing data less frequently, which should be used instead.</span></span>

<span data-ttu-id="8b012-110">Die korrekte und sichere Verwendung der sperlocklosen Programmierung erfordert sowohl die Hardware als auch den Compiler.</span><span class="sxs-lookup"><span data-stu-id="8b012-110">Using lockless programming correctly and safely requires significant knowledge of both your hardware and your compiler.</span></span> <span data-ttu-id="8b012-111">In diesem Artikel erhalten Sie einen Überblick über einige der Probleme, die bei der Verwendung von lockless-Programmiertechniken zu beachten sind.</span><span class="sxs-lookup"><span data-stu-id="8b012-111">This article gives an overview of some of the issues to consider when trying to use lockless programming techniques.</span></span>

## <a name="programming-with-locks"></a><span data-ttu-id="8b012-112">Programmieren mit Sperren</span><span class="sxs-lookup"><span data-stu-id="8b012-112">Programming with Locks</span></span>

<span data-ttu-id="8b012-113">Beim Schreiben von Multithreadcode müssen häufig Daten zwischen Threads gemeinsam genutzt werden.</span><span class="sxs-lookup"><span data-stu-id="8b012-113">When writing multi-threaded code it is often necessary to share data between threads.</span></span> <span data-ttu-id="8b012-114">Wenn mehrere Threads gleichzeitig die freigegebenen Datenstrukturen lesen und schreiben, kann eine Speicher Beschädigung auftreten.</span><span class="sxs-lookup"><span data-stu-id="8b012-114">If multiple threads are simultaneously reading and writing the shared data structures, memory corruption can occur.</span></span> <span data-ttu-id="8b012-115">Die einfachste Möglichkeit, dieses Problem zu lösen, ist die Verwendung von Sperren.</span><span class="sxs-lookup"><span data-stu-id="8b012-115">The simplest way of solving this problem is to use locks.</span></span> <span data-ttu-id="8b012-116">Wenn beispielsweise manipulateshareddata nur von einem Thread gleichzeitig ausgeführt werden soll, kann ein kritischer \_ Abschnitt verwendet werden, um dies zu gewährleisten, wie im folgenden Code:</span><span class="sxs-lookup"><span data-stu-id="8b012-116">For instance, if ManipulateSharedData should only be executed by one thread at a time, a CRITICAL\_SECTION can be used to guarantee this, as in the following code:</span></span>

``` syntax
// Initialize
CRITICAL_SECTION cs;
InitializeCriticalSection(&cs);

// Use
void ManipulateSharedData()
{
    EnterCriticalSection(&cs);
    // Manipulate stuff...
    LeaveCriticalSection(&cs);
}

// Destroy
DeleteCriticalSection(&cs);
```

<span data-ttu-id="8b012-117">Dieser Code ist recht einfach und unkompliziert, und es ist leicht zu erkennen, dass er korrekt ist.</span><span class="sxs-lookup"><span data-stu-id="8b012-117">This code is fairly simple and straightforward, and it is easy to tell that it is correct.</span></span> <span data-ttu-id="8b012-118">Das Programmieren mit Sperren hat jedoch mehrere mögliche Nachteile.</span><span class="sxs-lookup"><span data-stu-id="8b012-118">However, programming with locks comes with several potential disadvantages.</span></span> <span data-ttu-id="8b012-119">Wenn z. b. zwei Threads versuchen, dieselben zwei Sperren zu erhalten, Sie aber in einer anderen Reihenfolge erwerben, tritt möglicherweise ein Deadlock auf.</span><span class="sxs-lookup"><span data-stu-id="8b012-119">For example, if two threads try to acquire the same two locks but acquire them in a different order, you may get a deadlock.</span></span> <span data-ttu-id="8b012-120">Wenn ein Programm eine zu lange Sperre aufweist – aufgrund eines schlechten Entwurfs oder weil der Thread von einem Thread mit höherer Priorität ausgetauscht wurde – können andere Threads lange Zeit blockiert werden.</span><span class="sxs-lookup"><span data-stu-id="8b012-120">If a program holds a lock for too long—because of poor design or because the thread has been swapped out by a higher priority thread—other threads may be blocked for a long time.</span></span> <span data-ttu-id="8b012-121">Dieses Risiko eignet sich besonders gut für Xbox 360, da den Entwicklern vom Entwickler ein Hardware Thread zugewiesen wird und das Betriebssystem nicht in einen anderen Hardware Thread verschoben wird, auch wenn sich der Thread im Leerlauf befindet.</span><span class="sxs-lookup"><span data-stu-id="8b012-121">This risk is particularly great on Xbox 360 because the software threads are assigned a hardware thread by the developer, and the operating system won't move them to another hardware thread, even if one is idle.</span></span> <span data-ttu-id="8b012-122">Die Xbox 360 hat auch keinen Schutz vor Prioritäts-Inversion, bei der ein Thread mit hoher Priorität in einer Schleife steht, während er darauf wartet, dass ein Thread mit niedriger Priorität eine Sperre freigibt.</span><span class="sxs-lookup"><span data-stu-id="8b012-122">The Xbox 360 also has no protection against priority inversion, where a high-priority thread spins in a loop while waiting for a low-priority thread to release a lock.</span></span> <span data-ttu-id="8b012-123">Wenn ein verzögerter Prozedur Rückruf oder Interrupt Service Routine versucht, eine Sperre zu erhalten, erhalten Sie möglicherweise einen Deadlock.</span><span class="sxs-lookup"><span data-stu-id="8b012-123">Finally, if a deferred procedure call or interrupt service routine tries to acquire a lock, you may get a deadlock.</span></span>

<span data-ttu-id="8b012-124">Trotz dieser Probleme sind Synchronisierungs primitive, wie z. b. kritische Abschnitte, in der Regel die beste Methode zum Koordinieren mehrerer Threads.</span><span class="sxs-lookup"><span data-stu-id="8b012-124">Despite these problems, synchronization primitives, such as critical sections, are generally the best way of coordinating multiple threads.</span></span> <span data-ttu-id="8b012-125">Wenn die Synchronisierungs primitiven zu langsam sind, besteht die beste Lösung in der Regel darin, diese seltener zu verwenden.</span><span class="sxs-lookup"><span data-stu-id="8b012-125">If the synchronization primitives are too slow, the best solution is usually to use them less frequently.</span></span> <span data-ttu-id="8b012-126">Für diejenigen, die die zusätzliche Komplexität leisten können, ist eine andere Option die sperlocklose Programmierung.</span><span class="sxs-lookup"><span data-stu-id="8b012-126">However, for those who can afford the extra complexity, another option is lockless programming.</span></span>

## <a name="lockless-programming"></a><span data-ttu-id="8b012-127">Sperlocklose Programmierung</span><span class="sxs-lookup"><span data-stu-id="8b012-127">Lockless Programming</span></span>

<span data-ttu-id="8b012-128">Die sperrenlose Programmierung, wie der Name vermuten lässt, ist eine Reihe von Techniken zur sicheren Bearbeitung von freigegebenen Daten ohne Verwendung von Sperren.</span><span class="sxs-lookup"><span data-stu-id="8b012-128">Lockless programming, as the name suggests, is a family of techniques for safely manipulating shared data without using locks.</span></span> <span data-ttu-id="8b012-129">Es gibt Sperr lose Algorithmen für das Übergeben von Nachrichten, Freigabe Listen und Warteschlangen von Daten sowie andere Tasks.</span><span class="sxs-lookup"><span data-stu-id="8b012-129">There are lockless algorithms available for passing messages, sharing lists and queues of data, and other tasks.</span></span>

<span data-ttu-id="8b012-130">Bei der sperlocklosen Programmierung gibt es zwei Herausforderungen, die Sie behandeln müssen: nicht atomarische Vorgänge und Neuanordnen.</span><span class="sxs-lookup"><span data-stu-id="8b012-130">When doing lockless programming, there are two challenges that you must deal with: non-atomic operations and reordering.</span></span>

## <a name="non-atomic-operations"></a><span data-ttu-id="8b012-131">Nicht atomarische Vorgänge</span><span class="sxs-lookup"><span data-stu-id="8b012-131">Non-Atomic Operations</span></span>

<span data-ttu-id="8b012-132">Eine atomarische Operation ist eine unteilbare Operation – eine, bei der der Vorgang bei der Hälfte abgeschlossen wird.</span><span class="sxs-lookup"><span data-stu-id="8b012-132">An atomic operation is one that is indivisible—one where other threads are guaranteed to never see the operation when it is half done.</span></span> <span data-ttu-id="8b012-133">Atomarische Vorgänge sind für die sperlocklose Programmierung wichtig, da andere Threads möglicherweise halbgeschriebene Werte oder einen anderweitig inkonsistenten Zustand sehen.</span><span class="sxs-lookup"><span data-stu-id="8b012-133">Atomic operations are important for lockless programming, because without them, other threads might see half-written values, or otherwise inconsistent state.</span></span>

<span data-ttu-id="8b012-134">Bei allen modernen Prozessoren können Sie davon ausgehen, dass Lese-und Schreibvorgänge von natürlich ausgerichteten systemeigenen Typen atomar sind.</span><span class="sxs-lookup"><span data-stu-id="8b012-134">On all modern processors, you can assume that reads and writes of naturally aligned native types are atomic.</span></span> <span data-ttu-id="8b012-135">Solange der Speicherbus mindestens so breit ist wie der gelesene oder geschriebene Typ, liest und schreibt die CPU diese Typen in eine einzelne bustransaktion, sodass andere Threads Sie nicht in einem halb abgeschlossenen Zustand sehen können.</span><span class="sxs-lookup"><span data-stu-id="8b012-135">As long as the memory bus is at least as wide as the type being read or written, the CPU reads and writes these types in a single bus transaction, making it impossible for other threads to see them in a half-completed state.</span></span> <span data-ttu-id="8b012-136">Auf x86 und x64 gibt es keine Garantie, dass Lese-und Schreibvorgänge, die größer als acht Bytes sind, atomarisch sind.</span><span class="sxs-lookup"><span data-stu-id="8b012-136">On x86 and x64 there, is no guarantee that reads and writes larger than eight bytes are atomic.</span></span> <span data-ttu-id="8b012-137">Dies bedeutet, dass 16-Byte-Lese-und-Schreibvorgänge von SSE-Registern (Streaming SIMD Extension) und Zeichen folgen Operationen möglicherweise nicht atomarisch sind.</span><span class="sxs-lookup"><span data-stu-id="8b012-137">This means that 16-byte reads and writes of streaming SIMD extension (SSE) registers, and string operations, might not be atomic.</span></span>

<span data-ttu-id="8b012-138">Lese-und Schreibvorgänge von Typen, die nicht auf natürliche Weise ausgerichtet sind, z. –. das Schreiben von DWords, die vier-Byte-Begrenzungen überschreiten – sind nicht unbedingt atomarisch.</span><span class="sxs-lookup"><span data-stu-id="8b012-138">Reads and writes of types that are not naturally aligned—for instance, writing DWORDs that cross four-byte boundaries—are not guaranteed to be atomic.</span></span> <span data-ttu-id="8b012-139">Die CPU muss möglicherweise diese Lese-und Schreibvorgänge als mehrere bustransaktionen ausführen, sodass ein anderer Thread die Daten in der Mitte des Lese-oder Schreibzugriffs ändern oder anzeigen kann.</span><span class="sxs-lookup"><span data-stu-id="8b012-139">The CPU may have to do these reads and writes as multiple bus transactions, which could allow another thread to modify or see the data in the middle of the read or write.</span></span>

<span data-ttu-id="8b012-140">Zusammengesetzte Vorgänge, wie z. b. die Sequenz für Lese-und Schreibvorgänge, die beim Inkrement einer freigegebenen Variablen auftritt, sind nicht atomarisch.</span><span class="sxs-lookup"><span data-stu-id="8b012-140">Composite operations, such as the read-modify-write sequence that occurs when you increment a shared variable, are not atomic.</span></span> <span data-ttu-id="8b012-141">Auf Xbox 360 werden diese Vorgänge als mehrere Anweisungen (LWZ, ADDI und STW) implementiert, und der Thread kann durch die Sequenz durchlaufen werden.</span><span class="sxs-lookup"><span data-stu-id="8b012-141">On Xbox 360, these operations are implemented as multiple instructions (lwz, addi, and stw), and the thread could be swapped out partway through the sequence.</span></span> <span data-ttu-id="8b012-142">Bei x86 und x64 gibt es eine einzige Anweisung (Inc), mit der eine Variable im Arbeitsspeicher erhöht werden kann.</span><span class="sxs-lookup"><span data-stu-id="8b012-142">On x86 and x64, there is a single instruction (inc) that can be used to increment a variable in memory.</span></span> <span data-ttu-id="8b012-143">Wenn Sie diese Anweisung verwenden, ist das Inkrementieren einer Variablen für Systeme mit nur einem Prozessor atomarisch, aber auf Systemen mit mehreren Prozessoren ist Sie immer noch nicht atomar.</span><span class="sxs-lookup"><span data-stu-id="8b012-143">If you use this instruction, incrementing a variable is atomic on single-processor systems, but it is still not atomic on multi-processor systems.</span></span> <span data-ttu-id="8b012-144">Das Erstellen von Inc Atomic auf x86-und x64-basierten Multiprozessorsystemen erfordert die Verwendung des Sperr Präfixes, das verhindert, dass ein anderer Prozessor eine eigene Lese-/Schreib-Schreibsequenz zwischen dem Lese-und dem Schreibvorgang der Inc-Anweisung durchführen kann.</span><span class="sxs-lookup"><span data-stu-id="8b012-144">Making inc atomic on x86- and x64-based multi-processor systems requires using the lock prefix, which prevents another processor from doing its own read-modify-write sequence between the read and the write of the inc instruction.</span></span>

<span data-ttu-id="8b012-145">Der folgende Code zeigt einige Beispiele:</span><span class="sxs-lookup"><span data-stu-id="8b012-145">The following code shows some examples:</span></span>

``` syntax
// This write is not atomic because it is not natively aligned.
DWORD* pData = (DWORD*)(pChar + 1);
*pData = 0;

// This is not atomic because it is three separate operations.
++g_globalCounter;

// This write is atomic.
g_alignedGlobal = 0;

// This read is atomic.
DWORD local = g_alignedGlobal;
```

## <a name="guaranteeing-atomicity"></a><span data-ttu-id="8b012-146">Gewährleisten der Atomizität</span><span class="sxs-lookup"><span data-stu-id="8b012-146">Guaranteeing Atomicity</span></span>

<span data-ttu-id="8b012-147">Sie können mit einer Kombination der folgenden atomischen Vorgänge sicher sein:</span><span class="sxs-lookup"><span data-stu-id="8b012-147">You can be sure you are using atomic operations by a combination of the following:</span></span>

-   <span data-ttu-id="8b012-148">Natürlich atomarische Vorgänge</span><span class="sxs-lookup"><span data-stu-id="8b012-148">Naturally atomic operations</span></span>
-   <span data-ttu-id="8b012-149">Sperren zum Einschließen von zusammengesetzten Vorgängen</span><span class="sxs-lookup"><span data-stu-id="8b012-149">Locks to wrap composite operations</span></span>
-   <span data-ttu-id="8b012-150">Betriebssystemfunktionen, die atomarische Versionen beliebter zusammengesetzter Vorgänge implementieren</span><span class="sxs-lookup"><span data-stu-id="8b012-150">Operating system functions that implement atomic versions of popular composite operations</span></span>

<span data-ttu-id="8b012-151">Das Inkrementieren einer Variablen ist kein atomarer Vorgang, und das Inkrementieren kann zu Daten Beschädigungen führen, wenn Sie in mehreren Threads ausgeführt werden.</span><span class="sxs-lookup"><span data-stu-id="8b012-151">Incrementing a variable is not an atomic operation, and incrementing may lead to data corruption if executed on multiple threads.</span></span>

``` syntax
// This will be atomic.
g_globalCounter = 0;

// This is not atomic and gives undefined behavior
// if executed on multiple threads
++g_globalCounter;
```

<span data-ttu-id="8b012-152">Win32 verfügt über eine Reihe von Funktionen, die atomarische Lese-und Schreibvorgänge für verschiedene gängige Vorgänge bieten.</span><span class="sxs-lookup"><span data-stu-id="8b012-152">Win32 comes with a family of functions that offer atomic read-modify-write versions of several common operations.</span></span> <span data-ttu-id="8b012-153">Dabei handelt es sich um die interlockedxxx-Funktions Familie.</span><span class="sxs-lookup"><span data-stu-id="8b012-153">These are the InterlockedXxx family of functions.</span></span> <span data-ttu-id="8b012-154">Wenn alle Änderungen der freigegebenen Variablen diese Funktionen verwenden, sind die Änderungen Thread sicher.</span><span class="sxs-lookup"><span data-stu-id="8b012-154">If all modifications of the shared variable use these functions, the modifications will be thread safe.</span></span>

``` syntax
// Incrementing our variable in a safe lockless way.
InterlockedIncrement(&g_globalCounter);
```

## <a name="reordering"></a><span data-ttu-id="8b012-155">Neuanordnung</span><span class="sxs-lookup"><span data-stu-id="8b012-155">Reordering</span></span>

<span data-ttu-id="8b012-156">Ein feineres Problem ist die Neuanordnung.</span><span class="sxs-lookup"><span data-stu-id="8b012-156">A more subtle problem is reordering.</span></span> <span data-ttu-id="8b012-157">Lese-und Schreibvorgänge erfolgen nicht immer in der Reihenfolge, in der Sie Sie in Ihren Code geschrieben haben, und dies kann zu sehr verwirrenden Problemen führen.</span><span class="sxs-lookup"><span data-stu-id="8b012-157">Reads and writes do not always happen in the order that you have written them in your code, and this can lead to very confusing problems.</span></span> <span data-ttu-id="8b012-158">In vielen multithreadalgorithmen schreibt ein Thread einige Daten und schreibt dann in ein Flag, das anderen Threads mitteilt, dass die Daten bereit sind.</span><span class="sxs-lookup"><span data-stu-id="8b012-158">In many multi-threaded algorithms, a thread writes some data and then writes to a flag that tells other threads that the data is ready.</span></span> <span data-ttu-id="8b012-159">Dies wird als "Write-Release" bezeichnet.</span><span class="sxs-lookup"><span data-stu-id="8b012-159">This is known as a write-release.</span></span> <span data-ttu-id="8b012-160">Wenn die Schreibvorgänge neu angeordnet werden, sehen andere Threads möglicherweise, dass das Flag festgelegt ist, bevor die geschriebenen Daten angezeigt werden.</span><span class="sxs-lookup"><span data-stu-id="8b012-160">If the writes are reordered, other threads may see that the flag is set before they can see the written data.</span></span>

<span data-ttu-id="8b012-161">Ebenso liest ein Thread in vielen Fällen aus einem Flag und liest dann einige freigegebene Daten, wenn das Flag besagt, dass der Thread Zugriff auf die freigegebenen Daten erlangt hat.</span><span class="sxs-lookup"><span data-stu-id="8b012-161">Similarly, in many cases, a thread reads from a flag and then reads some shared data if the flag says that the thread has acquired access to the shared data.</span></span> <span data-ttu-id="8b012-162">Dies wird als Lesezugriff bezeichnet.</span><span class="sxs-lookup"><span data-stu-id="8b012-162">This is known as a read-acquire.</span></span> <span data-ttu-id="8b012-163">Wenn Lesevorgänge neu angeordnet werden, werden die Daten möglicherweise vor dem-Flag aus dem freigegebenen Speicher gelesen, und die angezeigten Werte sind möglicherweise nicht auf dem neuesten Stand.</span><span class="sxs-lookup"><span data-stu-id="8b012-163">If reads are reordered, then the data may be read from shared storage before the flag, and the values seen might not be up to date.</span></span>

<span data-ttu-id="8b012-164">Die Neuanordnung von Lese-und Schreibvorgängen kann sowohl vom Compiler als auch vom Prozessor durchgeführt werden.</span><span class="sxs-lookup"><span data-stu-id="8b012-164">Reordering of reads and writes can be done both by the compiler and by the processor.</span></span> <span data-ttu-id="8b012-165">Compiler und Prozessoren haben diese Neuanordnung seit Jahren ausgeführt, aber auf Computern mit nur einem Prozessor war es weniger ein Problem.</span><span class="sxs-lookup"><span data-stu-id="8b012-165">Compilers and processors have done this reordering for years, but on single-processor machines it was less of an issue.</span></span> <span data-ttu-id="8b012-166">Dies liegt daran, dass die CPU-Neuanordnung von Lese-und Schreibvorgängen auf Computern mit nur einem Prozessor unsichtbar ist (für nicht-Gerätetreiber Code, der nicht Teil eines Gerätetreibers ist), und die Neuanordnung von Lese-und Schreibvorgängen durch den Compiler weniger wahrscheinlich Probleme auf Computern mit einem Prozessor verursacht.</span><span class="sxs-lookup"><span data-stu-id="8b012-166">This is because CPU rearrangement of reads and writes is invisible on single-processor machines (for non-device driver code that is not part of a device driver), and compiler rearrangement of reads and writes is less likely to cause problems on single-processor machines.</span></span>

<span data-ttu-id="8b012-167">Wenn der Compiler oder die CPU die im folgenden Code gezeigten Schreibvorgänge neu anordnet, kann ein anderer Thread feststellen, dass das Alive-Flag festgelegt ist, während die alten Werte für x oder y weiterhin angezeigt werden.</span><span class="sxs-lookup"><span data-stu-id="8b012-167">If the compiler or the CPU rearranges the writes shown in the following code, another thread may see that the alive flag is set while still seeing the old values for x or y.</span></span> <span data-ttu-id="8b012-168">Ähnliche Neuanordnung kann beim Lesen auftreten.</span><span class="sxs-lookup"><span data-stu-id="8b012-168">Similar rearrangement can happen when reading.</span></span>

<span data-ttu-id="8b012-169">In diesem Code fügt ein Thread einen neuen Eintrag zum Sprite-Array hinzu:</span><span class="sxs-lookup"><span data-stu-id="8b012-169">In this code, one thread adds a new entry to the sprite array:</span></span>

``` syntax
// Create a new sprite by writing its position into an empty
// entry and then setting the ‘alive' flag. If ‘alive' is
// written before x or y then errors may occur.
g_sprites[nextSprite].x = x;
g_sprites[nextSprite].y = y;
g_sprites[nextSprite].alive = true;
```

<span data-ttu-id="8b012-170">Im nächsten Codeblock liest ein weiterer Thread aus dem Sprite-Array:</span><span class="sxs-lookup"><span data-stu-id="8b012-170">In this next code block, another thread reads from the sprite array:</span></span>

``` syntax
// Draw all sprites. If the reads of x and y are moved ahead of
// the read of ‘alive' then errors may occur.
for( int i = 0; i < numSprites; ++i )
{
    if( g_sprites[nextSprite].alive )
    {
        DrawSprite( g_sprites[nextSprite].x,
                g_sprites[nextSprite].y );
    }
}
```

<span data-ttu-id="8b012-171">Um dieses Sprite-System sicher zu machen, müssen wir sowohl die Compilerfunktion als auch die CPU-Neuanordnung von Lese-und Schreibvorgängen verhindern</span><span class="sxs-lookup"><span data-stu-id="8b012-171">To make this sprite system safe, we need to prevent both compiler and CPU reordering of reads and writes.</span></span>

### <a name="understanding-cpu-rearrangement-of-writes"></a><span data-ttu-id="8b012-172">Grundlegendes zur CPU-Umgestaltung von Schreibvorgängen</span><span class="sxs-lookup"><span data-stu-id="8b012-172">Understanding CPU Rearrangement of Writes</span></span>

<span data-ttu-id="8b012-173">Einige CPUs ordnen Schreibvorgänge neu an, sodass Sie extern für andere Prozessoren oder Geräte in nicht-Programm Reihenfolge sichtbar sind.</span><span class="sxs-lookup"><span data-stu-id="8b012-173">Some CPUs rearrange writes so that they are externally visible to other processors or devices in non-program order.</span></span> <span data-ttu-id="8b012-174">Diese Neuanordnung ist für Single Thread-nicht-Treibercode nie sichtbar, kann jedoch Probleme im Multithread-Code verursachen.</span><span class="sxs-lookup"><span data-stu-id="8b012-174">This rearranging is never visible to single-threaded non-driver code, but it can cause problems in multi-threaded code.</span></span>

### <a name="xbox-360"></a><span data-ttu-id="8b012-175">Xbox 360</span><span class="sxs-lookup"><span data-stu-id="8b012-175">Xbox 360</span></span>

<span data-ttu-id="8b012-176">Während die Xbox 360-CPU keine Neuanordnung von Anweisungen durchführt, werden Schreibvorgänge, die nach den Anweisungen selbst ausgeführt werden, neu angeordnet.</span><span class="sxs-lookup"><span data-stu-id="8b012-176">While the Xbox 360 CPU does not reorder instructions, it does rearrange write operations, which complete after the instructions themselves.</span></span> <span data-ttu-id="8b012-177">Diese Neuanordnung von Schreibvorgängen ist durch das PowerPC-Speichermodell ausdrücklich zulässig.</span><span class="sxs-lookup"><span data-stu-id="8b012-177">This rearranging of writes is specifically allowed by the PowerPC memory model.</span></span>

<span data-ttu-id="8b012-178">Schreibvorgänge auf Xbox 360 gelangen nicht direkt in den L2-Cache.</span><span class="sxs-lookup"><span data-stu-id="8b012-178">Writes on Xbox 360 do not go directly to the L2 cache.</span></span> <span data-ttu-id="8b012-179">Zum Verbessern der Schreib Bandbreite des L2-Caches durchlaufen Sie stattdessen Speicher Warteschlangen und dann Speicher-Gather-Puffer.</span><span class="sxs-lookup"><span data-stu-id="8b012-179">Instead, in order to improve L2 cache write bandwidth, they go through store queues and then to store-gather buffers.</span></span> <span data-ttu-id="8b012-180">Die Speicher-Gather-Puffer ermöglichen es, dass 64-Byte-Blöcke in einem Vorgang in den L2-Cache geschrieben werden.</span><span class="sxs-lookup"><span data-stu-id="8b012-180">The store-gather buffers allow 64-byte blocks to be written to the L2 cache in one operation.</span></span> <span data-ttu-id="8b012-181">Es gibt acht Speicher-Gather-Puffer, die effizientes Schreiben in verschiedene Bereiche des Arbeitsspeichers ermöglichen.</span><span class="sxs-lookup"><span data-stu-id="8b012-181">There are eight store-gather buffers, which allow efficient writing to several different areas of memory.</span></span>

<span data-ttu-id="8b012-182">Die Speicher-Gather-Puffer werden normalerweise in FIFO-Reihenfolge (First-in-First-Out) in den L2-Cache geschrieben.</span><span class="sxs-lookup"><span data-stu-id="8b012-182">The store-gather buffers are normally written to the L2 cache in first-in-first-out (FIFO) order.</span></span> <span data-ttu-id="8b012-183">Wenn sich die Ziel Cache Zeile eines Schreibzugriffs jedoch nicht im L2-Cache befindet, kann dieser Schreibvorgang verzögert werden, während die Cache Zeile aus dem Arbeitsspeicher abgerufen wird.</span><span class="sxs-lookup"><span data-stu-id="8b012-183">However, if the target cache-line of a write is not in the L2 cache, that write may be delayed while the cache-line is fetched from memory.</span></span>

<span data-ttu-id="8b012-184">Auch wenn die Speicher Sammel Puffer in strenger FIFO-Reihenfolge in den L2-Cache geschrieben werden, gewährleistet dies nicht, dass einzelne Schreibvorgänge in der richtigen Reihenfolge in den L2-Cache geschrieben werden.</span><span class="sxs-lookup"><span data-stu-id="8b012-184">Even when the store-gather buffers are written to the L2 cache in strict FIFO order, this does not guarantee that individual writes are written to the L2 cache in order.</span></span> <span data-ttu-id="8b012-185">Stellen Sie sich beispielsweise vor, dass die CPU an Speicherort 0x1000, dann an Speicherort 0x2000 und dann an Speicherort 0x1004 schreibt.</span><span class="sxs-lookup"><span data-stu-id="8b012-185">For instance, imagine that the CPU writes to location 0x1000, then to location 0x2000, and then to location 0x1004.</span></span> <span data-ttu-id="8b012-186">Beim ersten Schreibvorgang wird ein Speicher Sammel Puffer zugewiesen und an der Vorderseite der Warteschlange abgelegt.</span><span class="sxs-lookup"><span data-stu-id="8b012-186">The first write allocates a store-gather buffer and puts it at the front of the queue.</span></span> <span data-ttu-id="8b012-187">Der zweite Schreibvorgang ordnet einen anderen Store-Gather-Puffer zu und fügt ihn als nächstes in die Warteschlange ein.</span><span class="sxs-lookup"><span data-stu-id="8b012-187">The second write allocates another store-gather buffer and puts it next in the queue.</span></span> <span data-ttu-id="8b012-188">Der dritte Schreibvorgang fügt seine Daten zum ersten Store-Gather-Puffer hinzu, der am Anfang der Warteschlange verbleibt.</span><span class="sxs-lookup"><span data-stu-id="8b012-188">The third write adds its data to the first store-gather buffer, which remains at the front of the queue.</span></span> <span data-ttu-id="8b012-189">Daher wird der dritte Schreibvorgang vor dem zweiten Schreibvorgang in den L2-Cache überlaufen.</span><span class="sxs-lookup"><span data-stu-id="8b012-189">Thus, the third write ends up going to the L2 cache before the second write.</span></span>

<span data-ttu-id="8b012-190">Die Neuanordnung durch Speicher Sammel Puffer ist grundsätzlich unvorhersehbar, insbesondere weil beide Threads auf einem Kern die Speicher Sammel Puffer gemeinsam nutzen, sodass die Speicher Sammel Puffer stark variabel werden.</span><span class="sxs-lookup"><span data-stu-id="8b012-190">Reordering caused by store-gather buffers is fundamentally unpredictable, especially because both threads on a core share the store-gather buffers, making the allocation and emptying of the store-gather buffers highly variable.</span></span>

<span data-ttu-id="8b012-191">Dies ist ein Beispiel dafür, wie Schreibvorgänge neu angeordnet werden können.</span><span class="sxs-lookup"><span data-stu-id="8b012-191">This is one example of how writes can be reordered.</span></span> <span data-ttu-id="8b012-192">Möglicherweise gibt es weitere Möglichkeiten.</span><span class="sxs-lookup"><span data-stu-id="8b012-192">There may be other possibilities.</span></span>

### <a name="x86-and-x64"></a><span data-ttu-id="8b012-193">x86 und x64</span><span class="sxs-lookup"><span data-stu-id="8b012-193">x86 and x64</span></span>

<span data-ttu-id="8b012-194">Obwohl x86-und x64-CPUs Anweisungen neu anordnen, ordnen Sie Schreibvorgänge im Vergleich zu anderen Schreibvorgängen in der Regel nicht neu an.</span><span class="sxs-lookup"><span data-stu-id="8b012-194">Even though x86 and x64 CPUs do reorder instructions, they generally do not reorder write operations relative to other writes.</span></span> <span data-ttu-id="8b012-195">Es gibt einige Ausnahmen für den Schreib kombinierten Arbeitsspeicher.</span><span class="sxs-lookup"><span data-stu-id="8b012-195">There are some exceptions for write-combined memory.</span></span> <span data-ttu-id="8b012-196">Außerdem können Zeichen folgen Vorgänge (muvs und STOS) und 16-Byte-SSE-Schreibvorgänge intern neu angeordnet werden. andernfalls werden Schreibvorgänge relativ zueinander nicht neu angeordnet.</span><span class="sxs-lookup"><span data-stu-id="8b012-196">Additionally, string operations (MOVS and STOS) and 16-byte SSE writes can be internally reordered, but otherwise, writes are not reordered relative to each other.</span></span>

### <a name="understanding-cpu-rearrangement-of-reads"></a><span data-ttu-id="8b012-197">Grundlegendes zur CPU-Umgestaltung von Lesevorgängen</span><span class="sxs-lookup"><span data-stu-id="8b012-197">Understanding CPU Rearrangement of Reads</span></span>

<span data-ttu-id="8b012-198">Einige CPUs ordnen Lesevorgänge neu an, sodass Sie tatsächlich aus dem freigegebenen Speicher in nicht-Programm Reihenfolge stammen.</span><span class="sxs-lookup"><span data-stu-id="8b012-198">Some CPUs rearrange reads so that they effectively come from shared storage in non-program order.</span></span> <span data-ttu-id="8b012-199">Diese Neuanordnung ist für Single Thread-nicht-Treibercode nie sichtbar, kann jedoch Probleme im Multithread-Code verursachen.</span><span class="sxs-lookup"><span data-stu-id="8b012-199">This rearranging is never visible to single-threaded non-driver code, but can cause problems in multi-threaded code.</span></span>

### <a name="xbox-360"></a><span data-ttu-id="8b012-200">Xbox 360</span><span class="sxs-lookup"><span data-stu-id="8b012-200">Xbox 360</span></span>

<span data-ttu-id="8b012-201">Cache Fehler können dazu führen, dass einige Lesevorgänge verzögert werden, was dazu führt, dass Lesevorgänge nicht in der richtigen Reihenfolge aus dem freigegebenen Speicher stammen und die zeitliche Steuerung dieser Cache Fehler grundsätzlich unvorhersehbar ist.</span><span class="sxs-lookup"><span data-stu-id="8b012-201">Cache misses can cause some reads to be delayed, which effectively causes reads to come from shared memory out of order, and the timing of these cache misses is fundamentally unpredictable.</span></span> <span data-ttu-id="8b012-202">Ein Vorabruf und eine Verzweigungs Vorhersage können auch bewirken, dass Daten aus dem freigegebenen Speicher entfernt werden.</span><span class="sxs-lookup"><span data-stu-id="8b012-202">Prefetching and branch prediction can also cause data to come from shared memory out of order.</span></span> <span data-ttu-id="8b012-203">Dies sind nur einige Beispiele dafür, wie Lesevorgänge neu angeordnet werden können.</span><span class="sxs-lookup"><span data-stu-id="8b012-203">These are just a few examples of how reads can be reordered.</span></span> <span data-ttu-id="8b012-204">Möglicherweise gibt es weitere Möglichkeiten.</span><span class="sxs-lookup"><span data-stu-id="8b012-204">There may be other possibilities.</span></span> <span data-ttu-id="8b012-205">Diese Neuanordnung von Lesevorgängen ist durch das PowerPC-Speichermodell ausdrücklich zulässig.</span><span class="sxs-lookup"><span data-stu-id="8b012-205">This rearranging of reads is specifically allowed by the PowerPC memory model.</span></span>

### <a name="x86-and-x64"></a><span data-ttu-id="8b012-206">x86 und x64</span><span class="sxs-lookup"><span data-stu-id="8b012-206">x86 and x64</span></span>

<span data-ttu-id="8b012-207">Obwohl x86-und x64-CPUs Anweisungen neu anordnen, ordnen Sie Lesevorgänge im Vergleich zu anderen Lesevorgängen in der Regel nicht neu an.</span><span class="sxs-lookup"><span data-stu-id="8b012-207">Even though x86 and x64 CPUs do reorder instructions, they generally do not reorder read operations relative to other reads.</span></span> <span data-ttu-id="8b012-208">Zeichen folgen Operationen (muvs und STOS) und 16-Byte-SSE-Lesevorgänge können intern neu angeordnet werden. andernfalls werden Lesevorgänge relativ zueinander nicht neu angeordnet.</span><span class="sxs-lookup"><span data-stu-id="8b012-208">String operations (MOVS and STOS) and 16-byte SSE reads can be internally reordered, but otherwise, reads are not reordered relative to each other.</span></span>

### <a name="other-reordering"></a><span data-ttu-id="8b012-209">Andere Neuanordnen</span><span class="sxs-lookup"><span data-stu-id="8b012-209">Other Reordering</span></span>

<span data-ttu-id="8b012-210">Obwohl x86-und x64-CPUs Schreibvorgänge relativ zu anderen Schreibvorgängen nicht neu anordnen oder Lesevorgänge in Bezug auf andere Lesevorgänge neu anordnen, können Sie die Lesevorgänge relativ zu Schreibvorgängen umordnen.</span><span class="sxs-lookup"><span data-stu-id="8b012-210">Even though x86 and x64 CPUs do not reorder writes relative to other writes, or reorder reads relative to other reads, they can reorder reads relative to writes.</span></span> <span data-ttu-id="8b012-211">Insbesondere, wenn ein Programm auf einen Speicherort schreibt, gefolgt von einem Lesevorgang von einem anderen Speicherort, können die gelesenen Daten aus dem gemeinsam genutzten Speicher stammen, bevor Sie von den geschriebenen Daten erstellt werden.</span><span class="sxs-lookup"><span data-stu-id="8b012-211">Specifically, if a program writes to one location followed by reading from a different location, the read data may come from shared memory before the written data makes it there.</span></span> <span data-ttu-id="8b012-212">Diese Neuanordnung kann einige Algorithmen unterbrechen, wie z. b. die gegenseitigen Ausschluss Algorithmen von Dekker.</span><span class="sxs-lookup"><span data-stu-id="8b012-212">This reordering can break some algorithms, such as Dekker’s mutual exclusion algorithms.</span></span> <span data-ttu-id="8b012-213">In dem-Algorithmus von Dekker legt jeder Thread ein Flag fest, um anzugeben, dass der kritische Bereich eingegeben werden soll. Anschließend wird das Flag des anderen Threads überprüft, um festzustellen, ob sich der andere Thread in der kritischen Region befindet oder zu versuchen, ihn einzugeben.</span><span class="sxs-lookup"><span data-stu-id="8b012-213">In Dekker's algorithm, each thread sets a flag to indicate that it wants to enter the critical region, and then checks the other thread’s flag to see if the other thread is in the critical region or trying to enter it.</span></span> <span data-ttu-id="8b012-214">Der anfängliche Code folgt.</span><span class="sxs-lookup"><span data-stu-id="8b012-214">The initial code follows.</span></span>

``` syntax
volatile bool f0 = false;
volatile bool f1 = false;

void P0Acquire()
{
    // Indicate intention to enter critical region
    f0 = true;
    // Check for other thread in or entering critical region
    while (f1)
    {
        // Handle contention.
    }
    // critical region
    ...
}


void P1Acquire()
{
    // Indicate intention to enter critical region
    f1 = true;
    // Check for other thread in or entering critical region
    while (f0)
    {
        // Handle contention.
    }
    // critical region
    ...
}
```

<span data-ttu-id="8b012-215">Das Problem besteht darin, dass der Lesevorgang von F1 in P0Acquire aus dem freigegebenen Speicher lesen kann, bevor der Schreibvorgang in F0 den freigegebenen Speicher ermöglicht.</span><span class="sxs-lookup"><span data-stu-id="8b012-215">The problem is that the read of f1 in P0Acquire can read from shared storage before the write to f0 makes it to shared storage.</span></span> <span data-ttu-id="8b012-216">In der Zwischenzeit kann der Lesevorgang von F0 in P1Acquire aus dem freigegebenen Speicher lesen, bevor der Schreibvorgang in F1 den freigegebenen Speicher ermöglicht.</span><span class="sxs-lookup"><span data-stu-id="8b012-216">Meanwhile, the read of f0 in P1Acquire can read from shared storage before the write to f1 makes it to shared storage.</span></span> <span data-ttu-id="8b012-217">Im Endeffekt legen beide Threads ihre Flags auf true fest, und beide Threads sehen das Flag des anderen Threads als false, sodass beide Threads in den kritischen Bereich gelangen.</span><span class="sxs-lookup"><span data-stu-id="8b012-217">The net effect is that both threads set their flags to TRUE, and both threads see the other thread's flag as being FALSE, so they both enter the critical region.</span></span> <span data-ttu-id="8b012-218">Obwohl Probleme mit der Neuanordnung von x86-und x64-Systemen weniger häufig sind als auf Xbox 360, können Sie auf jeden Fall weiterhin auftreten.</span><span class="sxs-lookup"><span data-stu-id="8b012-218">Therefore, while problems with reordering on x86- and x64-based systems are less common than on Xbox 360, they definitely can still happen.</span></span> <span data-ttu-id="8b012-219">Der-Algorithmus von Dekker funktioniert nicht ohne Hardware Speicherbarrieren auf diesen Plattformen.</span><span class="sxs-lookup"><span data-stu-id="8b012-219">Dekker’s algorithm will not work without hardware memory barriers on any of these platforms.</span></span>

<span data-ttu-id="8b012-220">x86-und x64-CPUs ordnen einen Schreibvorgang nicht vor einem vorherigen Lesevorgang neu an.</span><span class="sxs-lookup"><span data-stu-id="8b012-220">x86 and x64 CPUs will not reorder a write ahead of a previous read.</span></span> <span data-ttu-id="8b012-221">x86-und x64-CPUs ordnen Lesevorgänge nur vor vorherigen Schreibvorgängen neu an, wenn Sie an unterschiedliche Positionen abzielen</span><span class="sxs-lookup"><span data-stu-id="8b012-221">x86 and x64 CPUs only reorder reads ahead of previous writes if they target different locations.</span></span>

<span data-ttu-id="8b012-222">PowerPC-CPUs können Lesevorgänge vor Schreibvorgängen neu anordnen und Schreibvorgänge vor Lesevorgängen neu anordnen, sofern Sie zu unterschiedlichen Adressen gehören.</span><span class="sxs-lookup"><span data-stu-id="8b012-222">PowerPC CPUs can reorder reads ahead of writes, and can reorder writes ahead of reads, as long as they are to different addresses.</span></span>

### <a name="reordering-summary"></a><span data-ttu-id="8b012-223">Zusammenfassung der Neuanordnung</span><span class="sxs-lookup"><span data-stu-id="8b012-223">Reordering Summary</span></span>

<span data-ttu-id="8b012-224">Die Xbox 360-CPU ordnet Arbeitsspeicher Vorgänge weitaus aggressiver als x86-und x64-CPUs an, wie in der folgenden Tabelle dargestellt.</span><span class="sxs-lookup"><span data-stu-id="8b012-224">The Xbox 360 CPU reorders memory operations much more aggressively than do x86 and x64 CPUs, as shown in the following table.</span></span> <span data-ttu-id="8b012-225">Weitere Informationen finden Sie in der Prozessor Dokumentation.</span><span class="sxs-lookup"><span data-stu-id="8b012-225">For more details, consult the processor documentation.</span></span>



| <span data-ttu-id="8b012-226">Neuanordnen von Aktivitäten</span><span class="sxs-lookup"><span data-stu-id="8b012-226">Reordering Activity</span></span>           | <span data-ttu-id="8b012-227">x86 und x64</span><span class="sxs-lookup"><span data-stu-id="8b012-227">x86 and x64</span></span> | <span data-ttu-id="8b012-228">Xbox 360</span><span class="sxs-lookup"><span data-stu-id="8b012-228">Xbox 360</span></span> |
|-------------------------------|-------------|----------|
| <span data-ttu-id="8b012-229">Lesevorgänge vor Lesevorgängen</span><span class="sxs-lookup"><span data-stu-id="8b012-229">Reads moving ahead of reads</span></span>   | <span data-ttu-id="8b012-230">Nein</span><span class="sxs-lookup"><span data-stu-id="8b012-230">No</span></span>          | <span data-ttu-id="8b012-231">Ja</span><span class="sxs-lookup"><span data-stu-id="8b012-231">Yes</span></span>      |
| <span data-ttu-id="8b012-232">Schreibvorgänge vor Schreibvorgängen</span><span class="sxs-lookup"><span data-stu-id="8b012-232">Writes moving ahead of writes</span></span> | <span data-ttu-id="8b012-233">Nein</span><span class="sxs-lookup"><span data-stu-id="8b012-233">No</span></span>          | <span data-ttu-id="8b012-234">Ja</span><span class="sxs-lookup"><span data-stu-id="8b012-234">Yes</span></span>      |
| <span data-ttu-id="8b012-235">Schreibvorgänge vor Lesevorgängen</span><span class="sxs-lookup"><span data-stu-id="8b012-235">Writes moving ahead of reads</span></span>  | <span data-ttu-id="8b012-236">Nein</span><span class="sxs-lookup"><span data-stu-id="8b012-236">No</span></span>          | <span data-ttu-id="8b012-237">Ja</span><span class="sxs-lookup"><span data-stu-id="8b012-237">Yes</span></span>      |
| <span data-ttu-id="8b012-238">Lesevorgänge vor Schreibvorgängen</span><span class="sxs-lookup"><span data-stu-id="8b012-238">Reads moving ahead of writes</span></span>  | <span data-ttu-id="8b012-239">Ja</span><span class="sxs-lookup"><span data-stu-id="8b012-239">Yes</span></span>         | <span data-ttu-id="8b012-240">Ja</span><span class="sxs-lookup"><span data-stu-id="8b012-240">Yes</span></span>      |



 

## <a name="read-acquire-and-write-release-barriers"></a><span data-ttu-id="8b012-241">Read-Acquire und Write-Release Barrieren</span><span class="sxs-lookup"><span data-stu-id="8b012-241">Read-Acquire and Write-Release Barriers</span></span>

<span data-ttu-id="8b012-242">Die Hauptkonstrukte, die verwendet werden, um die Neuanordnung von Lese-und Schreibvorgängen zu verhindern, werden als Lese-und Freigabe Barrieren bezeichnet.</span><span class="sxs-lookup"><span data-stu-id="8b012-242">The main constructs used to prevent reordering of reads and writes are called read-acquire and write-release barriers.</span></span> <span data-ttu-id="8b012-243">Ein Lese-und Abruf Vorgang ist ein Lesevorgang eines Flags oder einer anderen Variablen, um den Besitz einer Ressource zu erhalten, gekoppelt mit einer Barriere gegen Neuanordnen.</span><span class="sxs-lookup"><span data-stu-id="8b012-243">A read-acquire is a read of a flag or other variable to gain ownership of a resource, coupled with a barrier against reordering.</span></span> <span data-ttu-id="8b012-244">Ebenso ist ein Schreib Release ein Schreibvorgang eines Flags oder einer anderen Variablen, um den Besitz einer Ressource zu verkoppeln, gekoppelt mit einer Barriere gegen Neuanordnen.</span><span class="sxs-lookup"><span data-stu-id="8b012-244">Similarly, a write-release is a write of a flag or other variable to give away ownership of a resource, coupled with a barrier against reordering.</span></span>

<span data-ttu-id="8b012-245">Die formalen Definitionen (Courtesy of Herb Sutter) lauten wie folgt:</span><span class="sxs-lookup"><span data-stu-id="8b012-245">The formal definitions, courtesy of Herb Sutter, are:</span></span>

-   <span data-ttu-id="8b012-246">Ein Lese-/Abruf wird vor allen Lese-und Schreibvorgängen durch denselben Thread ausgeführt, der in der Programm Reihenfolge befolgt wird.</span><span class="sxs-lookup"><span data-stu-id="8b012-246">A read-acquire executes before all reads and writes by the same thread that follow it in program order.</span></span>
-   <span data-ttu-id="8b012-247">Ein Schreib Release wird ausgeführt, nachdem alle Lese-und Schreibvorgänge durch denselben Thread in der Programm Reihenfolge ausgeführt wurden.</span><span class="sxs-lookup"><span data-stu-id="8b012-247">A write-release executes after all reads and writes by the same thread that precede it in program order.</span></span>

<span data-ttu-id="8b012-248">Wenn Ihr Code den Besitz eines Speichers erhält, indem er entweder eine Sperre erhält oder ein Element aus einer freigegebenen verknüpften Liste (ohne Sperre) abruft, ist immer ein Lesevorgang beteiligt – das Testen eines Flags oder Zeigers, um festzustellen, ob der Besitz des Speichers abgerufen wurde.</span><span class="sxs-lookup"><span data-stu-id="8b012-248">When your code acquires ownership of some memory, either by acquiring a lock or by pulling an item off of a shared linked list (without a lock), there is always a read involved—testing a flag or pointer to see if ownership of the memory has been acquired.</span></span> <span data-ttu-id="8b012-249">Dieser Lesevorgang kann Teil eines **interlockedxxx** -Vorgangs sein. in diesem Fall umfasst er sowohl einen Lese-als auch einen Schreibvorgang. er ist jedoch der Lesevorgang, der angibt, ob der Besitz gewonnen wurde.</span><span class="sxs-lookup"><span data-stu-id="8b012-249">This read may be part of an **InterlockedXxx** operation, in which case it involves both a read and a write, but it is the read that indicates whether ownership has been gained.</span></span> <span data-ttu-id="8b012-250">Nachdem der Besitz des Speichers abgerufen wurde, werden die Werte in der Regel aus dem Speicher gelesen oder in diesen geschrieben. es ist sehr wichtig, dass diese Lese-und Schreibvorgänge nach dem Erwerb des Besitzes ausgeführt werden.</span><span class="sxs-lookup"><span data-stu-id="8b012-250">After ownership of the memory is acquired, values are typically read from or written to that memory, and it is very important that these reads and writes execute after acquiring ownership.</span></span> <span data-ttu-id="8b012-251">Dies wird durch eine Sperrgrenze gewährleistet.</span><span class="sxs-lookup"><span data-stu-id="8b012-251">A read-acquire barrier guarantees this.</span></span>

<span data-ttu-id="8b012-252">Wenn der Besitz eines Speichers freigegeben wird, indem entweder eine Sperre freigegeben oder ein Element auf eine freigegebene verknüpfte Liste übertragen wird, ist immer ein Schreibvorgang beteiligt, der andere Threads benachrichtigt, dass Ihnen der Arbeitsspeicher jetzt zur Verfügung steht.</span><span class="sxs-lookup"><span data-stu-id="8b012-252">When ownership of some memory is released, either by releasing a lock or by pushing an item on to a shared linked list, there is always a write involved which notifies other threads that the memory is now available to them.</span></span> <span data-ttu-id="8b012-253">Während Ihr Code den Besitz des Speichers besaß, wurde er wahrscheinlich von gelesen oder geschrieben, und es ist sehr wichtig, dass diese Lese-und Schreibvorgänge ausgeführt werden, bevor Sie den Besitz freigeben.</span><span class="sxs-lookup"><span data-stu-id="8b012-253">While your code had ownership of the memory, it probably read from or wrote to it, and it is very important that these reads and writes execute before releasing ownership.</span></span> <span data-ttu-id="8b012-254">Dies wird durch eine Barriere zum Schreiben von Releases sichergestellt.</span><span class="sxs-lookup"><span data-stu-id="8b012-254">A write-release barrier guarantees this.</span></span>

<span data-ttu-id="8b012-255">Es ist am einfachsten, die Sperren von Lese-und Schreib Freigaben als einzelne Vorgänge zu betrachten.</span><span class="sxs-lookup"><span data-stu-id="8b012-255">It is simplest to think of read-acquire and write-release barriers as single operations.</span></span> <span data-ttu-id="8b012-256">Manchmal müssen Sie jedoch aus zwei Teilen erstellt werden: ein Lese-oder Schreibvorgang und eine Barriere, bei der keine Lese-oder Schreibvorgänge über diese hinweg durchlaufen werden können.</span><span class="sxs-lookup"><span data-stu-id="8b012-256">However, they sometimes have to be constructed from two parts: a read or write and a barrier that does not allow reads or writes to move across it.</span></span> <span data-ttu-id="8b012-257">In diesem Fall ist die Platzierung der Barriere von entscheidender Bedeutung.</span><span class="sxs-lookup"><span data-stu-id="8b012-257">In this case, the placement of the barrier is critical.</span></span> <span data-ttu-id="8b012-258">Bei einer Barriere mit Lesezugriff wird zuerst der Lesevorgang des Flags, dann die Barriere und dann die Lese-und Schreibvorgänge für die freigegebenen Daten durchläuft.</span><span class="sxs-lookup"><span data-stu-id="8b012-258">For a read-acquire barrier, the read of the flag comes first, then the barrier, and then the reads and writes of the shared data.</span></span> <span data-ttu-id="8b012-259">Bei einer Barriere mit Schreib Freigabe werden zunächst die Lese-und Schreibvorgänge der freigegebenen Daten, dann die Barriere und der Schreibvorgang des Flags angezeigt.</span><span class="sxs-lookup"><span data-stu-id="8b012-259">For a write-release barrier the reads and writes of the shared data come first, then the barrier, and then the write of the flag.</span></span>

``` syntax
// Read that acquires the data.
if( g_flag )
{
    // Guarantee that the read of the flag executes before
    // all reads and writes that follow in program order.
    BarrierOfSomeSort();

    // Now we can read and write the shared data.
    int localVariable = sharedData.y;
    sharedData.x = 0;

    // Guarantee that the write to the flag executes after all
    // reads and writes that precede it in program order.
    BarrierOfSomeSort();
    
    // Write that releases the data.
    g_flag = false;
}
```

<span data-ttu-id="8b012-260">Der einzige Unterschied zwischen einem Lese-und einem Schreib Release ist der Speicherort der Arbeitsspeicher Barriere.</span><span class="sxs-lookup"><span data-stu-id="8b012-260">The only difference between a read-acquire and a write-release is the location of the memory barrier.</span></span> <span data-ttu-id="8b012-261">Ein Lese-/Abruf weist die Barriere nach dem Sperr Vorgang auf, und ein Schreib Release weist die Barriere vor.</span><span class="sxs-lookup"><span data-stu-id="8b012-261">A read-acquire has the barrier after the lock operation, and a write-release has the barrier before.</span></span> <span data-ttu-id="8b012-262">In beiden Fällen befindet sich die Barriere zwischen den verweisen auf den gesperrten Arbeitsspeicher und den verweisen auf die Sperre.</span><span class="sxs-lookup"><span data-stu-id="8b012-262">In both cases the barrier is in-between the references to the locked memory and the references to the lock.</span></span>

<span data-ttu-id="8b012-263">Um zu verstehen, warum Barrieren sowohl beim Abrufen als auch beim Freigeben von Daten erforderlich sind, ist es am besten (und genauesten), diese Barrieren so zu betrachten, dass die Synchronisierung mit frei gegebenem Speicher, nicht mit anderen Prozessoren gewährleistet ist</span><span class="sxs-lookup"><span data-stu-id="8b012-263">To understand why barriers are needed both when acquiring and when releasing data, it is best (and most accurate) to think of these barriers as guaranteeing synchronization with shared memory, not with other processors.</span></span> <span data-ttu-id="8b012-264">Wenn ein Prozessor ein Schreib Release verwendet, um eine Datenstruktur für den freigegebenen Arbeitsspeicher freizugeben, und ein anderer Prozessor einen Lese-/Abruf verwendet, um auf diese Datenstruktur aus dem freigegebenen Speicher zuzugreifen, funktioniert der Code ordnungsgemäß.</span><span class="sxs-lookup"><span data-stu-id="8b012-264">If one processor uses a write-release to release a data structure to shared memory, and another processor uses a read-acquire to gain access to that data structure from shared memory, the code will then work properly.</span></span> <span data-ttu-id="8b012-265">Wenn einer der beiden Prozessoren nicht die geeignete Barriere verwendet, kann die Datenfreigabe fehlschlagen.</span><span class="sxs-lookup"><span data-stu-id="8b012-265">If either processor doesn't use the appropriate barrier, the data sharing may fail.</span></span>

<span data-ttu-id="8b012-266">Die Verwendung der rechten Barriere, um zu verhindern, dass die kompieration von Compiler und CPU für Ihre Plattform entscheidend ist.</span><span class="sxs-lookup"><span data-stu-id="8b012-266">Using the right barrier to prevent compiler and CPU reordering for your platform is critical.</span></span>

<span data-ttu-id="8b012-267">Einer der Vorteile der Verwendung der vom Betriebssystem bereitgestellten Synchronisierungs primitiven besteht darin, dass alle die entsprechenden Speicherbarrieren enthalten.</span><span class="sxs-lookup"><span data-stu-id="8b012-267">One of the advantages of using the synchronization primitives provided by the operating system is that all of them include the appropriate memory barriers.</span></span>

## <a name="preventing-compiler-reordering"></a><span data-ttu-id="8b012-268">Verhindern der Neuanordnung von Compilers</span><span class="sxs-lookup"><span data-stu-id="8b012-268">Preventing Compiler Reordering</span></span>

<span data-ttu-id="8b012-269">Der Auftrag eines Compilers besteht darin, den Code aggressiv zu optimieren, um die Leistung zu verbessern.</span><span class="sxs-lookup"><span data-stu-id="8b012-269">A compiler's job is to aggressively optimize your code in order to improve performance.</span></span> <span data-ttu-id="8b012-270">Dies umfasst auch das Anordnen von Anweisungen, wenn dies hilfreich ist und immer dann, wenn das Verhalten nicht geändert wird.</span><span class="sxs-lookup"><span data-stu-id="8b012-270">This includes rearranging instructions wherever it is helpful and wherever it will not change behavior.</span></span> <span data-ttu-id="8b012-271">Da der C++-Standard nie Multithreading erwähnt und der Compiler nicht weiß, welcher Code Thread sicher sein muss, geht der Compiler davon aus, dass der Code mit einem einzigen Thread versehen wird, wenn er entscheidet, welche Neuanordnungen er sicher ausführen kann.</span><span class="sxs-lookup"><span data-stu-id="8b012-271">Because the C++ Standard never mentions multithreading, and because the compiler doesn't know what code needs to be thread-safe, the compiler assumes that your code is single-threaded when deciding what rearrangements it can safely do.</span></span> <span data-ttu-id="8b012-272">Daher müssen Sie den Compiler informieren, wenn es nicht zulässig ist, Lese-und Schreibvorgänge neu anzuordnen.</span><span class="sxs-lookup"><span data-stu-id="8b012-272">Therefore, you need to tell the compiler when it is not allowed to reorder reads and writes.</span></span>

<span data-ttu-id="8b012-273">Mit Visual C++ Sie die Neuanordnung von Compilers mithilfe der systeminternen [**\_ compilerbarriere**](https://msdn.microsoft.com/library/f20w0x5e(v=VS.71).aspx)von "Compiler" verhindern.</span><span class="sxs-lookup"><span data-stu-id="8b012-273">With Visual C++ you can prevent compiler reordering by using the compiler intrinsic [**\_ReadWriteBarrier**](https://msdn.microsoft.com/library/f20w0x5e(v=VS.71).aspx).</span></span> <span data-ttu-id="8b012-274">Wenn Sie "read- **\_ tebarrier** " in den Code einfügen, verschiebt der Compiler Lese-und Schreibvorgänge nicht über diesen.</span><span class="sxs-lookup"><span data-stu-id="8b012-274">Where you insert **\_ReadWriteBarrier** into your code, the compiler will not move reads and writes across it.</span></span>

``` syntax
#if _MSC_VER < 1400
    // With VC++ 2003 you need to declare _ReadWriteBarrier
    extern "C" void _ReadWriteBarrier();
#else
    // With VC++ 2005 you can get the declaration from intrin.h
#include <intrin.h>
#endif
// Tell the compiler that this is an intrinsic, not a function.
#pragma intrinsic(_ReadWriteBarrier)

// Create a new sprite by filling in a previously empty entry.
g_sprites[nextSprite].x = x;
g_sprites[nextSprite].y = y;
// Write-release, barrier followed by write.
// Guarantee that the compiler leaves the write to the flag
// after all reads and writes that precede it in program order.
_ReadWriteBarrier();
g_sprites[nextSprite].alive = true;
```

<span data-ttu-id="8b012-275">Im folgenden Code liest ein anderer Thread aus dem Sprite-Array:</span><span class="sxs-lookup"><span data-stu-id="8b012-275">In the following code, another thread reads from the sprite array:</span></span>

``` syntax
// Draw all sprites.
for( int i = 0; i < numSprites; ++i )
{

    // Read-acquire, read followed by barrier.
    if( g_sprites[nextSprite].alive )
    {
    
        // Guarantee that the compiler leaves the read of the flag
        // before all reads and writes that follow in program order.
        _ReadWriteBarrier();
        DrawSprite( g_sprites[nextSprite].x,
                g_sprites[nextSprite].y );
    }
}
```

<span data-ttu-id="8b012-276">Es ist wichtig zu verstehen, dass "read- [**\_ tebarrier**](https://msdn.microsoft.com/library/f20w0x5e(v=VS.71).aspx) " keine weiteren Anweisungen einfügt und nicht verhindert, dass die CPU Lese-und Schreibvorgänge neu anordnet – es wird lediglich verhindert, dass der Compiler Sie neu anordnet.</span><span class="sxs-lookup"><span data-stu-id="8b012-276">It is important to understand that [**\_ReadWriteBarrier**](https://msdn.microsoft.com/library/f20w0x5e(v=VS.71).aspx) does not insert any additional instructions, and it does not prevent the CPU from rearranging reads and writes—it only prevents the compiler from rearranging them.</span></span> <span data-ttu-id="8b012-277">Daher ist "Read-Write- **\_ Barriere** " ausreichend, wenn Sie eine Sperre für die Schreib Freigabe auf x86 und x64 implementieren (da x86 und x64 Schreibvorgänge nicht neu anordnen und ein normaler Schreibvorgang für die Freigabe einer Sperre ausreicht), aber in den meisten anderen Fällen ist es auch erforderlich, dass die CPU die Neuanordnung von Lese-und Schreibvorgängen verhindert.</span><span class="sxs-lookup"><span data-stu-id="8b012-277">Thus, **\_ReadWriteBarrier** is sufficient when you implement a write-release barrier on x86 and x64 (because x86 and x64 do not reorder writes, and a normal write is sufficient for releasing a lock), but in most other cases, it is also necessary to prevent the CPU from reordering reads and writes.</span></span>

<span data-ttu-id="8b012-278">Sie können auch "Read-Write- [**\_ Barrier**](https://msdn.microsoft.com/library/f20w0x5e(v=VS.71).aspx) " verwenden, wenn Sie in einen nicht zwischen speicherbaren Schreib kombinierten Arbeitsspeicher schreiben, um die Neuanordnung von Schreibvorgängen zu verhindern</span><span class="sxs-lookup"><span data-stu-id="8b012-278">You can also use [**\_ReadWriteBarrier**](https://msdn.microsoft.com/library/f20w0x5e(v=VS.71).aspx) when you write to non-cacheable write-combined memory to prevent reordering of writes.</span></span> <span data-ttu-id="8b012-279">In diesem Fall hilft "read **\_ Write** Items", die Leistung zu verbessern, indem sichergestellt wird, dass die Schreibvorgänge in der bevorzugten linearen Reihenfolge des Prozessors erfolgen</span><span class="sxs-lookup"><span data-stu-id="8b012-279">In this case **\_ReadWriteBarrier** helps to improve performance, by guaranteeing that the writes happen in the processor's preferred linear order.</span></span>

<span data-ttu-id="8b012-280">Es ist auch möglich, die Funktionen "read [**\_ Barrier**](https://msdn.microsoft.com/library/z055s48f(v=VS.80).aspx) " und " [**\_ Write Barrier**](https://msdn.microsoft.com/library/65tt87y8(v=VS.80).aspx) " zu verwenden, um die Neuanordnung des Compilers genauer zu steuern.</span><span class="sxs-lookup"><span data-stu-id="8b012-280">It is also possible to use the [**\_ReadBarrier**](https://msdn.microsoft.com/library/z055s48f(v=VS.80).aspx) and [**\_WriteBarrier**](https://msdn.microsoft.com/library/65tt87y8(v=VS.80).aspx) intrinsics for more precise control of compiler reordering.</span></span> <span data-ttu-id="8b012-281">Der Compiler verschiebt Lesevorgänge nicht über eine Read- **\_ Barriere**, und die Schreibvorgänge werden nicht über eine **\_ beschreibbare Barriere** verschoben.</span><span class="sxs-lookup"><span data-stu-id="8b012-281">The compiler will not move reads across a **\_ReadBarrier**, and it will not move writes across a **\_WriteBarrier**.</span></span>

## <a name="preventing-cpu-reordering"></a><span data-ttu-id="8b012-282">Verhindern der CPU-Neuanordnung</span><span class="sxs-lookup"><span data-stu-id="8b012-282">Preventing CPU Reordering</span></span>

<span data-ttu-id="8b012-283">Die erneute Reihenfolge der CPU-Reihenfolge ist besser als die erneute Reihenfolge</span><span class="sxs-lookup"><span data-stu-id="8b012-283">CPU reordering is more subtle than compiler reordering.</span></span> <span data-ttu-id="8b012-284">Sie können nicht jemals sehen, dass es direkt passiert, Sie sehen nur unerklärliche Fehler.</span><span class="sxs-lookup"><span data-stu-id="8b012-284">You can't ever see it happen directly, you just see inexplicable bugs.</span></span> <span data-ttu-id="8b012-285">Um die CPU-Neuanordnung von Lese-und Schreibvorgängen zu verhindern, müssen Sie bei manchen Prozessoren arbeitsspeicherabgrenzungsanweisungen verwenden.</span><span class="sxs-lookup"><span data-stu-id="8b012-285">In order to prevent CPU reordering of reads and writes you need to use memory barrier instructions, on some processors.</span></span> <span data-ttu-id="8b012-286">Der Name der vollständig verwendbare Speicher Absperr Anweisung auf Xbox 360 und unter Windows ist [**MemoryBarrier**](/windows/win32/api/winnt/nf-winnt-memorybarrier).</span><span class="sxs-lookup"><span data-stu-id="8b012-286">The all-purpose name for a memory barrier instruction, on Xbox 360 and on Windows, is [**MemoryBarrier**](/windows/win32/api/winnt/nf-winnt-memorybarrier).</span></span> <span data-ttu-id="8b012-287">Dieses Makro wird für jede Plattform Ordnungs entsprechend implementiert.</span><span class="sxs-lookup"><span data-stu-id="8b012-287">This macro is implemented appropriately for each platform.</span></span>

<span data-ttu-id="8b012-288">Auf Xbox 360 ist [**MemoryBarrier**](/windows/win32/api/winnt/nf-winnt-memorybarrier) als **lwsync** (Lightweight Sync) definiert, das auch über die systeminterne Funktion **\_ \_ lwsync** verfügbar ist, die in ppcintrinsics. h definiert ist.</span><span class="sxs-lookup"><span data-stu-id="8b012-288">On Xbox 360, [**MemoryBarrier**](/windows/win32/api/winnt/nf-winnt-memorybarrier) is defined as **lwsync** (lightweight sync), also available through the **\_\_lwsync** intrinsic, which is defined in ppcintrinsics.h.</span></span> <span data-ttu-id="8b012-289">**\_ \_ lwsync** dient auch als compilerarbeitsspeicherbarriere, die das erneute Anordnen von Lese-und Schreibvorgängen durch den Compiler verhindert.</span><span class="sxs-lookup"><span data-stu-id="8b012-289">**\_\_lwsync** also serves as a compiler memory barrier, preventing rearranging of reads and writes by the compiler.</span></span>

<span data-ttu-id="8b012-290">Die **lwsync** -Anweisung ist eine Arbeitsspeicher Barriere auf Xbox 360, die einen Prozessorkern mit dem L2-Cache synchronisiert.</span><span class="sxs-lookup"><span data-stu-id="8b012-290">The **lwsync** instruction is a memory barrier on Xbox 360 that synchronizes one processor core with the L2 cache.</span></span> <span data-ttu-id="8b012-291">Dadurch wird sichergestellt, dass alle Schreibvorgänge vor **lwsync** vor den nachfolgenden Schreibvorgängen in den L2-Cache gestellt werden.</span><span class="sxs-lookup"><span data-stu-id="8b012-291">It guarantees that all writes before **lwsync** make it to the L2 cache before any writes that follow.</span></span> <span data-ttu-id="8b012-292">Außerdem wird sichergestellt, dass bei Lesevorgängen, die **lwsync** folgen, keine älteren Daten von L2 als vorherige Lesevorgänge erhalten werden.</span><span class="sxs-lookup"><span data-stu-id="8b012-292">It also guarantees that any reads that follow **lwsync** don't get older data from L2 than previous reads.</span></span> <span data-ttu-id="8b012-293">Der einzige Typ der Neuanordnung, der nicht verhindert wird, ist ein Lesevorgang vor einem Schreibvorgang in eine andere Adresse.</span><span class="sxs-lookup"><span data-stu-id="8b012-293">The one type of reordering that it does not prevent is a read moving ahead of a write to a different address.</span></span> <span data-ttu-id="8b012-294">Folglich erzwingt **lwsync** eine Speicher Anordnung, die der Standard Arbeitsspeicher-Reihenfolge auf x86-und x64-Prozessoren entspricht.</span><span class="sxs-lookup"><span data-stu-id="8b012-294">Thus, **lwsync** enforces memory ordering that matches the default memory ordering on x86 and x64 processors.</span></span> <span data-ttu-id="8b012-295">Um die vollständige Arbeitsspeicher-Reihenfolge zu erhalten, ist die kostengünstigere Synchronisierungs Anweisung (auch als "schwere Synchronisierung" bezeichnet) erforderlich</span><span class="sxs-lookup"><span data-stu-id="8b012-295">To get full memory ordering requires the more expensive sync instruction (also known as heavyweight sync), but in most cases, this is not required.</span></span> <span data-ttu-id="8b012-296">In der folgenden Tabelle sind die Optionen für die Speicher Neuanordnung auf Xbox 360 aufgeführt.</span><span class="sxs-lookup"><span data-stu-id="8b012-296">The memory reordering options on Xbox 360 are shown in the following table.</span></span>



| <span data-ttu-id="8b012-297">Neuanordnung von Xbox 360</span><span class="sxs-lookup"><span data-stu-id="8b012-297">Xbox 360 Reordering</span></span>           | <span data-ttu-id="8b012-298">Keine Synchronisierung</span><span class="sxs-lookup"><span data-stu-id="8b012-298">No sync</span></span> | <span data-ttu-id="8b012-299">lwsync</span><span class="sxs-lookup"><span data-stu-id="8b012-299">lwsync</span></span> | <span data-ttu-id="8b012-300">sync</span><span class="sxs-lookup"><span data-stu-id="8b012-300">sync</span></span> |
|-------------------------------|---------|--------|------|
| <span data-ttu-id="8b012-301">Lesevorgänge vor Lesevorgängen</span><span class="sxs-lookup"><span data-stu-id="8b012-301">Reads moving ahead of reads</span></span>   | <span data-ttu-id="8b012-302">Ja</span><span class="sxs-lookup"><span data-stu-id="8b012-302">Yes</span></span>     | <span data-ttu-id="8b012-303">Nein</span><span class="sxs-lookup"><span data-stu-id="8b012-303">No</span></span>     | <span data-ttu-id="8b012-304">Nein</span><span class="sxs-lookup"><span data-stu-id="8b012-304">No</span></span>   |
| <span data-ttu-id="8b012-305">Schreibvorgänge vor Schreibvorgängen</span><span class="sxs-lookup"><span data-stu-id="8b012-305">Writes moving ahead of writes</span></span> | <span data-ttu-id="8b012-306">Ja</span><span class="sxs-lookup"><span data-stu-id="8b012-306">Yes</span></span>     | <span data-ttu-id="8b012-307">Nein</span><span class="sxs-lookup"><span data-stu-id="8b012-307">No</span></span>     | <span data-ttu-id="8b012-308">Nein</span><span class="sxs-lookup"><span data-stu-id="8b012-308">No</span></span>   |
| <span data-ttu-id="8b012-309">Schreibvorgänge vor Lesevorgängen</span><span class="sxs-lookup"><span data-stu-id="8b012-309">Writes moving ahead of reads</span></span>  | <span data-ttu-id="8b012-310">Ja</span><span class="sxs-lookup"><span data-stu-id="8b012-310">Yes</span></span>     | <span data-ttu-id="8b012-311">Nein</span><span class="sxs-lookup"><span data-stu-id="8b012-311">No</span></span>     | <span data-ttu-id="8b012-312">Nein</span><span class="sxs-lookup"><span data-stu-id="8b012-312">No</span></span>   |
| <span data-ttu-id="8b012-313">Lesevorgänge vor Schreibvorgängen</span><span class="sxs-lookup"><span data-stu-id="8b012-313">Reads moving ahead of writes</span></span>  | <span data-ttu-id="8b012-314">Ja</span><span class="sxs-lookup"><span data-stu-id="8b012-314">Yes</span></span>     | <span data-ttu-id="8b012-315">Ja</span><span class="sxs-lookup"><span data-stu-id="8b012-315">Yes</span></span>    | <span data-ttu-id="8b012-316">Nein</span><span class="sxs-lookup"><span data-stu-id="8b012-316">No</span></span>   |



 

<span data-ttu-id="8b012-317">PowerPC verfügt auch über die Synchronisierungs Anweisungen **iSync** und **eieio** (die zum Steuern der Neuanordnen von zwischen speichertem Speicher verwendet werden).</span><span class="sxs-lookup"><span data-stu-id="8b012-317">PowerPC also has the synchronization instructions **isync** and **eieio** (which is used to control reordering to caching-inhibited memory).</span></span> <span data-ttu-id="8b012-318">Diese Synchronisierungs Anweisungen sollten nicht für normale Synchronisierungs Zwecke benötigt werden.</span><span class="sxs-lookup"><span data-stu-id="8b012-318">These synchronization instructions should not be needed for normal synchronization purposes.</span></span>

<span data-ttu-id="8b012-319">Unter Windows ist [**MemoryBarrier**](/windows/win32/api/winnt/nf-winnt-memorybarrier) in "Winnt. h" definiert und gibt eine andere Speicher Absperr Anweisung aus, je nachdem, ob Sie für x86 oder x64 kompilieren.</span><span class="sxs-lookup"><span data-stu-id="8b012-319">On Windows, [**MemoryBarrier**](/windows/win32/api/winnt/nf-winnt-memorybarrier) is defined in Winnt.h and gives you a different memory barrier instruction depending on whether you are compiling for x86 or x64.</span></span> <span data-ttu-id="8b012-320">Die Speicher Abgrenzungs Anweisung dient als vollständige Barriere und verhindert die erneute Anordnung von Lese-und Schreibvorgängen über die Barriere hinweg.</span><span class="sxs-lookup"><span data-stu-id="8b012-320">The memory barrier instruction serves as a full barrier, preventing all reordering of reads and writes across the barrier.</span></span> <span data-ttu-id="8b012-321">Daher bietet **MemoryBarrier** unter Windows eine stärkere neubestell Garantie als auf Xbox 360.</span><span class="sxs-lookup"><span data-stu-id="8b012-321">Thus, **MemoryBarrier** on Windows gives a stronger reordering guarantee than it does on Xbox 360.</span></span>

<span data-ttu-id="8b012-322">Auf Xbox 360 und vielen anderen CPUs gibt es eine zusätzliche Möglichkeit, dass die Lese-und Neuanordnung durch die CPU verhindert werden kann.</span><span class="sxs-lookup"><span data-stu-id="8b012-322">On Xbox 360, and on many other CPUs, there is one additional way that read-reordering by the CPU can be prevented.</span></span> <span data-ttu-id="8b012-323">Wenn Sie einen Zeiger lesen und dann diesen Zeiger zum Laden anderer Daten verwenden, gewährleistet die CPU, dass die Lesevorgänge des Zeigers nicht älter sind als das Lesen des Zeigers.</span><span class="sxs-lookup"><span data-stu-id="8b012-323">If you read a pointer and then use that pointer to load other data, the CPU guarantees that the reads off of the pointer are not older than the read of the pointer.</span></span> <span data-ttu-id="8b012-324">Wenn das sperrenflag ein Zeiger ist und alle Lesevorgänge von freigegebenen Daten vom Zeiger entfernt sind, kann [**MemoryBarrier**](/windows/win32/api/winnt/nf-winnt-memorybarrier) weggelassen werden, um geringfügige Leistungs Einsparungen zu erzielen.</span><span class="sxs-lookup"><span data-stu-id="8b012-324">If your lock flag is a pointer and if all reads of shared data are off of the pointer, the [**MemoryBarrier**](/windows/win32/api/winnt/nf-winnt-memorybarrier) can be omitted, for a modest performance savings.</span></span>

``` syntax
Data* localPointer = g_sharedPointer;
if( localPointer )
{
    // No import barrier is needed--all reads off of localPointer
    // are guaranteed to not be reordered past the read of
    // localPointer.
    int localVariable = localPointer->y;
    // A memory barrier is needed to stop the read of g_global
    // from being speculatively moved ahead of the read of
    // g_sharedPointer.
    int localVariable2 = g_global;
}
```

<span data-ttu-id="8b012-325">Die [**MemoryBarrier**](/windows/win32/api/winnt/nf-winnt-memorybarrier) -Anweisung verhindert nur das Neuanordnen von Lese-und Schreibvorgängen in den zwischen speicherbaren Speicher.</span><span class="sxs-lookup"><span data-stu-id="8b012-325">The [**MemoryBarrier**](/windows/win32/api/winnt/nf-winnt-memorybarrier) instruction only prevents reordering of reads and writes to cacheable memory.</span></span> <span data-ttu-id="8b012-326">Wenn Sie Arbeitsspeicher als "page \_ NoCache" oder "page \_ Beschreib tecombine" zuweisen, ist dies ein gängiges Verfahren für Gerätetreiber Autoren und Spieleentwickler auf Xbox 360. **MemoryBarrier** hat keine Auswirkung auf den Zugriff auf diesen Arbeitsspeicher.</span><span class="sxs-lookup"><span data-stu-id="8b012-326">If you allocate memory as PAGE\_NOCACHE or PAGE\_WRITECOMBINE, a common technique for device driver authors and for game developers on Xbox 360, **MemoryBarrier** has no effect on accesses to this memory.</span></span> <span data-ttu-id="8b012-327">Die meisten Entwickler benötigen keine Synchronisierung des nicht zwischen speicherbaren Speichers.</span><span class="sxs-lookup"><span data-stu-id="8b012-327">Most developers don't need synchronization of non-cacheable memory.</span></span> <span data-ttu-id="8b012-328">Dies geht jedoch über den Rahmen dieses Artikels hinaus.</span><span class="sxs-lookup"><span data-stu-id="8b012-328">That is beyond the scope of this article.</span></span>

## <a name="interlocked-functions-and-cpu-reordering"></a><span data-ttu-id="8b012-329">Interlocked-Funktionen und CPU-Neuanordnung</span><span class="sxs-lookup"><span data-stu-id="8b012-329">Interlocked Functions and CPU Reordering</span></span>

<span data-ttu-id="8b012-330">Manchmal wird der Lese-oder Schreibvorgang, der eine Ressource übernimmt oder freigibt, mit einer der **interlockedxxx** -Funktionen durchgeführt.</span><span class="sxs-lookup"><span data-stu-id="8b012-330">Sometimes the read or write that acquires or releases a resource is done using one of the **InterlockedXxx** functions.</span></span> <span data-ttu-id="8b012-331">Unter Windows vereinfacht dies die Dinge. Da unter Windows die **interlockedxxx** -Funktionen alle vollständig im Arbeitsspeicher sind.</span><span class="sxs-lookup"><span data-stu-id="8b012-331">On Windows, this simplifies things; because on Windows, the **InterlockedXxx** functions are all full-memory barriers.</span></span> <span data-ttu-id="8b012-332">Sie verfügen praktisch über eine CPU-Arbeitsspeicher Barriere vor und nach dem Arbeitsspeicher, was bedeutet, dass Sie eine vollständige Lese-oder Schreib Freigabe Barriere allein darstellen.</span><span class="sxs-lookup"><span data-stu-id="8b012-332">They effectively have a CPU memory barrier both before and after them, which means that they are a full read-acquire or write-release barrier all by themselves.</span></span>

<span data-ttu-id="8b012-333">Auf Xbox 360 enthalten die **interlockedxxx** -Funktionen keine CPU-Speicherbarrieren.</span><span class="sxs-lookup"><span data-stu-id="8b012-333">On Xbox 360, the **InterlockedXxx** functions do not contain CPU memory barriers.</span></span> <span data-ttu-id="8b012-334">Sie verhindern die Neuanordnung von Lese-und Schreibvorgängen durch den Compiler, aber keine CPU-Neuanordnung</span><span class="sxs-lookup"><span data-stu-id="8b012-334">They prevent compiler reordering of reads and writes but not CPU reordering.</span></span> <span data-ttu-id="8b012-335">Daher sollten Sie in den meisten Fällen, wenn Sie die Funktionen von **interlockedxxx** auf Xbox 360 verwenden, eine **\_ \_ lwsync** voranstellen oder diesen folgen, um Sie als Sperre für Lese-oder Schreib Freigabe festzulegen.</span><span class="sxs-lookup"><span data-stu-id="8b012-335">Therefore, in most cases when using **InterlockedXxx** functions on Xbox 360, you should precede or follow them with an **\_\_lwsync**, to make them a read-acquire or write-release barrier.</span></span> <span data-ttu-id="8b012-336">Zur Vereinfachung und zur einfacheren **Lesbarkeit gibt es die Abruf-** und **Releaseversionen** vieler der **interlockedxxx** -Funktionen.</span><span class="sxs-lookup"><span data-stu-id="8b012-336">For convenience and for easier readability, there are **Acquire** and **Release** versions of many of the **InterlockedXxx** functions.</span></span> <span data-ttu-id="8b012-337">Diese verfügen über eine integrierte Speicherbarriere.</span><span class="sxs-lookup"><span data-stu-id="8b012-337">These come with a built-in memory barrier.</span></span> <span data-ttu-id="8b012-338">Beispielsweise führt [**interlockedinanmentabruf**](/previous-versions/windows/desktop/legacy/ms683618(v=vs.85)) eine Interlocked-Inkrement gefolgt von einer **\_ \_ lwsync** -Arbeitsspeicher Barriere aus, um die vollständige Funktionalität für den Lesezugriff zu erhalten.</span><span class="sxs-lookup"><span data-stu-id="8b012-338">For instance, [**InterlockedIncrementAcquire**](/previous-versions/windows/desktop/legacy/ms683618(v=vs.85)) does an interlocked increment followed by an **\_\_lwsync** memory barrier to give the full read-acquire functionality.</span></span>

<span data-ttu-id="8b012-339">Es wird empfohlen, dass Sie die **Abruf-und** **Releaseversionen** der **interlockedxxx** -Funktionen verwenden (die meisten unter Windows verfügbar sind, ohne Leistungseinbußen), um ihre Absicht deutlicher zu machen und die erforderlichen Speicher Absperr Anweisungen an der richtigen Stelle zu vereinfachen.</span><span class="sxs-lookup"><span data-stu-id="8b012-339">It is recommended that you use the **Acquire** and **Release** versions of the **InterlockedXxx** functions (most of which are available on Windows as well, with no performance penalty) to make your intent more obvious and to make it easier to get the memory barrier instructions in the correct place.</span></span> <span data-ttu-id="8b012-340">Jede Verwendung von **interlockedxxx** auf Xbox 360 ohne eine Arbeitsspeicher Barriere sollte sehr sorgfältig untersucht werden, da es sich häufig um einen Fehler handelt.</span><span class="sxs-lookup"><span data-stu-id="8b012-340">Any use of **InterlockedXxx** on Xbox 360 without a memory barrier should be examined very carefully, because it is often a bug.</span></span>

<span data-ttu-id="8b012-341">In diesem Beispiel wird veranschaulicht, wie ein Thread Tasks oder andere Daten mithilfe der Erstellungs **-** und **Releaseversionen** der **interlockedxxxslist** -Funktionen an einen anderen Thread übergeben kann.</span><span class="sxs-lookup"><span data-stu-id="8b012-341">This sample demonstrates how one thread can pass tasks or other data to another thread using the **Acquire** and **Release** versions of the **InterlockedXxxSList** functions.</span></span> <span data-ttu-id="8b012-342">Die **interlockedxxxslist** -Funktionen sind eine Reihe von Funktionen, mit denen eine freigegebene, einzeln verknüpfte Liste ohne Sperre verwaltet werden können.</span><span class="sxs-lookup"><span data-stu-id="8b012-342">The **InterlockedXxxSList** functions are a family of functions for maintaining a shared singly linked list without a lock.</span></span> <span data-ttu-id="8b012-343">Beachten Sie **, dass die** Abruf-und **releasevarianten** dieser Funktionen unter Windows nicht verfügbar sind, aber die regulären Versionen dieser Funktionen sind unter Windows eine vollständige Arbeitsspeicher Barriere.</span><span class="sxs-lookup"><span data-stu-id="8b012-343">Note that **Acquire** and **Release** variants of these functions are not available on Windows, but the regular versions of these functions are a full memory barrier on Windows.</span></span>

``` syntax
// Declarations for the Task class go here.

// Add a new task to the list using lockless programming.
void AddTask( DWORD ID, DWORD data )
{
    Task* newItem = new Task( ID, data );
    InterlockedPushEntrySListRelease( g_taskList, newItem );
}

// Remove a task from the list, using lockless programming.
// This will return NULL if there are no items in the list.
Task* GetTask()
{
    Task* result = (Task*)
        InterlockedPopEntrySListAcquire( g_taskList );
    return result;
}
```

## <a name="volatile-variables-and-reordering"></a><span data-ttu-id="8b012-344">Flüchtige Variablen und Neuanordnen</span><span class="sxs-lookup"><span data-stu-id="8b012-344">Volatile Variables and Reordering</span></span>

<span data-ttu-id="8b012-345">Der C++-Standard besagt, dass Lesevorgänge flüchtiger Variablen nicht zwischengespeichert werden können, flüchtige Schreibvorgänge nicht verzögert werden können und flüchtige Lese-und Schreibvorgänge nicht aufeinander hin verschoben werden können.</span><span class="sxs-lookup"><span data-stu-id="8b012-345">The C++ Standard says that reads of volatile variables cannot be cached, volatile writes cannot be delayed, and volatile reads and writes cannot be moved past each other.</span></span> <span data-ttu-id="8b012-346">Dies ist für die Kommunikation mit Hardware Geräten ausreichend, was der Zweck des volatile-Schlüssel Worts im C++-Standard ist.</span><span class="sxs-lookup"><span data-stu-id="8b012-346">This is sufficient for communicating with hardware devices, which is the purpose of the volatile keyword in the C++ Standard.</span></span>

<span data-ttu-id="8b012-347">Allerdings reichen die Garantien des Standards nicht aus, um volatile für das Multithreading zu verwenden.</span><span class="sxs-lookup"><span data-stu-id="8b012-347">However, the guarantees of the standard are not sufficient for using volatile for multi-threading.</span></span> <span data-ttu-id="8b012-348">Der C++-Standard hindert den Compiler nicht daran, nicht flüchtige Lese-und Schreibvorgänge relativ zu flüchtigen Lese-und Schreibvorgängen neu anzuordnen, und es wird nichts angezeigt, um die CPU-Neuanordnung zu verhindern.</span><span class="sxs-lookup"><span data-stu-id="8b012-348">The C++ Standard does not stop the compiler from reordering non-volatile reads and writes relative to volatile reads and writes, and it says nothing about preventing CPU reordering.</span></span>

<span data-ttu-id="8b012-349">Visual C++ 2005 überschreitet Standard C++, um Multithreading-freundliche Semantik für den flüchtigen Variablen Zugriff zu definieren.</span><span class="sxs-lookup"><span data-stu-id="8b012-349">Visual C++ 2005 goes beyond standard C++ to define multi-threading-friendly semantics for volatile variable access.</span></span> <span data-ttu-id="8b012-350">Ab Visual C++ 2005 werden Lesevorgänge aus flüchtigen Variablen als Semantik für den Lesezugriff definiert, und Schreibvorgänge in flüchtige Variablen sind so definiert, dass Sie über eine Semantik zur Schreib Freigabe verfügen.</span><span class="sxs-lookup"><span data-stu-id="8b012-350">Starting with Visual C++ 2005, reads from volatile variables are defined to have read-acquire semantics, and writes to volatile variables are defined to have write-release semantics.</span></span> <span data-ttu-id="8b012-351">Dies bedeutet, dass der Compiler Lese-und Schreibvorgänge nicht neu anordnet und unter Windows sicherstellt, dass die CPU dies auch nicht tut.</span><span class="sxs-lookup"><span data-stu-id="8b012-351">This means that the compiler will not rearrange any reads and writes past them, and on Windows it will ensure that the CPU does not do so either.</span></span>

<span data-ttu-id="8b012-352">Es ist wichtig zu verstehen, dass diese neuen Garantien nur für Visual C++ 2005 und zukünftige Versionen von Visual C++ gelten.</span><span class="sxs-lookup"><span data-stu-id="8b012-352">It is important to understand that these new guarantees only apply to Visual C++ 2005 and future versions of Visual C++.</span></span> <span data-ttu-id="8b012-353">Compiler von anderen Anbietern implementieren in der Regel eine andere Semantik, ohne dass die zusätzlichen Garantien Visual C++ 2005.</span><span class="sxs-lookup"><span data-stu-id="8b012-353">Compilers from other vendors will generally implement different semantics, without the extra guarantees of Visual C++ 2005.</span></span> <span data-ttu-id="8b012-354">Außerdem fügt der Compiler auf Xbox 360 keine Anweisungen ein, um zu verhindern, dass die CPU Lese-und Schreibvorgänge neu anordnet.</span><span class="sxs-lookup"><span data-stu-id="8b012-354">Also, on Xbox 360, the compiler does not insert any instructions to prevent the CPU from reordering reads and writes.</span></span>

## <a name="example-of-a-lock-free-data-pipe"></a><span data-ttu-id="8b012-355">Beispiel für eine Lock-Free Data Pipe</span><span class="sxs-lookup"><span data-stu-id="8b012-355">Example of a Lock-Free Data Pipe</span></span>

<span data-ttu-id="8b012-356">Eine Pipe ist ein Konstrukt, mit dem ein oder mehrere Threads Daten schreiben können, die dann von anderen Threads gelesen werden.</span><span class="sxs-lookup"><span data-stu-id="8b012-356">A pipe is a construct that lets one or more threads write data that is then read by other threads.</span></span> <span data-ttu-id="8b012-357">Eine sperrenlose Version einer Pipe kann eine elegante und effiziente Möglichkeit sein, die Arbeit vom Thread an den Thread zu übergeben.</span><span class="sxs-lookup"><span data-stu-id="8b012-357">A lockless version of a pipe can be an elegant and efficient way to pass work from thread to thread.</span></span> <span data-ttu-id="8b012-358">Das DirectX SDK bietet **lockfrepipe**, eine locker-Sperre mit einem einzigen Lesezeichen, die in dxutlockfrepipe. h verfügbar ist.</span><span class="sxs-lookup"><span data-stu-id="8b012-358">The DirectX SDK supplies **LockFreePipe**, a single-reader, single-writer lockless pipe that is available in DXUTLockFreePipe.h.</span></span> <span data-ttu-id="8b012-359">Die gleiche **lockfrepipe** ist im Xbox 360 SDK in atglockfrepipe. h verfügbar.</span><span class="sxs-lookup"><span data-stu-id="8b012-359">The same **LockFreePipe** is available in the Xbox 360 SDK in AtgLockFreePipe.h.</span></span>

<span data-ttu-id="8b012-360">**Lockfrepipe** kann verwendet werden, wenn zwei Threads eine Producer/Consumer-Beziehung haben.</span><span class="sxs-lookup"><span data-stu-id="8b012-360">**LockFreePipe** can be used when two threads have a producer/consumer relationship.</span></span> <span data-ttu-id="8b012-361">Der Producer-Thread kann Daten in die Pipe schreiben, damit der Consumerthread zu einem späteren Zeitpunkt verarbeitet werden kann, ohne jemals blockieren zu müssen.</span><span class="sxs-lookup"><span data-stu-id="8b012-361">The producer thread can write data to the pipe for the consumer thread to process at a later date, without ever blocking.</span></span> <span data-ttu-id="8b012-362">Wenn die Pipe aufgefüllt wird, können Schreibvorgänge fehlschlagen, und der Producer-Thread muss den Vorgang später wiederholen. Dies geschieht jedoch nur, wenn der Producer-Thread voraus ist.</span><span class="sxs-lookup"><span data-stu-id="8b012-362">If the pipe fills up, writes fail, and the producer thread will have to try again later, but this would only happen if the producer thread is ahead.</span></span> <span data-ttu-id="8b012-363">Wenn der senkrechter Strich angezeigt wird, treten bei Lesevorgängen Fehler auf, und der Consumerthread muss den Vorgang später wiederholen. Dies geschieht jedoch nur dann, wenn es keine Arbeit für den Consumerthread gibt.</span><span class="sxs-lookup"><span data-stu-id="8b012-363">If the pipe empties, reads fail, and the consumer thread will have to try again later, but this would only happen if there is no work for the consumer thread to do.</span></span> <span data-ttu-id="8b012-364">Wenn die beiden Threads ausgeglichen sind und die Pipe groß genug ist, können Sie mit der Pipe problemlos Daten zusammen mit keinen Verzögerungen oder Blöcken übergeben.</span><span class="sxs-lookup"><span data-stu-id="8b012-364">If the two threads are well-balanced, and the pipe is big enough, the pipe lets them smoothly pass data along with no delays or blocks.</span></span>

## <a name="xbox-360-performance"></a><span data-ttu-id="8b012-365">Leistung von Xbox 360</span><span class="sxs-lookup"><span data-stu-id="8b012-365">Xbox 360 Performance</span></span>

<span data-ttu-id="8b012-366">Die Leistung der Synchronisierungs Anweisungen und-Funktionen auf Xbox 360 variiert in Abhängigkeit davon, welche anderen Codes ausgeführt werden.</span><span class="sxs-lookup"><span data-stu-id="8b012-366">The performance of synchronization instructions and functions on Xbox 360 will vary depending on what other code is running.</span></span> <span data-ttu-id="8b012-367">Das Abrufen von Sperren dauert deutlich länger, wenn ein anderer Thread die Sperre zurzeit besitzt.</span><span class="sxs-lookup"><span data-stu-id="8b012-367">Acquiring locks will take much longer if another thread currently owns the lock.</span></span> <span data-ttu-id="8b012-368">[**Interlockedinkrement**](/windows/win32/api/winnt/nf-winnt-interlockedincrement) -und Critical-Abschnitts Vorgänge dauern erheblich länger, wenn andere Threads in dieselbe Cache Zeile schreiben.</span><span class="sxs-lookup"><span data-stu-id="8b012-368">[**InterlockedIncrement**](/windows/win32/api/winnt/nf-winnt-interlockedincrement) and critical section operations will take much longer if other threads are writing to the same cache line.</span></span> <span data-ttu-id="8b012-369">Der Inhalt der Speicher Warteschlangen kann sich auch auf die Leistung auswirken.</span><span class="sxs-lookup"><span data-stu-id="8b012-369">The contents of the store queues can also affect performance.</span></span> <span data-ttu-id="8b012-370">Daher sind all diese Zahlen nur Näherungen, die aus sehr einfachen Tests generiert werden:</span><span class="sxs-lookup"><span data-stu-id="8b012-370">Therefore, all of these numbers are just approximations, generated from very simple tests:</span></span>

-   <span data-ttu-id="8b012-371">**lwsync** wurde als 33-48 Zyklen gemessen.</span><span class="sxs-lookup"><span data-stu-id="8b012-371">**lwsync** was measured as taking 33-48 cycles.</span></span>
-   <span data-ttu-id="8b012-372">Die [**interlockedinkrement**](/windows/win32/api/winnt/nf-winnt-interlockedincrement) wurde als 225-260 Zyklen gemessen.</span><span class="sxs-lookup"><span data-stu-id="8b012-372">[**InterlockedIncrement**](/windows/win32/api/winnt/nf-winnt-interlockedincrement) was measured as taking 225-260 cycles.</span></span>
-   <span data-ttu-id="8b012-373">Das Abrufen oder Freigeben eines kritischen Abschnitts wurde als "ungefähr 345 Zyklen" gemessen.</span><span class="sxs-lookup"><span data-stu-id="8b012-373">Acquiring or releasing a critical section was measured as taking about 345 cycles.</span></span>
-   <span data-ttu-id="8b012-374">Das Abrufen oder Freigeben eines Mutex wurde als Wert von ungefähr 2350 Zyklen gemessen.</span><span class="sxs-lookup"><span data-stu-id="8b012-374">Acquiring or releasing a mutex was measured as taking about 2350 cycles.</span></span>

## <a name="windows-performance"></a><span data-ttu-id="8b012-375">Windows-Leistung</span><span class="sxs-lookup"><span data-stu-id="8b012-375">Windows Performance</span></span>

<span data-ttu-id="8b012-376">Die Leistung der Synchronisierungs Anweisungen und-Funktionen unter Windows variiert in Abhängigkeit vom Prozessortyp und der Konfiguration sowie davon, welcher anderer Code ausgeführt wird.</span><span class="sxs-lookup"><span data-stu-id="8b012-376">The performance of synchronization instructions and functions on Windows vary widely depending on the processor type and configuration, and on what other code is running.</span></span> <span data-ttu-id="8b012-377">Multicore-und multisocketsysteme beanspruchen häufig die Ausführung von Synchronisierungs Anweisungen länger, und das Abrufen von Sperren nimmt viel mehr Zeit in Anspruch, wenn ein anderer Thread die Sperre zurzeit besitzt.</span><span class="sxs-lookup"><span data-stu-id="8b012-377">Multi-core and multi-socket systems often take longer to execute synchronizing instructions, and acquiring locks take much longer if another thread currently owns the lock.</span></span>

<span data-ttu-id="8b012-378">Allerdings sind sogar einige von sehr einfachen Tests generierte Messungen hilfreich:</span><span class="sxs-lookup"><span data-stu-id="8b012-378">However, even some measurements generated from very simple tests are helpful:</span></span>

-   <span data-ttu-id="8b012-379">" [**MemoryBarrier**](/windows/win32/api/winnt/nf-winnt-memorybarrier) " wurde als 20-90 Zyklen gemessen.</span><span class="sxs-lookup"><span data-stu-id="8b012-379">[**MemoryBarrier**](/windows/win32/api/winnt/nf-winnt-memorybarrier) was measured as taking 20-90 cycles.</span></span>
-   <span data-ttu-id="8b012-380">Die [**interlockedinkrement**](/windows/win32/api/winnt/nf-winnt-interlockedincrement) wurde als 36-90 Zyklen gemessen.</span><span class="sxs-lookup"><span data-stu-id="8b012-380">[**InterlockedIncrement**](/windows/win32/api/winnt/nf-winnt-interlockedincrement) was measured as taking 36-90 cycles.</span></span>
-   <span data-ttu-id="8b012-381">Das Abrufen oder Freigeben eines kritischen Abschnitts wurde als 40-100 Zyklen gemessen.</span><span class="sxs-lookup"><span data-stu-id="8b012-381">Acquiring or releasing a critical section was measured as taking 40-100 cycles.</span></span>
-   <span data-ttu-id="8b012-382">Das Abrufen oder Freigeben eines Mutex wurde als Wert von ungefähr 750-2500 Zyklen gemessen.</span><span class="sxs-lookup"><span data-stu-id="8b012-382">Acquiring or releasing a mutex was measured as taking about 750-2500 cycles.</span></span>

<span data-ttu-id="8b012-383">Diese Tests wurden unter Windows XP für eine Reihe von verschiedenen Prozessoren ausgeführt.</span><span class="sxs-lookup"><span data-stu-id="8b012-383">These tests were done on Windows XP on a range of different processors.</span></span> <span data-ttu-id="8b012-384">Die kurzen Zeiten befanden sich auf einem Computer mit einem Prozessor, und die längeren Zeiten waren auf einem Computer mit mehreren Prozessoren.</span><span class="sxs-lookup"><span data-stu-id="8b012-384">The short times were on a single-processor machine, and the longer times were on a multi-processor machine.</span></span>

<span data-ttu-id="8b012-385">Das Abrufen und Freigeben von Sperren ist zwar kostengünstiger als die Verwendung der sperrenlosen Programmierung, aber es ist noch besser, Daten seltener freizugeben und so die Kosten vollständig zu vermeiden.</span><span class="sxs-lookup"><span data-stu-id="8b012-385">While acquiring and releasing locks is more expensive than using lockless programming, it is even better to share data less frequently, thus avoiding the cost altogether.</span></span>

## <a name="performance-thoughts"></a><span data-ttu-id="8b012-386">Leistungsgedanken</span><span class="sxs-lookup"><span data-stu-id="8b012-386">Performance Thoughts</span></span>

<span data-ttu-id="8b012-387">Das Abrufen oder Freigeben eines kritischen Abschnitts besteht aus einer Speicherbarriere, einem **interlockedxxx** -Vorgang und einigen zusätzlichen Überprüfungen, um die Rekursion zu verarbeiten und ggf. auf einen Mutex zurückzugreifen.</span><span class="sxs-lookup"><span data-stu-id="8b012-387">Acquiring or releasing a critical section consists of a memory barrier, an **InterlockedXxx** operation, and some extra checking to handle recursion and to fall back to a mutex, if necessary.</span></span> <span data-ttu-id="8b012-388">Sie sollten sich mit der Implementierung Ihres eigenen kritischen Abschnitts aushüten, da das Drehen in einer Schleife, die auf eine Sperre wartet, ohne zurück auf einen Mutex, eine beträchtliche Leistung verschwendet.</span><span class="sxs-lookup"><span data-stu-id="8b012-388">You should be wary of implementing your own critical section, because spinning in a loop waiting for a lock to be free, without falling back to a mutex, can waste considerable performance.</span></span> <span data-ttu-id="8b012-389">Bei kritischen Abschnitten, die stark in Konflikt stehen, aber nicht lange aufbewahrt werden, sollten Sie die Verwendung von " [**InitializeCriticalSectionAndSpinCount**](/windows/win32/api/synchapi/nf-synchapi-initializecriticalsectionandspincount) " in Erwägung gezogen, damit das Betriebssystem für einen spinnt, während darauf gewartet wird, dass der kritische Abschnitt verfügbar ist, und wenn der kritische Abschnitt im Besitz des Versuchs ist.</span><span class="sxs-lookup"><span data-stu-id="8b012-389">For critical sections that are heavily contended but not held for long, you should consider using [**InitializeCriticalSectionAndSpinCount**](/windows/win32/api/synchapi/nf-synchapi-initializecriticalsectionandspincount) so that the operating system will spin for a while waiting for the critical section to be available rather than immediately deferring to a mutex if the critical section is owned when you try to acquire it.</span></span> <span data-ttu-id="8b012-390">Um wichtige Abschnitte zu identifizieren, die von einer Spin-Anzahl profitieren können, ist es erforderlich, die Länge der typischen Wartezeit auf eine bestimmte Sperre zu messen.</span><span class="sxs-lookup"><span data-stu-id="8b012-390">In order to identify critical sections that can benefit from a spin count, it is necessary to measure the length of the typical wait for a particular lock.</span></span>

<span data-ttu-id="8b012-391">Wenn ein frei gegebener Heap für Speicher Belegungen verwendet wird – das Standardverhalten – erfordert jede Speicher Belegung und jede freie Sperre das Abrufen einer Sperre.</span><span class="sxs-lookup"><span data-stu-id="8b012-391">If a shared heap is used for memory allocations—the default behavior—every memory allocation and free involves acquiring a lock.</span></span> <span data-ttu-id="8b012-392">Wenn die Anzahl der Threads und die Anzahl der Zuordnungen zunimmt, wird die Leistungsstufe deaktiviert und schließlich verringert.</span><span class="sxs-lookup"><span data-stu-id="8b012-392">As the number of threads and the number of allocations increases, performance levels off, and eventually starts to decrease.</span></span> <span data-ttu-id="8b012-393">Durch die Verwendung von Thread spezifischen Heaps oder das Verringern der Anzahl von Zuordnungen kann dieser Sperr Engpass vermieden werden.</span><span class="sxs-lookup"><span data-stu-id="8b012-393">Using per-thread heaps, or reducing the number of allocations, can avoid this locking bottleneck.</span></span>

<span data-ttu-id="8b012-394">Wenn ein Thread Daten erzeugt und ein anderer Thread Daten beansprucht, werden diese möglicherweise häufig Daten gemeinsam nutzen.</span><span class="sxs-lookup"><span data-stu-id="8b012-394">If one thread is generating data and another thread is consuming data, they may end up sharing data frequently.</span></span> <span data-ttu-id="8b012-395">Dies kann vorkommen, wenn ein Thread Ressourcen lädt und ein anderer Thread die Szene rendert.</span><span class="sxs-lookup"><span data-stu-id="8b012-395">This can happen if one thread is loading resources and another thread is rendering the scene.</span></span> <span data-ttu-id="8b012-396">Wenn der Renderingthread auf die freigegebenen Daten bei jedem Zeichnen-Befehl verweist, ist der Sperr Aufwand hoch.</span><span class="sxs-lookup"><span data-stu-id="8b012-396">If the rendering thread references the shared data on every draw call, the locking overhead will be high.</span></span> <span data-ttu-id="8b012-397">Eine viel bessere Leistung kann erreicht werden, wenn jeder Thread über private Datenstrukturen verfügt, die dann einmal pro Frame oder weniger synchronisiert werden.</span><span class="sxs-lookup"><span data-stu-id="8b012-397">Much better performance can be realized if each thread has private data structures which are then synchronized once per frame or less.</span></span>

<span data-ttu-id="8b012-398">Sperr lose Algorithmen sind nicht garantiert schneller als Algorithmen, die Sperren verwenden.</span><span class="sxs-lookup"><span data-stu-id="8b012-398">Lockless algorithms are not guaranteed to be faster than algorithms that use locks.</span></span> <span data-ttu-id="8b012-399">Sie sollten überprüfen, ob Sperren tatsächlich Probleme verursachen, bevor Sie versuchen, Sie zu vermeiden, und Sie sollten Messen, ob der sperrenfreie Code tatsächlich die Leistung verbessert.</span><span class="sxs-lookup"><span data-stu-id="8b012-399">You should check to see if locks are actually causing you problems before trying to avoid them, and you should measure to see if your lockless code actually improves performance.</span></span>

## <a name="platform-differences-summary"></a><span data-ttu-id="8b012-400">Übersicht über Platt Form Unterschiede</span><span class="sxs-lookup"><span data-stu-id="8b012-400">Platform Differences Summary</span></span>

-   <span data-ttu-id="8b012-401">**Interlockedxxx** -Funktionen verhindern eine Neuanordnung der CPU-Lese-/Schreibvorgänge unter Windows, nicht jedoch auf Xbox 360.</span><span class="sxs-lookup"><span data-stu-id="8b012-401">**InterlockedXxx** functions prevent CPU read/write reordering on Windows, but not on Xbox 360.</span></span>
-   <span data-ttu-id="8b012-402">Das Lesen und Schreiben von flüchtigen Variablen mithilfe von Visual Studio C++ 2005 verhindert eine Neuanordnung der CPU-Lese-/Schreibvorgänge unter 360 Windows</span><span class="sxs-lookup"><span data-stu-id="8b012-402">Reading and writing of volatile variables using Visual Studio C++ 2005 prevents CPU read/write reordering on Windows, but on Xbox 360, it only prevents compiler read/write reordering.</span></span>
-   <span data-ttu-id="8b012-403">Schreibvorgänge werden auf Xbox 360 neu angeordnet, jedoch nicht auf x86 oder x64.</span><span class="sxs-lookup"><span data-stu-id="8b012-403">Writes are reordered on Xbox 360, but not on x86 or x64.</span></span>
-   <span data-ttu-id="8b012-404">Lesevorgänge werden auf Xbox 360 neu angeordnet, aber auf x86-oder x64-Daten werden Sie nur relativ zu Schreibvorgängen neu angeordnet, und nur, wenn die Lese-und Schreibvorgänge an unterschiedliche Speicherorte richten</span><span class="sxs-lookup"><span data-stu-id="8b012-404">Reads are reordered on Xbox 360, but on x86 or x64 they are only reordered relative to writes, and only if the reads and writes target different locations.</span></span>

## <a name="recommendations"></a><span data-ttu-id="8b012-405">Empfehlungen</span><span class="sxs-lookup"><span data-stu-id="8b012-405">Recommendations</span></span>

-   <span data-ttu-id="8b012-406">Verwenden Sie sperren, wenn möglich, da Sie leichter zu verwenden sind.</span><span class="sxs-lookup"><span data-stu-id="8b012-406">Use locks when possible because they are easier to use correctly.</span></span>
-   <span data-ttu-id="8b012-407">Vermeiden Sie eine zu häufige Sperre, sodass Sperrkosten nicht signifikant werden.</span><span class="sxs-lookup"><span data-stu-id="8b012-407">Avoid locking too frequently, so that locking costs do not become significant.</span></span>
-   <span data-ttu-id="8b012-408">Vermeiden Sie eine zu lange Sperre, um lange Stände zu vermeiden.</span><span class="sxs-lookup"><span data-stu-id="8b012-408">Avoid holding locks for too long, in order to avoid long stalls.</span></span>
-   <span data-ttu-id="8b012-409">Verwenden Sie ggf. die unlocklose Programmierung, aber stellen Sie sicher, dass die Vorteile die Komplexität rechtfertigen.</span><span class="sxs-lookup"><span data-stu-id="8b012-409">Use lockless programming when appropriate, but be sure that the gains justify the complexity.</span></span>
-   <span data-ttu-id="8b012-410">Verwenden Sie lockless Programming oder Spin Locks in Situationen, in denen andere Sperren nicht zulässig sind, z. b. bei der Freigabe von Daten zwischen verzögerten Prozedur aufrufen und normalem Code.</span><span class="sxs-lookup"><span data-stu-id="8b012-410">Use lockless programming or spin locks in situations where other locks are prohibited, such as when sharing data between deferred procedure calls and normal code.</span></span>
-   <span data-ttu-id="8b012-411">Verwenden Sie nur die standardmäßigen Sperr losen Programmierungs Algorithmen, die als richtig erwiesen wurden.</span><span class="sxs-lookup"><span data-stu-id="8b012-411">Only use standard lockless programming algorithms that have been proven to be correct.</span></span>
-   <span data-ttu-id="8b012-412">Achten Sie bei der sperlocklosen Programmierung darauf, dass Sie bei Bedarf flüchtige Flagvariablen und Speicher Abgrenzungs Anweisungen verwenden.</span><span class="sxs-lookup"><span data-stu-id="8b012-412">When doing lockless programming, be sure to use volatile flag variables and memory barrier instructions as needed.</span></span>
-   <span data-ttu-id="8b012-413">Wenn Sie **interlockedxxx** auf Xbox 360 verwenden, verwenden **Sie die Abruf** -und **releasevarianten** .</span><span class="sxs-lookup"><span data-stu-id="8b012-413">When using **InterlockedXxx** on Xbox 360, use the **Acquire** and **Release** variants.</span></span>

## <a name="references"></a><span data-ttu-id="8b012-414">References</span><span class="sxs-lookup"><span data-stu-id="8b012-414">References</span></span>

-   <span data-ttu-id="8b012-415">MSDN Library.</span><span class="sxs-lookup"><span data-stu-id="8b012-415">MSDN Library.</span></span> <span data-ttu-id="8b012-416">"[**volatile (C++)**](https://msdn.microsoft.com/library/12a04hfd(v=VS.71).aspx)".</span><span class="sxs-lookup"><span data-stu-id="8b012-416">"[**volatile (C++)**](https://msdn.microsoft.com/library/12a04hfd(v=VS.71).aspx)."</span></span> <span data-ttu-id="8b012-417">C++-Sprachreferenz.</span><span class="sxs-lookup"><span data-stu-id="8b012-417">C++ Language Reference.</span></span>
-   <span data-ttu-id="8b012-418">Vance Morrison.</span><span class="sxs-lookup"><span data-stu-id="8b012-418">Vance Morrison.</span></span> <span data-ttu-id="8b012-419">"[Verstehen der Auswirkungen von Low-Lock Techniken in Multithread-apps](/archive/msdn-magazine/2005/october/understanding-low-lock-techniques-in-multithreaded-apps)."</span><span class="sxs-lookup"><span data-stu-id="8b012-419">"[Understand the Impact of Low-Lock Techniques in Multithreaded Apps](/archive/msdn-magazine/2005/october/understanding-low-lock-techniques-in-multithreaded-apps)."</span></span> <span data-ttu-id="8b012-420">MSDN Magazine, Oktober 2005.</span><span class="sxs-lookup"><span data-stu-id="8b012-420">MSDN Magazine, October 2005.</span></span>
-   <span data-ttu-id="8b012-421">Lyons, Michael.</span><span class="sxs-lookup"><span data-stu-id="8b012-421">Lyons, Michael.</span></span> <span data-ttu-id="8b012-422">"[PowerPC-Speichermodell und AIX-Programmierung](https://www-128.ibm.com/developerworks/eserver/articles/powerpc.mdl)".</span><span class="sxs-lookup"><span data-stu-id="8b012-422">"[PowerPC Storage Model and AIX Programming](https://www-128.ibm.com/developerworks/eserver/articles/powerpc.mdl)."</span></span> <span data-ttu-id="8b012-423">IBM developerworks, 16. Nov., 2005.</span><span class="sxs-lookup"><span data-stu-id="8b012-423">IBM developerWorks, 16 Nov 2005.</span></span>
-   <span data-ttu-id="8b012-424">McKenney, Paul E. "Arbeits[Speicher Anordnung in modernen Mikroprozessoren, Teil II](https://www.linuxjournal.com/article/8212)."</span><span class="sxs-lookup"><span data-stu-id="8b012-424">McKenney, Paul E. "[Memory Ordering in Modern Microprocessors, Part II](https://www.linuxjournal.com/article/8212)."</span></span> <span data-ttu-id="8b012-425">Linux-Journal, September 2005.</span><span class="sxs-lookup"><span data-stu-id="8b012-425">Linux Journal, September 2005.</span></span> <span data-ttu-id="8b012-426">\[In diesem Artikel sind einige x86-Details aufgeführt.\]</span><span class="sxs-lookup"><span data-stu-id="8b012-426">\[This article has some x86 details.\]</span></span>
-   <span data-ttu-id="8b012-427">Intel Corporation.</span><span class="sxs-lookup"><span data-stu-id="8b012-427">Intel Corporation.</span></span> <span data-ttu-id="8b012-428">"[Intel® 64-Architektur Arbeitsspeicher-Reihen](https://www.cs.cmu.edu/~410-f10/doc/Intel_Reordering_318147.pdf)Folge."</span><span class="sxs-lookup"><span data-stu-id="8b012-428">"[Intel® 64 Architecture Memory Ordering](https://www.cs.cmu.edu/~410-f10/doc/Intel_Reordering_318147.pdf)."</span></span> <span data-ttu-id="8b012-429">2007. August.</span><span class="sxs-lookup"><span data-stu-id="8b012-429">August 2007.</span></span> <span data-ttu-id="8b012-430">\[Gilt sowohl für IA-32-als auch für Intel 64-Prozessoren.\]</span><span class="sxs-lookup"><span data-stu-id="8b012-430">\[Applies to both IA-32 and Intel 64 processors.\]</span></span>
-   <span data-ttu-id="8b012-431">Niebler, Eric.</span><span class="sxs-lookup"><span data-stu-id="8b012-431">Niebler, Eric.</span></span> <span data-ttu-id="8b012-432">"[Trip Report: Ad-hoc Meeting on Threads in C++](https://www.artima.com/cppsource/threads_meeting.html)".</span><span class="sxs-lookup"><span data-stu-id="8b012-432">"[Trip Report: Ad-Hoc Meeting on Threads in C++](https://www.artima.com/cppsource/threads_meeting.html)."</span></span> <span data-ttu-id="8b012-433">Die C++-Quelle, 17. Okt, 2006.</span><span class="sxs-lookup"><span data-stu-id="8b012-433">The C++ Source, 17 Oct 2006.</span></span>
-   <span data-ttu-id="8b012-434">Hart, Thomas E. 2006.</span><span class="sxs-lookup"><span data-stu-id="8b012-434">Hart, Thomas E. 2006.</span></span> <span data-ttu-id="8b012-435">"[Schnelles Sperren der Synchronisierung: Leistungseinbußen bei der Arbeitsspeicher Rückgewinnung](https://www.cs.toronto.edu/~tomhart/papers/hart_ipdps06.pdf)".</span><span class="sxs-lookup"><span data-stu-id="8b012-435">"[Making Lockless Synchronization Fast: Performance Implications of Memory Reclamation](https://www.cs.toronto.edu/~tomhart/papers/hart_ipdps06.pdf)."</span></span> <span data-ttu-id="8b012-436">Der Prozess des 2006 International Parallel and verteilte processing-Symposiums (IPDPS 2006), der Rhodos-Insel, Griechenland, April 2006.</span><span class="sxs-lookup"><span data-stu-id="8b012-436">Proceedings of the 2006 International Parallel and Distributed Processing Symposium (IPDPS 2006), Rhodes Island, Greece, April 2006.</span></span>

 

 