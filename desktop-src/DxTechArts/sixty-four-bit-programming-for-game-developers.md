---
title: 64-Bit-Programmierung für Spieleentwickler
description: In diesem Artikel werden Kompatibilitäts-und Portierungsprobleme behandelt und Entwickler bei der Umstellung auf 64-Bit-Plattformen unterstützt.
ms.assetid: 23a7ed41-6637-0607-327e-983b622e9104
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: b12e57ea1b3cc3272ca40465df31a04244d99e68
ms.sourcegitcommit: 592c9bbd22ba69802dc353bcb5eb30699f9e9403
ms.translationtype: MT
ms.contentlocale: de-DE
ms.lasthandoff: 08/20/2020
ms.locfileid: "104039311"
---
# <a name="64-bit-programming-for-game-developers"></a><span data-ttu-id="5147c-103">64-Bit-Programmierung für Spieleentwickler</span><span class="sxs-lookup"><span data-stu-id="5147c-103">64-bit programming for Game Developers</span></span>

<span data-ttu-id="5147c-104">Prozessor Hersteller liefern ausschließlich 64-Bit-Prozessoren auf Ihren Desktop Computern, und auch die Chip Sätze der meisten Laptop Computer unterstützen x64-Technologien.</span><span class="sxs-lookup"><span data-stu-id="5147c-104">Processor manufacturers are exclusively shipping 64-bit processors in their desktop computers, and even the chipsets of most laptop computers support x64 technology.</span></span> <span data-ttu-id="5147c-105">Es ist wichtig für Spieleentwickler, von den Verbesserungen zu profitieren, die 64-Bit-Prozessoren mit ihren neuen Anwendungen bieten, und um sicherzustellen, dass Ihre früheren Anwendungen ordnungsgemäß auf den neuen Prozessoren und in den 64-Bit-Editionen von Windows Vista und Windows 7 ausgeführt werden.</span><span class="sxs-lookup"><span data-stu-id="5147c-105">It is important for game developers to take advantage of the improvements that 64-bit processors offer with their new applications and to ensure that their earlier applications run correctly on the new processors and the 64-bit editions of Windows Vista and Windows 7.</span></span> <span data-ttu-id="5147c-106">In diesem Artikel werden Kompatibilitäts-und Portierungsprobleme behandelt und Entwickler bei der Umstellung auf 64-Bit-Plattformen unterstützt.</span><span class="sxs-lookup"><span data-stu-id="5147c-106">This article addresses compatibility and porting issues and helps developers ease their transition to 64-bit platforms.</span></span>

<span data-ttu-id="5147c-107">Microsoft verfügt derzeit über die folgenden 64-Bit-Betriebssysteme:</span><span class="sxs-lookup"><span data-stu-id="5147c-107">Microsoft currently has the following 64-bit operating systems:</span></span>

-   <span data-ttu-id="5147c-108">Windows Server 2003 Service Pack 1</span><span class="sxs-lookup"><span data-stu-id="5147c-108">Windows Server 2003 Service Pack 1</span></span>
-   <span data-ttu-id="5147c-109">Windows XP Professional x64 Edition (verfügbar für OEMs und Entwickler über MSDN)</span><span class="sxs-lookup"><span data-stu-id="5147c-109">Windows XP Professional x64 Edition (available to OEMs and to developers through MSDN)</span></span>
-   <span data-ttu-id="5147c-110">Windows Vista</span><span class="sxs-lookup"><span data-stu-id="5147c-110">Windows Vista</span></span>
-   <span data-ttu-id="5147c-111">Windows Server 2008</span><span class="sxs-lookup"><span data-stu-id="5147c-111">Windows Server 2008</span></span>
-   <span data-ttu-id="5147c-112">Windows 7</span><span class="sxs-lookup"><span data-stu-id="5147c-112">Windows 7</span></span>
-   <span data-ttu-id="5147c-113">Windows Server 2008 R2</span><span class="sxs-lookup"><span data-stu-id="5147c-113">Windows Server 2008 R2</span></span>

> [!Note]  
> <span data-ttu-id="5147c-114">Windows Server 2008 R2 ist nur als 64-Bit-Edition verfügbar.</span><span class="sxs-lookup"><span data-stu-id="5147c-114">Windows Server 2008 R2 is only available as a 64-bit edition.</span></span>

 

-   [<span data-ttu-id="5147c-115">Unterschiede im adressierbaren Speicher</span><span class="sxs-lookup"><span data-stu-id="5147c-115">Differences in Addressable Memory</span></span>](#differences-in-addressable-memory)
-   [<span data-ttu-id="5147c-116">Angeben von großen Adressen bei der Erstellung</span><span class="sxs-lookup"><span data-stu-id="5147c-116">Specifying Large-Address-Aware When Building</span></span>](#specifying-large-address-aware-when-building)
-   [<span data-ttu-id="5147c-117">Kompatibilität von 32-Bit-Anwendungen auf 64-Bit-Plattformen</span><span class="sxs-lookup"><span data-stu-id="5147c-117">Compatibility of 32-Bit Applications on 64-Bit Platforms</span></span>](#compatibility-of-32-bit-applications-on-64-bit-platforms)
    -   [<span data-ttu-id="5147c-118">Mögliche Kompatibilitäts Fehler</span><span class="sxs-lookup"><span data-stu-id="5147c-118">Potential Compatibility Pitfalls</span></span>](#potential-compatibility-pitfalls)
-   [<span data-ttu-id="5147c-119">Portieren von Anwendungen auf 64-Bit-Plattformen</span><span class="sxs-lookup"><span data-stu-id="5147c-119">Porting Applications to 64-Bit Platforms</span></span>](#porting-applications-to-64-bit-platforms)
-   [<span data-ttu-id="5147c-120">Profilerstellung und Optimierung von portierten Anwendungen</span><span class="sxs-lookup"><span data-stu-id="5147c-120">Profiling and Optimization of Ported Applications</span></span>](#profiling-and-optimization-of-ported-applications)
-   [<span data-ttu-id="5147c-121">Verwalteter Code auf einem 64-Bit-Betriebs System</span><span class="sxs-lookup"><span data-stu-id="5147c-121">Managed Code on a 64-bit Operating System</span></span>](#managed-code-on-a-64-bit-operating-system)
-   [<span data-ttu-id="5147c-122">Auswirkungen der Ausführung eines 64-Bit-Betriebssystems auf die Leistung</span><span class="sxs-lookup"><span data-stu-id="5147c-122">Performance Implications of Running a 64-bit Operating System</span></span>](#performance-implications-of-running-a-64-bit-operating-system)
-   [<span data-ttu-id="5147c-123">Zusammenfassung</span><span class="sxs-lookup"><span data-stu-id="5147c-123">Summary</span></span>](#summary)

## <a name="differences-in-addressable-memory"></a><span data-ttu-id="5147c-124">Unterschiede im adressierbaren Speicher</span><span class="sxs-lookup"><span data-stu-id="5147c-124">Differences in Addressable Memory</span></span>

<span data-ttu-id="5147c-125">Die meisten Entwickler bemerken zunächst, dass 64-Bit-Prozessoren einen großen Schritt in der Menge an physischem und virtuellem Arbeitsspeicher bereitstellen, der adressiert werden kann.</span><span class="sxs-lookup"><span data-stu-id="5147c-125">The first thing most developers notice is that 64-bit processors provide a huge leap in the amount of physical and virtual memory that can be addressed.</span></span>

-   <span data-ttu-id="5147c-126">32-Bit-Anwendungen auf 32-Bit-Plattformen können bis zu 2 GB adressieren.</span><span class="sxs-lookup"><span data-stu-id="5147c-126">32-bit applications on 32-bit platforms can address up to 2 GB.</span></span>
-   <span data-ttu-id="5147c-127">32-Bit-Anwendungen, die mit dem/LARGEADDRESSAWARE: Yes-linkerflag auf 32-Bit Windows XP oder Windows Server 2003 mit der/3GB-Startoption erstellt wurden, können bis zu 3 GB adressieren.</span><span class="sxs-lookup"><span data-stu-id="5147c-127">32-bit applications built with the /LARGEADDRESSAWARE:YES linker flag on 32-bit Windows XP or Windows Server 2003 with the special /3gb boot option can address up to 3 GB.</span></span> <span data-ttu-id="5147c-128">Dadurch wird der Kernel auf nur 1 GB beschränkt, was dazu führen kann, dass einige Treiber und/oder Dienste fehlschlagen.</span><span class="sxs-lookup"><span data-stu-id="5147c-128">This constrains the kernel to only 1 GB which may cause some drivers and/or services to fail.</span></span>
-   <span data-ttu-id="5147c-129">32-Bit-Anwendungen, die mit dem/LARGEADDRESSAWARE: Yes-linkerflag in den 32-Bit-Editionen von Windows Vista, Windows Server 2008 und Windows 7 erstellt wurden, können den Arbeitsspeicher bis zu dem vom Start Konfigurationsdaten-Element (BCD) angegebenen Wert adressieuserva adressieren.</span><span class="sxs-lookup"><span data-stu-id="5147c-129">32-bit applications built with the /LARGEADDRESSAWARE:YES linker flag on the 32-bit editions of Windows Vista, Windows Server 2008, and Windows 7 can address memory up to the number specified by the boot configuration data (BCD) element IncreaseUserVa.</span></span> <span data-ttu-id="5147c-130">Für "ereuserva" kann ein Wert zwischen 2048 (Standardwert) und 3072 (der mit der von der/3GB-Startoption unter Windows XP konfigurierten Speichermenge übereinstimmt) festgelegt werden.</span><span class="sxs-lookup"><span data-stu-id="5147c-130">IncreaseUserVa can have a value ranging from 2048, the default, to 3072 (which matches the amount of memory configured by the /3gb boot option on Windows XP).</span></span> <span data-ttu-id="5147c-131">Der Rest von 4 GB wird dem Kernel zugewiesen und kann zu fehlerhaften Treiber-und Dienst Konfigurationen führen.</span><span class="sxs-lookup"><span data-stu-id="5147c-131">The remainder of 4 GB is allocated to the kernel and can result in failing driver and service configurations.</span></span>

    <span data-ttu-id="5147c-132">Weitere Informationen zu BCD finden Sie unter [Startkonfigurationsdaten](https://msdn.microsoft.com/library/aa362692.aspx) auf MSDN.</span><span class="sxs-lookup"><span data-stu-id="5147c-132">For more information about BCD, see [Boot Configuration Data](https://msdn.microsoft.com/library/aa362692.aspx) on MSDN.</span></span>

-   <span data-ttu-id="5147c-133">32-Bit-Anwendungen auf 64-Bit-Plattformen können bis zu 2 GB oder bis zu 4 GB mit dem/LARGEADDRESSAWARE: Yes-linkerflag adressieren.</span><span class="sxs-lookup"><span data-stu-id="5147c-133">32-bit applications on 64-bit platforms can address up to 2 GB, or up to 4 GB with the /LARGEADDRESSAWARE:YES linker flag.</span></span>
-   <span data-ttu-id="5147c-134">64-Bit-Anwendungen verwenden 43 Bits für die Adressierung, die eine virtuelle Adresse von 8 TB für Anwendungen und 8 TB für den Kernel reserviert.</span><span class="sxs-lookup"><span data-stu-id="5147c-134">64-bit applications use 43 bits for addressing, which provides 8 TB of virtual address for applications and 8 TB reserved for the kernel.</span></span>

<span data-ttu-id="5147c-135">Über den Arbeitsspeicher hinaus werden 64-Bit-Anwendungen, die Speicher Abbild Datei-e/a nutzen, stark vom erweiterten virtuellen Adressraum profitieren.</span><span class="sxs-lookup"><span data-stu-id="5147c-135">Beyond just memory, 64-bit applications that use memory-mapped file I/O benefit greatly from the increased virtual address space.</span></span> <span data-ttu-id="5147c-136">Die 64-Bit-Architektur hat auch eine verbesserte Gleit Komma Leistung und ein schnelleres übergeben von Parametern.</span><span class="sxs-lookup"><span data-stu-id="5147c-136">The 64-bit architecture also has improved floating-point performance and faster passing of parameters.</span></span> <span data-ttu-id="5147c-137">64-Bit-Prozessoren haben die doppelte Anzahl von Registern, sowohl von "General Purpose"-als auch von Streaming SIMD Extensions (SSE)-Typen sowie von Unterstützung für SSE-und SSE2-Anweisungs Sätze. viele 64-Bit-Prozessoren unterstützen sogar SSE3-Anweisungs Sätze.</span><span class="sxs-lookup"><span data-stu-id="5147c-137">Sixty-four-bit processors have double the number of registers, of both general purpose and streaming SIMD extensions (SSE) types, as well as support for SSE and SSE2 instruction sets; many 64-bit processors even support SSE3 instruction sets.</span></span>

## <a name="specifying-large-address-aware-when-building"></a><span data-ttu-id="5147c-138">Angeben von großen Adressen bei der Erstellung</span><span class="sxs-lookup"><span data-stu-id="5147c-138">Specifying Large-Address-Aware When Building</span></span>

<span data-ttu-id="5147c-139">Es empfiehlt sich, bei der Erstellung von 32-Bit-Anwendungen mithilfe des Linkerflags/LARGEADDRESSAWARE auch dann, wenn die Anwendung nicht für eine 64-Bit-Plattform vorgesehen ist, die Groß-und klein zulegung zu unterstützen, da die Vorteile ohne Kosten entstehen.</span><span class="sxs-lookup"><span data-stu-id="5147c-139">It is a good practice to specify large-address-aware when building 32-bit applications, by using the linker flag /LARGEADDRESSAWARE, even if the application is not intended for a 64-bit platform, because of the advantages that are gained at no cost.</span></span> <span data-ttu-id="5147c-140">Wie bereits erläutert, ermöglicht das Aktivieren dieses Flags für einen Build einem 32-Bit-Programm den Zugriff auf mehr Arbeitsspeicher mit speziellen Startoptionen für ein 32-Bit-Betriebssystem oder ein 64-Bit-Betriebssystem.</span><span class="sxs-lookup"><span data-stu-id="5147c-140">As explained earlier, enabling this flag for a build allows a 32-bit program to access more memory with special boot options on a 32-bit OS or on a 64-bit OS.</span></span> <span data-ttu-id="5147c-141">Allerdings müssen Entwickler darauf achten, dass keine Zeiger Annahmen getroffen werden, wie z. b., wenn die High-Bit-Version niemals in einem 32-Bit-Zeiger festgelegt ist.</span><span class="sxs-lookup"><span data-stu-id="5147c-141">However, developers must be careful that pointer assumptions are not made, such as assuming that the high-bit is never set in a 32-bit pointer.</span></span> <span data-ttu-id="5147c-142">Im Allgemeinen empfiehlt es sich, das/LARGEADDRESSAWARE-Flag zu aktivieren.</span><span class="sxs-lookup"><span data-stu-id="5147c-142">In general, enabling the /LARGEADDRESSAWARE flag is a good practice.</span></span>

<span data-ttu-id="5147c-143">32-Bit-Anwendungen, die große Adressen unterstützen, können zur Laufzeit ermitteln, wie viel gesamter virtueller Adressraum mit der aktuellen Betriebssystem Konfiguration verfügbar ist, indem Sie [**GlobalMemoryStatus usex**](/windows/desktop/api/sysinfoapi/nf-sysinfoapi-globalmemorystatusex)aufrufen.</span><span class="sxs-lookup"><span data-stu-id="5147c-143">Thirty-two-bit applications that are large-address-aware can determine at run time how much total virtual address space is available to them with the current OS configuration by calling [**GlobalMemoryStatusEx**](/windows/desktop/api/sysinfoapi/nf-sysinfoapi-globalmemorystatusex).</span></span> <span data-ttu-id="5147c-144">Das ulltotalvirtual-Ergebnis reicht von 2147352576 bytes (2 GB) bis 4294836224 bytes (4 GB).</span><span class="sxs-lookup"><span data-stu-id="5147c-144">The ullTotalVirtual result will range from 2147352576 bytes (2 GB) to 4294836224 bytes (4 GB).</span></span> <span data-ttu-id="5147c-145">Werte, die größer als 3221094400 (3 GB) sind, können nur in 64-Bit-Editionen von Windows abgerufen werden.</span><span class="sxs-lookup"><span data-stu-id="5147c-145">Values that are larger than 3221094400 (3 GB) can only be obtained on 64-bit editions of Windows.</span></span> <span data-ttu-id="5147c-146">Wenn z. b. "ersetzeuserva" den Wert "2560" hat, ist das Ergebnis "ulltotalvirtual" mit einem Wert von 2684223488 bytes.</span><span class="sxs-lookup"><span data-stu-id="5147c-146">For example, if IncreaseUserVa has a value of 2560, the result is ullTotalVirtual with a value of 2684223488 bytes.</span></span>

## <a name="compatibility-of-32-bit-applications-on-64-bit-platforms"></a><span data-ttu-id="5147c-147">Kompatibilität von 32-Bit-Anwendungen auf 64-Bit-Plattformen</span><span class="sxs-lookup"><span data-stu-id="5147c-147">Compatibility of 32-Bit Applications on 64-Bit Platforms</span></span>

<span data-ttu-id="5147c-148">64-Bit-Windows-Betriebssysteme sind binär kompatibel mit der ia32-Architektur, und die meisten APIs, die von 32-Bit-Anwendungen verwendet werden, sind über das Windows 32-Bit unter Windows 64-Bit-Emulator WOW64 verfügbar.</span><span class="sxs-lookup"><span data-stu-id="5147c-148">Sixty-four-bit Windows operating systems are binary compatible with the IA32 architecture, and the majority of APIs that 32-bit applications use are available through the Windows 32-bit on Windows 64-bit Emulator, WOW64.</span></span> <span data-ttu-id="5147c-149">Mit WOW64 wird sichergestellt, dass diese APIs wie beabsichtigt funktionieren.</span><span class="sxs-lookup"><span data-stu-id="5147c-149">WOW64 helps ensure that these APIs will work as intended.</span></span>

<span data-ttu-id="5147c-150">WOW64 verfügt über eine Ausführungs Ebene, die das Marshalling von 32-Bit-Daten behandelt.</span><span class="sxs-lookup"><span data-stu-id="5147c-150">WOW64 has an execution layer that handles the marshalling of 32-bit data.</span></span> <span data-ttu-id="5147c-151">WOW64 umleitet dll-Datei Anforderungen, leitet einige registrierungsbranches für 32-Bit-Anwendungen um und reflektiert einige Registrierungs branches für 32-und 64-Bit-Anwendungen.</span><span class="sxs-lookup"><span data-stu-id="5147c-151">WOW64 redirects DLL file requests, redirects some registry branches for 32-bit applications, and reflects some registry branches for 32- and 64-bit applications.</span></span>

<span data-ttu-id="5147c-152">Weitere Informationen zu WOW64 finden Sie unter [WOW64-Implementierungs Details](/windows/desktop/WinProg64/wow64-implementation-details) auf MSDN.</span><span class="sxs-lookup"><span data-stu-id="5147c-152">More information on WOW64 can be found at [WOW64 Implementation Details](/windows/desktop/WinProg64/wow64-implementation-details) on MSDN.</span></span> <span data-ttu-id="5147c-153">Bewährte Methoden zum Entwickeln von Anwendungen, die auf WOW64 ausgeführt werden, finden Sie unter [Best Practices for WOW64](https://www.microsoft.com/whdc/system/platform/64bit/WoW64_bestprac.mspx) on Windows Hardware Developer Central.</span><span class="sxs-lookup"><span data-stu-id="5147c-153">For best practices for building applications that run on WOW64, see [Best Practices for WOW64](https://www.microsoft.com/whdc/system/platform/64bit/WoW64_bestprac.mspx) on Windows Hardware Developer Central.</span></span>

### <a name="potential-compatibility-pitfalls"></a><span data-ttu-id="5147c-154">Mögliche Kompatibilitäts Fehler</span><span class="sxs-lookup"><span data-stu-id="5147c-154">Potential Compatibility Pitfalls</span></span>

<span data-ttu-id="5147c-155">Die meisten Anwendungen, die für eine 32-Bit-Plattform entwickelt wurden, können ohne Probleme auf einer 64-Bit-Plattform ausgeführt werden.</span><span class="sxs-lookup"><span data-stu-id="5147c-155">Most applications developed for a 32-bit platform will run without problems on a 64-bit platform.</span></span> <span data-ttu-id="5147c-156">Einige Anwendungen können Probleme haben, die Folgendes umfassen können:</span><span class="sxs-lookup"><span data-stu-id="5147c-156">A few applications could have issues, which might include the following:</span></span>

-   <span data-ttu-id="5147c-157">Alle Treiber für die 64-Bit-Editionen von Windows-Betriebssystemen müssen 64-Bit-Versionen sein.</span><span class="sxs-lookup"><span data-stu-id="5147c-157">All drivers for by 64-bit editions of Windows operating systems must be 64-bit versions.</span></span> <span data-ttu-id="5147c-158">Das verlangen neuer 64-Bit-Treiber hat Auswirkungen auf Kopierschutz Schemas, die auf alten Treibern basieren.</span><span class="sxs-lookup"><span data-stu-id="5147c-158">Requiring new 64-bit drivers has implications for copy-protection schemes that rely on old drivers.</span></span> <span data-ttu-id="5147c-159">Beachten Sie, dass Kernelmodustreiber mit Authenticode signiert werden müssen, um von den 64-Bit-Editionen von Windows geladen zu werden.</span><span class="sxs-lookup"><span data-stu-id="5147c-159">Note that kernel-mode drivers must be Authenticode-signed to be loaded by 64-bit editions of Windows.</span></span>
-   <span data-ttu-id="5147c-160">64-Bit-Prozesse können keine 32-Bit-DLLs laden, und 32-Bit-Prozesse können keine 64-Bit-DLLs laden.</span><span class="sxs-lookup"><span data-stu-id="5147c-160">64-bit processes cannot load 32-bit DLLs, and 32-bit processes cannot load 64-bit DLLs.</span></span> <span data-ttu-id="5147c-161">Entwickler müssen sicherstellen, dass 64-Bit-Versionen von Drittanbieter-DLLs verfügbar sind, bevor Sie mit der Entwicklung fortfahren.</span><span class="sxs-lookup"><span data-stu-id="5147c-161">Developers must ensure that 64-bit versions of third-party DLLs are available before proceeding with development.</span></span> <span data-ttu-id="5147c-162">Wenn Sie in einem 64-Bit-Prozess eine 32-Bit-DLL verwenden müssen, können Sie die Windows-prozessübergreifende Kommunikation (Inter-Process Communication, IPC) verwenden.</span><span class="sxs-lookup"><span data-stu-id="5147c-162">If you must use a 32-bit DLL in a 64-bit process, then Windows inter-process communication (IPC) can be used.</span></span> <span data-ttu-id="5147c-163">COM-Komponenten können auch Out-of-Process-Server verwenden und Marshalling, um zwischen Grenzen zu kommunizieren. Dies kann jedoch zu einer Leistungs Einbuße führen.</span><span class="sxs-lookup"><span data-stu-id="5147c-163">COM components can also make use of out-of-process servers and marshalling to communicate between boundaries, but doing so may introduce a performance penalty.</span></span>
-   <span data-ttu-id="5147c-164">Viele x64-Prozessoren sind auch Multi-Core-Prozessoren, und Entwickler müssen testen, wie sich dies auf Ihre Legacy Anwendungen auswirkt.</span><span class="sxs-lookup"><span data-stu-id="5147c-164">Many x64 processors are also multi-core processors, and developers need to test to how this affects their legacy applications.</span></span> <span data-ttu-id="5147c-165">Weitere Informationen zu Multi-Core-Prozessoren und den Auswirkungen auf Spiele Anwendungen finden Sie unter [Game Timing und Multicore-Prozessoren](/windows/desktop/DxTechArts/game-timing-and-multicore-processors).</span><span class="sxs-lookup"><span data-stu-id="5147c-165">More information on multi-core processors and the implications for gaming applications can be found in [Game Timing and Multicore Processors](/windows/desktop/DxTechArts/game-timing-and-multicore-processors).</span></span>
-   <span data-ttu-id="5147c-166">Anwendungen sollten auch [**SHGetFolderPath**](/windows/desktop/api/shlobj_core/nf-shlobj_core-shgetfolderpatha) aufrufen, um Dateipfade zu ermitteln, da einige Ordnernamen in bestimmten Fällen geändert wurden.</span><span class="sxs-lookup"><span data-stu-id="5147c-166">Applications should also call [**SHGetFolderPath**](/windows/desktop/api/shlobj_core/nf-shlobj_core-shgetfolderpatha) to discover file paths, as some folder names have changed in certain cases.</span></span> <span data-ttu-id="5147c-167">CSIDL- \_ Programm \_ Dateien würden z. b. "c: \\ Program Files (x86)" für eine 32-Bit-Anwendung, die auf einer 64-Bit-Plattform ausgeführt wird, anstelle von "c: Program Files" zurückgeben \\ .</span><span class="sxs-lookup"><span data-stu-id="5147c-167">For example, CSIDL\_PROGRAM\_FILES would return "C:\\Program Files(x86)" for a 32-bit application running on a 64-bit platform instead of "C:\\Program Files".</span></span> <span data-ttu-id="5147c-168">Entwickler müssen berücksichtigen, wie die Umleitungs-und reflektionserfähigkeiten des WOW64-Emulators funktionieren.</span><span class="sxs-lookup"><span data-stu-id="5147c-168">Developers must be mindful of how the WOW64 emulator's redirection and reflection capabilities work.</span></span>

<span data-ttu-id="5147c-169">Außerdem müssen Entwickler mit 16-Bit-Programmen gewarnt werden, die Sie möglicherweise weiterhin verwenden.</span><span class="sxs-lookup"><span data-stu-id="5147c-169">In addition, developers need to be wary of 16-bit programs that they might still be using.</span></span> <span data-ttu-id="5147c-170">WOW64 kann keine 16-Bit-Anwendungen verarbeiten. Dies schließt alte Installationsprogramme und alle MS-DOS-Programme ein.</span><span class="sxs-lookup"><span data-stu-id="5147c-170">WOW64 cannot handle 16-bit applications; this includes old installers and all MS-DOS programs.</span></span>

> [!Note]  
> <span data-ttu-id="5147c-171">Die häufigsten Kompatibilitätsprobleme sind Installationsprogramme, die 16-Bit-Code ausführen und nicht über 64-Bit-Treiber für Kopierschutz Schemas verfügen.</span><span class="sxs-lookup"><span data-stu-id="5147c-171">The most common compatibility issues are installers that execute 16-bit code and not having 64-bit drivers for copy protection schemes.</span></span>

 

<span data-ttu-id="5147c-172">Im nächsten Abschnitt werden Probleme im Zusammenhang mit dem Portieren von Code auf 64-Bit-System eigen für Entwickler erläutert, die sicherstellen möchten, dass Ihre Legacy Programme auf 64-Bit-Plattformen</span><span class="sxs-lookup"><span data-stu-id="5147c-172">The next section discusses issues related to porting code to 64-bit native for developers that want to ensure their legacy programs work on 64-bit platforms.</span></span> <span data-ttu-id="5147c-173">Dies gilt auch für Entwickler, die mit der 64-Bit-Programmierung nicht vertraut sind.</span><span class="sxs-lookup"><span data-stu-id="5147c-173">It is also for developers who are unfamiliar with 64-bit programming.</span></span>

## <a name="porting-applications-to-64-bit-platforms"></a><span data-ttu-id="5147c-174">Portieren von Anwendungen auf 64-Bit-Plattformen</span><span class="sxs-lookup"><span data-stu-id="5147c-174">Porting Applications to 64-Bit Platforms</span></span>

<span data-ttu-id="5147c-175">Wenn Sie über die richtigen Tools und Bibliotheken verfügen, wird der Übergang von der 32-Bit-zu 64-Bit-Entwicklung erleichtert.</span><span class="sxs-lookup"><span data-stu-id="5147c-175">Having the right tools and libraries will help to ease the transition from 32-bit to 64-bit development.</span></span> <span data-ttu-id="5147c-176">Das DirectX 9 SDK verfügt über Bibliotheken zur Unterstützung von x86-und x64-basierten Projekten.</span><span class="sxs-lookup"><span data-stu-id="5147c-176">The DirectX 9 SDK has libraries to support both x86- and x64-based projects.</span></span> <span data-ttu-id="5147c-177">Microsoft Visual Studio 2005 und Visual Studio 2008 unterstützen die Codegenerierung für x86 und x64, und Sie verfügen über Bibliotheken, die für die Generierung von x64-Code optimiert sind.</span><span class="sxs-lookup"><span data-stu-id="5147c-177">Microsoft Visual Studio 2005 and Visual Studio 2008 support code generation for both x86 and x64, and they comes with libraries optimized for generating x64 code.</span></span> <span data-ttu-id="5147c-178">Es ist jedoch auch erforderlich, dass Entwickler die Visual C-Laufzeiten mit Ihren Anwendungen verteilen.</span><span class="sxs-lookup"><span data-stu-id="5147c-178">However, it will also be necessary for developers to distribute the Visual C runtimes with their applications.</span></span> <span data-ttu-id="5147c-179">Beachten Sie, dass die Express-Editionen von Visual Studio 2005 und Visual Studio 2008 nicht den x64-Compiler enthalten, sondern die Standard-, Professional-und Team System-Editionen.</span><span class="sxs-lookup"><span data-stu-id="5147c-179">Note that the Express Editions of Visual Studio 2005 and Visual Studio 2008 do not include the x64 compiler, but that the Standard, Professional, and Team System editions all do.</span></span>

<span data-ttu-id="5147c-180">Entwickler, die auf 32-Bit-Plattformen abzielen, können sich auf die 64-Bit-Entwicklung vorbereiten, um den Übergang später zu vereinfachen.</span><span class="sxs-lookup"><span data-stu-id="5147c-180">Developers who are targeting 32-bit platforms can prepare for 64-bit development to make their transition easier later on.</span></span> <span data-ttu-id="5147c-181">Beim Kompilieren von 32-Bit-Projekten sollten Entwickler das/Wp64-Flag verwenden, das die Generierung von Warnungen zu Problemen verursacht, die die Portabilität beeinflussen.</span><span class="sxs-lookup"><span data-stu-id="5147c-181">When compiling 32-bit projects, developers should use the /Wp64 flag, which will cause the generation of warnings about issues that affect portability.</span></span> <span data-ttu-id="5147c-182">Wenn Sie zu 64-Bit-Tools und-Bibliotheken wechseln, werden anfänglich wahrscheinlich viele neue Buildfehler generiert. Daher empfiehlt es sich, bitneutrale Tools und Bibliotheken zu wechseln und alle Warnungen zu korrigieren, bevor Sie zu einem 64-Bit-Build wechseln.</span><span class="sxs-lookup"><span data-stu-id="5147c-182">Switching to 64-bit tools and libraries will probably generate a lot of new build errors initially; so, it is advisable to switch bit-neutral tools and libraries and correct any warnings before switching to a 64-bit build.</span></span>

<span data-ttu-id="5147c-183">Das Ändern von Tools, das Ändern von Bibliotheken und die Verwendung bestimmter Compilerflags reicht jedoch nicht aus.</span><span class="sxs-lookup"><span data-stu-id="5147c-183">Changing tools, changing libraries, and using certain compiler flags will not be enough, though.</span></span> <span data-ttu-id="5147c-184">Annahmen in Codierungsstandards müssen neu ausgewertet werden, um sicherzustellen, dass die aktuellen Codierungsstandards keine Portabilitäts Probleme zulassen.</span><span class="sxs-lookup"><span data-stu-id="5147c-184">Assumptions in coding standards must be reevaluated to ensure that current coding standards don't allow portability issues.</span></span> <span data-ttu-id="5147c-185">Portabilitäts Probleme können das Abschneiden von Zeigern, die Größe und die Ausrichtung von Datentypen, die Abhängigkeit von 32-Bit-DLLs, die Verwendung von Legacy-APIs, Assemblycode und alte Binärdateien einschließen.</span><span class="sxs-lookup"><span data-stu-id="5147c-185">Portability issues can include pointer truncation, size and alignment of data types, reliance on 32-bit DLLs, use of legacy APIs, assembly code, and old binary files.</span></span>

> [!Note]  
> <span data-ttu-id="5147c-186">Visual C++ 2010 enthält die "stdint. h"-und "cstdint C99"-Header, die die standardportabilitäts Typen definieren Int32 \_ t, UInt32 \_ t, Int64 \_ t, UInt64 \_ t, IntPtr \_ t und UIntPtr \_ t.</span><span class="sxs-lookup"><span data-stu-id="5147c-186">Visual C++ 2010 includes the stdint.h and cstdint C99 headers which define the standard portability types int32\_t, uint32\_t, int64\_t, uint64\_t, intptr\_t, and uintptr\_t.</span></span> <span data-ttu-id="5147c-187">Die Verwendung dieser Datentypen mit den standardmäßigen ptrdiff \_ t-und size \_ t-Datentypen ist möglicherweise für die unten verwendeten Windows-portabationstypen zum Verbessern der Portabilität von Code vorzuziehen.</span><span class="sxs-lookup"><span data-stu-id="5147c-187">Using these along with the standard ptrdiff\_t and size\_t data types may be preferrable to the Windows portabilty types used below for improving portability of code.</span></span>

 

<span data-ttu-id="5147c-188">Wichtige Probleme bei der Portierung sind u. a.:</span><span class="sxs-lookup"><span data-stu-id="5147c-188">Major porting issues include the following:</span></span>

<dl> <dt>

<span data-ttu-id="5147c-189"><span id="Pointer_Truncation"></span><span id="pointer_truncation"></span><span id="POINTER_TRUNCATION"></span>**Abschneiden von Zeigern**</span><span class="sxs-lookup"><span data-stu-id="5147c-189"><span id="Pointer_Truncation"></span><span id="pointer_truncation"></span><span id="POINTER_TRUNCATION"></span>**Pointer Truncation**</span></span>
</dt> <dd>

<span data-ttu-id="5147c-190">Zeiger sind 64-Bit-Werte auf einem 64-Bit-Betriebssystem, sodass das Umwandeln von Zeigern auf andere Datentypen zu einem Abschneiden führen kann und Zeigerarithmetik zu Beschädigungen führen kann.</span><span class="sxs-lookup"><span data-stu-id="5147c-190">Pointers are 64-bits on a 64-bit OS, so casting pointers to other data types can result in truncation, and pointer arithmetic can result in corruption.</span></span> <span data-ttu-id="5147c-191">Die Verwendung des/Wp64-Flags stellt in der Regel eine Warnung zu dieser Art von Problem dar, aber die Verwendung von polymorphen Typen (int \_ ptr, DWORD \_ ptr, size \_ T, uint \_ ptr usw.) ist eine bewährte Vorgehensweise, um dieses Problem zu vermeiden.</span><span class="sxs-lookup"><span data-stu-id="5147c-191">Using the /Wp64 flag will usually provide a warning about this kind of issue, but using polymorphic types (INT\_PTR, DWORD\_PTR, SIZE\_T, UINT\_PTR, and so on) when casting pointer types is a good practice to help avoid this issue altogether.</span></span> <span data-ttu-id="5147c-192">Da Zeiger auf neuen Plattformen 64-Bit sind, sollten Entwickler die Reihenfolge von Zeigern und die Datentypen in Klassen und Strukturen überprüfen, um die Auffüll Zeichen zu reduzieren oder auszuschließen.</span><span class="sxs-lookup"><span data-stu-id="5147c-192">Since pointers are 64-bit on new platforms, developers should check the ordering of pointers, and the data types in classes and structures, to reduce or eliminate padding.</span></span>

</dd> <dt>

<span data-ttu-id="5147c-193"><span id="Data_Types_and_Binary_Files"></span><span id="data_types_and_binary_files"></span><span id="DATA_TYPES_AND_BINARY_FILES"></span>**Datentypen und Binärdateien**</span><span class="sxs-lookup"><span data-stu-id="5147c-193"><span id="Data_Types_and_Binary_Files"></span><span id="data_types_and_binary_files"></span><span id="DATA_TYPES_AND_BINARY_FILES"></span>**Data Types and Binary Files**</span></span>
</dt> <dd>

<span data-ttu-id="5147c-194">Während Zeiger auf einer 64-Bit-Plattform von 32 Bits auf 64 steigen, sind andere Datentypen nicht.</span><span class="sxs-lookup"><span data-stu-id="5147c-194">While pointers increase from 32 bits to 64 on a 64-bit platform, other data types don't.</span></span> <span data-ttu-id="5147c-195">Datentypen mit fester Genauigkeit (DWORD32, DWORD64, Int32, Int64, LONG32, LONG64, UInt32, UINT64) können an Stellen verwendet werden, an denen die Größe des Datentyps bekannt sein muss. beispielsweise in einer binären Dateistruktur.</span><span class="sxs-lookup"><span data-stu-id="5147c-195">Fixed-precision data types (DWORD32, DWORD64, INT32, INT64, LONG32, LONG64, UINT32, UINT64) can be used in places where the size of the data type must be known; for example, in a binary file structure.</span></span> <span data-ttu-id="5147c-196">Die Änderungen an der Zeiger Größe und der Daten Ausrichtung erfordern eine spezielle Behandlung, um die 32-Bit-zu-64-Bit-Kompatibilität sicherzustellen.</span><span class="sxs-lookup"><span data-stu-id="5147c-196">The changes in pointer size and data alignment require special handling to ensure 32-bit-to-64-bit compatibility.</span></span> <span data-ttu-id="5147c-197">Weitere Informationen finden Sie unter [vorbereiten für 64-Bit-Windows: die neuen Datentypen](/windows/desktop/WinProg64/the-new-data-types).</span><span class="sxs-lookup"><span data-stu-id="5147c-197">More information can be found in [Getting Ready for 64-bit Windows: The New Data Types](/windows/desktop/WinProg64/the-new-data-types).</span></span>

</dd> <dt>

<span data-ttu-id="5147c-198"><span id="Older_Win32_APIs_and_Data_Alignment"></span><span id="older_win32_apis_and_data_alignment"></span><span id="OLDER_WIN32_APIS_AND_DATA_ALIGNMENT"></span>**Ältere Win32-APIs und Daten Ausrichtung**</span><span class="sxs-lookup"><span data-stu-id="5147c-198"><span id="Older_Win32_APIs_and_Data_Alignment"></span><span id="older_win32_apis_and_data_alignment"></span><span id="OLDER_WIN32_APIS_AND_DATA_ALIGNMENT"></span>**Older Win32 APIs and Data Alignment**</span></span>
</dt> <dd>

<span data-ttu-id="5147c-199">Einige Win32-APIs wurden als veraltet markiert und durch komplexere API-Aufrufe, wie z. b. setwindowlongptr anstelle von SetWindowLong, ersetzt.</span><span class="sxs-lookup"><span data-stu-id="5147c-199">Some Win32 APIs have been deprecated and replaced with more neutral API calls such as SetWindowLongPtr in place of SetWindowLong.</span></span>

<span data-ttu-id="5147c-200">Die Leistungseinbußen bei nicht ausgerichteten Zugriffen sind auf der x64-Plattform höher als auf einer x86-Plattform.</span><span class="sxs-lookup"><span data-stu-id="5147c-200">The performance penalty for non-aligned accesses is greater on x64 platform than on an x86 platform.</span></span> <span data-ttu-id="5147c-201">Die \_ typausrichtung (t) und die Feld \_ Offset-Makros (t, Member) können verwendet werden, um Ausrichtungs Informationen zu bestimmen, die direkt im Code verwendet werden können.</span><span class="sxs-lookup"><span data-stu-id="5147c-201">The TYPE\_ALIGNMENT(t) and the FIELD\_OFFSET(t, member) macros can be used to determine alignment information that can used directly by code.</span></span> <span data-ttu-id="5147c-202">Die korrekte Verwendung dieser oben genannten Makros sollte mögliche nicht ausgerichtete Zugriffs Strafen vermeiden.</span><span class="sxs-lookup"><span data-stu-id="5147c-202">Correct use of these aforementioned macros should eliminate potential non-aligned access penalties.</span></span>

<span data-ttu-id="5147c-203">Weitere Informationen zum Type \_ Alignment-Makro, das Field \_ Offset-Makro und allgemeine 64-Bit-Programmierinformationen finden Sie unter [64-Bit-Windows-Programmierung: Migrations Tipps: Weitere Überlegungen](/windows/desktop/WinProg64/additional-considerations) und vorbereiten [für 64-Bit-Windows: Regeln für die Verwendung von Zeigern](/windows/desktop/WinProg64/rules-for-using-pointers).</span><span class="sxs-lookup"><span data-stu-id="5147c-203">More information on the TYPE\_ALIGNMENT macro, the FIELD\_OFFSET macro, and general 64-bit programming information can be found at [64-bit Windows Programming: Migration Tips: Additional Considerations](/windows/desktop/WinProg64/additional-considerations) and [Getting Ready for 64-bit Windows: Rules for Using Pointers](/windows/desktop/WinProg64/rules-for-using-pointers).</span></span>

</dd> <dt>

<span data-ttu-id="5147c-204"><span id="Assembly_Code"></span><span id="assembly_code"></span><span id="ASSEMBLY_CODE"></span>**Assemblycode**</span><span class="sxs-lookup"><span data-stu-id="5147c-204"><span id="Assembly_Code"></span><span id="assembly_code"></span><span id="ASSEMBLY_CODE"></span>**Assembly Code**</span></span>
</dt> <dd>

<span data-ttu-id="5147c-205">Inline-Assemblycode wird auf 64-Bit-Plattformen nicht unterstützt und muss ersetzt werden.</span><span class="sxs-lookup"><span data-stu-id="5147c-205">Inline assembly code is not supported on 64-bit platforms and needs to be replaced.</span></span> <span data-ttu-id="5147c-206">Änderungen an der Architektur haben möglicherweise Anwendungs Engpässe geändert, und C/C++ oder intrinsische Funktionen können ähnliche Ergebnisse mit Code erzielen, der leichter lesbar ist.</span><span class="sxs-lookup"><span data-stu-id="5147c-206">Changes in the architecture may have changed application bottlenecks, and C/C++ or intrinsics can achieve similar results with code that is easier to read.</span></span> <span data-ttu-id="5147c-207">Die empfohlene Vorgehensweise besteht darin, den gesamten Assemblycode in C oder C++ zu ändern.</span><span class="sxs-lookup"><span data-stu-id="5147c-207">The most advisable practice is to switch all assembly code to C or C++.</span></span> <span data-ttu-id="5147c-208">Intrinsie können anstelle von Assemblycode verwendet werden, sollten aber nur nach der vollständigen Profilerstellung und Analyse verwendet werden.</span><span class="sxs-lookup"><span data-stu-id="5147c-208">Intrinsics can be used in place of assembly code, but should only be used after full profiling and analysis has been performed.</span></span>

<span data-ttu-id="5147c-209">X87, MMX und 3dnow!</span><span class="sxs-lookup"><span data-stu-id="5147c-209">The x87, MMX, and 3DNow!</span></span> <span data-ttu-id="5147c-210">Anweisungs Sätze werden im 64-Bit-Modus als veraltet markiert.</span><span class="sxs-lookup"><span data-stu-id="5147c-210">instruction sets are deprecated in 64-bit modes.</span></span> <span data-ttu-id="5147c-211">Die Anweisungs Sätze sind zur Abwärtskompatibilität für den 32-Bit-Modus weiterhin vorhanden. um Kompatibilitätsprobleme in Zukunft zu vermeiden, wird jedoch davon abgeraten, die Verwendung in aktuellen und zukünftigen Projekten zu vermeiden.</span><span class="sxs-lookup"><span data-stu-id="5147c-211">The instructions sets are still present for backward compatibility for 32-bit mode; however, to avoid compatibility issues in the future, their use in current and future projects is discouraged.</span></span>

</dd> <dt>

<span data-ttu-id="5147c-212"><span id="Deprecated_APIs"></span><span id="deprecated_apis"></span><span id="DEPRECATED_APIS"></span>**Veraltete APIs**</span><span class="sxs-lookup"><span data-stu-id="5147c-212"><span id="Deprecated_APIs"></span><span id="deprecated_apis"></span><span id="DEPRECATED_APIS"></span>**Deprecated APIs**</span></span>
</dt> <dd>

<span data-ttu-id="5147c-213">Einige ältere DirectX-APIs wurden für Native 64-Bit-Anwendungen gelöscht: DirectPlay 4 und früher, DirectDraw 6 und früher, Direct3D 8 und früher und DirectInput 7 und früher.</span><span class="sxs-lookup"><span data-stu-id="5147c-213">Some older DirectX APIs have been dropped for 64-bit native applications: DirectPlay 4 and earlier, DirectDraw 6 and earlier, Direct3D 8 and earlier, and DirectInput 7 and earlier.</span></span> <span data-ttu-id="5147c-214">Außerdem ist die Kern-API von DirectMusic für Native 64-Bit-Anwendungen verfügbar, aber die Leistungs Ebene und der DirectMusic-Producer sind veraltet.</span><span class="sxs-lookup"><span data-stu-id="5147c-214">Also, the core API of DirectMusic is available to native 64-bit applications, but the performance layer and DirectMusic Producer are deprecated.</span></span>

<span data-ttu-id="5147c-215">Visual Studio gibt veraltete Warnungen aus, und diese Änderungen sind kein Problem für Entwickler, die die neuesten APIs verwenden.</span><span class="sxs-lookup"><span data-stu-id="5147c-215">Visual Studio issues deprecation warnings, and these changes are not an issue for developers who use the latest APIs.</span></span>

</dd> </dl>

## <a name="profiling-and-optimization-of-ported-applications"></a><span data-ttu-id="5147c-216">Profilerstellung und Optimierung von portierten Anwendungen</span><span class="sxs-lookup"><span data-stu-id="5147c-216">Profiling and Optimization of Ported Applications</span></span>

<span data-ttu-id="5147c-217">Alle Entwickler müssen Profile für alle Anwendungen neu erstellen, die in neue Architekturen portiert werden.</span><span class="sxs-lookup"><span data-stu-id="5147c-217">All developers need to re-profile any applications that are being ported to new architectures.</span></span> <span data-ttu-id="5147c-218">Viele Anwendungen, die auf 64-Bit-Plattformen portiert werden, haben unterschiedliche Leistungsprofile von ihren 32-Bit-Versionen.</span><span class="sxs-lookup"><span data-stu-id="5147c-218">Many applications being ported to 64-bit platforms will have different performance profiles from their 32-bit versions.</span></span> <span data-ttu-id="5147c-219">Entwickler müssen 64-Bit-Leistungstests ausführen, bevor Sie bewerten, was optimiert werden muss.</span><span class="sxs-lookup"><span data-stu-id="5147c-219">Developers need to run 64-bit performance tests before assessing what needs to be optimized.</span></span> <span data-ttu-id="5147c-220">Die gute Nachricht ist, dass viele herkömmliche Optimierungen auf 64-Bit-Plattformen funktionieren.</span><span class="sxs-lookup"><span data-stu-id="5147c-220">The good news about this is that many traditional optimizations work on 64-bit platforms.</span></span> <span data-ttu-id="5147c-221">Außerdem können 64-Bit-Compiler auch viele Optimierungen mit der korrekten Verwendung von Compilerflags und Codierungs hinweisen ausführen.</span><span class="sxs-lookup"><span data-stu-id="5147c-221">In addition, 64-bit compilers can also perform many optimizations with the correct use of compiler flags and coding hints.</span></span>

<span data-ttu-id="5147c-222">Einige Strukturen können Ihre internen Datentypen neu angeordnet haben, um Speicherplatz zu sparen und das Zwischenspeichern zu verbessern.</span><span class="sxs-lookup"><span data-stu-id="5147c-222">Some structures may have their internal data types reordered to conserve memory space and improve caching.</span></span> <span data-ttu-id="5147c-223">Array Indizes können in einigen Fällen anstelle eines vollständigen 64-Bit-Zeigers verwendet werden.</span><span class="sxs-lookup"><span data-stu-id="5147c-223">Array indices can be used instead of a full 64-bit pointer in some cases.</span></span> <span data-ttu-id="5147c-224">Das Flag "/fp: fast" kann die Gleit Komma Optimierung und die Vektorisierung verbessern.</span><span class="sxs-lookup"><span data-stu-id="5147c-224">The /fp:fast flag can improve floating-point optimizing and vectorization.</span></span> <span data-ttu-id="5147c-225">Mithilfe \_ \_ von einschränken, declspec (einschränken) und declspec (noalias) kann der Compiler das Aliasing auflösen und die Verwendung der Register Datei verbessern.</span><span class="sxs-lookup"><span data-stu-id="5147c-225">Using \_\_restrict, declspec(restrict), and declspec(noalias) can help the compiler resolve aliasing and improve use of the register file.</span></span>

<span data-ttu-id="5147c-226">Weitere Informationen zu/FP finden Sie unter [/fp (Floating-Point Verhalten angeben)](/cpp/build/reference/fp-specify-floating-point-behavior).</span><span class="sxs-lookup"><span data-stu-id="5147c-226">More information on /fp:fast can be found at [/fp (Specify Floating-Point Behavior)](/cpp/build/reference/fp-specify-floating-point-behavior).</span></span>

<span data-ttu-id="5147c-227">Weitere Informationen zur Einschränkung finden Sie \_ \_ unter [Microsoft-spezifische Modifizierer](/cpp/cpp/microsoft-specific-modifiers).</span><span class="sxs-lookup"><span data-stu-id="5147c-227">More information on \_\_restrict can be found at [Microsoft-Specific Modifiers](/cpp/cpp/microsoft-specific-modifiers).</span></span>

<span data-ttu-id="5147c-228">Weitere Informationen zu declspec (einschränken) finden Sie unter [bewährte Methoden](/cpp/build/optimization-best-practices)für die Optimierung.</span><span class="sxs-lookup"><span data-stu-id="5147c-228">More information on declspec(restrict) can be found at [Optimization Best Practices](/cpp/build/optimization-best-practices).</span></span>

<span data-ttu-id="5147c-229">Weitere Informationen zu declspec (noalias) finden Sie unter [ \_ \_ declspec (noalias)](https://msdn.microsoft.com/library/k649tyc7(VS.80).aspx).</span><span class="sxs-lookup"><span data-stu-id="5147c-229">More information on declspec(noalias) can be found at [\_\_declspec(noalias)](https://msdn.microsoft.com/library/k649tyc7(VS.80).aspx).</span></span>

## <a name="managed-code-on-a-64-bit-operating-system"></a><span data-ttu-id="5147c-230">Verwalteter Code auf einem 64-Bit-Betriebs System</span><span class="sxs-lookup"><span data-stu-id="5147c-230">Managed Code on a 64-bit Operating System</span></span>

<span data-ttu-id="5147c-231">Verwalteter Code wird von vielen Spiel Entwicklern in der Toolkette verwendet. Daher kann es hilfreich sein, sich mit dem Verhalten eines 64-Bit-Betriebssystems vertraut zu machen.</span><span class="sxs-lookup"><span data-stu-id="5147c-231">Managed code is used by many game developers in their tool chain, so an understanding of how it behaves on a 64-bit OS can be helpful.</span></span> <span data-ttu-id="5147c-232">Verwalteter Code ist Weisungs Satz neutral. Wenn Sie also eine verwaltete Anwendung auf einem 64-Bit-Betriebssystem ausführen, kann die Common Language Runtime (CLR) Sie entweder als 32-Bit-oder 64-Bit-Prozess ausführen.</span><span class="sxs-lookup"><span data-stu-id="5147c-232">Managed code is instruction-set neutral, so when you run a managed application on a 64-bit OS, the Common Language Runtime (CLR) can run it as either a 32-bit or 64-bit process.</span></span> <span data-ttu-id="5147c-233">Standardmäßig führt die CLR verwaltete Anwendungen als 64-Bit-Version aus, und Sie sollten problemlos problemlos funktionieren.</span><span class="sxs-lookup"><span data-stu-id="5147c-233">By default, the CLR runs managed applications as 64-bit, and they should work fine with no problems.</span></span> <span data-ttu-id="5147c-234">Wenn die Anwendung jedoch von einer dll abhängig ist, die systemeigene 32-Bit-Version ist, schlägt die Anwendung fehl, wenn versucht wird, diese DLL aufzurufen.</span><span class="sxs-lookup"><span data-stu-id="5147c-234">However, if your application depends on a DLL that is native 32-bit, then your application will fail when it tries to call this DLL.</span></span> <span data-ttu-id="5147c-235">Ein 64-Bit-Prozess erfordert vollständigen 64-Bit-Code, und eine 32-Bit-DLL kann nicht von einem 64-Bit-Prozess aufgerufen werden.</span><span class="sxs-lookup"><span data-stu-id="5147c-235">A 64-bit process needs completely 64-bit code, and a 32-bit DLL cannot be called from a 64-bit process.</span></span> <span data-ttu-id="5147c-236">Die beste langfristige Lösung besteht darin, den nativen Code auch als 64-Bit-Version zu kompilieren. eine absolut sinnvolle kurzfristige Lösung besteht jedoch darin, die verwaltete Anwendung einfach nur für x86 zu markieren, indem das/Platform: x86-Buildflag verwendet wird.</span><span class="sxs-lookup"><span data-stu-id="5147c-236">The best long-term solution is to compile your native code as 64-bit also, but a perfectly reasonable short-term solution is to simply mark your managed application as being for x86 only by using the /platform:x86 build flag.</span></span>

## <a name="performance-implications-of-running-a-64-bit-operating-system"></a><span data-ttu-id="5147c-237">Auswirkungen der Ausführung eines 64-Bit-Betriebssystems auf die Leistung</span><span class="sxs-lookup"><span data-stu-id="5147c-237">Performance Implications of Running a 64-bit Operating System</span></span>

<span data-ttu-id="5147c-238">Da Prozessoren mit amd64-und Intel 64-Architektur die 32-Bit-Anweisungen nativ ausführen können, können Sie 32-Bit-Anwendungen mit voller Geschwindigkeit ausführen, auch bei einem 64-Bit-Betriebssystem.</span><span class="sxs-lookup"><span data-stu-id="5147c-238">Because processors with AMD64 and Intel 64 architecture can execute 32-bit instructions natively, they can run 32-bit applications at full speed, even on a 64-bit OS.</span></span> <span data-ttu-id="5147c-239">Beim Aufrufen von Betriebssystemfunktionen gibt es einen geringfügigen Aufwand für das Umrechnen von Parametern zwischen 32-Bit und 64-Bit. diese Kosten sind jedoch im allgemeinen unerheblich.</span><span class="sxs-lookup"><span data-stu-id="5147c-239">There is a modest cost for converting parameters between 32-bit and 64-bit when calling operating system functions, but this cost is generally negligible.</span></span> <span data-ttu-id="5147c-240">Dies bedeutet, dass beim Ausführen von 32-Bit-Anwendungen auf einem 64-Bit-Betriebssystem keine Verlangsamung angezeigt werden sollte.</span><span class="sxs-lookup"><span data-stu-id="5147c-240">This means that you should see no slowdown when running 32-bit applications on a 64-bit OS.</span></span>

<span data-ttu-id="5147c-241">Wenn Sie Anwendungen als 64-Bit-Version kompilieren, werden die Berechnungen komplizierter.</span><span class="sxs-lookup"><span data-stu-id="5147c-241">When you compile applications as 64-bit, the calculations get more complicated.</span></span> <span data-ttu-id="5147c-242">Ein 64-Bit-Programm verwendet 64-Bit-Zeiger, und die Anweisungen sind etwas größer, sodass die Arbeitsspeicher Anforderungen geringfügig zunehmen.</span><span class="sxs-lookup"><span data-stu-id="5147c-242">A 64-bit program uses 64-bit pointers, and its instructions are slightly larger, so the memory requirement is slightly increased.</span></span> <span data-ttu-id="5147c-243">Dies kann zu einem geringfügigen Leistungsabfall führen.</span><span class="sxs-lookup"><span data-stu-id="5147c-243">This can cause a slight drop in performance.</span></span> <span data-ttu-id="5147c-244">Andererseits ist die Verwendung von doppelt so vielen Registern und die Möglichkeit, 64-Bit-ganz Zahl Berechnungen in einer einzigen Anweisung auszuführen, häufig länger als kompensiert.</span><span class="sxs-lookup"><span data-stu-id="5147c-244">On the other hand, having twice as many registers and having the ability to do 64-bit integer calculations in a single instruction will often more than compensate.</span></span> <span data-ttu-id="5147c-245">Das Ergebnis ist, dass eine 64-Bit-Anwendung möglicherweise langsamer ausgeführt wird, als die gleiche Anwendung, die als 32-Bit kompiliert wurde, aber oft schneller ausgeführt wird.</span><span class="sxs-lookup"><span data-stu-id="5147c-245">The net result is that a 64-bit application might run slightly slower than the same application compiled as 32-bit, but it will often run slightly faster.</span></span>

## <a name="summary"></a><span data-ttu-id="5147c-246">Zusammenfassung</span><span class="sxs-lookup"><span data-stu-id="5147c-246">Summary</span></span>

<span data-ttu-id="5147c-247">64-Bit-Architekturen ermöglichen es Entwicklern, die Einschränkungen für das Aussehen, den Sound und die Wiedergabe von spielen zu übertragen.</span><span class="sxs-lookup"><span data-stu-id="5147c-247">Sixty-four-bit architectures allow developers to push the limitations on how games look, sound, and play.</span></span> <span data-ttu-id="5147c-248">Die Umstellung von der 32-Bit-Programmierung auf die 64-Bit-Programmierung ist jedoch nicht trivial.</span><span class="sxs-lookup"><span data-stu-id="5147c-248">Transitioning from 32-bit programming to 64-bit programming is not trivial, however.</span></span> <span data-ttu-id="5147c-249">Wenn Sie die Unterschiede zwischen den beiden und den neuesten Tools verstehen, kann der Übergang zu 64-Bit-Plattformen einfacher und schneller sein.</span><span class="sxs-lookup"><span data-stu-id="5147c-249">By understanding the differences between the two, and by using the newest tools, the transition to 64-bit platforms can be easier and faster.</span></span>

<span data-ttu-id="5147c-250">Weitere Informationen zur 64-Bit-Programmierung finden Sie unter [Visual C++ Developer Center: 64-Bit-Programmierung](https://msdn.microsoft.com/vstudio//aa336463.aspx).</span><span class="sxs-lookup"><span data-stu-id="5147c-250">More information on 64-bit programming can be found at [Visual C++ Developer Center: 64-Bit Programming](https://msdn.microsoft.com/vstudio//aa336463.aspx).</span></span>

 

 