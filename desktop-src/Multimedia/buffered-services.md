---
title: Gepufferte Dienste
description: Gepufferte Dienste
ms.assetid: 4816ab05-42fc-4c22-b753-8fd153d88c27
keywords:
- Multimedia-Datei-e/a, gepufferte Dienste
- Datei-e/a, gepufferte Dienste
- Eingabe und Ausgabe (e/a), gepufferte Dienste
- E/a (Eingabe und Ausgabe), gepufferte Dienste
- gepufferte e/a
- mmioopen-Funktion
- Interner e/a-Puffer
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: d014ed765609dd43886cc7b33987f8fd5ac7e65a
ms.sourcegitcommit: 7ef31bf778e76ce4196205d4c4c632fbdc649805
ms.translationtype: MT
ms.contentlocale: de-DE
ms.lasthandoff: 02/05/2021
ms.locfileid: "103961047"
---
# <a name="buffered-services"></a><span data-ttu-id="2da8d-110">Gepufferte Dienste</span><span class="sxs-lookup"><span data-stu-id="2da8d-110">Buffered Services</span></span>

<span data-ttu-id="2da8d-111">Der meiste Aufwand in Datei-e/a tritt beim Zugriff auf das Medien Gerät auf.</span><span class="sxs-lookup"><span data-stu-id="2da8d-111">Most of the overhead in file I/O occurs when accessing the media device.</span></span> <span data-ttu-id="2da8d-112">Wenn Sie viele kleine Informationsblöcke lesen oder schreiben, kann das Gerät für jeden Lese-oder Schreibvorgang viel Zeit für die Umstellung auf den physischen Speicherort auf den Medien aufwenden.</span><span class="sxs-lookup"><span data-stu-id="2da8d-112">If you are reading or writing many small blocks of information, the device can spend a lot of time moving to the physical location on the media for each read or write operation.</span></span> <span data-ttu-id="2da8d-113">In diesem Fall können Sie eine bessere Leistung erzielen, indem Sie gepufferte Datei-e/a-Dienste verwenden.</span><span class="sxs-lookup"><span data-stu-id="2da8d-113">In this case, you can achieve better performance by using buffered file I/O services.</span></span> <span data-ttu-id="2da8d-114">Mit gepufferter e/a behält der Datei-e/a-Manager einen Zwischenpuffer bei, der größer ist als die Informationsblöcke, die Sie lesen oder schreiben.</span><span class="sxs-lookup"><span data-stu-id="2da8d-114">With buffered I/O, the file I/O manager maintains an intermediate buffer larger than the blocks of information you are reading or writing.</span></span> <span data-ttu-id="2da8d-115">Es greift nur auf das Gerät zu, wenn der Puffer ausgefüllt oder auf den Datenträger geschrieben werden muss.</span><span class="sxs-lookup"><span data-stu-id="2da8d-115">It accesses the device only when the buffer must be filled from or written to the disk.</span></span>

<span data-ttu-id="2da8d-116">Bevor Sie die gepufferte Datei-e/a einrichten und verwenden, müssen Sie entscheiden, ob der Datei-e/a-Manager oder die Anwendung den Puffer zuordnen soll.</span><span class="sxs-lookup"><span data-stu-id="2da8d-116">Before you set up and use buffered file I/O, you must decide whether you want the file I/O manager or the application to allocate the buffer.</span></span> <span data-ttu-id="2da8d-117">Es ist einfacher, dem Datei-e/a-Manager den Puffer zuzuweisen.</span><span class="sxs-lookup"><span data-stu-id="2da8d-117">It is simpler to let the file I/O manager allocate the buffer.</span></span> <span data-ttu-id="2da8d-118">Sie können jedoch zulassen, dass die Anwendung den Puffer zuweist, wenn Sie direkt auf den Puffer zugreifen oder eine Speicherdatei öffnen möchten.</span><span class="sxs-lookup"><span data-stu-id="2da8d-118">However, you can let the application allocate the buffer if you want to directly access the buffer or open a memory file.</span></span> <span data-ttu-id="2da8d-119">Weitere Informationen zur Verwendung von Speicherdateien finden Sie unter [Durchführen von Speicherdatei-e/](performing-memory-file-i-o.md)a.</span><span class="sxs-lookup"><span data-stu-id="2da8d-119">For more information about using memory files, see [Performing Memory File I/O](performing-memory-file-i-o.md).</span></span> <span data-ttu-id="2da8d-120">Ein Beispiel für den direkten Zugriff auf einen e/a-Puffer finden Sie unter [zugreifen auf einen Datei-e/a-Puffer](accessing-a-file-i-o-buffer.md) .</span><span class="sxs-lookup"><span data-stu-id="2da8d-120">For an example of directly accessing an I/O buffer, see [Accessing a File I/O Buffer](accessing-a-file-i-o-buffer.md)</span></span>

<span data-ttu-id="2da8d-121">Ein Puffer, der vom Datei-e/a-Manager zugeordnet wird, wird als interner e/a-Puffer bezeichnet.</span><span class="sxs-lookup"><span data-stu-id="2da8d-121">A buffer allocated by the file I/O manager is called an internal I/O buffer.</span></span> <span data-ttu-id="2da8d-122">Wenn Sie eine Datei für gepufferte e/a-Vorgänge mit einem internen Puffer öffnen möchten, geben Sie das MMIO- \_ allocbuf-Flag an, wenn Sie die Datei mit der [**mmioopen**](/windows/win32/api/mmiscapi/nf-mmiscapi-mmioopen) -Funktion öffnen.</span><span class="sxs-lookup"><span data-stu-id="2da8d-122">To open a file for buffered I/O using an internal buffer, specify the MMIO\_ALLOCBUF flag when you open the file with the [**mmioOpen**](/windows/win32/api/mmiscapi/nf-mmiscapi-mmioopen) function.</span></span> <span data-ttu-id="2da8d-123">Die folgende Abbildung zeigt den ursprünglichen Zustand des Datei-e/a-Puffers, nachdem eine Datei für einen gepufferten Lesevorgang geöffnet wurde.</span><span class="sxs-lookup"><span data-stu-id="2da8d-123">The following illustration shows the initial state of the file I/O buffer after a file is opened for a buffered read operation.</span></span> <span data-ttu-id="2da8d-124">Die Pufferung ist transparent – Sie lesen und suchen, als wären Sie nicht gepufferte e/a-Vorgänge verwendet.</span><span class="sxs-lookup"><span data-stu-id="2da8d-124">The buffering is transparent — you read and seek as if you were using unbuffered I/O.</span></span> <span data-ttu-id="2da8d-125">Die **mmioopen** -Funktion hat pchnext und *pchendread* so festgelegt, dass Sie auf den Anfang des Datei-e/a-Puffers zeigen.</span><span class="sxs-lookup"><span data-stu-id="2da8d-125">The **mmioOpen** function has set pchNext and *pchEndRead* to point to the beginning of the file I/O buffer.</span></span>

![Screenshot mit "pchendread" und "pchnext", die auf den Anfang des Datei-e/a-Puffers zeigen.](images/mmio7.gif)

<span data-ttu-id="2da8d-127">Die folgende Abbildung zeigt den ursprünglichen Zustand des Datei-e/a-Puffers, nachdem eine Datei für einen gepufferten Schreibvorgang geöffnet wurde.</span><span class="sxs-lookup"><span data-stu-id="2da8d-127">The following illustration shows the initial state of the file I/O buffer after a file is opened for a buffered write operation.</span></span> <span data-ttu-id="2da8d-128">Die **mmioopen** -Funktion hat **pchnext** auf den Anfang des Datei-e/a-Puffers und **pchendwrite** festgelegt, um auf das Ende des Puffers zu zeigen.</span><span class="sxs-lookup"><span data-stu-id="2da8d-128">The **mmioOpen** function has set **pchNext** to point to the beginning of the file I/O buffer and **pchEndWrite** to point to the end of the buffer.</span></span>

![Screenshot, der ' pchnext ' am Anfang des Datei-e/a-Puffers und ' pchendwrite ' am Ende anzeigt.](images/mmio11.gif)

<span data-ttu-id="2da8d-130">Die Standardgröße des internen e/a-Puffers beträgt 8K.</span><span class="sxs-lookup"><span data-stu-id="2da8d-130">The default size of the internal I/O buffer is 8K.</span></span> <span data-ttu-id="2da8d-131">Wenn diese Größe nicht ausreicht, können Sie die [**mmiosetbuffer**](/windows/win32/api/mmiscapi/nf-mmiscapi-mmiosetbuffer) -Funktion verwenden, um die Puffergröße zu ändern.</span><span class="sxs-lookup"><span data-stu-id="2da8d-131">If this size is not adequate, you can use the [**mmioSetBuffer**](/windows/win32/api/mmiscapi/nf-mmiscapi-mmiosetbuffer) function to change the buffer size.</span></span> <span data-ttu-id="2da8d-132">Sie können diese Funktion auch verwenden, um die Pufferung für eine Datei zu aktivieren, die für nicht gepufferte e/a-Vorgänge geöffnet wurde, oder um einen eigenen Puffer zur Verwendung als Speicherdatei bereitzustellen.</span><span class="sxs-lookup"><span data-stu-id="2da8d-132">You can also use this function to enable buffering on a file opened for unbuffered I/O, or to supply your own buffer for use as a memory file.</span></span>

<span data-ttu-id="2da8d-133">Mithilfe der [**mmioflush**](/windows/win32/api/mmiscapi/nf-mmiscapi-mmioflush) -Funktion können Sie erzwingen, dass der Inhalt eines e/a-Puffers auf den Datenträger geschrieben wird.</span><span class="sxs-lookup"><span data-stu-id="2da8d-133">You can force the contents of an I/O buffer to be written to disk by using the [**mmioFlush**](/windows/win32/api/mmiscapi/nf-mmiscapi-mmioflush) function.</span></span> <span data-ttu-id="2da8d-134">Wenn Sie jedoch eine Datei mithilfe der [**mmioclose**](/windows/win32/api/mmiscapi/nf-mmiscapi-mmioclose) -Funktion schließen, müssen Sie **mmioflush** nicht zum leeren eines e/a-Puffers aufzurufen – die **mmioclose** -Funktion leert Sie automatisch.</span><span class="sxs-lookup"><span data-stu-id="2da8d-134">However, when you close a file by using the [**mmioClose**](/windows/win32/api/mmiscapi/nf-mmiscapi-mmioclose) function, you do not have to call **mmioFlush** to flush an I/O buffer — the **mmioClose** function automatically flushes it.</span></span> <span data-ttu-id="2da8d-135">Wenn nicht genügend Speicherplatz zur Verfügung steht, kann **mmioflush** fehlschlagen, auch wenn die vorherigen Aufrufe der [**mmiowrite**](/windows/win32/api/mmiscapi/nf-mmiscapi-mmiowrite) -Funktion erfolgreich waren.</span><span class="sxs-lookup"><span data-stu-id="2da8d-135">If you run out of disk space, **mmioFlush** could fail, even if the preceding calls to the [**mmioWrite**](/windows/win32/api/mmiscapi/nf-mmiscapi-mmiowrite) function were successful.</span></span> <span data-ttu-id="2da8d-136">Ebenso kann **mmioclose** fehlschlagen, wenn es den e/a-Puffer leert.</span><span class="sxs-lookup"><span data-stu-id="2da8d-136">Similarly, **mmioClose** could fail when it is flushing its I/O buffer.</span></span>

<span data-ttu-id="2da8d-137">Anwendungen, die Leistungs abhängig sind, z. b. solche, die Daten in Echtzeit von einer CD-ROM streamen, können die Datei-e/a-Leistung optimieren, indem Sie direkt auf den e/a-Puffer zugreifen.</span><span class="sxs-lookup"><span data-stu-id="2da8d-137">Applications that are performance-sensitive, such as those that stream data in real time from a CD-ROM, can optimize file I/O performance by directly accessing the I/O buffer.</span></span> <span data-ttu-id="2da8d-138">Wenn Sie dies tun, sollten Sie vorsichtig vorgehen, da Sie einige der Sicherheitsvorkehrungen und die Fehlerüberprüfung des Datei-e/a-Managers umgehen.</span><span class="sxs-lookup"><span data-stu-id="2da8d-138">You should be careful if you choose to do this, because you bypass some of the safeguards and error checking provided by the file I/O manager.</span></span>

<span data-ttu-id="2da8d-139">Der Multimedia-Datei-e/a-Manager verwendet die [**mmioinfo**](/previous-versions//dd757322(v=vs.85)) -Struktur, um Zustandsinformationen zu einer geöffneten Datei beizubehalten.</span><span class="sxs-lookup"><span data-stu-id="2da8d-139">The multimedia file I/O manager uses the [**MMIOINFO**](/previous-versions//dd757322(v=vs.85)) structure to maintain state information about an open file.</span></span> <span data-ttu-id="2da8d-140">Sie verwenden drei Member in dieser Struktur, um den e/a-Puffer zu lesen und zu schreiben: **pchnext**, **pchendread** und **pchendwrite**.</span><span class="sxs-lookup"><span data-stu-id="2da8d-140">You use three members in this structure to read and write the I/O buffer: **pchNext**, **pchEndRead**, and **pchEndWrite**.</span></span> <span data-ttu-id="2da8d-141">Der **pchnext** -Member verweist auf die nächste Position im Puffer, die gelesen oder geschrieben werden soll.</span><span class="sxs-lookup"><span data-stu-id="2da8d-141">The **pchNext** member points to the next location in the buffer to read or write.</span></span> <span data-ttu-id="2da8d-142">Sie müssen diesen Member erhöhen, während Sie den Puffer lesen und schreiben.</span><span class="sxs-lookup"><span data-stu-id="2da8d-142">You must increment this member as you read and write the buffer.</span></span> <span data-ttu-id="2da8d-143">Der **pchendread** -Member identifiziert das letzte gültige Zeichen, das Sie aus dem Puffer lesen können.</span><span class="sxs-lookup"><span data-stu-id="2da8d-143">The **pchEndRead** member identifies the last valid character you can read from the buffer.</span></span> <span data-ttu-id="2da8d-144">Ebenso identifiziert dieser Member den letzten Speicherort im Puffer, den Sie schreiben können.</span><span class="sxs-lookup"><span data-stu-id="2da8d-144">Likewise, this member identifies the last location in the buffer you can write.</span></span> <span data-ttu-id="2da8d-145">Genauer ist, zeigen sowohl **pchendread** als auch **pchendwrite** auf den Speicherort, der den letzten gültigen Daten im Puffer folgt.</span><span class="sxs-lookup"><span data-stu-id="2da8d-145">More precisely, both **pchEndRead** and **pchEndWrite** point to the memory location that follows the last valid data in the buffer.</span></span> <span data-ttu-id="2da8d-146">Verwenden Sie die Funktionen [**mmiogetinfo**](/windows/win32/api/mmiscapi/nf-mmiscapi-mmiogetinfo) und [**mmiosetinfo**](/windows/win32/api/mmiscapi/nf-mmiscapi-mmiosetinfo) , um Zustandsinformationen zum Datei-e/a-Puffer abzurufen und festzulegen.</span><span class="sxs-lookup"><span data-stu-id="2da8d-146">Use the [**mmioGetInfo**](/windows/win32/api/mmiscapi/nf-mmiscapi-mmiogetinfo) and [**mmioSetInfo**](/windows/win32/api/mmiscapi/nf-mmiscapi-mmiosetinfo) functions to retrieve and set state information about the file I/O buffer.</span></span> <span data-ttu-id="2da8d-147">Die folgende Abbildung zeigt den Status des e/a-Puffers, nachdem die Anwendung während eines Lesevorgangs **mmioadvance** aufgerufen hat.</span><span class="sxs-lookup"><span data-stu-id="2da8d-147">The following illustration shows the state of the I/O buffer after the application calls **mmioAdvance** during a read operation.</span></span> <span data-ttu-id="2da8d-148">Die **mmioadvance** -Funktion füllt den Puffer auf und legt den **pchendread** -Zeiger auf das Ende des Puffers fest.</span><span class="sxs-lookup"><span data-stu-id="2da8d-148">The **mmioAdvance** function fills the buffer and sets the **pchEndRead** pointer to the end of the buffer.</span></span>

![Screenshot, der "pchnext" am Anfang des Datei-e/a-Puffers und "pchendread" am Ende anzeigt.](images/mmio8.gif)

<span data-ttu-id="2da8d-150">In der folgenden Abbildung liest die Anwendung aus dem e/a-Puffer an dem Speicherort, der von **pchnext** angegeben wird, und verschiebt den Zeiger.</span><span class="sxs-lookup"><span data-stu-id="2da8d-150">In the following illustration, the application reads from the I/O buffer at the location specified by **pchNext**, and advances the pointer.</span></span>

![Screenshot, der ' pchnext ' in der Mitte des Datei-e/a-Puffers und ' pchendread ' am Ende anzeigt.](images/mmio9.gif)

<span data-ttu-id="2da8d-152">Ebenso schreibt die Anwendung bei einem Schreibvorgang in den e/a-Puffer und erhöht den **pchnext** -Zeiger, wie in der folgenden Abbildung dargestellt.</span><span class="sxs-lookup"><span data-stu-id="2da8d-152">Similarly, for a write operation, the application writes to the I/O buffer and advances the **pchNext** pointer, as shown in the following illustration.</span></span>

![Screenshot, der ' pchnext ' in der Mitte des Datei-e/a-Puffers und ' pchendwrite ' am Ende anzeigt.](images/mmio12.gif)

<span data-ttu-id="2da8d-154">Nachdem die Anwendung den Puffer ausgefüllt hat, wird **mmioadvance** aufgerufen, um den Puffer auf den Datenträger zu leeren.</span><span class="sxs-lookup"><span data-stu-id="2da8d-154">After the application fills the buffer, it calls **mmioAdvance** to flush the buffer to disk.</span></span> <span data-ttu-id="2da8d-155">Die **mmioadvance** -Funktion setzt **pchnext** auf den Anfang des Puffers zurück, wie in der folgenden Abbildung dargestellt.</span><span class="sxs-lookup"><span data-stu-id="2da8d-155">The **mmioAdvance** function resets **pchNext** to point to the beginning of the buffer, as shown in the following illustration.</span></span>

![Screenshot, der ' pchnext ' am Anfang des Datei-E/a-Puffers, den Puffer in der Mitte von E O F und ' pchendwrite ' am Ende des Puffers anzeigt.](images/mmio13.gif)

<span data-ttu-id="2da8d-157">Wenn Sie das Ende des e/a-Puffers erreichen, müssen Sie den Puffer so verschieben, dass er vom Datenträger ausgefüllt wird, wenn Sie ihn lesen oder auf den Datenträger leeren, wenn Sie schreiben.</span><span class="sxs-lookup"><span data-stu-id="2da8d-157">When you reach the end of the I/O buffer, you must advance the buffer to fill it from the disk, if you are reading, or flush it to the disk, if you are writing.</span></span> <span data-ttu-id="2da8d-158">Verwenden Sie die [**mmioadvance**](/windows/win32/api/mmiscapi/nf-mmiscapi-mmioadvance) -Funktion, um einen e/a-Puffer zu verbessern.</span><span class="sxs-lookup"><span data-stu-id="2da8d-158">Use the [**mmioAdvance**](/windows/win32/api/mmiscapi/nf-mmiscapi-mmioadvance) function to advance an I/O buffer.</span></span> <span data-ttu-id="2da8d-159">Um einen e/a-Puffer von der Festplatte zu füllen, verwenden Sie **mmioadvance** mit dem MMIO- \_ leseflag.</span><span class="sxs-lookup"><span data-stu-id="2da8d-159">To fill an I/O buffer from disk, use **mmioAdvance** with the MMIO\_READ flag.</span></span> <span data-ttu-id="2da8d-160">Wenn nicht genügend Daten in der Datei vorhanden sind, um den Puffer auszufüllen, verweist der **pchendread** -Member der **mmioinfo** -Struktur auf den Speicherort, der dem letzten gültigen Byte im Puffer folgt.</span><span class="sxs-lookup"><span data-stu-id="2da8d-160">If there is not enough data remaining in the file to fill the buffer, the **pchEndRead** member of the **MMIOINFO** structure points to the location following the last valid byte in the buffer.</span></span> <span data-ttu-id="2da8d-161">Um einen Puffer auf den Datenträger zu leeren, legen Sie das MMIO \_ -Flag "Dirty" im **dwFlags** -Member der **mmioinfo** -Struktur fest, und geben Sie dann **mmioadvance** mit dem MMIO- \_ Schreib Flag ein.</span><span class="sxs-lookup"><span data-stu-id="2da8d-161">To flush a buffer to disk, set the MMIO\_DIRTY flag in the **dwFlags** member of the **MMIOINFO** structure and then call **mmioAdvance** with the MMIO\_WRITE flag.</span></span>

<span data-ttu-id="2da8d-162">Beispielsweise legt die **mmioadvance** -Funktion während eines Lesevorgangs **pchendread** so fest, dass Sie auf das Ende gültiger Daten im Puffer zeigt, wie in der folgenden Abbildung dargestellt.</span><span class="sxs-lookup"><span data-stu-id="2da8d-162">For example, during a read operation, the **mmioAdvance** function sets **pchEndRead** to point to the end of valid data in the buffer, as shown in the following illustration.</span></span>

![Screenshot, der ' pchnext ' am Anfang des Datei-E/a-Puffers, den Puffer am Ende von E O F und ' pchendread ' am Ende des Puffers anzeigt.](images/mmio10.gif)

<span data-ttu-id="2da8d-164">Ebenso Ruft die Anwendung während eines Schreibvorgangs **mmioadvance** auf, um den Puffer zu leeren und **pchnext** an das Ende der gültigen Daten im Puffer zu verschieben, wie in der folgenden Abbildung dargestellt.</span><span class="sxs-lookup"><span data-stu-id="2da8d-164">Similarly, during a write operation, the application calls **mmioAdvance** to flush the buffer and advance **pchNext** to the end of valid data in the buffer, as shown in the following illustration.</span></span>

![Datei-e/a-Puffer Image](images/mmio14.gif)

 

 