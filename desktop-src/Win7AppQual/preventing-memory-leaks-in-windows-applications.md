---
description: Erfahren Sie, wie Sie Speicher Verluste in Windows-Anwendungen für Windows 7-und Windows Server 2008 R2-Plattformen vermeiden.
ms.assetid: c5dedcab-3e6f-433f-95de-d741321c683e
title: Verhindern von Speicher Verlusten in Windows-Anwendungen
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: e973da19d075ac94824df340d1741fd9cefb3486
ms.sourcegitcommit: af9983bab40fe0b042f177ce7ca79f2eb0f9d0e8
ms.translationtype: MT
ms.contentlocale: de-DE
ms.lasthandoff: 02/06/2021
ms.locfileid: "104567224"
---
# <a name="preventing-memory-leaks-in-windows-applications"></a><span data-ttu-id="e5796-103">Verhindern von Speicher Verlusten in Windows-Anwendungen</span><span class="sxs-lookup"><span data-stu-id="e5796-103">Preventing Memory Leaks in Windows Applications</span></span>

## <a name="affected-platforms"></a><span data-ttu-id="e5796-104">Betroffene Plattformen</span><span class="sxs-lookup"><span data-stu-id="e5796-104">Affected Platforms</span></span>

<span data-ttu-id="e5796-105">**Clients** -Windows 7</span><span class="sxs-lookup"><span data-stu-id="e5796-105">**Clients** - Windows 7</span></span>  
<span data-ttu-id="e5796-106">**Server** -Windows Server 2008 R2</span><span class="sxs-lookup"><span data-stu-id="e5796-106">**Servers** - Windows Server 2008 R2</span></span>  

## <a name="description"></a><span data-ttu-id="e5796-107">BESCHREIBUNG</span><span class="sxs-lookup"><span data-stu-id="e5796-107">Description</span></span>

<span data-ttu-id="e5796-108">Speicher Verluste sind eine Klasse von Fehlern, bei denen die Anwendung keinen Arbeitsspeicher mehr freigeben kann, wenn Sie nicht mehr benötigt wird.</span><span class="sxs-lookup"><span data-stu-id="e5796-108">Memory leaks are a class of bugs where the application fails to release memory when no longer needed.</span></span> <span data-ttu-id="e5796-109">Im Laufe der Zeit wirken sich Speicher Verluste sowohl auf die Leistung der jeweiligen Anwendung als auch auf das Betriebssystem aus.</span><span class="sxs-lookup"><span data-stu-id="e5796-109">Over time, memory leaks affect the performance of both the particular application as well as the operating system.</span></span> <span data-ttu-id="e5796-110">Ein großer Ausfall kann zu unzulässigen Antwortzeiten aufgrund von übermäßigem Paging führen.</span><span class="sxs-lookup"><span data-stu-id="e5796-110">A large leak might result in unacceptable response times due to excessive paging.</span></span> <span data-ttu-id="e5796-111">Letztendlich treten bei der Anwendung und anderen Teilen des Betriebssystems Fehler auf.</span><span class="sxs-lookup"><span data-stu-id="e5796-111">Eventually the application as well as other parts of the operating system will experience failures.</span></span>

<span data-ttu-id="e5796-112">Windows gibt den gesamten Arbeitsspeicher frei, der von der Anwendung bei Beendigung des Prozesses belegt wird, sodass sich Anwendungen mit kurzer Laufzeit nicht erheblich auf die Gesamtleistung des Systems auswirken.</span><span class="sxs-lookup"><span data-stu-id="e5796-112">Windows will free all memory allocated by the application on process termination, so short-running applications will not affect overall system performance significantly.</span></span> <span data-ttu-id="e5796-113">Verluste in Prozessen mit langer Ausführungszeit, wie Dienste oder sogar Explorer-Plug-ins, können sich jedoch erheblich auf die Zuverlässigkeit des Systems auswirken und erzwingen möglicherweise, dass der Benutzer Windows neu startet, damit das System wiederverwendbar ist.</span><span class="sxs-lookup"><span data-stu-id="e5796-113">However, leaks in long-running processes like services or even Explorer plug-ins can greatly impact system reliability and might force the user to reboot Windows in order to make the system usable again.</span></span>

<span data-ttu-id="e5796-114">Anwendungen können Arbeitsspeicher in Ihrem Auftrag auf mehrfache Weise zuweisen.</span><span class="sxs-lookup"><span data-stu-id="e5796-114">Applications can allocate memory on their behalf by multiple means.</span></span> <span data-ttu-id="e5796-115">Jeder Zuordnungstyp kann zu einem Leck führen, wenn er nach der Verwendung nicht freigegeben wird.</span><span class="sxs-lookup"><span data-stu-id="e5796-115">Each type of allocation can result in a leak if not freed after use.</span></span> <span data-ttu-id="e5796-116">Im folgenden finden Sie einige Beispiele für allgemeine Zuordnungs Muster:</span><span class="sxs-lookup"><span data-stu-id="e5796-116">Here are some examples of common allocation patterns:</span></span>

-   <span data-ttu-id="e5796-117">Heap Speicher über die [**heapbelegc**](/windows/win32/api/heapapi/nf-heapapi-heapalloc) -Funktion oder deren C/C++-Lauf Zeit Entsprechungen **malloc** oder **New**</span><span class="sxs-lookup"><span data-stu-id="e5796-117">Heap memory via the [**HeapAlloc**](/windows/win32/api/heapapi/nf-heapapi-heapalloc) function or its C/C++ runtime equivalents **malloc** or **new**</span></span>
-   <span data-ttu-id="e5796-118">Direkte Zuweisungen vom Betriebssystem über die [**VirtualAlloc**](/windows/win32/api/memoryapi/nf-memoryapi-virtualalloc) -Funktion.</span><span class="sxs-lookup"><span data-stu-id="e5796-118">Direct allocations from the operating system via the [**VirtualAlloc**](/windows/win32/api/memoryapi/nf-memoryapi-virtualalloc) function.</span></span>
-   <span data-ttu-id="e5796-119">Kernel Handles, die über kernel32-APIs erstellt werden, wie z. b. " [**kreatefile**](/windows/win32/api/fileapi/nf-fileapi-createfilea)", " [**forateevent**](/windows/win32/api/synchapi/nf-synchapi-createeventa)" oder " [**foratethread**](/windows/win32/api/processthreadsapi/nf-processthreadsapi-createthread)"</span><span class="sxs-lookup"><span data-stu-id="e5796-119">Kernel handles created via Kernel32 APIs such as [**CreateFile**](/windows/win32/api/fileapi/nf-fileapi-createfilea), [**CreateEvent**](/windows/win32/api/synchapi/nf-synchapi-createeventa), or [**CreateThread**](/windows/win32/api/processthreadsapi/nf-processthreadsapi-createthread), hold kernel memory on behalf of the application</span></span>
-   <span data-ttu-id="e5796-120">GDI-und Benutzer Handles, die über User32-und gdi32-APIs erstellt wurden (Standardmäßig verfügt jeder Prozess über ein Kontingent von 10.000 Handles)</span><span class="sxs-lookup"><span data-stu-id="e5796-120">GDI and USER handles created via User32 and Gdi32 APIs (by default, each process has a quota of 10,000 handles)</span></span>

## <a name="best-practices"></a><span data-ttu-id="e5796-121">Bewährte Methoden</span><span class="sxs-lookup"><span data-stu-id="e5796-121">Best Practices</span></span>

<span data-ttu-id="e5796-122">Das Überwachen des Ressourcenverbrauchs Ihrer Anwendung im Zeitverlauf ist der erste Schritt bei der Erkennung und Diagnose von Speicher Verlusten.</span><span class="sxs-lookup"><span data-stu-id="e5796-122">Monitoring the resource consumption of your application over time is the first step in detecting and diagnosing memory leaks.</span></span> <span data-ttu-id="e5796-123">Verwenden Sie den Windows Task-Manager, und fügen Sie die folgenden Spalten hinzu: "commitsize", "Handles", "User Objects" und "GDI Objects".</span><span class="sxs-lookup"><span data-stu-id="e5796-123">Use Windows Task Manager and add the following columns: "Commit Size", "Handles", "User Objects", and "GDI Objects".</span></span> <span data-ttu-id="e5796-124">Auf diese Weise können Sie eine Baseline für Ihre Anwendung einrichten und die Ressourcennutzung über einen bestimmten Zeitraum überwachen.</span><span class="sxs-lookup"><span data-stu-id="e5796-124">This will allow you to establish a baseline for your application and monitor resource usage over time.</span></span>

![Screenshot, der die Seite "Prozesse" im Windows Task-Manager anzeigt.](images/preventingmemoryleaks-windowstaskmanager.gif)

<span data-ttu-id="e5796-126">Die folgenden Microsoft-Tools bieten ausführlichere Informationen und können Ihnen helfen, Verluste für die verschiedenen Zuordnungs Typen in Ihrer Anwendung zu erkennen und zu diagnostizieren:</span><span class="sxs-lookup"><span data-stu-id="e5796-126">The following Microsoft tools provide more-detailed information and can help to detect and diagnose leaks for the various allocation types in your application:</span></span>

-   <span data-ttu-id="e5796-127">System Monitor und Ressourcenmonitor sind Teil von Windows 7 und können die Ressourcenverwendung über einen bestimmten Zeitraum überwachen und überwachen.</span><span class="sxs-lookup"><span data-stu-id="e5796-127">Performance Monitor and Resource Monitor are part of Windows 7 and can monitor and graph resource use over time</span></span>
-   <span data-ttu-id="e5796-128">Die neueste Version von Application Verifier kann Heap Lecks unter Windows 7 diagnostizieren.</span><span class="sxs-lookup"><span data-stu-id="e5796-128">The latest version of Application Verifier can diagnose heap leaks on Windows 7</span></span>
-   <span data-ttu-id="e5796-129">Mit dem in den Debuggingtools für Windows vorhandenen Umschlag werden die Heap Speicher Belegungen für einen bestimmten Prozess analysiert, und es können Verluste und andere ungewöhnliche Verwendungs Muster gefunden werden.</span><span class="sxs-lookup"><span data-stu-id="e5796-129">UMDH, which is part of the Debugging Tools for Windows, analyzes the heap memory allocations for a given process and can help find leaks and other unusual usage patterns</span></span>
-   <span data-ttu-id="e5796-130">XPerf ist ein anspruchsvolles Leistungsanalyse Tool mit Unterstützung für Heap Zuordnungs Ablauf Verfolgungen.</span><span class="sxs-lookup"><span data-stu-id="e5796-130">Xperf is a sophisticated performance analysis tool with support for heap allocation traces</span></span>
-   <span data-ttu-id="e5796-131">CRT-Debugheap verfolgt Heap Zuordnungen und kann helfen, eigene Heap-Debugging-Features zu erstellen</span><span class="sxs-lookup"><span data-stu-id="e5796-131">CRT Debug Heap tracks heap allocations and can help build your own heap debugging features</span></span>

<span data-ttu-id="e5796-132">Bestimmte Codierungs-und Entwurfsverfahren können die Anzahl der Lecks in Ihrem Code einschränken.</span><span class="sxs-lookup"><span data-stu-id="e5796-132">Certain coding and design practices can limit the number of leaks in your code.</span></span>

-   <span data-ttu-id="e5796-133">Verwenden Sie intelligente Zeiger in C++-Code sowohl für Heap Zuweisungen als auch für Win32-Ressourcen wie Kernel **handle** s.</span><span class="sxs-lookup"><span data-stu-id="e5796-133">Use smart pointers in C++ code both for heap allocations as well as for Win32 resources like kernel **HANDLE** s.</span></span> <span data-ttu-id="e5796-134">Die C++-Standard Bibliothek stellt die **automatische \_ ptr** -Klasse für Heap Zuweisungen bereit.</span><span class="sxs-lookup"><span data-stu-id="e5796-134">The C++ Standard library provides the **auto\_ptr** class for heap allocations.</span></span> <span data-ttu-id="e5796-135">Bei anderen Zuordnungs Typen müssen Sie eigene Klassen schreiben.</span><span class="sxs-lookup"><span data-stu-id="e5796-135">For other allocation types you will need to write your own classes.</span></span> <span data-ttu-id="e5796-136">Die ATL-Bibliothek stellt einen umfangreichen Satz von Klassen für die automatische Ressourcenverwaltung für Heap Objekte und Kernel Handles bereit.</span><span class="sxs-lookup"><span data-stu-id="e5796-136">The ATL library provides a rich set of classes for automatic resource management for both heap objects and kernel handles</span></span>
-   <span data-ttu-id="e5796-137">Verwenden Sie systeminterne Compilerfunktionen wie **\_ com \_ ptr \_ t** , um Ihre COM-Schnittstellen Zeiger in "intelligente Zeiger" zu kapseln und die Verweis Zählung zu unterstützen.</span><span class="sxs-lookup"><span data-stu-id="e5796-137">Use compiler intrinsic features like **\_com\_ptr\_t** to encapsulate your COM interface pointers into "smart pointers" and assist with reference counting.</span></span> <span data-ttu-id="e5796-138">Es gibt ähnliche Klassen für andere com-Datentypen: **\_ BSTR \_ t** und **\_ Variant \_ t** .</span><span class="sxs-lookup"><span data-stu-id="e5796-138">There are similar classes for other COM data types: **\_bstr\_t** and **\_variant\_t**</span></span>
-   <span data-ttu-id="e5796-139">Überwachen Sie die ungewöhnliche Speicherauslastung von .NET-Code.</span><span class="sxs-lookup"><span data-stu-id="e5796-139">Monitor your .NET code unusual memory usage.</span></span> <span data-ttu-id="e5796-140">Verwalteter Code ist nicht gegen Speicher Verluste anfällig.</span><span class="sxs-lookup"><span data-stu-id="e5796-140">Managed code is not immune to memory leaks.</span></span> <span data-ttu-id="e5796-141">Informationen zum Auffinden von GC-Verlusten finden [Sie unter "Nachverfolgen von verwalteten Speicher Verlusten"](/archive/blogs/ricom/) .</span><span class="sxs-lookup"><span data-stu-id="e5796-141">See ["Tracking down managed memory leaks"](/archive/blogs/ricom/) on how to find GC leaks</span></span>
-   <span data-ttu-id="e5796-142">Beachten Sie die Muster für den Client seitigen Webcode.</span><span class="sxs-lookup"><span data-stu-id="e5796-142">Be aware of leak patterns in web client-side code.</span></span> <span data-ttu-id="e5796-143">Zirkuläre Verweise zwischen COM-Objekten und Skript-Engines wie JScript können große Verluste in Webanwendungen verursachen.</span><span class="sxs-lookup"><span data-stu-id="e5796-143">Circular references between COM objects and scripting engines like JScript can cause large leaks in web applications.</span></span> <span data-ttu-id="e5796-144">["Verstehen und lösen von Internet Explorer-Verlust Mustern"](/previous-versions/ms976398(v=msdn.10)) enthält weitere Informationen zu diesen Arten von Verlusten.</span><span class="sxs-lookup"><span data-stu-id="e5796-144">["Understanding and Solving Internet Explorer Leak Patterns"](/previous-versions/ms976398(v=msdn.10)) has more information on these kinds of leaks.</span></span> <span data-ttu-id="e5796-145">Sie können das JavaScript-Speicher Verlust-Erkennungs Modul verwenden, um Speicher Verluste in Ihrem Code zu debuggen.</span><span class="sxs-lookup"><span data-stu-id="e5796-145">You can use the JavaScript Memory Leak Detector to debug memory leaks in your code.</span></span> <span data-ttu-id="e5796-146">Obwohl Windows Internet Explorer 8, das mit Windows 7 ausgeliefert wird, die meisten dieser Probleme verringert, sind ältere Browser weiterhin anfällig für diese Fehler.</span><span class="sxs-lookup"><span data-stu-id="e5796-146">While Windows Internet Explorer 8, which is shipping with Windows 7, mitigates most of these issues, older browsers are still vulnerable to these bugs</span></span>
-   <span data-ttu-id="e5796-147">Vermeiden Sie die Verwendung mehrerer Beendigungs Pfade aus einer Funktion.</span><span class="sxs-lookup"><span data-stu-id="e5796-147">Avoid using multiple exit paths from a function.</span></span> <span data-ttu-id="e5796-148">Zuordnungen, die Variablen im Funktionsbereich zugewiesen werden, sollten am Ende der Funktion in einem bestimmten Block freigegeben werden.</span><span class="sxs-lookup"><span data-stu-id="e5796-148">Allocations assigned to variables at function scope should be freed in one particular block at the end of the function</span></span>
-   <span data-ttu-id="e5796-149">Verwenden Sie keine Ausnahmen in Ihrem Code, ohne alle lokalen Variablen in Funktionen freizugeben.</span><span class="sxs-lookup"><span data-stu-id="e5796-149">Do not use exceptions in your code without freeing all local variables in functions.</span></span> <span data-ttu-id="e5796-150">Wenn Sie systemeigene Ausnahmen verwenden, geben Sie alle Zuordnungen im Block "endlich" frei \_ \_ .</span><span class="sxs-lookup"><span data-stu-id="e5796-150">If you use native exceptions, free all your allocations inside the \_\_finally block.</span></span> <span data-ttu-id="e5796-151">Wenn Sie C++-Ausnahmen verwenden, müssen alle Heap-und Handle-Zuordnungen in intelligente Zeiger umschließt werden.</span><span class="sxs-lookup"><span data-stu-id="e5796-151">If you use C++ exceptions, all your heap and handle allocations need to be wrapped in smart pointers</span></span>
-   <span data-ttu-id="e5796-152">Ein [**PROPVARIANT**](/windows/win32/api/propidlbase/ns-propidlbase-propvariant) -Objekt nicht verwerfen oder erneut initialisieren, ohne die [**propvariantclear**](/windows/win32/api/combaseapi/nf-combaseapi-propvariantclear) -Funktion Aufrufs</span><span class="sxs-lookup"><span data-stu-id="e5796-152">Do not discard or reinitialize a [**PROPVARIANT**](/windows/win32/api/propidlbase/ns-propidlbase-propvariant) object without calling the [**PropVariantClear**](/windows/win32/api/combaseapi/nf-combaseapi-propvariantclear) function</span></span>

## <a name="links-to-resources"></a><span data-ttu-id="e5796-153">Links zu Ressourcen</span><span class="sxs-lookup"><span data-stu-id="e5796-153">Links to Resources</span></span>

<span data-ttu-id="e5796-154">*Allgemeine Zuordnungs Muster:*</span><span class="sxs-lookup"><span data-stu-id="e5796-154">*Common Allocation Patterns:*</span></span>

-   [<span data-ttu-id="e5796-155">**Heap Zuordnungs Funktion**</span><span class="sxs-lookup"><span data-stu-id="e5796-155">**Heap Allocation Function**</span></span>](/windows/win32/api/heapapi/nf-heapapi-heapalloc)
-   <span data-ttu-id="e5796-156">[**Speicher Belegungs Funktion**](https://msdn.microsoft.com/library/6ewkz86d(v=VS.71).aspx)</span><span class="sxs-lookup"><span data-stu-id="e5796-156">[**Memory Allocation Function**](https://msdn.microsoft.com/library/6ewkz86d(v=VS.71).aspx)</span></span>
-   <span data-ttu-id="e5796-157">[**New-Operator (C++)**](https://msdn.microsoft.com/library/kewsb8ba(v=VS.71).aspx)</span><span class="sxs-lookup"><span data-stu-id="e5796-157">[**New Operator (C++)**](https://msdn.microsoft.com/library/kewsb8ba(v=VS.71).aspx)</span></span>
-   [<span data-ttu-id="e5796-158">**Virtuelle Zuordnungs Funktion**</span><span class="sxs-lookup"><span data-stu-id="e5796-158">**Virtual Allocation Function**</span></span>](/windows/win32/api/memoryapi/nf-memoryapi-virtualalloc)
-   [<span data-ttu-id="e5796-159">Kernel Objekte</span><span class="sxs-lookup"><span data-stu-id="e5796-159">Kernel Objects</span></span>](../sysinfo/kernel-objects.md)
-   [<span data-ttu-id="e5796-160">GDI-Objekt Handles</span><span class="sxs-lookup"><span data-stu-id="e5796-160">GDI Object Handles</span></span>](../sysinfo/gdi-objects.md)
-   [<span data-ttu-id="e5796-161">Objekt Handles für die Benutzeroberfläche</span><span class="sxs-lookup"><span data-stu-id="e5796-161">User Interface Object Handles</span></span>](../sysinfo/user-objects.md)

<span data-ttu-id="e5796-162">*Microsoft-Tools:*</span><span class="sxs-lookup"><span data-stu-id="e5796-162">*Microsoft Tools:*</span></span>

-   [<span data-ttu-id="e5796-163">Application Verifier</span><span class="sxs-lookup"><span data-stu-id="e5796-163">Application Verifier</span></span>](application-verifier.md)
-   [<span data-ttu-id="e5796-164">Debuggingtools für Windows</span><span class="sxs-lookup"><span data-stu-id="e5796-164">Debugging Tools for Windows</span></span>](/windows-hardware/drivers/debugger/)
-   [<span data-ttu-id="e5796-165">Dumpheap im Benutzermodus</span><span class="sxs-lookup"><span data-stu-id="e5796-165">User-Mode Dump Heap</span></span>](/windows-hardware/drivers/debugger/umdh)
-   [<span data-ttu-id="e5796-166">Ablaufverfolgungs-, Verarbeitungs-und Analyse Tool</span><span class="sxs-lookup"><span data-stu-id="e5796-166">Trace Capture, Processing, and Analysis Tool</span></span>](https://msdn.microsoft.com/performance/cc825801.aspx)
-   [<span data-ttu-id="e5796-167">CRT-Debugheap</span><span class="sxs-lookup"><span data-stu-id="e5796-167">CRT Debug Heap</span></span>](/visualstudio/debugger/crt-debug-heap-details?view=vs-2015)

<span data-ttu-id="e5796-168">*Weitere Links:*</span><span class="sxs-lookup"><span data-stu-id="e5796-168">*Additional Links:*</span></span>

-   <span data-ttu-id="e5796-169">[**Auto \_ ptr-Klasse**](https://msdn.microsoft.com/library/ew3fk483(v=VS.71).aspx)</span><span class="sxs-lookup"><span data-stu-id="e5796-169">[**auto\_ptr Class**](https://msdn.microsoft.com/library/ew3fk483(v=VS.71).aspx)</span></span>
-   <span data-ttu-id="e5796-170">[Active Template Library (ATL)-Speicher Klassen](https://msdn.microsoft.com/library/44yh1z4f(v=VS.71).aspx)</span><span class="sxs-lookup"><span data-stu-id="e5796-170">[Active Template Library (ATL) Memory Classes](https://msdn.microsoft.com/library/44yh1z4f(v=VS.71).aspx)</span></span>
-   <span data-ttu-id="e5796-171">[**\_com \_ ptr \_ t-Objekt**](https://msdn.microsoft.com/library/417w8b3b(v=VS.71).aspx)</span><span class="sxs-lookup"><span data-stu-id="e5796-171">[**\_com\_ptr\_t Object**](https://msdn.microsoft.com/library/417w8b3b(v=VS.71).aspx)</span></span>
-   <span data-ttu-id="e5796-172">[**\_BSTR \_ t-Klasse**](https://msdn.microsoft.com/library/zthfhkd6(v=VS.71).aspx)</span><span class="sxs-lookup"><span data-stu-id="e5796-172">[**\_bstr\_t Class**](https://msdn.microsoft.com/library/zthfhkd6(v=VS.71).aspx)</span></span>
-   <span data-ttu-id="e5796-173">[**\_Variant \_ YT-Klasse**](https://msdn.microsoft.com/library/x295h94e(v=VS.71).aspx)</span><span class="sxs-lookup"><span data-stu-id="e5796-173">[**\_variant\_yt Class**](https://msdn.microsoft.com/library/x295h94e(v=VS.71).aspx)</span></span>
-   [<span data-ttu-id="e5796-174">"Nachverfolgung von verwalteten Speicher Verlusten"</span><span class="sxs-lookup"><span data-stu-id="e5796-174">"Tracking down managed memory leaks"</span></span>](/archive/blogs/ricom/)
-   <span data-ttu-id="e5796-175">["Verstehen und lösen von Internet Explorer-entwurfmustern"](/previous-versions/ms976398(v=msdn.10))</span><span class="sxs-lookup"><span data-stu-id="e5796-175">["Understanding and Solving Internet Explorer Leak Patterns"](/previous-versions/ms976398(v=msdn.10))</span></span>
-   [<span data-ttu-id="e5796-176">"JavaScript-Speicherlecks-Erkennung"</span><span class="sxs-lookup"><span data-stu-id="e5796-176">"JavaScript Memory Leak Detector"</span></span>](/archive/blogs/gpde/new-javascript-memory-leak-detector-from-our-team)
-   <span data-ttu-id="e5796-177">[Minderung von zirkulären Speicherlecks (in Browsern):](/previous-versions/windows/internet-explorer/ie-developer/platform-apis/dd361842(v=vs.85))</span><span class="sxs-lookup"><span data-stu-id="e5796-177">[Circular Memory Leak Mitigation (in browsers):](/previous-versions/windows/internet-explorer/ie-developer/platform-apis/dd361842(v=vs.85))</span></span>
-   <span data-ttu-id="e5796-178">[**try-finally-Anweisung**](https://msdn.microsoft.com/library/yb3kz605(v=VS.71).aspx)</span><span class="sxs-lookup"><span data-stu-id="e5796-178">[**try-finally statement**](https://msdn.microsoft.com/library/yb3kz605(v=VS.71).aspx)</span></span>
-   [<span data-ttu-id="e5796-179">**PROPVARIANT-Struktur**</span><span class="sxs-lookup"><span data-stu-id="e5796-179">**PROPVARIANT Structure**</span></span>](/windows/win32/api/propidlbase/ns-propidlbase-propvariant)
-   [<span data-ttu-id="e5796-180">**Propvariantclear-Funktion**</span><span class="sxs-lookup"><span data-stu-id="e5796-180">**PropVariantClear Function**</span></span>](/windows/win32/api/combaseapi/nf-combaseapi-propvariantclear)

 

 
