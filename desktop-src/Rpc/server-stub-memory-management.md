---
title: Server-Stub-Speicherverwaltung
description: Server-Stub-Speicherverwaltung
ms.assetid: 99e3ee56-5adb-4b25-bcf2-316d1bbdbdba
keywords:
- Server-Stub-Speicherverwaltung
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: d6e052df6da999e5371ac498a1d39852b4be2b5e
ms.sourcegitcommit: ae73f4dd3cf5a3c6a1ea7d191ca32a5b01f6686b
ms.translationtype: MT
ms.contentlocale: de-DE
ms.lasthandoff: 09/08/2020
ms.locfileid: "103858521"
---
# <a name="server-stub-memory-management"></a><span data-ttu-id="f8a24-104">Server-Stub-Speicherverwaltung</span><span class="sxs-lookup"><span data-stu-id="f8a24-104">Server Stub Memory Management</span></span>

## <a name="an-introduction-to-server-stub-memory-management"></a><span data-ttu-id="f8a24-105">Eine Einführung in die Server-Stub der Speicherverwaltung</span><span class="sxs-lookup"><span data-stu-id="f8a24-105">An Introduction to Server-Stub Memory Management</span></span>

<span data-ttu-id="f8a24-106">Mit mittlerer l generierte stubvorgänge fungieren als Schnittstelle zwischen einem Client Prozess und einem Server Prozess.</span><span class="sxs-lookup"><span data-stu-id="f8a24-106">MIDL-generated stubs act as the interface between a client process and a server process.</span></span> <span data-ttu-id="f8a24-107">Ein Clientstub marshallte alle Daten, die an Parameter, die mit dem [**\[ in \]**](../midl/in.md) -Attribut gekennzeichnet sind, und sendet Sie an den Serverstub.</span><span class="sxs-lookup"><span data-stu-id="f8a24-107">A client stub marshals all data passed to parameters marked with the [**\[in\]**](../midl/in.md) attribute, and sends it to the server stub.</span></span> <span data-ttu-id="f8a24-108">Der Serverstub erstellt nach dem Empfang dieser Daten die-Rückruf Stapel und führt dann die entsprechende vom Benutzer implementierte Server Funktion aus.</span><span class="sxs-lookup"><span data-stu-id="f8a24-108">The server stub, upon receiving this data, reconstructs the call stack, and then executes the corresponding user-implemented server function.</span></span> <span data-ttu-id="f8a24-109">Der [**\[ \] Serverstub**](../midl/out-idl.md) Marshalls auch die mit dem Out-Attribut markierten Parameterdaten und gibt Sie an die Client Anwendung zurück.</span><span class="sxs-lookup"><span data-stu-id="f8a24-109">The server stub also marshals the parameter data marked with the [**\[out\]**](../midl/out-idl.md) attribute and returns it to the client application.</span></span>

<span data-ttu-id="f8a24-110">Das von Msrpc verwendete gemarshallte 32-Bit-Datenformat ist eine kompatible Version der Übertragungs Syntax für die Netzwerkdaten Darstellung (Übertragung).</span><span class="sxs-lookup"><span data-stu-id="f8a24-110">The 32-bit marshaled data format used by MSRPC is a compliant version of the Network Data Representation (NDR) transfer syntax.</span></span> <span data-ttu-id="f8a24-111">Weitere Informationen zu diesem Format finden Sie auf [der Website Open Group](https://www.opengroup.org/).</span><span class="sxs-lookup"><span data-stu-id="f8a24-111">For more information about this format, see [The Open Group website](https://www.opengroup.org/).</span></span> <span data-ttu-id="f8a24-112">Bei 64-Bit-Plattformen kann eine Microsoft 64-Bit-Erweiterung mit der Bezeichnung "NDR64" verwendet werden, um die Leistung zu verbessern.</span><span class="sxs-lookup"><span data-stu-id="f8a24-112">For 64-bit platforms, a Microsoft 64-bit extension to NDR transfer syntax called NDR64 can be used for better performance.</span></span>

## <a name="unmarshaling-inbound-data"></a><span data-ttu-id="f8a24-113">Marshalling eingehender Daten</span><span class="sxs-lookup"><span data-stu-id="f8a24-113">Unmarshaling Inbound Data</span></span>

<span data-ttu-id="f8a24-114">In Msrpc marshallert der Clientstub alle in einem kontinuierlichen Puffer markierten [**\[ \]**](../midl/in.md) Parameterdaten für die Übertragung an den Serverstub.</span><span class="sxs-lookup"><span data-stu-id="f8a24-114">In MSRPC, the client stub marshals all of the parameter data tagged as [**\[in\]**](../midl/in.md) in one continuous buffer for transmission to the server stub.</span></span> <span data-ttu-id="f8a24-115">Entsprechend marshallert der [**\[ \] Serverstub**](../midl/out-idl.md) alle Daten, die mit dem Out-Attribut gekennzeichnet sind, in einem kontinuierlichen Puffer für die Rückgabe an den Client-Stub.</span><span class="sxs-lookup"><span data-stu-id="f8a24-115">Likewise, the server stub marshals all data marked with the [**\[out\]**](../midl/out-idl.md) attribute in a continuous buffer for return to the client stub.</span></span> <span data-ttu-id="f8a24-116">Während die Netzwerkprotokoll Ebene unterhalb von RPC den Puffer für die Übertragung fragmentieren kann, ist die Fragmentierung für die RPC-stubvorgänge transparent.</span><span class="sxs-lookup"><span data-stu-id="f8a24-116">While the network protocol layer beneath RPC can fragment and packetize the buffer for transmission, the fragmentation is transparent to the RPC stubs.</span></span>

<span data-ttu-id="f8a24-117">Die Speicher Belegung zum Erstellen des Server-Aufrufframes kann ein kostspieliger Vorgang sein.</span><span class="sxs-lookup"><span data-stu-id="f8a24-117">Memory allocation for creating the server call frame can be an expensive operation.</span></span> <span data-ttu-id="f8a24-118">Der Serverstub versucht, unnötige Speicherauslastung zu minimieren, wenn dies möglich ist, und es wird davon ausgegangen, dass die Server Routine keine Daten freigibt oder neu **\[ zuweist \] ,** die mit den Attributen [**\[ in \]**](../midl/in.md) oder in, out gekennzeichnet sind.</span><span class="sxs-lookup"><span data-stu-id="f8a24-118">The server stub will attempt to minimize unnecessary memory usage when possible, and it is assumed that the server routine will not free or reallocate data marked with the [**\[in\]**](../midl/in.md) or **\[in, out\]** attributes.</span></span> <span data-ttu-id="f8a24-119">Der Serverstub versucht nach Möglichkeit, Daten im Puffer wiederzuverwenden, um unnötige Duplizierungen zu vermeiden.</span><span class="sxs-lookup"><span data-stu-id="f8a24-119">The server stub attempts to reuse data in the buffer whenever possible to avoid unnecessary duplication.</span></span> <span data-ttu-id="f8a24-120">Die allgemeine Regel: Wenn das gemarshallte Datenformat mit dem Speicherformat identisch ist, verwendet RPC Zeiger auf die marshallten Daten, anstatt zusätzlichen Arbeitsspeicher für identisch formatierte Daten zuzuordnen.</span><span class="sxs-lookup"><span data-stu-id="f8a24-120">The general rule is that if the marshaled data format is the same as the memory format, RPC will use pointers to the marshalled data instead of allocating additional memory for identically formatted data.</span></span>

<span data-ttu-id="f8a24-121">Der folgende RPC-Aufruf wird z. b. mit einer-Struktur definiert, deren gemarshalltes Format mit dem in-Memory-Format identisch ist.</span><span class="sxs-lookup"><span data-stu-id="f8a24-121">For example, the following RPC call is defined with a structure whose marshaled format is identical to its in-memory format.</span></span>

``` syntax
typedef struct RpcStructure
{
    long val;
    long val2;
}

void ProcessRpcStructure
(
    [in]  RpcStructure *plInStructure;
    [out] RpcStructure *plOutStructure;
);
```

<span data-ttu-id="f8a24-122">In diesem Fall weist RPC keinen zusätzlichen Arbeitsspeicher für die Daten zu, auf die von *plinstructure* verwiesen wird. Stattdessen übergibt Sie den Zeiger einfach an die gemarshallte Daten an die serverseitige Funktions Implementierung.</span><span class="sxs-lookup"><span data-stu-id="f8a24-122">In this case, RPC does not allocate additional memory for the data referenced by *plInStructure*; rather, it simply passes the pointer to the marshaled data to the server-side function implementation.</span></span> <span data-ttu-id="f8a24-123">Der Server-Stub für den RPC-Server überprüft den Puffer während des Unmarshalling-Prozesses, wenn der Stub mit dem Flag "-robust" kompiliert wird (Dies ist eine Standardeinstellung in der aktuellsten Version des compl-Compilers).</span><span class="sxs-lookup"><span data-stu-id="f8a24-123">The RPC server stub verifies the buffer during the unmarshaling process if the stub is compiled using the "-robust" flag (which is a default setting in the nmost recent version of the MIDL compiler).</span></span> <span data-ttu-id="f8a24-124">RPC gewährleistet, dass die Daten, die an die serverseitige Funktions Implementierung übermittelt werden, gültig sind.</span><span class="sxs-lookup"><span data-stu-id="f8a24-124">RPC guarantees that the data passed to the server-side function implementation is valid.</span></span>

<span data-ttu-id="f8a24-125">Beachten Sie, dass der Arbeitsspeicher für *ploutstructure* reserviert ist, da keine Daten für ihn an den Server übermittelt werden.</span><span class="sxs-lookup"><span data-stu-id="f8a24-125">Be aware that memory is allocated for *plOutStructure*, since no data is passed to the server for it.</span></span>

## <a name="memory-allocation-for-inbound-data"></a><span data-ttu-id="f8a24-126">Speicher Belegung für eingehende Daten</span><span class="sxs-lookup"><span data-stu-id="f8a24-126">Memory Allocation for Inbound Data</span></span>

<span data-ttu-id="f8a24-127">Fälle können eintreten, wenn der Serverstub Speicher für Parameterdaten zuordnet, die mit den Attributen [**\[ in \]**](../midl/in.md) oder **\[ in, out \] gekennzeichnet sind** .</span><span class="sxs-lookup"><span data-stu-id="f8a24-127">Cases can arise where the server stub allocates memory for parameter data marked with the [**\[in\]**](../midl/in.md) or **\[in, out\]** attributes.</span></span> <span data-ttu-id="f8a24-128">Dies tritt auf, wenn sich das gemarshallte Datenformat vom Speicherformat unterscheidet oder wenn die Strukturen, die die gemarshallten Daten enthalten, ausreichend komplex sind und vom RPC-Serverstub atomisch gelesen werden müssen.</span><span class="sxs-lookup"><span data-stu-id="f8a24-128">This occurs when the marshaled data format differs from the memory format, or when the structures that comprise the marshaled data are sufficient complex and must be read atomically by the RPC server stub.</span></span> <span data-ttu-id="f8a24-129">Im folgenden finden Sie einige häufige Fälle, in denen Arbeitsspeicher für Daten zugeordnet werden muss, die vom Serverstub empfangen werden.</span><span class="sxs-lookup"><span data-stu-id="f8a24-129">Listed below are several common cases when memory must be allocated for data received by the server stub.</span></span>

-   <span data-ttu-id="f8a24-130">Bei den Daten handelt es sich um ein veränderliches Array oder um ein unterschiedliches Array.</span><span class="sxs-lookup"><span data-stu-id="f8a24-130">The data is a varying array or a conformant varying array.</span></span> <span data-ttu-id="f8a24-131">Dabei handelt es sich um Arrays (oder Zeiger auf Arrays), für die die [**\[ Länge \_ () \]**](../midl/length-is.md) oder das [**\[ erste \_ is () \]**](../midl/first-is.md) -Attribut festgelegt ist.</span><span class="sxs-lookup"><span data-stu-id="f8a24-131">These are arrays (or pointers to arrays) that have the [**\[length\_is()\]**](../midl/length-is.md) or [**\[first\_is()\]**](../midl/first-is.md) attribute set on them.</span></span> <span data-ttu-id="f8a24-132">In der NDR wird nur das erste Element dieser Arrays gemarshallt und übertragen.</span><span class="sxs-lookup"><span data-stu-id="f8a24-132">In NDR, only the first element of these arrays are marshaled and transmitted.</span></span> <span data-ttu-id="f8a24-133">Im folgenden Code Ausschnitt wird z. b. für die Daten, die im- *Parameter des* -Parameters übergeben werden, Arbeitsspeicher zugeordnet.</span><span class="sxs-lookup"><span data-stu-id="f8a24-133">For example, in the code snippet below, the data passed in the parameter *pv* will have memory allocated for it.</span></span>

    ``` syntax
    void RpcFunction
    (
        [in] long size,
        [in, out] long *pLength,
        [in, out, size_is(size), length_is(*pLength)] long *pv
    );
    ```

-   <span data-ttu-id="f8a24-134">Bei den Daten handelt es sich um eine Zeichenfolge oder eine nicht konforme Zeichenfolge.</span><span class="sxs-lookup"><span data-stu-id="f8a24-134">The data is a sized string or non-conformant string.</span></span> <span data-ttu-id="f8a24-135">Diese Zeichen folgen sind in der Regel Zeiger auf Zeichendaten, die mit dem Attribut [**\[ size \_ is () \]**](../midl/size-is.md) gekennzeichnet sind.</span><span class="sxs-lookup"><span data-stu-id="f8a24-135">These strings are usually pointers to character data tagged with the [**\[size\_is()\]**](../midl/size-is.md) attribute.</span></span> <span data-ttu-id="f8a24-136">Im folgenden Beispiel wird der Arbeitsspeicher für die an die serverseitige **sizedstring** -Funktion übergebenen Zeichenfolge zugewiesen, während die an die **Normal String** -Funktion übergebenen Zeichenfolge wieder verwendet wird.</span><span class="sxs-lookup"><span data-stu-id="f8a24-136">In the example below, the string passed to the **SizedString** server-side function will have memory allocated, whereas the string passed to the **NormalString** function will be reused.</span></span>

    ``` syntax
    void SizedString
    (
        [in] long size,
        [in, size_is(size), string] char *str
    );

    void NormalString
    (
        [in, string] char str
    );
    ```

-   <span data-ttu-id="f8a24-137">Bei den Daten handelt es sich um einen einfachen Typ, dessen Speichergröße von der gemarshallten Größe abweicht, z. b. **enum16** und **\_ \_ int3264**.</span><span class="sxs-lookup"><span data-stu-id="f8a24-137">The data is a simple type whose memory size differs from its marshaled size, such as **enum16** and **\_\_int3264**.</span></span>
-   <span data-ttu-id="f8a24-138">Die Daten werden durch eine Struktur definiert, deren Arbeitsspeicher Ausrichtung kleiner ist als die natürliche Ausrichtung, enthält einen der oben genannten Datentypen oder eine nachfolgende Byte Auffüll Zeichen.</span><span class="sxs-lookup"><span data-stu-id="f8a24-138">The data is defined by a structure whose memory alignment is smaller than the natural alignment, contains any of the above data types, or has trailing byte padding.</span></span> <span data-ttu-id="f8a24-139">Beispielsweise verfügt die folgende komplexe Datenstruktur über eine erzwungene 2-Byte-Ausrichtung und ist am Ende Auffüll Zeichen.</span><span class="sxs-lookup"><span data-stu-id="f8a24-139">For example, the following complex data structure has forced 2-byte alignment and has padding at the end.</span></span>

    ``` syntax
#pragma pack(2)
    typedef struct ComplexPackedStructure
    {
        char c;  
        long l;   // alignment is forced at the second byte
        char c2;  // there will be a trailing one-byte pad to keep 2-byte alignment
    }
    ```

-   <span data-ttu-id="f8a24-140">Die Daten enthalten eine Struktur, die als Feld nach Feld gemarshallt werden muss.</span><span class="sxs-lookup"><span data-stu-id="f8a24-140">The data contains a structure that must be marshaled field by field.</span></span> <span data-ttu-id="f8a24-141">Diese Felder enthalten Schnittstellen Zeiger, die in DCOM-Schnittstellen definiert sind. ignorierte Zeiger; ganzzahlige Werte, die mit dem [**\[ Range \]**](../midl/range.md) -Attribut festgelegt werden. Elemente von Arrays, die mit dem [**\[ Wire \_ \] Marshal**](../midl/wire-marshal.md)definiert sind, [**\[ User \_ Marshal \]**](../midl/user-marshal.md), über [**\[ tragen \_ als \]**](../midl/transmit-as.md) und [**\[ repräsentieren \_ als \]**](../midl/represent-as.md) Attribute und eingebettete komplexe Datenstrukturen.</span><span class="sxs-lookup"><span data-stu-id="f8a24-141">These fields include interface pointers defined in DCOM interfaces; ignored pointers; integer values set with the [**\[range\]**](../midl/range.md) attribute; elements of arrays defined with the [**\[wire\_marshal\]**](../midl/wire-marshal.md), [**\[user\_marshal\]**](../midl/user-marshal.md), [**\[transmit\_as\]**](../midl/transmit-as.md) and [**\[represent\_as\]**](../midl/represent-as.md) attributes; and embedded complex data structures.</span></span>
-   <span data-ttu-id="f8a24-142">Die Daten enthalten eine Union, eine Struktur, die eine Union enthält, oder ein Array von Unions.</span><span class="sxs-lookup"><span data-stu-id="f8a24-142">The data contains a union, a structure containing a union, or an array of unions.</span></span> <span data-ttu-id="f8a24-143">Nur der jeweilige Branch der Union wird bei der Übertragung gemarshallt.</span><span class="sxs-lookup"><span data-stu-id="f8a24-143">Only the specific branch of the union is marshaled on the wire.</span></span>
-   <span data-ttu-id="f8a24-144">Die Daten enthalten eine Struktur mit einem mehrdimensionalen konformen Array, das mindestens eine nicht fixierte Dimension aufweist.</span><span class="sxs-lookup"><span data-stu-id="f8a24-144">The data contains a structure with a multidimensional conformant array that has at least one non-fixed dimension.</span></span>
-   <span data-ttu-id="f8a24-145">Die Daten enthalten ein Array komplexer Strukturen.</span><span class="sxs-lookup"><span data-stu-id="f8a24-145">The data contains an array of complex structures.</span></span>
-   <span data-ttu-id="f8a24-146">Die Daten enthalten ein Array von einfachen Datentypen, z. b. **enum16** und **\_ \_ int3264**.</span><span class="sxs-lookup"><span data-stu-id="f8a24-146">The data contains an array of simple data types such as **enum16** and **\_\_int3264**.</span></span>
-   <span data-ttu-id="f8a24-147">Die Daten enthalten ein Array von ref-und Schnittstellen Zeigern.</span><span class="sxs-lookup"><span data-stu-id="f8a24-147">The data contains an array of ref and interface pointers.</span></span>
-   <span data-ttu-id="f8a24-148">Die Daten verfügen über ein [**\[ Force \_ \]**](../midl/force-allocate.md) -Attribut, das auf einen Zeiger angewendet wird.</span><span class="sxs-lookup"><span data-stu-id="f8a24-148">The data has a [**\[force\_allocate\]**](../midl/force-allocate.md) attribute applied to a pointer.</span></span>
-   <span data-ttu-id="f8a24-149">Die Daten verfügen über ein Attribut zum [**\[ zuordnen (alle \_ Knoten) \]**](../midl/allocate.md) , das auf einen Zeiger angewendet wird.</span><span class="sxs-lookup"><span data-stu-id="f8a24-149">The data has a [**\[allocate(all\_nodes)\]**](../midl/allocate.md) attribute applied to a pointer.</span></span>
-   <span data-ttu-id="f8a24-150">Die Daten verfügen über ein [**\[ Byte \_ Count \]**](../midl/byte-count.md) -Attribut, das auf einen Zeiger angewendet wird.</span><span class="sxs-lookup"><span data-stu-id="f8a24-150">The data has a [**\[byte\_count\]**](../midl/byte-count.md) attribute applied to a pointer.</span></span>

## <a name="64-bit-data-and-ndr64-transfer-syntax"></a><span data-ttu-id="f8a24-151">64-Bit-Daten-und NDR64-Übertragungs Syntax</span><span class="sxs-lookup"><span data-stu-id="f8a24-151">64-bit Data and NDR64 Transfer Syntax</span></span>

<span data-ttu-id="f8a24-152">Wie bereits erwähnt, werden 64-Bit-Daten mithilfe einer bestimmten 64-Bit-Übertragungs Syntax mit dem Namen NDR64 gemarshallt.</span><span class="sxs-lookup"><span data-stu-id="f8a24-152">As mentioned previously, 64-bit data is marshalled using a specific 64-bit transfer syntax called NDR64.</span></span> <span data-ttu-id="f8a24-153">Diese Übertragungs Syntax wurde entwickelt, um ein bestimmtes Problem zu beheben, das auftritt, wenn Zeiger unter 32-Bit-NDR gemarshallt und an einen Server-Stub auf einer 64-Bit-Plattform übertragen werden.</span><span class="sxs-lookup"><span data-stu-id="f8a24-153">This transfer syntax was developed to address the specific issue that arises when pointers are marshaled under 32-bit NDR and transmitted to a server-stub on a 64-bit platform.</span></span> <span data-ttu-id="f8a24-154">In diesem Fall entspricht ein gemarshallter 32-Bit-Datenzeiger nicht einem 64-Bit-Wert, und die Speicher Belegung erfolgt immer.</span><span class="sxs-lookup"><span data-stu-id="f8a24-154">In this case, a marshaled 32-bit data pointer does not match a 64-bit one, and memory allocation will invariably occur.</span></span> <span data-ttu-id="f8a24-155">Um ein konsistentes Verhalten auf 64-Bit-Plattformen zu erstellen, hat Microsoft eine neue Übertragungs Syntax namens NDR64 entwickelt.</span><span class="sxs-lookup"><span data-stu-id="f8a24-155">To create a more consistent behavior on 64-bit platforms, Microsoft developed a new transfer syntax called NDR64.</span></span>

<span data-ttu-id="f8a24-156">Ein Beispiel zur Veranschaulichung dieses Problems lautet wie folgt:</span><span class="sxs-lookup"><span data-stu-id="f8a24-156">An example illustrating this problem is as follows:</span></span>


```C++
typedef struct PtrStruct
{
  long l;
  long *pl;
}
```



<span data-ttu-id="f8a24-157">Diese Struktur wird beim Marshalling vom Serverstub auf einem 32-Bit-System wieder verwendet.</span><span class="sxs-lookup"><span data-stu-id="f8a24-157">This structure, when marshaled, will be reused by the server stub on a 32-bit system.</span></span> <span data-ttu-id="f8a24-158">Wenn sich der Serverstub jedoch in einem 64-Bit-System befindet, sind die für den NDR gemarshallten Daten 4 Bytes lang, die erforderliche Arbeitsspeicher Größe ist jedoch 8.</span><span class="sxs-lookup"><span data-stu-id="f8a24-158">However, if the server stub resides on a 64-bit system, the NDR-marshaled data is 4 bytes in length, but the required memory size will be 8.</span></span> <span data-ttu-id="f8a24-159">Demzufolge wird die Speicher Belegung erzwungen, und die Wiederverwendung des Puffers tritt selten auf.</span><span class="sxs-lookup"><span data-stu-id="f8a24-159">As a result, memory allocation is forced, and buffer reuse will rarely occur.</span></span> <span data-ttu-id="f8a24-160">NDR64 löst dieses Problem, indem die gemarshallte Größe eines Zeigers 64-Bit-Wert ist.</span><span class="sxs-lookup"><span data-stu-id="f8a24-160">NDR64 addresses this problem by making the marshaled size of a pointer 64-bit.</span></span>

<span data-ttu-id="f8a24-161">Im Gegensatz zum 32-Bit-NDR machen einfache Datentypen wie **enum16** und **\_ \_ int3264** unter NDR64 keine Struktur oder ein Array Komplex.</span><span class="sxs-lookup"><span data-stu-id="f8a24-161">In contrast with 32-bit NDR, simple data tyes such as **enum16** and **\_\_int3264** do not make a structure or array complex under NDR64.</span></span> <span data-ttu-id="f8a24-162">Ebenso machen nachfolgende Auffüll Werte keine Struktur Komplex.</span><span class="sxs-lookup"><span data-stu-id="f8a24-162">Likewise, trailing pad values do not make a structure complex.</span></span> <span data-ttu-id="f8a24-163">Schnittstellen Zeiger werden als eindeutige Zeiger auf der obersten Ebene behandelt. Folglich werden Strukturen und Arrays, die Schnittstellen Zeiger enthalten, nicht als Komplex eingestuft und erfordern keine bestimmte Speicher Belegung für ihre Verwendung.</span><span class="sxs-lookup"><span data-stu-id="f8a24-163">Interface pointers are treated as unique pointers at the top level; as a result, structures and arrays containing interface pointers are not considered complex and will not require specific memory allocation for their use.</span></span>

## <a name="initializing-outbound-data"></a><span data-ttu-id="f8a24-164">Initialisieren von ausgehenden Daten</span><span class="sxs-lookup"><span data-stu-id="f8a24-164">Initializing Outbound Data</span></span>

<span data-ttu-id="f8a24-165">Nachdem alle eingehenden Daten unmarshallt wurden, muss der Server-Stub die ausgehenden Zeiger initialisieren, die mit dem [**\[ out \]**](../midl/out-idl.md) -Attribut markiert sind.</span><span class="sxs-lookup"><span data-stu-id="f8a24-165">After all of the inbound data has been unmarshalled, the server stub needs to initialize the outbound-only pointers marked with the [**\[out\]**](../midl/out-idl.md) attribute.</span></span>


```C++
typedef struct RpcStructure
{
    long val;
    long val2;
}

void ProcessRpcStructure
(
    [in]  RpcStructure *plInStructure;
    [out] RpcStructure *plOutStructure;
);
```



<span data-ttu-id="f8a24-166">Im obigen-Befehl muss der Server-Stub *ploutstructure* initialisieren, da es nicht in den gemarshallten Daten enthalten war, und es handelt sich um [**einen impliziten \[ \] Verweis**](../midl/ref.md) Zeiger, der für die Implementierung der Server Funktion verfügbar gemacht werden muss.</span><span class="sxs-lookup"><span data-stu-id="f8a24-166">In the above call, the server stub must initialize *plOutStructure* because it was not present in the marshaled data, and it is an implied [**\[ref\]**](../midl/ref.md) pointer that must be made available to the server function implementation.</span></span> <span data-ttu-id="f8a24-167">Der Server-Stub für den RPC-Server initialisiert und nullt alle Verweis Zeiger auf oberster Ebene mit dem [**\[ out \]**](../midl/out-idl.md) -Attribut ab.</span><span class="sxs-lookup"><span data-stu-id="f8a24-167">The RPC server stub initializes and zeroes out any top-level reference-only pointers with the [**\[out\]**](../midl/out-idl.md) attribute.</span></span> <span data-ttu-id="f8a24-168">Alle **darunter \[ liegenden Verweis Zeiger werden rekursiv initialisiert. \]**</span><span class="sxs-lookup"><span data-stu-id="f8a24-168">Any **\[out\]** reference pointers beneath it are recursively initialized as well.</span></span> <span data-ttu-id="f8a24-169">Die Rekursion hält an allen Zeigern, auf die die [**\[ eindeutigen \]**](../midl/unique.md) oder [**\[ ptr \]**](../midl/ptr.md) -Attribute festgelegt sind.</span><span class="sxs-lookup"><span data-stu-id="f8a24-169">The recursion stops at any pointers with the [**\[unique\]**](../midl/unique.md) or [**\[ptr\]**](../midl/ptr.md) attributes set on them.</span></span>

<span data-ttu-id="f8a24-170">Die Implementierung der Server Funktion kann Zeiger Werte der obersten Ebene nicht direkt ändern und Sie daher nicht neu zuordnen.</span><span class="sxs-lookup"><span data-stu-id="f8a24-170">The server function implementation cannot directly alter top-level pointer values, and thus cannot reallocate them.</span></span> <span data-ttu-id="f8a24-171">Der folgende Code ist beispielsweise in der Implementierung von **processrpcstructure** oben ungültig:</span><span class="sxs-lookup"><span data-stu-id="f8a24-171">For example, in the implementation of **ProcessRpcStructure** above, the following code is invalid:</span></span>


```C++
void ProcessRpcStructure(RpcStructure *plInStructure, rpcStructure *plOutStructure)
{
    plOutStructure = MIDL_user_allocate(sizeof(RpcStructure));
    Process(plOutStructure);
}
```



<span data-ttu-id="f8a24-172">*ploutstructure* ist ein Stapel Wert, und die Änderung wird nicht an RPC zurückgegeben.</span><span class="sxs-lookup"><span data-stu-id="f8a24-172">*plOutStructure* is a stack value and its change is not propagated back to RPC.</span></span> <span data-ttu-id="f8a24-173">Die Implementierung der Server Funktion kann versuchen, eine Zuordnung zu vermeiden, indem versucht wird, *ploutstructure* freizugeben. Dies kann zu einer Beschädigung des Arbeitsspeichers führen.</span><span class="sxs-lookup"><span data-stu-id="f8a24-173">The server function implementation can attempt to avoid allocation by attempting to free *plOutStructure*, which may result in memory corruption.</span></span> <span data-ttu-id="f8a24-174">Der Serverstub weist dann Speicherplatz für den Zeiger auf oberster Ebene im Speicher (im Fall von Zeiger auf Zeiger) und eine einfache Struktur auf oberster Ebene zu, deren Größe auf dem Stapel kleiner als erwartet ist.</span><span class="sxs-lookup"><span data-stu-id="f8a24-174">The server stub will then allocate space for the top-level pointer in memory (in the pointer-to-pointer case) and a top-level simple structure whose size on the stack is smaller than expected.</span></span>

<span data-ttu-id="f8a24-175">Der Client kann unter bestimmten Umständen die Größe der Speicher Belegung der Serverseite angeben.</span><span class="sxs-lookup"><span data-stu-id="f8a24-175">The client can, under certain circumstances, specify the memory allocation size of the server side.</span></span> <span data-ttu-id="f8a24-176">Im folgenden Beispiel gibt der Client die Größe der ausgehenden Daten im Parameter für die eingehende *Größe* an.</span><span class="sxs-lookup"><span data-stu-id="f8a24-176">In the following example, the client specifies the size of the outbound data in the inbound *size* parameter.</span></span>

``` syntax
void VariableSizeData
(
    [in] long size,
    [out, size_is(size)] char *pv
);
```

<span data-ttu-id="f8a24-177">Nach dem Entsperren der eingehenden Daten, einschließlich der *Größe*, ordnet der Server-Stub einen Puffer für *PV* mit der Größe "sizeof (Char) \* size" zu.</span><span class="sxs-lookup"><span data-stu-id="f8a24-177">After unmarshalling the inbound data, including *size*, the server stub allocates a buffer for *pv* with a size of "sizeof(char)\*size".</span></span> <span data-ttu-id="f8a24-178">Nachdem der Speicherplatz zugeordnet wurde, nullt der Server-Stub den Puffer.</span><span class="sxs-lookup"><span data-stu-id="f8a24-178">After the space has been allocated, the server stub zeroes out the buffer.</span></span> <span data-ttu-id="f8a24-179">Beachten Sie, dass der Stub in diesem speziellen Fall den Speicher mit der **mittleren \_ Benutzer \_ Zuordnung ()** zuordnet, da die Größe des Puffers zur Laufzeit bestimmt wird.</span><span class="sxs-lookup"><span data-stu-id="f8a24-179">Note that in this particular case, the stub allocates the memory with **MIDL\_user\_allocate()**, since the size of the buffer is determined at runtime.</span></span>

<span data-ttu-id="f8a24-180">Beachten Sie, dass im Fall von DCOM-Schnittstellen die von der Mitte generierten Stubdaten möglicherweise überhaupt nicht beteiligt sind, wenn der Client und der Server dasselbe com-Apartment verwenden oder wenn **icallframe** implementiert ist.</span><span class="sxs-lookup"><span data-stu-id="f8a24-180">Be aware that in the case of DCOM interfaces, MIDL-generated stubs may not be involved at all if the client and server share the same COM apartment, or if **ICallFrame** is implemented.</span></span> <span data-ttu-id="f8a24-181">In diesem Fall kann der Server nicht vom Zuordnungs Verhalten abhängen und muss den Client Speicher unabhängig überprüfen.</span><span class="sxs-lookup"><span data-stu-id="f8a24-181">In this case, the server cannot depend on the allocation behavior, and needs to independently verify client-sized memory.</span></span>

## <a name="server-side-function-implementations-and-outbound-data-marshaling"></a><span data-ttu-id="f8a24-182">Server seitige Funktions Implementierungen und ausgehende Datenmarshalling</span><span class="sxs-lookup"><span data-stu-id="f8a24-182">Server-side Function Implementations and Outbound Data Marshaling</span></span>

<span data-ttu-id="f8a24-183">Unmittelbar nach dem Unmarshalling bei eingehenden Daten und der Initialisierung des Speichers, der für ausgehende Daten reserviert ist, führt der RPC-Server-Stub die serverseitige Implementierung der Funktion aus, die vom Client aufgerufen wird.</span><span class="sxs-lookup"><span data-stu-id="f8a24-183">Immediately subsequent to the unmarshalling on inbound data and the initialization of the memory allocated to contain outbound data, the RPC server stub executes the server-side implementation of the function called by the client.</span></span> <span data-ttu-id="f8a24-184">Zu diesem Zeitpunkt kann der Server die Daten ändern, die speziell mit dem **\[ in-, \] out** -Attribut gekennzeichnet sind, und den Arbeitsspeicher auffüllen, der für ausgehende Daten verwendet wird (die mit [**\[ \] markierten Daten).**](../midl/out-idl.md)</span><span class="sxs-lookup"><span data-stu-id="f8a24-184">At this time, the server can modify the data specifically marked with the **\[in, out\]** attribute, and it can populate the memory allocated for outbound-only data (the data tagged with [**\[out\]**](../midl/out-idl.md)).</span></span>

<span data-ttu-id="f8a24-185">Die allgemeinen Regeln für die Bearbeitung von marshallingparameterdaten sind einfach: der Server kann nur neuen Arbeitsspeicher zuordnen oder den Speicher ändern, der speziell vom Serverstub zugewiesen wird.</span><span class="sxs-lookup"><span data-stu-id="f8a24-185">The general rules for the manipulation of marshalled parameter data are simple: the server can only allocate new memory or modify the memory specifically allocated by the server stub.</span></span> <span data-ttu-id="f8a24-186">Das erneute Zuordnen oder Freigeben von vorhandenem Arbeitsspeicher für Daten kann sich negativ auf die Ergebnisse und die Leistung des Funktions Aufrufes auswirken und kann sehr schwer zu debuggen sein.</span><span class="sxs-lookup"><span data-stu-id="f8a24-186">Reallocating or releasing existing memory for data can have a negative impact on the results and performance of the function call, and can be very difficult to debug.</span></span>

<span data-ttu-id="f8a24-187">Logisch, der RPC-Server befindet sich in einem anderen Adressraum als der Client, und es kann normalerweise davon ausgegangen werden, dass Sie keinen Speicher freigeben.</span><span class="sxs-lookup"><span data-stu-id="f8a24-187">Logically, the RPC server lives in a different address space than the client, and it can generally be assumed that they do not share memory.</span></span> <span data-ttu-id="f8a24-188">Daher ist es sicher, dass die Implementierung der Server Funktion die mit dem [**\[ in \]**](../midl/in.md) -Attribut markierten Daten als "temporären" Arbeitsspeicher verwendet, ohne dass sich dies auf die Client Speicheradressen auswirkt.</span><span class="sxs-lookup"><span data-stu-id="f8a24-188">As a result, it is safe for the server function implementation to use the data marked with the [**\[in\]**](../midl/in.md) attribute as "scratch" memory without affecting the client memory addresses.</span></span> <span data-ttu-id="f8a24-189">Das heißt, der Server sollte nicht versuchen, die Daten neu zuzuordnen oder **\[ in \]** Daten freizugeben, sodass diese Leerzeichen nicht mehr dem RPC-Serverstub selbst überlassen werden.</span><span class="sxs-lookup"><span data-stu-id="f8a24-189">That said, the server should not attempt to reallocate or release **\[in\]** data, leaving the control of those spaces to the RPC server stub itself.</span></span>

<span data-ttu-id="f8a24-190">Im Allgemeinen muss die Implementierung der Server Funktion keine Daten neu zuordnen oder freigeben, die mit dem **\[ in-, \] out** -Attribut markiert sind.</span><span class="sxs-lookup"><span data-stu-id="f8a24-190">Generally, the server function implementation does not need to reallocate or release data marked with the **\[in, out\]** attribute.</span></span> <span data-ttu-id="f8a24-191">Bei Daten fester Größe kann die Funktions Implementierungs Logik die Daten direkt ändern.</span><span class="sxs-lookup"><span data-stu-id="f8a24-191">For fixed size data, the function implementation logic can directly modify the data.</span></span> <span data-ttu-id="f8a24-192">Ebenso darf die Funktions Implementierung für Daten mit variabler Größe den Feldwert nicht ändern, der für das Attribut [**\[ size \_ is () \]**](../midl/size-is.md) angegeben ist.</span><span class="sxs-lookup"><span data-stu-id="f8a24-192">Likewise, for variable-sized data, the function implementation must not modify the field value supplied to the [**\[size\_is()\]**](../midl/size-is.md) attribute, either.</span></span> <span data-ttu-id="f8a24-193">Ändern Sie den Feldwert, der zum Anpassen der Größe der Daten verwendet wird, in einen kleineren oder größeren Puffer, der an den Client zurückgegeben wird, der möglicherweise nicht mit der ungewöhnlichen Länge ausgestattet ist.</span><span class="sxs-lookup"><span data-stu-id="f8a24-193">Change the field value used to size the data results in a smaller or larger buffer returned to the client which may be ill-equipped to deal with the abnormal length.</span></span>

<span data-ttu-id="f8a24-194">Wenn die Server Routine den Arbeitsspeicher neu zuordnen muss, der von Daten verwendet wird, die mit dem **\[ in- \] , out** -Attribut gekennzeichnet sind, ist es durchaus möglich, dass die Implementierung der serverseitigen Funktion nicht weiß, ob der vom Stub bereitgestellte Zeiger dem Arbeitsspeicher entspricht, der mit der **\_ Benutzer \_ Zuordnung ()** oder dem gemarshallten Wire-Puffer zugeordnet ist.</span><span class="sxs-lookup"><span data-stu-id="f8a24-194">If circumstances occur where the server routine has to reallocate the memory used by data marked with the **\[in, out\]** attribute, it is entirely possible that the server-side function implementation will not know if the pointer provided by the stub is to memory allocated with **MIDL\_user\_allocate()** or the marshaled wire buffer.</span></span> <span data-ttu-id="f8a24-195">Um dieses Problem zu umgehen, kann MS RPC sicherstellen, dass keine Speicher Verluste oder Beschädigungen auftreten, wenn das Attribut " [**\[ \_ zuordnen \] erzwingen**](../midl/force-allocate.md) " für die Daten festgelegt ist.</span><span class="sxs-lookup"><span data-stu-id="f8a24-195">To work around this problem, MS RPC can ensure that no memory leak or corruption occurs if the [**\[force\_allocate\]**](../midl/force-allocate.md) attribute is set on the data.</span></span> <span data-ttu-id="f8a24-196">Wenn **\[ \_ erzwingen \]** von Zuordnungen festgelegt ist, belegt der Serverstub immer Arbeitsspeicher für den Zeiger, obwohl der Nachteil darin besteht, dass die Leistung für jede Verwendung verringert wird.</span><span class="sxs-lookup"><span data-stu-id="f8a24-196">When **\[force\_allocate\]** is set, the server stub will always allocate memory for the pointer, although the caveat is that performance will decrease for every use of it.</span></span>

<span data-ttu-id="f8a24-197">Wenn der-Rückruf von der serverseitigen Implementierung der Funktion zurückgegeben wird, Marshalls der Server-Stub die mit dem [**\[ out \]**](../midl/out-idl.md) -Attribut markierten Daten und sendet Sie an den Client.</span><span class="sxs-lookup"><span data-stu-id="f8a24-197">When the call returns from the server-side function implementation, the server stub marshals the data marked with the [**\[out\]**](../midl/out-idl.md) attribute and sends it to the client.</span></span> <span data-ttu-id="f8a24-198">Beachten Sie, dass der Stub die Daten nicht Mars Hallen kann, wenn die Implementierung der serverseitigen Funktion eine Ausnahme auslöst.</span><span class="sxs-lookup"><span data-stu-id="f8a24-198">Be aware that the stub does not marshal the data if the server-side function implementation throws an exception.</span></span>

## <a name="releasing-allocated-memory"></a><span data-ttu-id="f8a24-199">Freigeben von zugewiesener Speicher</span><span class="sxs-lookup"><span data-stu-id="f8a24-199">Releasing Allocated Memory</span></span>

<span data-ttu-id="f8a24-200">Der Server-Stub für den RPC-Server gibt den Stapel Speicher frei, nachdem der Aufruf von der serverseitigen Funktion zurückgegeben wurde, unabhängig davon, ob eine Ausnahme auftritt oder nicht.</span><span class="sxs-lookup"><span data-stu-id="f8a24-200">The RPC server stub will release the stack memory after the call has returned from the server-side function, whether an exception occurs or not.</span></span> <span data-ttu-id="f8a24-201">Der Serverstub gibt den gesamten vom Stub zugeordneten Arbeitsspeicher sowie alle zugeordneten Arbeitsspeicher für die **mittlere \_ Benutzer \_ Zuordnung ()** frei.</span><span class="sxs-lookup"><span data-stu-id="f8a24-201">The server stub frees all memory allocated by the stub as well as any memory allocated with **MIDL\_user\_allocate()**.</span></span> <span data-ttu-id="f8a24-202">Die serverseitige Funktions Implementierung muss immer einen konsistenten RPC-Status aufweisen, entweder durch Auslösen einer Ausnahme oder durch Zurückgeben eines Fehlercodes.</span><span class="sxs-lookup"><span data-stu-id="f8a24-202">The server-side function implementation must always give RPC a consistent state, either by throwing an exception or returning an error code.</span></span> <span data-ttu-id="f8a24-203">Wenn die Funktion während der Auffüllung komplizierter Datenstrukturen fehlschlägt, muss sichergestellt werden, dass alle Zeiger auf gültige Daten verweisen oder auf **null** festgelegt sind.</span><span class="sxs-lookup"><span data-stu-id="f8a24-203">If the function fails during the population of complicated data structures, it must ensure that all pointers point to valid data or are set to **NULL**.</span></span>

<span data-ttu-id="f8a24-204">Während dieses Erfolgs gibt der Serverstub den gesamten Arbeitsspeicher frei, der nicht Teil des gemarshallten Puffers ist, der den [**\[ in \]**](../midl/in.md) den Daten enthält.</span><span class="sxs-lookup"><span data-stu-id="f8a24-204">During this pass, the server stub frees all memory that is not part of the marshaled buffer containing the [**\[in\]**](../midl/in.md) data.</span></span> <span data-ttu-id="f8a24-205">Eine Ausnahme zu diesem Verhalten besteht darin, dass Daten mit dem Attribut " [**\[ zuordnen" (nicht \_ frei) \]**](../midl/allocate.md) für Sie festgelegt sind. der Serverstub gibt keinen Arbeitsspeicher frei, der diesen Zeigern zugeordnet ist.</span><span class="sxs-lookup"><span data-stu-id="f8a24-205">One exception to this behavior is data with the [**\[allocate(dont\_free)\]**](../midl/allocate.md) attribute set on them - the server stub does not free any memory associated with these pointers.</span></span>

<span data-ttu-id="f8a24-206">Nachdem der Server-Stub den vom Stub und der Funktions Implementierung belegten Arbeitsspeicher freigegeben hat, ruft der Stub eine bestimmte Benachrichtigungsfunktion auf, wenn das [**\[ Notify \_ Flag \]**](../midl/notify-flag.md) -Attribut für bestimmte Daten angegeben wird.</span><span class="sxs-lookup"><span data-stu-id="f8a24-206">After the server stub releases the memory allocated by the stub and the function implementation, the stub calls a specific notification function if the [**\[notify\_flag\]**](../midl/notify-flag.md) attribute is specified for particular data.</span></span>

## <a name="marshalling-a-linked-list-over-rpc----an-example"></a><span data-ttu-id="f8a24-207">Marshalling einer verknüpften Liste über RPC (ein Beispiel)</span><span class="sxs-lookup"><span data-stu-id="f8a24-207">Marshalling a Linked List over RPC -- An Example</span></span>


```C++
typedef struct _LINKEDLIST
{
    long lSize;
    [size_is(lSize)] char *pData;
    struct _LINKEDLIST *pNext;
} LINKEDLIST, *PLINKEDLIST;

void Test
(
    [in] LINKEDLIST *pIn,
    [in, out] PLINKEDLIST *pInOut,
    [out] LINKEDLIST *pOut
);
```



<span data-ttu-id="f8a24-208">Im obigen Beispiel ist das Speicherformat für **LinkedList** identisch mit dem gemarshallten Wire-Format.</span><span class="sxs-lookup"><span data-stu-id="f8a24-208">In the above example, the memory format for **LINKEDLIST** will be identical to the marshaled wire format.</span></span> <span data-ttu-id="f8a24-209">Demzufolge belegt der Serverstub keinen Arbeitsspeicher für die gesamte Datenzeiger Kette unter *pIn*.</span><span class="sxs-lookup"><span data-stu-id="f8a24-209">As a result, the server stub does not allocate memory for the entire chain of data pointers under *pIn*.</span></span> <span data-ttu-id="f8a24-210">Stattdessen verwendet RPC den Wire-Puffer für die gesamte verknüpfte Liste erneut.</span><span class="sxs-lookup"><span data-stu-id="f8a24-210">Rather, RPC reuses the wire buffer for the entire linked list.</span></span> <span data-ttu-id="f8a24-211">Ebenso belegt der Stub keinen Arbeitsspeicher für das *Pinout*, sondern verwendet stattdessen den vom Client gemarshallten Wire-Puffer.</span><span class="sxs-lookup"><span data-stu-id="f8a24-211">Similarly, the stub does not allocate memory for *pInOut*, but instead reuses the wire buffer marshaled by the client.</span></span>

<span data-ttu-id="f8a24-212">Da die Funktions Signatur einen ausgehenden Parameter ( *Pout*) enthält, ordnet der Server-Stub Speicher zu, der die zurückgegebenen Daten enthält.</span><span class="sxs-lookup"><span data-stu-id="f8a24-212">Because the function signature contains an outbound parameter, *pOut*, the server stub allocates memory to contain the returned data.</span></span> <span data-ttu-id="f8a24-213">Der zugeordnete Arbeitsspeicher ist anfänglich Nullen, wobei **pNext** auf **null** festgelegt ist.</span><span class="sxs-lookup"><span data-stu-id="f8a24-213">The allocated memory is initially zeroes out, with **pNext** set to **NULL**.</span></span> <span data-ttu-id="f8a24-214">Die Anwendung kann den Arbeitsspeicher für eine neue verknüpfte Liste zuweisen und *Pout-Pout* -> **darauf verweisen** .</span><span class="sxs-lookup"><span data-stu-id="f8a24-214">The application can allocate the memory for a new linked list and point *pOut*->**pNext** to it.</span></span> <span data-ttu-id="f8a24-215">die *pIn* und die verknüpfte Liste, die Sie enthält, können als Scratch-Bereich verwendet werden. die Anwendung sollte jedoch keinen der pNext-Zeiger ändern.</span><span class="sxs-lookup"><span data-stu-id="f8a24-215">*pIn* and the linked list it contains can be used as a scratch area, but the application should not change any of the pNext pointers.</span></span>

<span data-ttu-id="f8a24-216">Die Anwendung kann den Inhalt der verknüpften Liste, auf die durch *Pinout* gezeigt wird, frei ändern, aber keinen der **pNext** -Zeiger ändern, sondern allein den Link der obersten Ebene selbst.</span><span class="sxs-lookup"><span data-stu-id="f8a24-216">The application can freely change the content of the linked list pointed to by *pInOut*, but it must not change any of the **pNext** pointers, let alone the top-level link itself.</span></span> <span data-ttu-id="f8a24-217">Wenn die Anwendung entscheidet, die verknüpfte Liste zu verkürzen, kann nicht festgestellt werden, ob ein angegebener **pNext** -Zeiger einen internen RPC-Puffer oder einen Puffer verknüpft, der explizit mit der **mittleren \_ Benutzer \_ Zuordnung ()** zugeordnet ist.</span><span class="sxs-lookup"><span data-stu-id="f8a24-217">If the application decides to shorten the linked list, it cannot know if any given **pNext** pointer links tto an RPC internal buffer or a buffer specifically allocated with **MIDL\_user\_allocate()**.</span></span> <span data-ttu-id="f8a24-218">Um dieses Problem zu umgehen, fügen Sie eine bestimmte Typdeklaration für verknüpfte Listen Zeiger hinzu, die die Benutzer Zuordnung erzwingt, wie im folgenden Code zu sehen ist.</span><span class="sxs-lookup"><span data-stu-id="f8a24-218">To work around this issue, you add a specific type declaration for linked list pointers that forces user allocation, as seen in the code below.</span></span>

``` syntax
typedef [force_allocate] PLINKEDLIST;
```

<span data-ttu-id="f8a24-219">Mit diesem Attribut wird erzwungen, dass der Serverstub jeden Knoten der verknüpften Liste separat zuweist, und die Anwendung kann den verkürzten Teil der verknüpften Liste durch Aufrufen von " **\_ Benutzer \_ freiem Benutzer ()**" freigeben.</span><span class="sxs-lookup"><span data-stu-id="f8a24-219">This attribute forces the server stub to allocate each node of the linked list separately, and the application can free the shortened part of the linked list by calling **MIDL\_user\_free()**.</span></span> <span data-ttu-id="f8a24-220">Die Anwendung kann dann den **pNext** -Zeiger am Ende der neu verkürzten verknüpften Liste auf **null** festlegen.</span><span class="sxs-lookup"><span data-stu-id="f8a24-220">The application can then safely set the **pNext** pointer at the end of the newly-shortened linked list to **NULL**.</span></span>

 

 