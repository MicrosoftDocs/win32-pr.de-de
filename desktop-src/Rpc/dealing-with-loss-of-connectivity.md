---
title: Umgang mit Verbindungsverlust
description: Umgang mit Verbindungsverlust
ms.assetid: a90fcb5a-773e-4c21-bf6c-c3519ec13a09
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: de8e7a8088cfe09a4c4026c16cc3dc5ea36b3430
ms.sourcegitcommit: 592c9bbd22ba69802dc353bcb5eb30699f9e9403
ms.translationtype: MT
ms.contentlocale: de-DE
ms.lasthandoff: 08/20/2020
ms.locfileid: "103728865"
---
# <a name="dealing-with-loss-of-connectivity"></a><span data-ttu-id="f3493-103">Umgang mit Verbindungsverlust</span><span class="sxs-lookup"><span data-stu-id="f3493-103">Dealing with Loss of Connectivity</span></span>

<span data-ttu-id="f3493-104">Nachdem ein RPC-Aufruf abgeschlossen wurde, wird die Verbindung nicht geschlossen. Er ist als frei markiert.</span><span class="sxs-lookup"><span data-stu-id="f3493-104">After an RPC call completes the connection is not closed; it is marked as free.</span></span> <span data-ttu-id="f3493-105">Der Server kann daher ausgefallen sein, oder die Netzwerk Konnektivität kann während oder zwischen Aufrufen unterbrochen werden, während sich eine Verbindung im Pool befindet.</span><span class="sxs-lookup"><span data-stu-id="f3493-105">As such, the server can go down or network connectivity can be lost during or between calls, while a connection is sitting in the pool.</span></span> <span data-ttu-id="f3493-106">Bei der Richtlinie werden diese Aufrufe von der RPC-Laufzeit nur dann erneut versucht, wenn die folgenden beiden Bedingungen erfüllt sind:</span><span class="sxs-lookup"><span data-stu-id="f3493-106">As a matter of policy, the RPC run time re-attempts those calls only if the following two conditions are met:</span></span>

-   <span data-ttu-id="f3493-107">Der Server kann den Aufruf nicht ausführen, oder der Aufruf ist idempotent.</span><span class="sxs-lookup"><span data-stu-id="f3493-107">The server cannot possibly execute the call, or the call is idempotent.</span></span>
-   <span data-ttu-id="f3493-108">Der Client kann Wiederholungs Versuche auf Leistungs effiziente Weise implementieren.</span><span class="sxs-lookup"><span data-stu-id="f3493-108">The client can implement retries in a performance-efficient manner.</span></span>

<span data-ttu-id="f3493-109">In den folgenden Abschnitten werden die beiden Bedingungen erweitert und verdeutlicht.</span><span class="sxs-lookup"><span data-stu-id="f3493-109">The following paragraphs expand and clarify the two conditions.</span></span>

<span data-ttu-id="f3493-110">Bei einem idempotenten Aufruf handelt es sich um einen Aufruf, der auf dem Server mehrmals ausgeführt werden kann, ohne dass unerwünschte Nebeneffekte auftreten.</span><span class="sxs-lookup"><span data-stu-id="f3493-110">An idempotent call is a call that can be executed more than once on the server without undesirable side effects.</span></span> <span data-ttu-id="f3493-111">Beispielsweise ist ein RPC-Aufruf, der den Saldo der Bank für ein bestimmtes Konto abfragt, idempotent.</span><span class="sxs-lookup"><span data-stu-id="f3493-111">For example, having an RPC call that queries the balance in the bank for a given account is idempotent.</span></span> <span data-ttu-id="f3493-112">Wenn dieser Befehl aufgrund eines Verlusts der Konnektivität zweimal ausgeführt wird, erfolgt keine Beschädigung.</span><span class="sxs-lookup"><span data-stu-id="f3493-112">If this call is executed twice due to loss of connectivity, no harm is done.</span></span> <span data-ttu-id="f3493-113">Ein weiteres Beispiel für einen idempotenten Aufruf besteht darin, die Adresse eines Kunden in einer Datenbank zu ändern.</span><span class="sxs-lookup"><span data-stu-id="f3493-113">Another example of an idempotent call is changing the address of a customer in a database.</span></span> <span data-ttu-id="f3493-114">Die doppelte Ausführung ist in Ordnung, da die zweite Ausführung einfach die bereits aktuelle Adresse durch dieselbe Adresse ersetzt.</span><span class="sxs-lookup"><span data-stu-id="f3493-114">Executing twice is fine, since the second execution simply replaces the already-current address with the same address.</span></span> <span data-ttu-id="f3493-115">Ein Vorgang wie "Subtrahieren von 50 Dollar von Konto XYZ" ist nicht idempotent.</span><span class="sxs-lookup"><span data-stu-id="f3493-115">An operation like "subtract fifty dollars from account xyz" is not idempotent.</span></span> <span data-ttu-id="f3493-116">Der Verlust der Netzwerk Konnektivität sollte nicht zu mehreren Ausführungen eines solchen Aufrufes führen.</span><span class="sxs-lookup"><span data-stu-id="f3493-116">Loss of network connectivity should not result in multiple executions of such a call.</span></span>

<span data-ttu-id="f3493-117">Um sicher zu sein, werden alle Aufrufe von der RPC-Laufzeit als nicht idempotent behandelt.</span><span class="sxs-lookup"><span data-stu-id="f3493-117">To be safe, the RPC run time treats all calls as non-idempotent.</span></span> <span data-ttu-id="f3493-118">Das \[ idempotente \] -Attribut wird nicht für [**ncacn \_ -IP- \_ TCP**](/windows/desktop/Midl/ncacn-ip-tcp)unterstützt und wird ignoriert.</span><span class="sxs-lookup"><span data-stu-id="f3493-118">The \[idempotent\] attribute is not supported for [**ncacn\_ip\_tcp**](/windows/desktop/Midl/ncacn-ip-tcp), and is ignored.</span></span> <span data-ttu-id="f3493-119">Daher wird die erste Bedingung in der vorangehenden Liste auf den Server reduziert, der den-Befehl *nicht ausführen kann*.</span><span class="sxs-lookup"><span data-stu-id="f3493-119">As such, the first condition in the preceding list is reduced to *the server that cannot possibly execute the call*.</span></span>

<span data-ttu-id="f3493-120">In vielen Fällen kann die RPC-Laufzeit nicht endgültig ermitteln, ob der Aufruf nicht bereits auf dem Server ausgeführt wurde.</span><span class="sxs-lookup"><span data-stu-id="f3493-120">In many cases the RPC run time is unable to conclusively determine the call was not already executed on the server.</span></span> <span data-ttu-id="f3493-121">In solchen Fällen wird vom Client nicht erneut versucht, den-Befehl auszuführen.</span><span class="sxs-lookup"><span data-stu-id="f3493-121">In such cases, the client will not retry executing the call.</span></span>

<span data-ttu-id="f3493-122">In den folgenden Beispielen wird veranschaulicht, wann die RPC-Laufzeit einen Aufruf durchführt oder nicht erneut versucht:</span><span class="sxs-lookup"><span data-stu-id="f3493-122">The following examples illustrate when the RPC run time does or does not retry a call:</span></span>

-   <span data-ttu-id="f3493-123">Ein Server wird neu gestartet.</span><span class="sxs-lookup"><span data-stu-id="f3493-123">A server is rebooted.</span></span>

    <span data-ttu-id="f3493-124">Ein einfacher RPC-Aufruf ohne Sicherheit wird an einer Schnittstelle vorgenommen, auf der nach dem Neustart kein vorheriger Aufruf erfolgt ist.</span><span class="sxs-lookup"><span data-stu-id="f3493-124">A simple, no-security RPC call is made on an interface on which no previous call has been made after the reboot.</span></span> <span data-ttu-id="f3493-125">Da keine Aufrufe an dieser Schnittstelle durchgeführt wurden, versucht die RPC-Laufzeit zunächst, die Verwendung der Schnittstelle auszuhandeln.</span><span class="sxs-lookup"><span data-stu-id="f3493-125">Since no calls were made on this interface, the RPC run time first attempts to negotiate use of the interface.</span></span> <span data-ttu-id="f3493-126">Er sendet ein Paket mithilfe einer Verbindung im Pool.</span><span class="sxs-lookup"><span data-stu-id="f3493-126">It sends a packet using a connection in the pool.</span></span> <span data-ttu-id="f3493-127">Da der Server neu gestartet wurde und die Verbindung nicht mehr gültig ist, wird ein Fehler zurückgegeben.</span><span class="sxs-lookup"><span data-stu-id="f3493-127">Since the server was rebooted, and the connection is no longer valid, it returns an error.</span></span> <span data-ttu-id="f3493-128">Da die Client seitige RPC-Laufzeit noch nicht mit dem Senden der Daten für den eigentlichen Aufruf begonnen hat, ermittelt der Client, dass der Server möglicherweise nicht für diese Daten ausgeführt wurde.</span><span class="sxs-lookup"><span data-stu-id="f3493-128">Since the client side RPC run time has not yet started sending the data for the actual call, the client determines that the server could not possibly have executed on those data.</span></span> <span data-ttu-id="f3493-129">Daher wird die Verbindung geschlossen, und es wird nach einer anderen Verbindung im Pool gesucht.</span><span class="sxs-lookup"><span data-stu-id="f3493-129">Therefore, it closes the connection and looks for another connection in the pool.</span></span> <span data-ttu-id="f3493-130">Wenn keine Verbindung gefunden werden kann, wird eine neue Verbindung geöffnet, und es wird versucht, die Verwendung der Schnittstelle erneut auszuhandeln.</span><span class="sxs-lookup"><span data-stu-id="f3493-130">If it cannot find a connection, it opens a new connection and tries to negotiate use of the interface again.</span></span> <span data-ttu-id="f3493-131">Wenn dies erfolgreich ist, wird der-Vorgang ausgeführt (d. h., es wird eine Wiederholung durchgeführt, da der Fehler vor dem Start des Aufrufes erkannt wurde).</span><span class="sxs-lookup"><span data-stu-id="f3493-131">If this succeeds, the call is made (that is, a retry is made, because the failure was detected before the call was started).</span></span>

-   <span data-ttu-id="f3493-132">Ein RPC-Aufruf mit Sicherheit auf Datenschutzebene (Verschlüsselung) erfolgt bei einer Verbindung mit einem bereits ausgehandelten Sicherheitskontext.</span><span class="sxs-lookup"><span data-stu-id="f3493-132">An RPC call with privacy-level security (encryption) is made on a connection with an already-negotiated security context.</span></span>

    <span data-ttu-id="f3493-133">Um eine effiziente Leistung sicherzustellen, verschlüsselt die RPC-Laufzeit das gemarshallte Paket Inline (über die Klartext-Daten).</span><span class="sxs-lookup"><span data-stu-id="f3493-133">To ensure efficient performance, the RPC run time encrypts the marshaled packet inline (over the clear text data).</span></span> <span data-ttu-id="f3493-134">Tritt beim Versuch, die Daten zu senden, ein Fehler auf, kann die RPC-Laufzeit den Aufruf nicht wiederholen, da die Klartext-Daten mit den verschlüsselten Daten überschrieben wurden und die Daten nicht erneut mit einem neuen Sicherheitskontext verschlüsselt werden können.</span><span class="sxs-lookup"><span data-stu-id="f3493-134">If the attempt to send the data fails, the RPC run time cannot retry the call, since the clear text data have been overwritten with the encrypted data, and it cannot re-encrypt the data with a new security context.</span></span> <span data-ttu-id="f3493-135">Daher wird keine Wiederholung durchgeführt.</span><span class="sxs-lookup"><span data-stu-id="f3493-135">Therefore, no retry is made.</span></span>

-   <span data-ttu-id="f3493-136">Das Senden eines nicht ersten Fragments schlägt fehl.</span><span class="sxs-lookup"><span data-stu-id="f3493-136">The sending of a non-first fragment fails.</span></span>

    <span data-ttu-id="f3493-137">Es wird keine Wiederholung durchgeführt, da die RPC-Laufzeit den Inhalt des ersten Fragments nach Abschluss verwerfen kann und keine Möglichkeit hat, das erste Fragment erneut zu senden.</span><span class="sxs-lookup"><span data-stu-id="f3493-137">Retry is not made, since the RPC run time may choose to discard the contents of the first fragment once it is complete, and has no way to retry sending the first fragment.</span></span>

-   <span data-ttu-id="f3493-138">Die RPC-Anforderung wird gesendet.</span><span class="sxs-lookup"><span data-stu-id="f3493-138">The RPC request is sent.</span></span>

    <span data-ttu-id="f3493-139">Der Server bricht die Verbindung ab.</span><span class="sxs-lookup"><span data-stu-id="f3493-139">The server aborts the connection.</span></span> <span data-ttu-id="f3493-140">Es wurde kein Wiederholungsversuch unternommen, da RPC nicht ermitteln kann, ob der Server den Aufruf empfangen und die Ausführung gestartet hat.</span><span class="sxs-lookup"><span data-stu-id="f3493-140">No retry is attempted, since RPC cannot discern whether the server received the call and started executing it.</span></span>

<span data-ttu-id="f3493-141">Wenn vom Server ein dynamischer Endpunkt verwendet wird, löst RPC den Endpunkt bei Wiederholungs versuchen nicht erneut auf.</span><span class="sxs-lookup"><span data-stu-id="f3493-141">If the server uses a dynamic endpoint, RPC will not re-resolve the endpoint during retries.</span></span> <span data-ttu-id="f3493-142">Dies bedeutet Folgendes: Wenn ein Server heruntergefahren und wieder hochgefahren wird, befindet er sich möglicherweise auf einem anderen Endpunkt, und RPC löst den Endpunkt nicht transparent erneut aus, wenn ein Aufruf wiederholt wird.</span><span class="sxs-lookup"><span data-stu-id="f3493-142">This means that if a server is brought down and comes back up, it may reside on a different endpoint, and RPC will not transparently re-resolve the endpoint when a call is retried.</span></span> <span data-ttu-id="f3493-143">Um das erneute Auflösen des Endpunkts zu erzwingen, sollte der RPC-Client [**rpcbindingreset**](/windows/desktop/api/Rpcdce/nf-rpcdce-rpcbindingreset) aufrufen, bevor ein Aufruf wiederholt wird.</span><span class="sxs-lookup"><span data-stu-id="f3493-143">To force re-resolving of the endpoint, the RPC client should calling [**RpcBindingReset**](/windows/desktop/api/Rpcdce/nf-rpcdce-rpcbindingreset) before it retries a call.</span></span>

<span data-ttu-id="f3493-144">In vielen Fällen kann es vorkommen, dass ein RPC-Client einen Wiederholungs Mechanismus zusätzlich zu RPC erstellt, wenn ein RPC-Client ermitteln kann, ob es sich um einen idempotenten Aufruf handelt, oder wenn er Daten beibehält.</span><span class="sxs-lookup"><span data-stu-id="f3493-144">In many of these cases, if an RPC client can determine whether a call is idempotent, or if it keeps data that RPC discards, it may choose to build a retry mechanism on top of RPC.</span></span>

> [!Note]  
> <span data-ttu-id="f3493-145">Wenn es sich bei dem Server um einen Cluster handelt und die verschiedenen Knoten des Clusters verschiedene Versionen der Server Software ausführen, kann ein RPC-Wiederholungsversuch den Aufruf auf einem anderen Knoten des Clusters im Falle eines Failovers und potenziell auf einer anderen Version des Servers durchführen.</span><span class="sxs-lookup"><span data-stu-id="f3493-145">If the server is a cluster, and the different nodes of the cluster run different versions of the server software, an RPC retry may land the call on a different node of the cluster in the case of failover, and potentially on a different version of the server.</span></span> <span data-ttu-id="f3493-146">Stellen Sie in solchen Bereitstellungs Szenarien sicher, dass der Client nicht von einer bestimmten Version der Server Software abhängig ist, um einen bestimmten-Befehl auszuführen.</span><span class="sxs-lookup"><span data-stu-id="f3493-146">In such deployment scenarios, make sure the client does not rely on a particular version of the server software to execute a given call.</span></span> <span data-ttu-id="f3493-147">Wenn dies der Fall ist, sollte der Client einen Mechanismus zusätzlich zu RPC erstellen, der solche Bedingungen erkennt und behandelt.</span><span class="sxs-lookup"><span data-stu-id="f3493-147">If it does, the client should build a mechanism on top of RPC that detects and handles such conditions.</span></span>

 

 

 