---
title: Ändern von Schnittstellen in abwärts kompatibler Weise
description: Die in der Versions Verwaltungs Theorie für RPC und com erläuterten Methoden sind aus vielen Gründen möglicherweise nicht akzeptabel.
ms.assetid: 7dec4b67-3d50-453f-b0ef-290d091186fd
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: 314daecc6b55aaf4a348411010eb578149f86921
ms.sourcegitcommit: 592c9bbd22ba69802dc353bcb5eb30699f9e9403
ms.translationtype: MT
ms.contentlocale: de-DE
ms.lasthandoff: 08/20/2020
ms.locfileid: "103729801"
---
# <a name="changing-interfaces-in-a-backward-compatible-manner"></a><span data-ttu-id="1eeac-103">Ändern von Schnittstellen in abwärts kompatibler Weise</span><span class="sxs-lookup"><span data-stu-id="1eeac-103">Changing Interfaces in a Backward Compatible Manner</span></span>

<span data-ttu-id="1eeac-104">Die in [der Versions Verwaltungs Theorie für RPC und com](the-versioning-theory-for-rpc-and-com.md) erläuterten Methoden sind aus vielen Gründen möglicherweise nicht akzeptabel.</span><span class="sxs-lookup"><span data-stu-id="1eeac-104">The methods explained in [The Versioning Theory for RPC and COM](the-versioning-theory-for-rpc-and-com.md) may be unacceptable for many reasons.</span></span> <span data-ttu-id="1eeac-105">Das Ändern einer Schnittstellen Version gemäß den Regeln erfordert im Wesentlichen, dass neue Clients nicht mit alten Servern kommunizieren.</span><span class="sxs-lookup"><span data-stu-id="1eeac-105">Changing an interface version according to the rules essentially requires that new clients not communicate with old servers.</span></span> <span data-ttu-id="1eeac-106">Dies ist bei kommerziellen Software, die im-Feld bereitgestellt wurde, oft nicht möglich.</span><span class="sxs-lookup"><span data-stu-id="1eeac-106">This is frequently impossible with commercial software deployed in the field.</span></span> <span data-ttu-id="1eeac-107">Manchmal hat Windows Schnittstellen Änderungen eingeführt, die sich auf geänderte GUIDs oder Versionen fehlen.</span><span class="sxs-lookup"><span data-stu-id="1eeac-107">Sometimes, Windows has introduced interface changes absent of changed GUIDs or versions.</span></span> <span data-ttu-id="1eeac-108">Dies war darauf zurückzuführen, dass neue Clients mit Legacy Servern kommunizieren mussten und dass die Lösung, die ein neuer Client sowohl die alte als auch die neue Schnittstelle unterstützen würde, als unerwünscht eingestuft wurde.</span><span class="sxs-lookup"><span data-stu-id="1eeac-108">This was a result of new clients needing to communicate with legacy servers, and because the solution that a new client would support both the old and new interfaces was deemed undesirable.</span></span>

## <a name="best-practice"></a><span data-ttu-id="1eeac-109">Bewährte Methode</span><span class="sxs-lookup"><span data-stu-id="1eeac-109">Best practice</span></span>

<span data-ttu-id="1eeac-110">Dies sind die angemessenen Methoden, um das Problem bei der Netzwerkverbindung zu umgehen, wenn die Schnittstellen-GUID und die Version nicht geändert werden können.</span><span class="sxs-lookup"><span data-stu-id="1eeac-110">These are the reasonable methods of working around the wire incompatibility issue when the interface GUID and version cannot be changed.</span></span>

1.  <span data-ttu-id="1eeac-111">Beachten Sie, dass die Anwendung die Funktionen der anderen Seite kennt.</span><span class="sxs-lookup"><span data-stu-id="1eeac-111">Have the application be aware of the other side's capabilities.</span></span>

    <span data-ttu-id="1eeac-112">Der Client und der Server verfügen über ein Protokoll, mit dem jede (oder zumindest der neue Client) die Identität des Partners einrichten kann.</span><span class="sxs-lookup"><span data-stu-id="1eeac-112">The client and server have a protocol that enables each (or at least the new client) to establish the identity of the partner.</span></span> <span data-ttu-id="1eeac-113">In der Regel genügt es, dass der neue Client die von alten und neuen Servern unterstützten Funktionen kennt.</span><span class="sxs-lookup"><span data-stu-id="1eeac-113">Typically it is sufficient to have the new client be aware of features supported by old and new servers.</span></span> <span data-ttu-id="1eeac-114">Dies kann problemlos erfolgen, wenn eine Anwendung einen Verbindungs Kontext einnimmt und durch einen vom Client ausgeführten Funktionsaufruf vom Typ *xxxgetinfo* vor der Ausführung von RPC-Vorgängen unterstützt wird.</span><span class="sxs-lookup"><span data-stu-id="1eeac-114">This may easily be done when an application holds on to a connection context, and be supported through an *XxxGetInfo* type of function call executed by the client before performing any RPC operations.</span></span> <span data-ttu-id="1eeac-115">Wenn eine Anwendung die Features pro Server-Freigabe verwaltet, kann ein Aufruf mit einer Inkompatibilität mit dem alten Server/Client niemals erfolgen, da die Anwendung steuert, welche Aufrufe an welchen Server ausgegeben werden.</span><span class="sxs-lookup"><span data-stu-id="1eeac-115">When an application manages the features on a per-server release basis, a call with an incompatibility to the old server/client can never occur, since the application controls which calls are issued to which server.</span></span> <span data-ttu-id="1eeac-116">Die untere Zeile besteht darin, dass die Anwendung proaktiv verhindert, dass eine Übereinstimmung auftritt.</span><span class="sxs-lookup"><span data-stu-id="1eeac-116">The bottom line is that the application is proactive in preventing a mismatch from happening.</span></span> <span data-ttu-id="1eeac-117">Dies kann in Verbindung mit der zweiten Vorgehensweise erfolgen.</span><span class="sxs-lookup"><span data-stu-id="1eeac-117">This may be performed in conjunction with the second practice.</span></span>

2.  <span data-ttu-id="1eeac-118">Führen Sie eine neue Remote-API ein.</span><span class="sxs-lookup"><span data-stu-id="1eeac-118">Introduce a new remote API.</span></span>

    <span data-ttu-id="1eeac-119">Eine neue Remote Methode steht nicht in Konflikt mit vorhandenen Methoden, wenn Sie am Ende der-Schnittstelle hinzugefügt wird.</span><span class="sxs-lookup"><span data-stu-id="1eeac-119">A new remote method does not collide with existing methods if it is added at the very end of the interface.</span></span> <span data-ttu-id="1eeac-120">Alte Clients können jederzeit neue Server abrufen.</span><span class="sxs-lookup"><span data-stu-id="1eeac-120">Old clients can call new servers as they always have.</span></span> <span data-ttu-id="1eeac-121">Der neue Client kann die neue Methode aufrufen, ohne die Identität des Servers zu kennen. Voraussetzung ist, dass die Fehler von dem aufgerufenen Server überwacht werden.</span><span class="sxs-lookup"><span data-stu-id="1eeac-121">The new client can call the new method without knowing the server's identity, provided it watches for the errors coming from the server being called.</span></span> <span data-ttu-id="1eeac-122">Die RPC-Laufzeit prüft stets die Methoden Nummer für jede Schnittstelle vor einer Verteilung, um sicherzustellen, dass die Methode in einer geeigneten v-Tabelle liegt.</span><span class="sxs-lookup"><span data-stu-id="1eeac-122">The RPC run time always checks the method number for each interface before a dispatch to ensure the method is within an appropriate v-table.</span></span> <span data-ttu-id="1eeac-123">Bei einer Methode, die einem Server unbekannt ist, löst die RPC-Laufzeit die Ausnahme RPC \_ S \_ procnum \_ außerhalb \_ des gültigen \_ Bereichs aus.</span><span class="sxs-lookup"><span data-stu-id="1eeac-123">For a method that is unknown to a server, the RPC run time raises the exception RPC\_S\_PROCNUM\_OUT\_OF\_RANGE.</span></span> <span data-ttu-id="1eeac-124">Diese Ausnahme wird nur in dieser speziellen Situation ausgelöst.</span><span class="sxs-lookup"><span data-stu-id="1eeac-124">This exception is raised only in this particular situation.</span></span> <span data-ttu-id="1eeac-125">Aus diesem Grund kann ein neuer Client die Ausnahme als Vorzeichen ansehen, dass der-Befehl an einen alten Server gesendet wurde und das Verhalten ordnungsgemäß ändern kann.</span><span class="sxs-lookup"><span data-stu-id="1eeac-125">Therefore, a new client can watch for the exception as a sign that the call went to an old server and can modify its behavior gracefully.</span></span>

3.  <span data-ttu-id="1eeac-126">Führen Sie neue Parameter oder neue Datentypen nur in den neuen Methoden ein.</span><span class="sxs-lookup"><span data-stu-id="1eeac-126">Introduce new parameters or new data types only in the new methods.</span></span>

    <span data-ttu-id="1eeac-127">Ein Grund, eine neue Methode einzuführen, besteht darin, die Daten Inkompatibilität zu vermeiden.</span><span class="sxs-lookup"><span data-stu-id="1eeac-127">One reason to introduce a new method is to avoid data incompatibility.</span></span> <span data-ttu-id="1eeac-128">Wenn ein neuer Datentyp eingeführt oder einfach geändert wird, sollte er grundsätzlich nur in einer neuen Methode (oder Methoden) verwendet werden.</span><span class="sxs-lookup"><span data-stu-id="1eeac-128">If a new data type is introduced or simply modified, in principle it should be used only in a new method (or methods).</span></span> <span data-ttu-id="1eeac-129">Beispiele für nicht kompatible Datentyp Änderungen finden Sie [unter Beispiele für inkompatible Änderungen](examples-of-incompatible-changes.md) .</span><span class="sxs-lookup"><span data-stu-id="1eeac-129">See [Examples of Incompatible Changes](examples-of-incompatible-changes.md) for examples of incompatible data type changes.</span></span> <span data-ttu-id="1eeac-130">Die einzige relevante Ausnahme von dieser Regel wird in Element 4 beschrieben.</span><span class="sxs-lookup"><span data-stu-id="1eeac-130">The only notable exception to this rule is described in item four.</span></span>

4.  <span data-ttu-id="1eeac-131">Ordnen Sie neue Parameter oder neue Datentypen über einen Wrapper zu.</span><span class="sxs-lookup"><span data-stu-id="1eeac-131">Map new parameters or new data types through a wrapper.</span></span>

    <span data-ttu-id="1eeac-132">Diese Lösung ist anwendbar, wenn ein neuer Parameter oder Datentyp für einen Benutzer verfügbar gemacht werden muss, aber nicht separat oder separat oder in den alten Datentypen oder-Parametern zugeordnet werden muss.</span><span class="sxs-lookup"><span data-stu-id="1eeac-132">This solution applies when a new parameter or data type must be exposed to a user, but actually does not have to be remoted separately or can be mapped to the old data types or parameters.</span></span> <span data-ttu-id="1eeac-133">Beispielsweise wird ein Remote-Befehl von vielen System-APIs umschlossen und ausgeführt.</span><span class="sxs-lookup"><span data-stu-id="1eeac-133">For example, many system APIs turn around and execute a remote call.</span></span> <span data-ttu-id="1eeac-134">Sie werden möglicherweise eine Art von Zuordnung von den Benutzer bekannten Datentypen zu den Datentypen, die tatsächlich im zugrunde liegenden RPC-Aufruf verwendet werden, durchgeführt.</span><span class="sxs-lookup"><span data-stu-id="1eeac-134">They may or may not be doing some kind of mapping from the user known data types to the data types actually used in the underlying RPC call.</span></span> <span data-ttu-id="1eeac-135">Daher ist es immer sinnvoll, zu überprüfen, ob die Änderung in der Benutzeroberfläche als Änderung an eine Remote Schnittstelle weitergegeben werden muss.</span><span class="sxs-lookup"><span data-stu-id="1eeac-135">It is therefore always worth examining if the change in the user interface needs to propagate as a change to a remote interface.</span></span>

    <span data-ttu-id="1eeac-136">Eine ähnliche Situation kann auftreten, wenn der Benutzer eine Remote-API direkt aufruft, aber ein Wrapper eingefügt werden kann, um eine neue Typzuordnung oder andere zusätzliche Aktionen durchzuführen, die notwendig sind.</span><span class="sxs-lookup"><span data-stu-id="1eeac-136">A similar situation may happen when the user calls a remote API directly, but a wrapper could be introduced to do a new type mapping or some other additional actions that have become necessary.</span></span> <span data-ttu-id="1eeac-137">Interface Definition Language (IDL) bietet mehrere Möglichkeiten, eine solche Neuzuordnung zu ermöglichen, d \[ . r. [**aufrufen \_ als**](/windows/desktop/Midl/call-as) \] , über \[ [**tragen \_ als und Übertragungs**](/windows/desktop/Midl/transmit-as) \] \[ [**\_ Mars Hall**](/windows/desktop/Midl/wire-marshal) \] .</span><span class="sxs-lookup"><span data-stu-id="1eeac-137">Interface Definition Language (IDL) has several ways of facilitating such remapping, namely \[[**call\_as**](/windows/desktop/Midl/call-as)\], \[[**transmit\_as**](/windows/desktop/Midl/transmit-as)\], and \[[**wire\_marshal**](/windows/desktop/Midl/wire-marshal)\].</span></span> <span data-ttu-id="1eeac-138">Der " \[ **\_ Callas** " \] -Attribut führt einen Funktions Wrapper auf dem Client und dem Server ein.</span><span class="sxs-lookup"><span data-stu-id="1eeac-138">The \[**call\_as**\] attribute introduces a function wrapper on the client and server.</span></span> <span data-ttu-id="1eeac-139">Beide werden zwischen dem Benutzercode und dem Mars Haller platziert.</span><span class="sxs-lookup"><span data-stu-id="1eeac-139">Both are placed between the user code and the marshaler.</span></span> <span data-ttu-id="1eeac-140">Die anderen Attribute befassen sich mit der direkten Typzuordnung.</span><span class="sxs-lookup"><span data-stu-id="1eeac-140">The other attributes deal with direct type mapping.</span></span> <span data-ttu-id="1eeac-141">Wenn Sie Erweiterungs Probleme haben, \[ **wenden Sie sich \_ so** \] an, wie es am häufigsten verwendet wird, und ist am einfachsten zu verstehen und zu bearbeiten.</span><span class="sxs-lookup"><span data-stu-id="1eeac-141">For extension problems, \[**call\_as**\] is the most frequently used, and is easiest to understand and manipulate without pitfalls.</span></span>

5.  <span data-ttu-id="1eeac-142">Ändern von Datentypen durch eine defaultless-Union.</span><span class="sxs-lookup"><span data-stu-id="1eeac-142">Modify data types through a defaultless union.</span></span>

    <span data-ttu-id="1eeac-143">Das Ändern eines Attributs oder Datentyps führt in der Regel zu Netzwerk Inkompatibilität.</span><span class="sxs-lookup"><span data-stu-id="1eeac-143">Changing an attribute or data type typically leads to wire incompatibility.</span></span> <span data-ttu-id="1eeac-144">Beispiele finden Sie [unter Beispiele für nicht kompatible Änderungen](examples-of-incompatible-changes.md) .</span><span class="sxs-lookup"><span data-stu-id="1eeac-144">See [Examples of Incompatible Changes](examples-of-incompatible-changes.md) for examples.</span></span> <span data-ttu-id="1eeac-145">Im Fall einer Union ohne eine DEFAULT-Klausel kann die Inkompatibilität jedoch ähnlich wie bei einer Prozedur außerhalb des gültigen Bereichs verwaltet werden, wie zuvor beschrieben.</span><span class="sxs-lookup"><span data-stu-id="1eeac-145">However, in the case of a union without a default clause, the incompatibility may be managed in a way similar to the case of a procedure out of range, as described previously.</span></span> <span data-ttu-id="1eeac-146">Dieses Schema kann problemlos auf die gängigen *xxxinfo* -Typen angewendet werden, die Unions verwenden.</span><span class="sxs-lookup"><span data-stu-id="1eeac-146">This scheme is readily applicable to the popular *XxxINFO* types that use unions.</span></span>

    <span data-ttu-id="1eeac-147">Beispielsweise ein solcher Beispiel</span><span class="sxs-lookup"><span data-stu-id="1eeac-147">For example, a call like this</span></span>

    ```C++
    XxxGetInfo( [in] level, [out] XxxINFO  * pInfo );
    ```

    

    <span data-ttu-id="1eeac-148">gibt möglicherweise Informationen auf Ebene 1, 2 oder 3 zurück, wobei *xxxinfo* eine Union mit drei Verzweigungen ist: 1, 2 und 3.</span><span class="sxs-lookup"><span data-stu-id="1eeac-148">could return information at level 1, 2 or 3, with *XxxINFO* being a union with three branches: 1, 2 and 3.</span></span>

6.  <span data-ttu-id="1eeac-149">Verwenden Sie das \[ [**Range**](/windows/desktop/Midl/range) - \] Attribut, um den Bereich anzugeben.</span><span class="sxs-lookup"><span data-stu-id="1eeac-149">Use the \[[**range**](/windows/desktop/Midl/range)\] attribute to specify range.</span></span>

    <span data-ttu-id="1eeac-150">Sie können das \[ [**Range**](/windows/desktop/Midl/range) - \] Attribut für einen einfachen Skalierungstyp ohne Unterbrechung der Abwärtskompatibilität angeben.</span><span class="sxs-lookup"><span data-stu-id="1eeac-150">You can specify the \[[**range**](/windows/desktop/Midl/range)\] attribute on a simple scale type without breaking backward compatibility.</span></span> <span data-ttu-id="1eeac-151">Dieses Attribut hat keine Auswirkung auf das Wire-Format, aber während des Unmarshalling prüft RPC den Wert bei der Übertragung, um zu bestätigen, dass er innerhalb des in der IDL-Datei angegebenen Bereichs liegt.</span><span class="sxs-lookup"><span data-stu-id="1eeac-151">This attribute does not affect wire format, but during unmarshalling RPC checks the value on wire to confirm that it is within the range specified in the .idl file.</span></span> <span data-ttu-id="1eeac-152">Andernfalls \_ wird eine ungültige RPC X- \_ \_ gebundene Ausnahme ausgelöst.</span><span class="sxs-lookup"><span data-stu-id="1eeac-152">If not, a RPC\_X\_INVALID\_BOUND exception is thrown.</span></span> <span data-ttu-id="1eeac-153">Dies ist besonders nützlich, wenn der Server die maximale Größe eines Arrays in der Größe kennt.</span><span class="sxs-lookup"><span data-stu-id="1eeac-153">This is especially useful if the server knows the maximum size of a sized array.</span></span>

    <span data-ttu-id="1eeac-154">Beispiel:</span><span class="sxs-lookup"><span data-stu-id="1eeac-154">For example:</span></span>

    ```C++
    HRESULT Method1( [in, range(0,100)] ULONG m, [size_is(m)] ULONG *plong); 
    ```

    

<span data-ttu-id="1eeac-155">Das RPC-Verhalten, wenn die festgestellte Ebene 4 ist und der Arm fehlt, hängt von der Definition der Union ab.</span><span class="sxs-lookup"><span data-stu-id="1eeac-155">The RPC behavior when the indicated level is 4 and the arm is missing, depends on the definition of the union.</span></span> <span data-ttu-id="1eeac-156">Bei einer Union, bei der die default-Klausel definiert ist, überträgt RPC einen Typ, der in der default-Klausel für alle anderen als die bekannten Arm-Bezeichnungen angegeben ist (in diesem Fall etwas anderes als 1, 2 oder 3).</span><span class="sxs-lookup"><span data-stu-id="1eeac-156">For a union with the default clause defined, RPC transmits a type indicated in the default clause for anything different than the known arm labels (in this case, anything other than 1, 2 or 3).</span></span> <span data-ttu-id="1eeac-157">Für eine defaultless-Union löst der unmars Haller eine Ausnahme aus, da es in der Definition keinen Standardwert gibt, auf den zurückgegriffen wird.</span><span class="sxs-lookup"><span data-stu-id="1eeac-157">For a defaultless union, the unmarshaler raises an exception because by definition there is no default to fall back to.</span></span> <span data-ttu-id="1eeac-158">Die Ausnahme ist ein \_ Ungültiges RPC S- \_ \_ Tag.</span><span class="sxs-lookup"><span data-stu-id="1eeac-158">The exception is RPC\_S\_INVALID\_TAG.</span></span>

<span data-ttu-id="1eeac-159">Auch hier kann ein neuer Client sein Verhalten anpassen, wenn er feststellt, dass er als Alter Server bezeichnet wurde.</span><span class="sxs-lookup"><span data-stu-id="1eeac-159">Again, a new client can adjust its behavior upon discovering that it called an old server.</span></span>

<span data-ttu-id="1eeac-160">Aus diesen empfohlenen Vorgehensweisen besteht folgendes: Wenn ein Remote barer Datentyp entworfen werden muss, der in Zukunft erweitert werden kann, verwenden Sie eine defaultless-Union in der IDL-Datei.</span><span class="sxs-lookup"><span data-stu-id="1eeac-160">What follows from these recommended practices is that if a remotable data type must be designed that can be extended in future, use a defaultless union in the IDL file.</span></span> <span data-ttu-id="1eeac-161">Wenn Sie eine Auswahl treffen, ist eine gekapselte Union etwas sauberer.</span><span class="sxs-lookup"><span data-stu-id="1eeac-161">Given a choice, an encapsulated union is slightly cleaner.</span></span>

<span data-ttu-id="1eeac-162">Aufgrund von quirllie interner Darstellung des NDR64 Wire-Protokolls muss die Empfehlung zum Hinzufügen von Waffen, die weiter oben in diesem Abschnitt bereitgestellt wurde, wie folgt qualifiziert werden: der neue Arm, der hinzugefügt wird, kann die Ausrichtung der Union nicht ändern, und insbesondere sollte die größte Ausrichtung der Waffen nicht geändert werden.</span><span class="sxs-lookup"><span data-stu-id="1eeac-162">Due to quirks of internal representation of the NDR64 wire protocol, the recommendation for adding arms provided earlier in this section needs to be qualified as follows: The new arm being added cannot change the alignment of the union, and in particular, the biggest alignment of the arms should not change.</span></span> <span data-ttu-id="1eeac-163">Dies ist in der Regel kein Problem, da ein Zeiger in einem Arm die Ausrichtung auf 8 erzwingt.</span><span class="sxs-lookup"><span data-stu-id="1eeac-163">This is typically not an issue, as a pointer in an arm forces alignment to 8.</span></span> <span data-ttu-id="1eeac-164">Ein Entwurf, bei dem jeder Arm ein Zeiger auf einen Arm-Typ ist, ist eine saubere Methode zum erfüllen der Anforderung.</span><span class="sxs-lookup"><span data-stu-id="1eeac-164">A design where each arm is a pointer to an arm type is one clean way of satisfying the requirement.</span></span>

 

 