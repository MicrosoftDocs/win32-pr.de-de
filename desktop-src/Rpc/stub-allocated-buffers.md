---
title: Stub-Allocated Puffer
description: Anstatt einen separaten Aufruf für jeden Knoten der Struktur oder des Diagramms zu erzwingen, können Sie die Stub anweisen, die Größe der Daten zu berechnen und Arbeitsspeicher zuzuordnen und freizugeben, indem Sie einen einzelnen Aufruf an die mittlere Benutzer Zuordnungs- \_ \_ oder mittellose Benutzer Freigabe richten \_ \_ .
ms.assetid: 9911649d-00e8-47d8-b512-7d9b185d1e09
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: 956acf6452c1a4e7d04afcd1da263439436e3bad
ms.sourcegitcommit: 592c9bbd22ba69802dc353bcb5eb30699f9e9403
ms.translationtype: MT
ms.contentlocale: de-DE
ms.lasthandoff: 08/20/2020
ms.locfileid: "104039334"
---
# <a name="stub-allocated-buffers"></a><span data-ttu-id="83282-103">Stub-Allocated Puffer</span><span class="sxs-lookup"><span data-stu-id="83282-103">Stub-Allocated Buffers</span></span>

<span data-ttu-id="83282-104">Anstatt einen separaten Aufruf für jeden Knoten der Struktur oder des Diagramms zu erzwingen, können Sie die Stub anweisen, die Größe der Daten zu berechnen und Arbeitsspeicher zuzuordnen und freizugeben, indem Sie einen einzelnen Aufruf an die [mittlere \_ Benutzer \_ ](/windows/desktop/Midl/midl-user-allocate-1) Zuordnungs-oder [mittellose \_ Benutzer \_ ](/windows/desktop/Midl/midl-user-free-1)Freigabe richten.</span><span class="sxs-lookup"><span data-stu-id="83282-104">Rather than forcing a distinct call for each node of the tree or graph, you can direct the stubs to compute the size of the data and to allocate and free memory by making a single call to [midl\_user\_allocate](/windows/desktop/Midl/midl-user-allocate-1) or [midl\_user\_free](/windows/desktop/Midl/midl-user-free-1).</span></span> <span data-ttu-id="83282-105">Das ACF-Attribut " **\[ zuordnen" (alle \_ Knoten) \]** weist die Stub an, alle Knoten in einem einzelnen Rückruf der vom Benutzer bereitgestellten –-Speicherverwaltungsfunktionen zuzuordnen oder freizugeben.</span><span class="sxs-lookup"><span data-stu-id="83282-105">The ACF attribute **\[allocate(all\_nodes)\]** directs the stubs to allocate or free all nodes in a single call to the user supplied–memory management functions.</span></span>

<span data-ttu-id="83282-106">Eine RPC-Anwendung könnte z. b. die folgende binäre Strukturdaten Struktur verwenden:</span><span class="sxs-lookup"><span data-stu-id="83282-106">For example, an RPC application might use the following binary tree data structure:</span></span>

``` syntax
/* IDL file fragment */
typedef struct _TREE_TYPE 
{
    short sNumber;
    struct _TREE_TYPE * pLeft;
    struct _TREE_TYPE * pRight;
} TREE_TYPE;

typedef TREE_TYPE * P_TREE_TYPE;
```

<span data-ttu-id="83282-107">Das auf diesen Datentyp angewendete ACF-Attribut **\[ (alle \_ Knoten \] )** wird in der **typedef** -Deklaration in der ACF wie folgt angezeigt:</span><span class="sxs-lookup"><span data-stu-id="83282-107">The ACF attribute **\[allocate(all\_nodes)\]** applied to this data type appears in the **typedef** declaration in the ACF as:</span></span>

``` syntax
/* ACF file fragment */
typedef [allocate(all_nodes)] P_TREE_TYPE;
```

<span data-ttu-id="83282-108">Das Attribut " **\[ zuordnen \]** " kann nur auf Zeiger Typen angewendet werden.</span><span class="sxs-lookup"><span data-stu-id="83282-108">The **\[allocate\]** attribute can only be applied to pointer types.</span></span> <span data-ttu-id="83282-109">Das Attribut "Zuordnungs-ACF" ist eine Microsoft-Erweiterung für DCE IDL und ist daher nicht verfügbar, wenn Sie mit dem **/OSF** -Schalter für mittlere Kompilierung kompilieren. **\[ \]**</span><span class="sxs-lookup"><span data-stu-id="83282-109">The **\[allocate\]** ACF attribute is a Microsoft extension to DCE IDL and, as such, is not available if you compile with the MIDL **/osf** switch.</span></span> <span data-ttu-id="83282-110">Wenn "Allocation **\[ (alle \_ Knoten \] )** " auf einen Zeigertyp angewendet wird, durchlaufen die vom Mittelwert Compiler generierten Stuben die angegebene Datenstruktur, um die Zuordnungs Größe zu bestimmen.</span><span class="sxs-lookup"><span data-stu-id="83282-110">When **\[allocate(all\_nodes)\]** is applied to a pointer type, the stubs generated by the MIDL compiler traverse the specified data structure to determine the allocation size.</span></span> <span data-ttu-id="83282-111">Die Stub erstellen dann einen einzelnen Aufruf, um die gesamte Menge an Arbeitsspeicher zuzuordnen, die für das Diagramm oder die Struktur benötigt wird.</span><span class="sxs-lookup"><span data-stu-id="83282-111">The stubs then make a single call to allocate the entire amount of memory needed by the graph or tree.</span></span> <span data-ttu-id="83282-112">Eine Client Anwendung kann viel effizienter Arbeitsspeicher freigeben, indem Sie einen einzelnen aufzurufenden **\_ Benutzer \_ kostenlos** aufruft.</span><span class="sxs-lookup"><span data-stu-id="83282-112">A client application can free memory much more efficiently by making a single call to **midl\_user\_free**.</span></span> <span data-ttu-id="83282-113">Die Server-Stub-Leistung wird jedoch im Allgemeinen bei der Verwendung der Knoten Speicher Belegung (Knoten Weise) gesteigert, da die Serverstubs häufig privaten Speicher verwenden können, der keine Zuweisungen erfordert.</span><span class="sxs-lookup"><span data-stu-id="83282-113">However, server-stub performance is generally increased when using node-by-node memory allocation because the server stubs can often use private memory that requires no allocations.</span></span>

<span data-ttu-id="83282-114">Weitere Informationen finden Sie unter [Zuordnung und Aufhebung der Zuordnung von Knoten](node-by-node-allocation-and-deallocation.md)zu Knoten.</span><span class="sxs-lookup"><span data-stu-id="83282-114">For additional information, see [Node-by-Node Allocation and Deallocation](node-by-node-allocation-and-deallocation.md).</span></span>

 

 