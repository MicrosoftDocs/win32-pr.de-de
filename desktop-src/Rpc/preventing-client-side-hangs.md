---
title: Verhindern von Client seitigen hängen
description: Es gibt zwei Möglichkeiten, wie der Client die Netzwerk Konnektivität beeinträchtigen kann, kann dazu führen, dass Serveranforderungen verloren gehen oder der Server selbst abstürzen kann. Mit den Standardoptionen führt RPC nie einen Timeout aus, und Ihr Client Thread wartet immer auf eine Antwort.
ms.assetid: 2c201e29-9d9c-48e6-b0b5-68e4b25c3fb7
keywords:
- Remote Prozedur Aufruf RPC, bewährte Methoden, verhindern von Client hängen
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: 18d4b5fc92ca18b575d081cd7b5abf90929e7df5
ms.sourcegitcommit: 592c9bbd22ba69802dc353bcb5eb30699f9e9403
ms.translationtype: MT
ms.contentlocale: de-DE
ms.lasthandoff: 08/20/2020
ms.locfileid: "103727785"
---
# <a name="preventing-client-side-hangs"></a><span data-ttu-id="6fd99-105">Verhindern von Client seitigen hängen</span><span class="sxs-lookup"><span data-stu-id="6fd99-105">Preventing Client-side Hangs</span></span>

<span data-ttu-id="6fd99-106">Der Client kann auf zwei Arten hängen: die Netzwerk Konnektivität kann dazu führen, dass Serveranforderungen verloren gehen oder der Server selbst abstürzen kann.</span><span class="sxs-lookup"><span data-stu-id="6fd99-106">There are two ways your client can hang: network connectivity can cause server requests to become lost, or the server itself can crash.</span></span> <span data-ttu-id="6fd99-107">Mit den Standardoptionen führt RPC nie einen Timeout aus, und Ihr Client Thread wartet immer auf eine Antwort.</span><span class="sxs-lookup"><span data-stu-id="6fd99-107">With default options, RPC will never time out a call, and your client thread will wait forever for a response.</span></span>

<span data-ttu-id="6fd99-108">Es gibt zwei Methoden, um dies zu verhindern: Speichern Sie Alives und Timeouts.</span><span class="sxs-lookup"><span data-stu-id="6fd99-108">There are two methods to prevent this: keep alives and time outs.</span></span>

## <a name="tcp-keep-alives"></a><span data-ttu-id="6fd99-109">TCP-Keep-Alives</span><span class="sxs-lookup"><span data-stu-id="6fd99-109">TCP Keep Alives</span></span>

<span data-ttu-id="6fd99-110">Der Client kann so eingerichtet werden, dass er regelmäßig einen Ping-Befehl für den Server durchführt, um sicherzustellen, dass der Server</span><span class="sxs-lookup"><span data-stu-id="6fd99-110">The client can be set up to periodically ping the server to ensure the server is alive and running.</span></span> <span data-ttu-id="6fd99-111">Bei den Pings handelt es sich um TCP-Keep-Alives für die HTTP-Protokoll Sequenzen [**ncacn \_ IP \_ TCP**](/windows/desktop/Midl/ncacn-ip-tcp) und [**ncacn \_**](/windows/desktop/Midl/ncacn-http) . Daher sind Sie in der CPU-Auslastung und der Netzwerkbandbreite effizient.</span><span class="sxs-lookup"><span data-stu-id="6fd99-111">The pings are TCP keep-alives for the [**ncacn\_ip\_tcp**](/windows/desktop/Midl/ncacn-ip-tcp) and [**ncacn\_http**](/windows/desktop/Midl/ncacn-http) protocol sequences, and as such, they are efficient in CPU utilization and network bandwidth.</span></span> <span data-ttu-id="6fd99-112">Um Keep-Alives für einen bestimmten Remote Prozedur aufzurufen, verwenden Sie die [**RpcMgmtSetComTimeout**](/windows/desktop/api/Rpcdce/nf-rpcdce-rpcmgmtsetcomtimeout) -Funktion vor dem Initiieren des Aufrufes.</span><span class="sxs-lookup"><span data-stu-id="6fd99-112">To enable keep alives on a given remote procedure call, use the [**RpcMgmtSetComTimeout**](/windows/desktop/api/Rpcdce/nf-rpcdce-rpcmgmtsetcomtimeout) function before the call is initiated.</span></span> <span data-ttu-id="6fd99-113">Diese Funktion nimmt ein Bindungs Handle und ein Timeout als Argumente an.</span><span class="sxs-lookup"><span data-stu-id="6fd99-113">This function takes a binding handle and a time out as arguments.</span></span> <span data-ttu-id="6fd99-114">Jeder Remote Prozedur Aufruf für dieses Bindungs Handle nach **RpcMgmtSetComTimeout** verwendet das angegebene Timeout.</span><span class="sxs-lookup"><span data-stu-id="6fd99-114">Every remote procedure call on this binding handle after **RpcMgmtSetComTimeout** uses the supplied time out.</span></span>

<span data-ttu-id="6fd99-115">Der Timeout-Parameter für die [**RpcMgmtSetComTimeout**](/windows/desktop/api/Rpcdce/nf-rpcdce-rpcmgmtsetcomtimeout) -Funktion gibt an, wie lange die RPC-Laufzeit wartet, bevor Sie die Keep-Alives einschaltet.</span><span class="sxs-lookup"><span data-stu-id="6fd99-115">The Timeout parameter for the [**RpcMgmtSetComTimeout**](/windows/desktop/api/Rpcdce/nf-rpcdce-rpcmgmtsetcomtimeout) function specifies how long the RPC run time waits before it turns on keep alives.</span></span> <span data-ttu-id="6fd99-116">Der Timeout Wert ist ein Wert zwischen 0 und 10, wobei 0 für das minimale Timeout und 10 für das unbegrenzte Zeit Limit (kein Timeout) steht.</span><span class="sxs-lookup"><span data-stu-id="6fd99-116">The time out is a value between 0 and 10, where 0 is the minimal time out, and 10 is infinite time out (no time out).</span></span> <span data-ttu-id="6fd99-117">Das einmalige Timeout ist nicht in Sekunden angegeben. die Übersetzung vom Timeout Wert, der an die **RpcMgmtSetComTimeout** -Funktion in Sekunden angegeben wird, erfolgt über die RPC-Laufzeit und ist Implementierungs spezifisch.</span><span class="sxs-lookup"><span data-stu-id="6fd99-117">The time out itself is not in seconds; the translation from the time-out value supplied to the **RpcMgmtSetComTimeout** function to seconds is done by the RPC run time, and is implementation specific.</span></span>

<span data-ttu-id="6fd99-118">In der folgenden Tabelle sind die Übersetzungen für Windows 2000 und Windows XP in Sekunden angegeben.</span><span class="sxs-lookup"><span data-stu-id="6fd99-118">The following table provides the translation to seconds for Windows 2000 and Windows XP.</span></span> <span data-ttu-id="6fd99-119">In zukünftigen Versionen von Windows kann die Zuordnung zwischen dem Timeout Parameter und dem Timeout Wert in Sekunden geändert werden:</span><span class="sxs-lookup"><span data-stu-id="6fd99-119">Future versions of Windows may change the mapping between the Timeout parameter and the time-out value in seconds:</span></span>

| <span data-ttu-id="6fd99-120">Timeout Parameter</span><span class="sxs-lookup"><span data-stu-id="6fd99-120">Timeout parameter</span></span>                       | <span data-ttu-id="6fd99-121">Tatsächlicher Timeout in Sekunden</span><span class="sxs-lookup"><span data-stu-id="6fd99-121">Actual time out in seconds</span></span> |
|-----------------------------------------|----------------------------|
| <span data-ttu-id="6fd99-122">0 (Minuten Timeout für RPC- \_ C- \_ Bindung \_ \_ )</span><span class="sxs-lookup"><span data-stu-id="6fd99-122">0 (RPC\_C\_BINDING\_MIN\_TIMEOUT)</span></span>       | <span data-ttu-id="6fd99-123">120</span><span class="sxs-lookup"><span data-stu-id="6fd99-123">120</span></span>                        |
| <span data-ttu-id="6fd99-124">1</span><span class="sxs-lookup"><span data-stu-id="6fd99-124">1</span></span>                                       | <span data-ttu-id="6fd99-125">240</span><span class="sxs-lookup"><span data-stu-id="6fd99-125">240</span></span>                        |
| <span data-ttu-id="6fd99-126">2</span><span class="sxs-lookup"><span data-stu-id="6fd99-126">2</span></span>                                       | <span data-ttu-id="6fd99-127">360</span><span class="sxs-lookup"><span data-stu-id="6fd99-127">360</span></span>                        |
| <span data-ttu-id="6fd99-128">3</span><span class="sxs-lookup"><span data-stu-id="6fd99-128">3</span></span>                                       | <span data-ttu-id="6fd99-129">480</span><span class="sxs-lookup"><span data-stu-id="6fd99-129">480</span></span>                        |
| <span data-ttu-id="6fd99-130">4</span><span class="sxs-lookup"><span data-stu-id="6fd99-130">4</span></span>                                       | <span data-ttu-id="6fd99-131">600</span><span class="sxs-lookup"><span data-stu-id="6fd99-131">600</span></span>                        |
| <span data-ttu-id="6fd99-132">5 (Standard Timeout für RPC- \_ C- \_ Bindung \_ \_ )</span><span class="sxs-lookup"><span data-stu-id="6fd99-132">5 (RPC\_C\_BINDING\_DEFAULT\_TIMEOUT)</span></span>   | <span data-ttu-id="6fd99-133">720</span><span class="sxs-lookup"><span data-stu-id="6fd99-133">720</span></span>                        |
| <span data-ttu-id="6fd99-134">6</span><span class="sxs-lookup"><span data-stu-id="6fd99-134">6</span></span>                                       | <span data-ttu-id="6fd99-135">840</span><span class="sxs-lookup"><span data-stu-id="6fd99-135">840</span></span>                        |
| <span data-ttu-id="6fd99-136">7</span><span class="sxs-lookup"><span data-stu-id="6fd99-136">7</span></span>                                       | <span data-ttu-id="6fd99-137">960</span><span class="sxs-lookup"><span data-stu-id="6fd99-137">960</span></span>                        |
| <span data-ttu-id="6fd99-138">8</span><span class="sxs-lookup"><span data-stu-id="6fd99-138">8</span></span>                                       | <span data-ttu-id="6fd99-139">1080</span><span class="sxs-lookup"><span data-stu-id="6fd99-139">1080</span></span>                       |
| <span data-ttu-id="6fd99-140">9 (max. RPC- \_ C- \_ Bindungs \_ \_ Timeout)</span><span class="sxs-lookup"><span data-stu-id="6fd99-140">9 (RPC\_C\_BINDING\_MAX\_TIMEOUT)</span></span>       | <span data-ttu-id="6fd99-141">1200</span><span class="sxs-lookup"><span data-stu-id="6fd99-141">1200</span></span>                       |
| <span data-ttu-id="6fd99-142">10 ( \_ unbegrenztes RPC-C- \_ Bindungs \_ \_ Timeout)</span><span class="sxs-lookup"><span data-stu-id="6fd99-142">10 (RPC\_C\_BINDING\_INFINITE\_TIMEOUT)</span></span> | <span data-ttu-id="6fd99-143">Unbegrenzte Zeitüberschreitung</span><span class="sxs-lookup"><span data-stu-id="6fd99-143">Infinite time out</span></span>          |



 

<span data-ttu-id="6fd99-144">Sobald die Keep-Alives aktiviert sind, sendet der Client jede Sekunde ein Keep-Alive-Paket.</span><span class="sxs-lookup"><span data-stu-id="6fd99-144">Once the keep alives are turned on, the client sends one keep alive packet every second.</span></span> <span data-ttu-id="6fd99-145">Wenn auf dem Server keine Bestätigung für drei oder mehr Keep-Alives vorhanden ist, deklariert der Client die Verbindung, und der Remote Prozedur Rückruf schlägt fehl.</span><span class="sxs-lookup"><span data-stu-id="6fd99-145">If there is no acknowledgment from the server for three or more keep alives, the client declares the connection dead and fails the remote procedure call.</span></span> <span data-ttu-id="6fd99-146">Wenn der Server innerhalb des angegebenen Timeouts eine Antwort sendet, werden die "Alives" nicht aktiviert.</span><span class="sxs-lookup"><span data-stu-id="6fd99-146">If the server sends a response within the specified time out, keep alives will not be turned on.</span></span> <span data-ttu-id="6fd99-147">Wenn der Server auf die Beibehaltung von Alives reagiert, aber nicht auf den Remote Prozedur aufzurufen antwortet, setzt der Client die Übermittlung von "Keep-Alives" fort.</span><span class="sxs-lookup"><span data-stu-id="6fd99-147">If the server responds to keep alives, but does not respond to the remote procedure call, the client continues sending keep alives.</span></span> <span data-ttu-id="6fd99-148">Nachdem der Server auf den RPC-Aufruf reagiert hat, sind die Keep-Alives deaktiviert.</span><span class="sxs-lookup"><span data-stu-id="6fd99-148">Once the server responds to the RPC call, the keep alives are turned off.</span></span> <span data-ttu-id="6fd99-149">Für Windows 2000 sind Keep-Alives nur bei synchronen RPC-Aufrufen aktiviert.</span><span class="sxs-lookup"><span data-stu-id="6fd99-149">For Windows 2000, keep alives are turned on only for synchronous RPC calls.</span></span> <span data-ttu-id="6fd99-150">Für Windows XP sind Keep-Alives auch für asynchrone RPC-Aufrufe aktiviert.</span><span class="sxs-lookup"><span data-stu-id="6fd99-150">For Windows XP, keep alives are turned on for asynchronous RPC calls as well.</span></span>

<span data-ttu-id="6fd99-151">Es ist verlockend, Keep-Alives auf den niedrigsten Wert festzulegen, um sicherzustellen, dass die Client Anwendung rechtzeitig auf Netzwerkprobleme antwortet.</span><span class="sxs-lookup"><span data-stu-id="6fd99-151">It is tempting to set keep alives to the lowest value to ensure the client application responds to network problems in a timely fashion.</span></span> <span data-ttu-id="6fd99-152">Diese Versuchung sollte sorgfältig beachtet werden, und es wird geprüft, ob ein aggressiver Wert gewährleistet ist.</span><span class="sxs-lookup"><span data-stu-id="6fd99-152">Careful consideration should be given to such temptation, and scrutiny applied to whether an aggressive value is warranted.</span></span> <span data-ttu-id="6fd99-153">Ein Server, der vorübergehend die Konnektivität verliert, ist möglicherweise nach dem Wiederherstellen der Konnektivität von zahlreichen Clients überflutet.</span><span class="sxs-lookup"><span data-stu-id="6fd99-153">A server that temporarily loses connectivity may find itself flooded with keep alives from numerous clients once connectivity is restored.</span></span> <span data-ttu-id="6fd99-154">Darüber hinaus kann es länger als zwei Minuten dauern, bis der Server mehr als zwei Minuten benötigt, und der Server kann sich mehr CPU-Zeit ausgeben, als die Ausführung nützlicher arbeiten.</span><span class="sxs-lookup"><span data-stu-id="6fd99-154">In addition, long computational tasks can take more than two minutes, and the server may find itself spending more CPU time answering keep alives than performing useful work.</span></span> <span data-ttu-id="6fd99-155">Daher sollten Keep-Alives mit Moderation verwendet werden.</span><span class="sxs-lookup"><span data-stu-id="6fd99-155">Therefore, keep alives should be used with moderation.</span></span> <span data-ttu-id="6fd99-156">Wenn der Client nicht tolerieren kann, dass sein Thread über lange Zeiträume hinweg gebunden ist, sollte der asynchrone RPC berücksichtigt werden.</span><span class="sxs-lookup"><span data-stu-id="6fd99-156">If the client cannot tolerate its thread being tied up for long periods, asynchronous RPC should be considered.</span></span>

<span data-ttu-id="6fd99-157">Andere Protokoll Sequenzen können unterschiedliche Mechanismen zum erkennen nicht reagierender Server implementieren, je nachdem, welcher Transport verwendet wird.</span><span class="sxs-lookup"><span data-stu-id="6fd99-157">Other protocol sequences may implement different mechanisms for detecting unresponsive servers, depending on which transport is used.</span></span> <span data-ttu-id="6fd99-158">Der [**Ncalrpc**](/windows/desktop/Midl/ncalrpc) -Transport verwendet keine Keep-Alives.</span><span class="sxs-lookup"><span data-stu-id="6fd99-158">The [**ncalrpc**](/windows/desktop/Midl/ncalrpc) transport does not use keep alives.</span></span> <span data-ttu-id="6fd99-159">Da die gesamte Kommunikation in **Ncalrpc** lokal ist und der Server nicht reagiert, während ein Aufruf ausgeführt wird, kann die RPC-Laufzeit auf dem Client den Aufruf sofort nicht durchführen.</span><span class="sxs-lookup"><span data-stu-id="6fd99-159">Since all communications in **ncalrpc** are local, if the server becomes unresponsive while a call is in progress, the RPC run time on the client immediately fails the call.</span></span>

## <a name="call-time-outs"></a><span data-ttu-id="6fd99-160">Timeout bei Aufrufen</span><span class="sxs-lookup"><span data-stu-id="6fd99-160">Call Time Outs</span></span>

<span data-ttu-id="6fd99-161">TCP-Keep-Alives sind in Ordnung, wenn die Netzwerk Konnektivität unterbrochen wird oder der Server abstürzt.</span><span class="sxs-lookup"><span data-stu-id="6fd99-161">TCP keep alives are fine if network connectivity is lost, or if the server crashes.</span></span> <span data-ttu-id="6fd99-162">Wenn der Server jedoch in den Benutzermodus wechselt, werden die TCP-Keep-Alives erfolgreich zurückgegeben, aber der-Befehl wird nie zurückgegeben.</span><span class="sxs-lookup"><span data-stu-id="6fd99-162">But if the server deadlocks in user mode, TCP keep alives return successfully but the call will never return.</span></span> <span data-ttu-id="6fd99-163">Zur Bewältigung dieses Szenarios wurde für Windows XP eine neue Lauf Zeit Option hinzugefügt: Timeout für RPC- \_ C- \_ opt- \_ Aufruf \_ .</span><span class="sxs-lookup"><span data-stu-id="6fd99-163">To deal with this scenario, a new run-time option was added for Windows XP: RPC\_C\_OPT\_CALL\_TIMEOUT.</span></span> <span data-ttu-id="6fd99-164">Diese Option weist die RPC-Laufzeit an, bei jedem Senden einer Anforderung an den Server einen Timer einzurichten.</span><span class="sxs-lookup"><span data-stu-id="6fd99-164">This option instructs the RPC run time to set up a timer each time it sends a request to the server.</span></span> <span data-ttu-id="6fd99-165">Wenn der Timer abläuft, wird der Aufruf automatisch abgebrochen und abgeschlossen, wenn der RPC- \_ S- \_ Aufruf \_ abgebrochen wurde.</span><span class="sxs-lookup"><span data-stu-id="6fd99-165">If the timer expires, the call is automatically canceled and completes with RPC\_S\_CALL\_CANCELLED.</span></span> <span data-ttu-id="6fd99-166">Solange der Server innerhalb des angegebenen Zeitraums antwortet, wird der Aufruf vom Client nicht abgebrochen.</span><span class="sxs-lookup"><span data-stu-id="6fd99-166">As long as the server responds within the specified time limit, the client will not cancel the call.</span></span> <span data-ttu-id="6fd99-167">Dies bedeutet, dass ein multifragmentaufruf mehr Zeit in Anspruch nehmen kann als das Timeout, da jede Antwort vom Server innerhalb des Timeout Zeitraums empfangen wird, auch wenn der Zeitraum für alle eingehenden Antworten über dem Timeout Zeitraum liegt.</span><span class="sxs-lookup"><span data-stu-id="6fd99-167">This means a multifragment call may take more than the time-out period to complete, as each response from the server is received within the time-out period, even though the time period for all responses to arrive was more than the time-out period.</span></span>

<span data-ttu-id="6fd99-168">Wenn ein-Befehl abgebrochen wird, wird der Server außerdem nicht über den Abbruch benachrichtigt.</span><span class="sxs-lookup"><span data-stu-id="6fd99-168">Also, when a call is canceled the server is not notified of the cancellation.</span></span> <span data-ttu-id="6fd99-169">Der Server führt den-Vorgang daher wahrscheinlich zu einem beliebigen Zeitpunkt aus, und der Client ignoriert einfach die Antwort vom Server.</span><span class="sxs-lookup"><span data-stu-id="6fd99-169">The server, therefore, will likely execute the call at some point, and the client will simply ignore the response from the server.</span></span>

<span data-ttu-id="6fd99-170">Der gefährlichste Fall bei Aufruf Zeiten ist das Einrichten eines kurzen Timeouts und wiederholen des Aufrufes auf demselben Server.</span><span class="sxs-lookup"><span data-stu-id="6fd99-170">The most dangerous pitfall with call time outs is establishing a short time out and retrying the call on the same server.</span></span> <span data-ttu-id="6fd99-171">Das folgende Szenario veranschaulicht die Gefahren dieses Ansatzes:</span><span class="sxs-lookup"><span data-stu-id="6fd99-171">The following scenario illustrates the dangers of this approach:</span></span>

<span data-ttu-id="6fd99-172">Stellen Sie sich einen Server vor, der die Kapazität fast erreicht</span><span class="sxs-lookup"><span data-stu-id="6fd99-172">Imagine a server that operates near capacity.</span></span> <span data-ttu-id="6fd99-173">Es verfügt über eine Reihe von Clients mit sehr kurzen Zeit Ausfällen, z. b. fünf Sekunden.</span><span class="sxs-lookup"><span data-stu-id="6fd99-173">It has a number of clients with very short time outs, such as five seconds.</span></span> <span data-ttu-id="6fd99-174">Ein vorübergehender Verlust von Netzwerk Konnektivität oder Überlastung bei einem Router führt zu einem Ausfall der Server Antworten für einige Sekunden.</span><span class="sxs-lookup"><span data-stu-id="6fd99-174">A temporary loss of network connectivity or congestion at a router causes a lapse in server replies for a few seconds.</span></span> <span data-ttu-id="6fd99-175">In Ethernet-Netzwerken kann diese Situation problemlos durch einen Aktivitäts Anstieg bei einem Link verursacht werden, der vom Server mit einem anderen Computer gemeinsam verwendet wird.</span><span class="sxs-lookup"><span data-stu-id="6fd99-175">On Ethernet networks, this situation can easily be caused by a burst of activity on a link that the server shares with another machine.</span></span> <span data-ttu-id="6fd99-176">Der Server verwaltet nicht, um alle Antworten vor dem fünf-Sekunden-Timeout zu senden. Die Aufrufe der Clients werden abgebrochen, und Sie werden sofort wiederholt.</span><span class="sxs-lookup"><span data-stu-id="6fd99-176">The server does not manage to send all replies before the five-second time out. The clients get their calls canceled, and immediately retry.</span></span> <span data-ttu-id="6fd99-177">Der Server weiß nicht, dass die Aufrufe Wiederholungen ausführen, und führt Sie auch aus.</span><span class="sxs-lookup"><span data-stu-id="6fd99-177">The server is not aware the calls are retries, and executes them as well.</span></span> <span data-ttu-id="6fd99-178">Daher führt Sie anstelle der normalen Arbeitsauslastung von Aufrufen 30-50% weitere Aufrufe aus, je nachdem, wie viele Clients ein Timeout feststellten. Wenn diese Kapazität überschritten wird und der Server nicht innerhalb von fünf Sekunden auf alle Clients antworten kann, wird eine weitere Runde von Aufrufen an den Server gesendet.</span><span class="sxs-lookup"><span data-stu-id="6fd99-178">Thus, instead of executing its normal workload of calls, it executes 30-50% more calls, depending on how many clients timed out. If this exceeds its capacity, and the server cannot respond to all clients within five seconds, another round of calls are sent to the server.</span></span> <span data-ttu-id="6fd99-179">Die Clients werden immer wieder mit denselben aufrufen fortgeführt. da der Server bei der Verarbeitung vorheriger Aufrufe überladen ist, kann er nicht innerhalb des Zeitüberschreitung Antworten. Nach dem Antworten haben die Clients den Timeout Wert ermittelt, einen neuen Aufruf ausgegeben und die Antwort verworfen.</span><span class="sxs-lookup"><span data-stu-id="6fd99-179">The clients keep reissuing the same calls, and since the server is overloaded processing previous calls, it is unable to respond within the time out. Once it responds, the clients have hit the time out, issued a new call, and discarded the answer.</span></span> <span data-ttu-id="6fd99-180">Im ungünstigsten Fall wird der Server bis zum Neustart nicht wieder hergestellt. abhängig vom Client Zugriffsmuster wird die Wiederherstellung möglicherweise erst wieder hergestellt, wenn eine ausreichende Anzahl von Clients angehalten wurde.</span><span class="sxs-lookup"><span data-stu-id="6fd99-180">In a worst case scenario, the server will not recover until reboot, and depending on client access pattern, may not recover until a sufficient number of clients are stopped.</span></span>

> [!Note]  
> <span data-ttu-id="6fd99-181">Aufruf Zeiten funktionieren nur in den HTTP [**-Protokoll Sequenzen ncacn \_ IP \_ TCP**](/windows/desktop/Midl/ncacn-ip-tcp) und [**ncacn \_**](/windows/desktop/Midl/ncacn-http) .</span><span class="sxs-lookup"><span data-stu-id="6fd99-181">Call time outs work only on the [**ncacn\_ip\_tcp**](/windows/desktop/Midl/ncacn-ip-tcp) and [**ncacn\_http**](/windows/desktop/Midl/ncacn-http) protocol sequences.</span></span>

 

 

 