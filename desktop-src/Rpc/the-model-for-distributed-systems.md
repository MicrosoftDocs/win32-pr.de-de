---
title: Das Modell für verteilte Systeme
description: Normalerweise führte das System auf mehreren Computern dazu, das System in separate Client-und Serverkomponenten aufzuteilen.
ms.assetid: 6055bcef-e34c-4f2d-92b9-9aec75cf3cec
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: 82cd1ea3301d68e77562a63c542bc075692e5192
ms.sourcegitcommit: 2d531328b6ed82d4ad971a45a5131b430c5866f7
ms.translationtype: MT
ms.contentlocale: de-DE
ms.lasthandoff: 09/16/2019
ms.locfileid: "103947544"
---
# <a name="the-model-for-distributed-systems"></a><span data-ttu-id="9921b-103">Das Modell für verteilte Systeme</span><span class="sxs-lookup"><span data-stu-id="9921b-103">The Model for Distributed Systems</span></span>

<span data-ttu-id="9921b-104">Normalerweise führte das System auf mehreren Computern dazu, das System in separate Client-und Serverkomponenten aufzuteilen.</span><span class="sxs-lookup"><span data-stu-id="9921b-104">Traditionally, having a monolithic system run across multiple computers meant splitting the system into separate client and server components.</span></span> <span data-ttu-id="9921b-105">In solchen Systemen hat die Client Komponente die Benutzeroberfläche verarbeitet, und der Server hat die Back-End-Verarbeitung bereitgestellt, wie z. b. Datenbankzugriff, Drucken usw.</span><span class="sxs-lookup"><span data-stu-id="9921b-105">In such systems, the client component handled the user interface and the server provided back-end processing, such as database access, printing, and so on.</span></span> <span data-ttu-id="9921b-106">Wenn sich die Computer weiter verbreiten, Kosten gesenkt und durch immer höhere Bandbreiten Netzwerke verbunden wurden, wurde das Aufteilen von Softwaresystemen in mehrere Komponenten bequemer, wobei jede Komponente auf einem anderen Computer ausgeführt und eine spezialisierte Funktion durchgeführt wurde.</span><span class="sxs-lookup"><span data-stu-id="9921b-106">As computers proliferated, dropped in cost, and became connected by ever-higher bandwidth networks, splitting software systems into multiple components became more convenient, with each component running on a different computer and performing a specialized function.</span></span> <span data-ttu-id="9921b-107">Dieser Ansatz vereinfacht die Entwicklung, Verwaltung, Verwaltung und häufig verbesserte Leistung und Stabilität, da das gesamte System aufgrund eines Fehlers auf einem Computer nicht zwangsläufig deaktiviert wurde.</span><span class="sxs-lookup"><span data-stu-id="9921b-107">This approach simplified development, management, administration, and often improved performance and robustness, since failure in one computer did not necessarily disable the entire system.</span></span>

<span data-ttu-id="9921b-108">In vielen Fällen wird dem Client das System als nicht transparente Cloud angezeigt, die die erforderlichen Vorgänge ausführt, auch wenn das verteilte System aus einzelnen Knoten besteht, wie in der folgenden Abbildung dargestellt.</span><span class="sxs-lookup"><span data-stu-id="9921b-108">In many cases the system appears to the client as an opaque cloud that performs the necessary operations, even though the distributed system is composed of individual nodes, as illustrated in the following figure.</span></span>

![Clients greifen auf Dienste in einem System von RPC-Servern zu, das als nicht transparente Cloud für externe Clients angezeigt wird](images/indy-nodes.png)

<span data-ttu-id="9921b-110">Die Deckkraft der Cloud wird aufrechterhalten, da Computer Vorgänge im Auftrag des Clients aufgerufen werden.</span><span class="sxs-lookup"><span data-stu-id="9921b-110">The opacity of the cloud is maintained because computing operations are invoked on behalf of the client.</span></span> <span data-ttu-id="9921b-111">Daher können Clients einen Computer (einen *Knoten*) in der Cloud suchen und einen bestimmten Vorgang anfordern. bei der Durchführung des Vorgangs kann dieser Computerfunktionen auf anderen Computern in der Cloud aufrufen, ohne die zusätzlichen Schritte oder den Computer, auf dem Sie ausgeführt wurden, auf dem Client verfügbar zu machen.</span><span class="sxs-lookup"><span data-stu-id="9921b-111">As such, clients can locate a computer (a *node*) within the cloud and request a given operation; in performing the operation, that computer can invoke functionality on other computers within the cloud without exposing the additional steps, or the computer on which they were carried out, to the client.</span></span>

<span data-ttu-id="9921b-112">Bei diesem Paradigma kann die Mechanik eines verteilten cloudähnlichen Systems in viele einzelne Paket Austausch Vorgänge oder Konversationen zwischen einzelnen Knoten aufgeteilt werden.</span><span class="sxs-lookup"><span data-stu-id="9921b-112">With this paradigm, the mechanics of a distributed, cloud-like system can be broken down into many individual packet exchanges, or conversations between individual nodes.</span></span>

<span data-ttu-id="9921b-113">Herkömmliche Client/Server-Systeme verfügen über zwei Knoten mit fester Rolle und Zuständigkeiten.</span><span class="sxs-lookup"><span data-stu-id="9921b-113">Traditional client-server systems have two nodes with fixed roles and responsibilities.</span></span> <span data-ttu-id="9921b-114">Moderne verteilte Systeme können über mehr als zwei Knoten verfügen, und ihre Rollen sind häufig dynamisch.</span><span class="sxs-lookup"><span data-stu-id="9921b-114">Modern-distributed systems can have more than two nodes, and their roles are often dynamic.</span></span> <span data-ttu-id="9921b-115">In einer Konversation kann ein Knoten ein Client sein, während in einer anderen Konversation der Knoten der Server sein kann.</span><span class="sxs-lookup"><span data-stu-id="9921b-115">In one conversation a node can be a client, while in another conversation the node can be the server.</span></span> <span data-ttu-id="9921b-116">In vielen Fällen ist der ultimative Consumer der verfügbar gemachten Funktionalität ein Client, bei dem sich ein Benutzer auf der Tastatur befindet und die Ausgabe überwacht.</span><span class="sxs-lookup"><span data-stu-id="9921b-116">In many cases, the ultimate consumer of the exposed functionality is a client with a user sitting at a keyboard, watching the output.</span></span> <span data-ttu-id="9921b-117">In anderen Fällen funktioniert das verteilte System unbeaufsichtigt und führt Hintergrund Vorgänge aus.</span><span class="sxs-lookup"><span data-stu-id="9921b-117">In other cases the distributed system functions unattended, performing background operations.</span></span>

<span data-ttu-id="9921b-118">Das verteilte System verfügt möglicherweise nicht über dedizierte Clients und Server für jeden bestimmten Paket Austausch, aber es ist wichtig, sich daran zu erinnern, dass es einen Aufrufer gibt (oder einen Initiator, der häufig als Client bezeichnet wird).</span><span class="sxs-lookup"><span data-stu-id="9921b-118">The distributed system may not have dedicated clients and servers for each particular packet exchange, but it is important to remember there is a caller, (or initiator, either of which is often referred to as the client).</span></span> <span data-ttu-id="9921b-119">Es gibt auch den Empfänger des Aufrufes (wird häufig als Server bezeichnet).</span><span class="sxs-lookup"><span data-stu-id="9921b-119">There is also the recipient of the call (often referred to as the server).</span></span> <span data-ttu-id="9921b-120">Es ist nicht erforderlich, einen bidirektionalen Paket Austausch im Anforderungs-Antwort-Format eines verteilten Systems zu haben. Häufig werden Nachrichten nur eine Möglichkeit gesendet.</span><span class="sxs-lookup"><span data-stu-id="9921b-120">It is not necessary to have two-way packet exchanges in the request-reply format of a distributed system; often messages are sent only one way.</span></span>

 

 




