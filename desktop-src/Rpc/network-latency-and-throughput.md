---
title: Netzwerk Latenz und Durchsatz
description: Netzwerk Latenz und Durchsatz mit Remote Prozedur Aufruf (RPC).
ms.assetid: 8285fd73-eb54-4c06-b01a-1bffafb7e675
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: c5c51c4db75b904ac5feae8c4a1cc5965fc2b06e
ms.sourcegitcommit: 2d531328b6ed82d4ad971a45a5131b430c5866f7
ms.translationtype: MT
ms.contentlocale: de-DE
ms.lasthandoff: 09/16/2019
ms.locfileid: "104207246"
---
# <a name="network-latency-and-throughput"></a><span data-ttu-id="0c866-103">Netzwerk Latenz und Durchsatz</span><span class="sxs-lookup"><span data-stu-id="0c866-103">Network Latency and Throughput</span></span>

<span data-ttu-id="0c866-104">Drei Hauptprobleme beziehen sich auf die optimale Verwendung des Netzwerks:</span><span class="sxs-lookup"><span data-stu-id="0c866-104">Three major issues relate to optimal use of the network:</span></span>

-   <span data-ttu-id="0c866-105">Netzwerklatenz</span><span class="sxs-lookup"><span data-stu-id="0c866-105">Network latency</span></span>
-   <span data-ttu-id="0c866-106">Netzwerk Sättigung</span><span class="sxs-lookup"><span data-stu-id="0c866-106">Network saturation</span></span>
-   <span data-ttu-id="0c866-107">Auswirkungen der Paketverarbeitung</span><span class="sxs-lookup"><span data-stu-id="0c866-107">Packet processing implications</span></span>

<span data-ttu-id="0c866-108">In diesem Abschnitt wird eine Programmieraufgabe eingeführt, die die Verwendung von RPC erfordert, anschließend werden zwei Lösungen entworfen: eine schlecht geschriebene und eine gut geschriebene.</span><span class="sxs-lookup"><span data-stu-id="0c866-108">This section introduces a programming task requiring use of RPC, then designs two solutions: one poorly written and one well written.</span></span> <span data-ttu-id="0c866-109">Beide Lösungen werden dann überprüft, und die Auswirkungen auf die Netzwerkleistung werden erörtert.</span><span class="sxs-lookup"><span data-stu-id="0c866-109">Both solutions are then scrutinized, and their affect on network performance is discussed.</span></span>

<span data-ttu-id="0c866-110">Bevor Sie die beiden Lösungen erörtern, werden die netzwerkbezogenen Leistungsprobleme in den nächsten Abschnitten erläutert und verdeutlicht.</span><span class="sxs-lookup"><span data-stu-id="0c866-110">Before discussing the two solutions, the next few sections discuss and clarify network related performance issues.</span></span>

## <a name="network-latency"></a><span data-ttu-id="0c866-111">Netzwerklatenz</span><span class="sxs-lookup"><span data-stu-id="0c866-111">Network Latency</span></span>

<span data-ttu-id="0c866-112">Netzwerkbandbreite und Netzwerk Latenz sind separate Begriffe.</span><span class="sxs-lookup"><span data-stu-id="0c866-112">Network bandwidth and network latency are separate terms.</span></span> <span data-ttu-id="0c866-113">Netzwerke mit hoher Bandbreite garantieren keine geringe Latenz.</span><span class="sxs-lookup"><span data-stu-id="0c866-113">Networks with high bandwidth do not guarantee low latency.</span></span> <span data-ttu-id="0c866-114">Beispielsweise weist ein Netzwerkpfad, der einen Satelliten Link durchläuft, häufig eine hohe Latenzzeit auf, obwohl der Durchsatz sehr hoch ist.</span><span class="sxs-lookup"><span data-stu-id="0c866-114">For example, a network path traversing a satellite link often has high latency, even though throughput is very high.</span></span> <span data-ttu-id="0c866-115">Es ist nicht ungewöhnlich, dass ein Netzwerkroundtrip einen Satellitenlink durchläuft, der fünf oder mehr Sekunden Latenz hat.</span><span class="sxs-lookup"><span data-stu-id="0c866-115">It is not uncommon for a network round trip traversing a satellite link to have five or more seconds of latency.</span></span> <span data-ttu-id="0c866-116">Eine solche Verzögerung besteht darin, dass eine Anwendung, die für das Senden einer Anforderung, das warten auf eine Antwort, das Senden einer anderen Anforderung, das warten auf eine andere Antwort usw. konzipiert ist, mindestens fünf Sekunden für jeden Paket Austausch wartet, unabhängig davon, wie schnell der Server ist.</span><span class="sxs-lookup"><span data-stu-id="0c866-116">The implication of such a delay is this: an application designed to send a request, wait for a reply, send another request, wait for another reply, and so on, will wait at least five seconds for each packet exchange, regardless of how fast the server is.</span></span> <span data-ttu-id="0c866-117">Trotz der zunehmenden Geschwindigkeit von Computern basieren Satellitenübertragungen und Netzwerk Medien auf der Geschwindigkeit des Lichts, das in der Regel konstant bleibt.</span><span class="sxs-lookup"><span data-stu-id="0c866-117">Despite the increasing speed of computers, satellite transmissions and network media are based on the speed of light, which generally stays constant.</span></span> <span data-ttu-id="0c866-118">Daher ist es unwahrscheinlich, dass die Latenz für vorhandene Satelliten Netzwerke verbessert wird.</span><span class="sxs-lookup"><span data-stu-id="0c866-118">As such, improvements in latency for existing satellite networks is unlikely to occur.</span></span>

## <a name="network-saturation"></a><span data-ttu-id="0c866-119">Netzwerk Sättigung</span><span class="sxs-lookup"><span data-stu-id="0c866-119">Network Saturation</span></span>

<span data-ttu-id="0c866-120">In vielen Netzwerken kommt es zu einer gewissen Sättigung.</span><span class="sxs-lookup"><span data-stu-id="0c866-120">Some saturation occurs in many networks.</span></span> <span data-ttu-id="0c866-121">Die einfachsten Netzwerke zum sätftigen sind langsame Modem Verknüpfungen, wie z. b. die analogen standardmäßigen 56K-Modems.</span><span class="sxs-lookup"><span data-stu-id="0c866-121">The easiest networks to saturate are slow modem links, such as standard 56k analog modems.</span></span> <span data-ttu-id="0c866-122">Allerdings können Ethernet-Verbindungen mit vielen Computern eines einzelnen Segments auch ausgelastet werden.</span><span class="sxs-lookup"><span data-stu-id="0c866-122">However, Ethernet links with many computers on a single segment can also become saturated.</span></span> <span data-ttu-id="0c866-123">Dasselbe gilt für Wide Area Networks mit einer Verbindung mit geringer Bandbreite oder anderweitig überladener Verbindung, z. b. einem Router oder Switch, der eine begrenzte Menge an Datenverkehr verarbeiten kann.</span><span class="sxs-lookup"><span data-stu-id="0c866-123">The same is true about wide area networks with a low-bandwidth or otherwise overburdened link, such as a router or switch that can handle a limited amount of traffic.</span></span> <span data-ttu-id="0c866-124">In solchen Fällen, wenn das Netzwerk mehr Pakete sendet, als der schwächste Link verarbeiten kann, werden Pakete gelöscht.</span><span class="sxs-lookup"><span data-stu-id="0c866-124">In such these cases, if the network sends more packets than its weakest link can handle, it drops packets.</span></span> <span data-ttu-id="0c866-125">Um Überlastung zu vermeiden, wird der Windows-TCP-Stapel zurückgezogen, wenn gelöschte Pakete erkannt werden, was zu erheblichen Verzögerungen führen kann.</span><span class="sxs-lookup"><span data-stu-id="0c866-125">To avoid congestion the Windows TCP stack scales back when dropped packets are detected which can result in significant delays.</span></span>

## <a name="packet-processing-implications"></a><span data-ttu-id="0c866-126">Auswirkungen der Paketverarbeitung</span><span class="sxs-lookup"><span data-stu-id="0c866-126">Packet Processing Implications</span></span>

<span data-ttu-id="0c866-127">Wenn Programme für Umgebungen höherer Ebene wie RPC, com und sogar Windows Sockets entwickelt werden, neigen Entwickler dazu, zu vergessen, wie viel Arbeit im Hintergrund für jedes gesendete oder empfangene Paket stattfindet.</span><span class="sxs-lookup"><span data-stu-id="0c866-127">When programs are developed for higher level environments like RPC, COM, and even Windows Sockets, developers tend to forget how much work takes place behind the scenes for each sent or received packet.</span></span> <span data-ttu-id="0c866-128">Wenn ein Paket aus dem Netzwerk eingeht, wird vom Computer ein Interrupt von der Netzwerkkarte gewartet.</span><span class="sxs-lookup"><span data-stu-id="0c866-128">When a packet arrives from the network, an interrupt from the network card is serviced by the computer.</span></span> <span data-ttu-id="0c866-129">Anschließend wird ein verzögerter Prozedur Rückruf (DPC) in die Warteschlange eingereiht und muss die Treiber durchlaufen.</span><span class="sxs-lookup"><span data-stu-id="0c866-129">Then a Deferred Procedure Call (DPC) is queued, and must make its way through the drivers.</span></span> <span data-ttu-id="0c866-130">Wenn eine Art von Sicherheit verwendet wird, muss das Paket möglicherweise entschlüsselt oder der kryptografische Hash überprüft werden.</span><span class="sxs-lookup"><span data-stu-id="0c866-130">If any form of security is used, the packet may have to be decrypted, or the cryptographic hash verified.</span></span> <span data-ttu-id="0c866-131">Eine Reihe von Gültigkeits Prüfungen muss auch in jedem Zustand ausgeführt werden.</span><span class="sxs-lookup"><span data-stu-id="0c866-131">A number of validity checks must also be performed at each state.</span></span> <span data-ttu-id="0c866-132">Nur dann empfängt das Paket am endgültigen Ziel: dem Servercode.</span><span class="sxs-lookup"><span data-stu-id="0c866-132">Only then does the packet arrive at the final destination: the server code.</span></span> <span data-ttu-id="0c866-133">Das Senden vieler kleiner Datenblöcke führt zu einem Paket Verarbeitungsaufwand für jeden kleinen Datenblock.</span><span class="sxs-lookup"><span data-stu-id="0c866-133">Sending many small chunks of data results in packet processing overhead for each small chunk of data.</span></span> <span data-ttu-id="0c866-134">Das Senden eines großen Datenblocks beansprucht tendenziell erheblich weniger CPU-Zeit im gesamten System, obwohl die Ausführungskosten für viele kleine Blöcke im Vergleich zu einem großen Block für die Serveranwendung identisch sein können.</span><span class="sxs-lookup"><span data-stu-id="0c866-134">Sending one big chunk of data tends to consume significantly less CPU time throughout the system, even though the cost of execution for many small chunks compared to one large chunk may be the same for the server application.</span></span>

## <a name="example-1-a-poorly-designed-rpc-server"></a><span data-ttu-id="0c866-135">Beispiel 1: ein schlecht gestalteter RPC-Server</span><span class="sxs-lookup"><span data-stu-id="0c866-135">Example 1: A Poorly Designed RPC Server</span></span>

<span data-ttu-id="0c866-136">Stellen Sie sich eine Anwendung vor, die auf Remote Dateien zugreifen muss, und die Aufgabe ist es, eine RPC-Schnittstelle zum Bearbeiten der Remote Datei zu entwerfen.</span><span class="sxs-lookup"><span data-stu-id="0c866-136">Imagine an application that must access remote files, and the task at hand is to design an RPC interface for manipulating the remote file.</span></span> <span data-ttu-id="0c866-137">Die einfachste Lösung ist die Spiegelung der Studio-Datei Routinen für lokale Dateien.</span><span class="sxs-lookup"><span data-stu-id="0c866-137">The simplest solution is to mirror the studio file routines for local files.</span></span> <span data-ttu-id="0c866-138">Dies führt möglicherweise zu einer nicht ordnungsgemäß sauberen und vertrauten Schnittstelle.</span><span class="sxs-lookup"><span data-stu-id="0c866-138">Doing so may result in a deceptively clean and familiar interface.</span></span> <span data-ttu-id="0c866-139">Im folgenden finden Sie eine abgekürzte IDL-Datei:</span><span class="sxs-lookup"><span data-stu-id="0c866-139">Here is an abbreviated .idl file:</span></span>

``` syntax
typedef [context_handle] void *remote_file;
... .
interface remote_file
{
    remote_file remote_fopen(file_name);
    void remote_fclose(remote_file ...);
    size_t remote_fread(void *, size_t, size_t, remote_file ...);
    size_t remote_fwrite(const void *, size_t, size_t, remote_file ...);
    size_t remote_fseek(remote_file ..., long, int);
}
```

<span data-ttu-id="0c866-140">Dies scheint elegant genug zu sein, aber das ist ein Zeit würdiges Rezept für einen Leistungs Notfall.</span><span class="sxs-lookup"><span data-stu-id="0c866-140">This seems elegant enough, but actually, this is a time-honored recipe for performance disaster.</span></span> <span data-ttu-id="0c866-141">Im Gegensatz zu gängigen Meinungen ist der Remote Prozedur Aufruf nicht einfach ein lokaler Prozedur Aufruf mit einer Verbindung zwischen dem Aufrufer und dem aufgerufenen.</span><span class="sxs-lookup"><span data-stu-id="0c866-141">Contrary to popular opinion, remote procedure call is not simply a local procedure call with a wire between the caller and callee.</span></span>

<span data-ttu-id="0c866-142">Um zu sehen, wie die Leistung durch dieses Rezept beeinträchtigt wird, sollten Sie eine 2K-Datei in Erwägung gezogen werden, bei der 20 Bytes von Anfang an und 20 Bytes vom Ende gelesen werden.</span><span class="sxs-lookup"><span data-stu-id="0c866-142">To see how this recipe burns performance, consider a 2K file, where 20 bytes are read from the beginning, and then 20 bytes from the end, and see how this performs.</span></span> <span data-ttu-id="0c866-143">Auf der Clientseite werden die folgenden Aufrufe durchgeführt (viele Codepfade werden aus Gründen der Kürze ausgelassen):</span><span class="sxs-lookup"><span data-stu-id="0c866-143">On the client side, the following calls are made (many code paths are omitted for brevity):</span></span>

``` syntax
rfp = remote_fopen("c:\\sample.txt");
remote_read(...);
remote_fseek(...);
remote_read(...);
remote_fclose(rfp);
```

<span data-ttu-id="0c866-144">Stellen Sie sich nun vor, dass der Server von einem Satelliten Link mit einer Roundtrip-Zeit von fünf Sekunden vom Client getrennt wird.</span><span class="sxs-lookup"><span data-stu-id="0c866-144">Now imagine that the server is separated from the client by a satellite link with a five-second round-trip time.</span></span> <span data-ttu-id="0c866-145">Jeder dieser Aufrufe muss auf eine Antwort warten, bevor er fortfahren kann. Dies bedeutet ein absolutes Minimal Limit für die Ausführung dieser Sequenz von 25 Sekunden.</span><span class="sxs-lookup"><span data-stu-id="0c866-145">Each of those calls must wait for a response before it can proceed, which means an absolute minimum for executing this sequence of 25 seconds.</span></span> <span data-ttu-id="0c866-146">Wenn wir nur 40 Bytes abrufen, ist dies eine unerhört langsame Leistung.</span><span class="sxs-lookup"><span data-stu-id="0c866-146">Considering we are retrieving only 40 bytes, this is outrageously slow performance.</span></span> <span data-ttu-id="0c866-147">Kunden dieser Anwendung sind wütend.</span><span class="sxs-lookup"><span data-stu-id="0c866-147">Customers of this application would be furious.</span></span>

<span data-ttu-id="0c866-148">Stellen Sie sich nun vor, dass das Netzwerk ausgelastet ist, weil die Kapazität eines Routers an einer beliebigen Stelle im Netzwerkpfad überlastet ist.</span><span class="sxs-lookup"><span data-stu-id="0c866-148">Now imagine the network is saturated, because a router's capacity somewhere in the network path is overburdened.</span></span> <span data-ttu-id="0c866-149">Dieser Entwurf zwingt den Router, mindestens 10 Pakete zu verarbeiten, wenn keine Sicherheit (eine für jede Anforderung und eine für jede Antwort) vorhanden ist.</span><span class="sxs-lookup"><span data-stu-id="0c866-149">This design forces the router to handle at least 10 packets if we do not have security (one for each request, and one for each reply).</span></span> <span data-ttu-id="0c866-150">Auch das ist nicht gut geeignet.</span><span class="sxs-lookup"><span data-stu-id="0c866-150">That, too, is not good.</span></span>

<span data-ttu-id="0c866-151">Dieser Entwurf zwingt auch den Server, fünf Pakete zu empfangen und fünf Pakete zu senden.</span><span class="sxs-lookup"><span data-stu-id="0c866-151">This design also forces the server to receive five packets and send five packets.</span></span> <span data-ttu-id="0c866-152">Auch hier keine sehr gute Implementierung.</span><span class="sxs-lookup"><span data-stu-id="0c866-152">Again, not a very good implementation.</span></span>

## <a name="example-2-a-better-designed-rpc-server"></a><span data-ttu-id="0c866-153">Beispiel 2: ein besser entworfener RPC-Server</span><span class="sxs-lookup"><span data-stu-id="0c866-153">Example 2: A Better Designed RPC Server</span></span>

<span data-ttu-id="0c866-154">Im folgenden wird die in Beispiel 1 erörterte Schnittstelle umgestaltet, um zu erfahren, ob wir Sie verbessern können.</span><span class="sxs-lookup"><span data-stu-id="0c866-154">Let's redesign the interface discussed in Example 1, and see whether we can make it better.</span></span> <span data-ttu-id="0c866-155">Es ist wichtig zu beachten, dass es für diesen Server wirklich sinnvoll ist, das Verwendungs Muster für die angegebenen Dateien zu kennen: solche Kenntnisse werden für dieses Beispiel nicht angenommen.</span><span class="sxs-lookup"><span data-stu-id="0c866-155">It is important to note that making this server really good requires knowledge of the usage pattern for the given files: such knowledge is not assumed for this example.</span></span> <span data-ttu-id="0c866-156">Daher handelt es sich hierbei um einen besser entwickelten RPC-Server, aber nicht um einen optimal entworfenen RPC-Server.</span><span class="sxs-lookup"><span data-stu-id="0c866-156">Therefore, this is a better designed RPC server, but not an optimally designed RPC server.</span></span>

<span data-ttu-id="0c866-157">Die Idee in diesem Beispiel besteht darin, so viele Remote Vorgänge wie möglich in einem Vorgang zu reduzieren.</span><span class="sxs-lookup"><span data-stu-id="0c866-157">The idea in this example is to collapse as many remote operations into one operation as possible.</span></span> <span data-ttu-id="0c866-158">Der erste Versuch lautet wie folgt:</span><span class="sxs-lookup"><span data-stu-id="0c866-158">The first attempt is the following:</span></span>

``` syntax
typedef [context_handle] void *remote_file;
typedef struct
{
    long position;
    int origin;
} remote_seek_instruction;
... .
interface remote_file
{
    remote_fread(file_name, void *, size_t, size_t, [in, out] remote_file ..., BOOL CloseWhenDone, remote_seek_instruction *...);
    size_t remote_fwrite(file_name, const void *, size_t, size_t, [in, out] remote_file ..., BOOL CloseWhenDone, remote_seek_instruction *...);
}
```

<span data-ttu-id="0c866-159">In diesem Beispiel werden alle Vorgänge auf einen Lese-und Schreibvorgang reduziert, wodurch ein optionales öffnen für denselben Vorgang sowie ein optionales schließen und suchen ermöglicht wird.</span><span class="sxs-lookup"><span data-stu-id="0c866-159">This example collapses all operations to a read and write, which allows for an optional open on the same operation, as well as an optional close and seek.</span></span>

<span data-ttu-id="0c866-160">Dieselbe Abfolge von Vorgängen, die in abgekürzten Formularen geschrieben werden, sieht wie folgt aus:</span><span class="sxs-lookup"><span data-stu-id="0c866-160">This same sequence of operation, when written in abbreviated form, looks like this:</span></span>

``` syntax
remote_read("c:\\sample.txt", ..., &rfp, FALSE, NULL);
remote_read(NULL, ..., &rfp, TRUE, seek_to_20_bytes_before_end);
```

<span data-ttu-id="0c866-161">Wenn Sie den besser entworfenen RPC-Server in Erwägung ziehen, prüft der Server beim zweiten Aufruf, ob der *Dateiname \_* **null** ist, und verwendet die gespeicherte geöffnete Datei in RFP.</span><span class="sxs-lookup"><span data-stu-id="0c866-161">When considering the better designed RPC server, on the second call the server checks that the *file\_name* is **NULL**, and uses the stored open file in rfp.</span></span> <span data-ttu-id="0c866-162">Dann sehen Sie, dass Such Anweisungen vorhanden sind, und die Dateizeiger 20 Bytes vor dem Ende positionieren, bevor Sie gelesen werden.</span><span class="sxs-lookup"><span data-stu-id="0c866-162">Then it sees there are seek instructions, and will position the file pointer 20 bytes before the end before it reads.</span></span> <span data-ttu-id="0c866-163">Wenn dies der Fall ist, erkennt er, dass das Flag **closewhendone** auf **true** festgelegt ist, schließt die Datei und schließt RFP.</span><span class="sxs-lookup"><span data-stu-id="0c866-163">When done, it will recognize the **CloseWhenDone** flag is set to **TRUE**, and will close the file, and close rfp.</span></span>

<span data-ttu-id="0c866-164">Im Netzwerk mit hoher Latenzzeit dauert diese bessere Version 10 Sekunden (2,5-mal schneller) und erfordert die Verarbeitung von nur vier Paketen. zwei vom Server empfangene und zwei Sende Vorgänge vom Server.</span><span class="sxs-lookup"><span data-stu-id="0c866-164">On the high latency network, this better version takes 10 seconds to complete (2.5 times faster) and requires processing of only four packets; two receives from the server, and two sends from the server.</span></span> <span data-ttu-id="0c866-165">Das zusätzliche *IFS* und das ungemarshalling des Servers sind im Vergleich zu allen anderen vernachlässigbar.</span><span class="sxs-lookup"><span data-stu-id="0c866-165">The extra *ifs* and unmarshaling the server performs are negligible compared to everything else.</span></span>

<span data-ttu-id="0c866-166">Wenn die kausale Reihenfolge ordnungsgemäß angegeben ist, kann die Schnittstelle sogar asynchron gemacht werden, und die beiden Aufrufe können parallel gesendet werden.</span><span class="sxs-lookup"><span data-stu-id="0c866-166">If causal ordering is specified properly, the interface can even be made asynchronous, and the two calls can be sent in parallel.</span></span> <span data-ttu-id="0c866-167">Wenn die kausale Reihenfolge verwendet wird, werden Aufrufe weiterhin in der richtigen Reihenfolge verteilt, was bedeutet, dass im Netzwerk mit hoher Latenz nur eine Verzögerung von fünf Sekunden durchlaufen wird, auch wenn die Anzahl der gesendeten und empfangenen Pakete gleich ist.</span><span class="sxs-lookup"><span data-stu-id="0c866-167">When causal ordering is used calls are still dispatched in order, which means on the high latency network only a five-second delay is endured, even though the number of packets sent and received is the same.</span></span>

<span data-ttu-id="0c866-168">Wir können dies noch weiter reduzieren, indem wir eine Methode erstellen, die ein Array von Strukturen annimmt, wobei jeder Member des Arrays einen bestimmten Datei Vorgang beschreibt. eine Remote Variation von Scatter/Gather-e/a.</span><span class="sxs-lookup"><span data-stu-id="0c866-168">We can collapse this even further by creating one method that takes an array of structures, each member of the array describing a particular file operation; a remote variation of scatter/gather I/O.</span></span> <span data-ttu-id="0c866-169">Der Ansatz zahlt sich aus, solange das Ergebnis jedes Vorgangs keine weitere Verarbeitung auf dem Client erfordert. Anders ausgedrückt: die Anwendung liest die 20 Bytes am Ende, unabhängig davon, was die ersten 20 Bytes sind.</span><span class="sxs-lookup"><span data-stu-id="0c866-169">The approach pays off as long as the result of each operation does not require further processing on the client; in other words the application is going to read the 20 bytes at the end regardless of what the first 20 bytes read are.</span></span>

<span data-ttu-id="0c866-170">Wenn jedoch einige Verarbeitungsschritte für die ersten 20 Bytes ausgeführt werden müssen, nachdem Sie gelesen wurden, um den nächsten Vorgang zu bestimmen, funktioniert das Reduzieren von Elementen in einen Vorgang nicht (zumindest nicht in allen Fällen).</span><span class="sxs-lookup"><span data-stu-id="0c866-170">However, if some processing must be performed on the first 20 bytes after reading them to determine the next operation, collapsing everything into one operation does not work (at least not in all cases).</span></span> <span data-ttu-id="0c866-171">Die Eleganz von RPC besteht darin, dass eine Anwendung beide Methoden in der Schnittstelle aufweisen kann und jede Methode je nach Bedarf aufruft.</span><span class="sxs-lookup"><span data-stu-id="0c866-171">The elegance of RPC is that an application can have both methods in the interface, and call either method depending on need.</span></span>

<span data-ttu-id="0c866-172">Im Allgemeinen ist es am besten, wenn das Netzwerk beteiligt ist, möglichst viele Aufrufe eines einzelnen Aufrufs zu kombinieren.</span><span class="sxs-lookup"><span data-stu-id="0c866-172">In general, when the network is involved it is best to combine as many calls onto a single call as possible.</span></span> <span data-ttu-id="0c866-173">Wenn eine Anwendung über zwei unabhängige Aktivitäten verfügt, verwenden Sie asynchrone Vorgänge, und lassen Sie sie parallel ausführen.</span><span class="sxs-lookup"><span data-stu-id="0c866-173">If an application has two independent activities, use asynchronous operations and let them run in parallel.</span></span> <span data-ttu-id="0c866-174">Halten Sie die Pipeline im wesentlichen vollständig.</span><span class="sxs-lookup"><span data-stu-id="0c866-174">Essentially, keep the pipeline full.</span></span>

 

 




