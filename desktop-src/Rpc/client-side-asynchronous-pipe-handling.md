---
title: Client seitige asynchrone Pipe-Verarbeitung
description: Vor dem Ausführen eines asynchronen Remote Aufrufes muss der Client zuerst das asynchrone handle initialisieren.
ms.assetid: 3d54b233-d8b0-45d1-b759-0d2d24c1e247
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: 11ff503f80c77b2403d683c2b644d89836365956
ms.sourcegitcommit: 2d531328b6ed82d4ad971a45a5131b430c5866f7
ms.translationtype: MT
ms.contentlocale: de-DE
ms.lasthandoff: 09/16/2019
ms.locfileid: "103856687"
---
# <a name="client-side-asynchronous-pipe-handling"></a><span data-ttu-id="dd98f-103">Client seitige asynchrone Pipe-Verarbeitung</span><span class="sxs-lookup"><span data-stu-id="dd98f-103">Client-side Asynchronous Pipe Handling</span></span>

<span data-ttu-id="dd98f-104">Vor dem Ausführen eines asynchronen Remote Aufrufes muss der Client zuerst das asynchrone handle initialisieren.</span><span class="sxs-lookup"><span data-stu-id="dd98f-104">Before making an asynchronous remote call, the client must first initialize the asynchronous handle.</span></span> <span data-ttu-id="dd98f-105">Wie bei nonpipe-Prozeduren ruft der Client eine asynchrone Funktion mit dem asynchronen Handle als ersten Parameter auf und verwendet das asynchrone handle, um pipedaten zu senden und zu empfangen, den Status des Aufrufs abzufragen und die Antwort zu empfangen.</span><span class="sxs-lookup"><span data-stu-id="dd98f-105">As with nonpipe procedures, the client calls an asynchronous function with the asynchronous handle as the first parameter and uses the asynchronous handle to send and receive pipe data, query the status of the call, and receive the reply.</span></span>

<span data-ttu-id="dd98f-106">Der Client führt den asynchronen Remote Prozedur Aufrufvorgang mit dem asynchronen Handle als ersten Parameter aus.</span><span class="sxs-lookup"><span data-stu-id="dd98f-106">The client makes the asynchronous remote procedure call with the asynchronous handle as the first parameter.</span></span> <span data-ttu-id="dd98f-107">Der Client kann dieses Handle verwenden, um den Status des Aufrufes abzufragen und die Antwort zu empfangen.</span><span class="sxs-lookup"><span data-stu-id="dd98f-107">The client can use this handle to query the status of the call and to receive the reply.</span></span> <span data-ttu-id="dd98f-108">Das asynchrone Pipe-Modell ist symmetrisch.</span><span class="sxs-lookup"><span data-stu-id="dd98f-108">The asynchronous pipe model is symmetric.</span></span> <span data-ttu-id="dd98f-109">Client-und Server Anwendungen senden und empfangen Pipe-Daten aktiv (im Gegensatz zu synchronem RPC, bei denen die pipedaten passiv gesendet und empfangen werden).</span><span class="sxs-lookup"><span data-stu-id="dd98f-109">Both client and server applications send and receive pipe data actively (as opposed to synchronous RPC, where the pipe data is sent and received passively).</span></span>

<span data-ttu-id="dd98f-110">Der Client sendet asynchrone Pipe-Daten durch Aufrufen der **Push** -Funktion in der entsprechenden asynchronen Pipe, wobei die Status Variable der Pipe als erster Parameter angegeben wird.</span><span class="sxs-lookup"><span data-stu-id="dd98f-110">The client sends asynchronous pipe data by calling the **push** function on the appropriate asynchronous pipe, with the pipe's state variable as the first parameter.</span></span> <span data-ttu-id="dd98f-111">Wenn die **Push** -Funktion zurückgegeben wird, kann der Client den Sendepuffer ändern oder freigeben.</span><span class="sxs-lookup"><span data-stu-id="dd98f-111">When the **push** function returns, the client can modify or free the send buffer.</span></span>

<span data-ttu-id="dd98f-112">Wenn das \_ Flag zum Vervollständigen von RPC Async \_ \_ on \_ Send \_ im asynchronen handle festgelegt ist und APCs als Benachrichtigungs Mechanismus verwendet werden, wird ein APC in die Warteschlange eingereiht, wenn der Pipe-Sendevorgang tatsächlich ausgeführt wird.</span><span class="sxs-lookup"><span data-stu-id="dd98f-112">If the RPC\_ASYNC\_NOTIFY\_ON\_SEND\_COMPLETE flag is set in the asynchronous handle, and if APCs are used as the notification mechanism, an APC is queued when the pipe send is actually complete.</span></span> <span data-ttu-id="dd98f-113">Sie können diesen Mechanismus nutzen, um die Fluss Steuerung zu implementieren.</span><span class="sxs-lookup"><span data-stu-id="dd98f-113">You can take advantage of this mechanism to implement flow control.</span></span> <span data-ttu-id="dd98f-114">Beachten Sie jedoch Folgendes: Wenn der Client einen anderen Puffer überträgt, bevor der vorherige Push-Vorgang ausgeführt wird, kann der Client abhängig von der Geschwindigkeit des Übertragungs Vorgangs nur eine Benachrichtigung zum Senden von Benachrichtigungen empfangen, anstatt für jeden Puffer oder jeden **Pushvorgang** eine Benachrichtigung zu erhalten.</span><span class="sxs-lookup"><span data-stu-id="dd98f-114">Note, however, that if the client pushes another buffer before the previous push is complete, the client may, depending on the speed of the transfer operation, receive only one send-complete notification, rather than one notification for each buffer or each **push** operation.</span></span> <span data-ttu-id="dd98f-115">Wenn der Client alle pipedaten gesendet hat, wird ein abschließender **Push** -Vorgang mit der Anzahl der Elemente auf 0 festgelegt.</span><span class="sxs-lookup"><span data-stu-id="dd98f-115">When the client has sent all of the pipe data, it makes one final **push** call with the number of elements set to 0.</span></span>

<span data-ttu-id="dd98f-116">Das Client Programm empfängt asynchrone Pipe-Daten durch Aufrufen der **Pull** -Funktion in der entsprechenden asynchronen Pipe, wobei die Status Variable der Pipe als erster Parameter angegeben wird.</span><span class="sxs-lookup"><span data-stu-id="dd98f-116">The client program receives asynchronous pipe data by calling the **pull** function on the appropriate asynchronous pipe, with the pipe's state variable as the first parameter.</span></span> <span data-ttu-id="dd98f-117">Wenn keine pipedaten verfügbar sind, gibt die **Pull** -Funktion einen asynchronen RPC \_ S- \_ \_ Aufruf \_ aus.</span><span class="sxs-lookup"><span data-stu-id="dd98f-117">If no pipe data is available, the **pull** function returns RPC\_S\_ASYNC\_CALL\_PENDING.</span></span>

<span data-ttu-id="dd98f-118">Wenn der Benachrichtigungs Mechanismus APC ist und der Server einen asynchronen RPC-Aufruf zurückgibt \_ \_ \_ \_ , muss der Client warten, bis er das APC **rpcreceivecomplete** von der Laufzeit empfängt  , bevor der Pullvorgang erneut aufgerufen wird.</span><span class="sxs-lookup"><span data-stu-id="dd98f-118">If the notification mechanism is APC, and the server returned RPC\_S\_ASYNC\_CALL\_PENDING, the client must wait until it receives the **RpcReceiveComplete** APC from run-time before calling **pull** again.</span></span>

 

 




