---
description: In diesem Thema wird gezeigt, wie Timer erstellt und zerstört werden und wie ein Timer verwendet wird, um Maus Eingaben in angegebenen Intervallen abzufangen.
ms.assetid: eee54078-759f-4fd4-9cf4-10a8bde888b7
title: Verwenden von Timern
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: 440c6479aca9d5394c2ad9ade87dd77b1474f31f
ms.sourcegitcommit: 831e8f3db78ab820e1710cede244553c70e50500
ms.translationtype: MT
ms.contentlocale: de-DE
ms.lasthandoff: 01/08/2021
ms.locfileid: "104348179"
---
# <a name="using-timers"></a><span data-ttu-id="31547-103">Verwenden von Timern</span><span class="sxs-lookup"><span data-stu-id="31547-103">Using Timers</span></span>

<span data-ttu-id="31547-104">In diesem Thema wird gezeigt, wie Timer erstellt und zerstört werden und wie ein Timer verwendet wird, um Maus Eingaben in angegebenen Intervallen abzufangen.</span><span class="sxs-lookup"><span data-stu-id="31547-104">This topic shows how to create and destroy timers, and how to use a timer to trap mouse input at specified intervals.</span></span>

<span data-ttu-id="31547-105">Dieses Thema enthält folgende Abschnitte:</span><span class="sxs-lookup"><span data-stu-id="31547-105">This topic contains the following sections.</span></span>

-   [<span data-ttu-id="31547-106">Erstellen eines Timers</span><span class="sxs-lookup"><span data-stu-id="31547-106">Creating a Timer</span></span>](#creating-a-timer)
-   [<span data-ttu-id="31547-107">Zerstören eines Timers</span><span class="sxs-lookup"><span data-stu-id="31547-107">Destroying a Timer</span></span>](#destroying-a-timer)
-   [<span data-ttu-id="31547-108">Verwenden von Timer-Funktionen zum Abfangen von Maus Eingaben</span><span class="sxs-lookup"><span data-stu-id="31547-108">Using Timer Functions to Trap Mouse Input</span></span>](#using-timer-functions-to-trap-mouse-input)
-   [<span data-ttu-id="31547-109">Zugehörige Themen</span><span class="sxs-lookup"><span data-stu-id="31547-109">Related topics</span></span>](#related-topics)

## <a name="creating-a-timer"></a><span data-ttu-id="31547-110">Erstellen eines Timers</span><span class="sxs-lookup"><span data-stu-id="31547-110">Creating a Timer</span></span>

<span data-ttu-id="31547-111">Im folgenden Beispiel wird die [**Funktion "**](/windows/win32/api/winuser/nf-winuser-settimer) -Funktion" verwendet, um zwei Timer zu erstellen.</span><span class="sxs-lookup"><span data-stu-id="31547-111">The following example uses the [**SetTimer**](/windows/win32/api/winuser/nf-winuser-settimer) function to create two timers.</span></span> <span data-ttu-id="31547-112">Der erste Timer wird für alle 10 Sekunden festgelegt, die zweite für alle fünf Minuten.</span><span class="sxs-lookup"><span data-stu-id="31547-112">The first timer is set for every 10 seconds, the second for every five minutes.</span></span>


```
// Set two timers. 
 
SetTimer(hwnd,             // handle to main window 
    IDT_TIMER1,            // timer identifier 
    10000,                 // 10-second interval 
    (TIMERPROC) NULL);     // no timer callback 
 
SetTimer(hwnd,             // handle to main window 
    IDT_TIMER2,            // timer identifier 
    300000,                // five-minute interval 
    (TIMERPROC) NULL);     // no timer callback 
```



<span data-ttu-id="31547-113">Um die von diesen Zeit Gebern generierten WM-Zeit Geber Meldungen zu verarbeiten, fügen Sie der Fenster Prozedur für den *HWND* -Parameter eine " **WM- \_ Timer** Case"-Anweisung hinzu. [**\_**](wm-timer.md)</span><span class="sxs-lookup"><span data-stu-id="31547-113">To process the [**WM\_TIMER**](wm-timer.md) messages generated by these timers, add a **WM\_TIMER** case statement to the window procedure for the *hwnd* parameter.</span></span>


```
case WM_TIMER: 
 
    switch (wParam) 
    { 
        case IDT_TIMER1: 
            // process the 10-second timer 
 
             return 0; 
 
        case IDT_TIMER2: 
            // process the five-minute timer 

            return 0; 
    } 
```



<span data-ttu-id="31547-114">Eine Anwendung kann auch einen Timer erstellen, dessen WM-Zeit Geber Nachrichten nicht von der Hauptfenster Prozedur, sondern von einer Anwendungs definierten Rückruffunktion verarbeitet werden, wie im folgenden Codebeispiel, das einen Timer erstellt und die Rückruffunktion **mytimerproc** verwendet, um die **WM \_** -Zeit Geber Meldungen des Timers zu verarbeiten. [**\_**](wm-timer.md)</span><span class="sxs-lookup"><span data-stu-id="31547-114">An application can also create a timer whose [**WM\_TIMER**](wm-timer.md) messages are processed not by the main window procedure but by an application-defined callback function, as in the following code sample, which creates a timer and uses the callback function **MyTimerProc** to process the timer's **WM\_TIMER** messages.</span></span>


```
// Set the timer. 
 
SetTimer(hwnd,                // handle to main window 
    IDT_TIMER3,               // timer identifier 
    5000,                     // 5-second interval 
    (TIMERPROC) MyTimerProc); // timer callback
```



<span data-ttu-id="31547-115">Die Aufruf Konvention für **mytimerproc** muss auf der [*timerproc*](/windows/win32/api/winuser/nc-winuser-timerproc) -Rückruffunktion basieren.</span><span class="sxs-lookup"><span data-stu-id="31547-115">The calling convention for **MyTimerProc** must be based on the [*TimerProc*](/windows/win32/api/winuser/nc-winuser-timerproc) callback function.</span></span>

<span data-ttu-id="31547-116">Wenn Ihre Anwendung einen Timer ohne Angabe eines Fenster Handles erstellt, muss Ihre Anwendung die Nachrichten Warteschlange auf die Zeit Geber Nachrichten der [**WM \_**](wm-timer.md) überwachen und Sie an das entsprechende Fenster verteilen.</span><span class="sxs-lookup"><span data-stu-id="31547-116">If your application creates a timer without specifying a window handle, your application must monitor the message queue for [**WM\_TIMER**](wm-timer.md) messages and dispatch them to the appropriate window.</span></span>


```
HWND hwndTimer;   // handle to window for timer messages 
MSG msg;          // message structure 
 
    while (GetMessage(&msg, // message structure 
            NULL,           // handle to window to receive the message 
               0,           // lowest message to examine 
               0))          // highest message to examine 
    { 
 
        // Post WM_TIMER messages to the hwndTimer procedure. 
 
        if (msg.message == WM_TIMER) 
        { 
            msg.hwnd = hwndTimer; 
        } 
 
        TranslateMessage(&msg); // translates virtual-key codes 
        DispatchMessage(&msg);  // dispatches message to window 
    } 
```



## <a name="destroying-a-timer"></a><span data-ttu-id="31547-117">Zerstören eines Timers</span><span class="sxs-lookup"><span data-stu-id="31547-117">Destroying a Timer</span></span>

<span data-ttu-id="31547-118">Anwendungen sollten die [**killtimer**](/windows/win32/api/winuser/nf-winuser-killtimer) -Funktion verwenden, um Timer zu zerstören, die nicht mehr benötigt werden.</span><span class="sxs-lookup"><span data-stu-id="31547-118">Applications should use the [**KillTimer**](/windows/win32/api/winuser/nf-winuser-killtimer) function to destroy timers that are no longer necessary.</span></span> <span data-ttu-id="31547-119">Im folgenden Beispiel werden die von den konstanten IDT \_ Timer1, IDT \_ TIMER2 und IDT TIMER3 identifizierten Timer zerstört \_ .</span><span class="sxs-lookup"><span data-stu-id="31547-119">The following example destroys the timers identified by the constants IDT\_TIMER1, IDT\_TIMER2, and IDT\_TIMER3.</span></span>


```
// Destroy the timers. 
 
KillTimer(hwnd, IDT_TIMER1); 
KillTimer(hwnd, IDT_TIMER2); 
KillTimer(hwnd, IDT_TIMER3); 
```



## <a name="using-timer-functions-to-trap-mouse-input"></a><span data-ttu-id="31547-120">Verwenden von Timer-Funktionen zum Abfangen von Maus Eingaben</span><span class="sxs-lookup"><span data-stu-id="31547-120">Using Timer Functions to Trap Mouse Input</span></span>

<span data-ttu-id="31547-121">Manchmal ist es erforderlich, mehr Eingaben zu verhindern, während ein Mauszeiger auf dem Bildschirm angezeigt wird.</span><span class="sxs-lookup"><span data-stu-id="31547-121">Sometimes it is necessary to prevent more input while you have a mouse pointer on the screen.</span></span> <span data-ttu-id="31547-122">Eine Möglichkeit, dies zu erreichen, besteht darin, eine spezielle Routine zu erstellen, die Maus Eingaben abfängt, bis ein bestimmtes Ereignis eintritt.</span><span class="sxs-lookup"><span data-stu-id="31547-122">One way to accomplish this is to create a special routine that traps mouse input until a specific event occurs.</span></span> <span data-ttu-id="31547-123">Viele Entwickler verweisen auf diese Routine als "aufbauen eines moustraps".</span><span class="sxs-lookup"><span data-stu-id="31547-123">Many developers refer to this routine as "building a mousetrap."</span></span>

<span data-ttu-id="31547-124">Im folgenden Beispiel werden die Funktionen " [**SETTIMER**](/windows/win32/api/winuser/nf-winuser-settimer) " und " [**killtimer**](/windows/win32/api/winuser/nf-winuser-killtimer) " zum Abfangen der Maus Eingaben verwendet.</span><span class="sxs-lookup"><span data-stu-id="31547-124">The following example uses the [**SetTimer**](/windows/win32/api/winuser/nf-winuser-settimer) and [**KillTimer**](/windows/win32/api/winuser/nf-winuser-killtimer) functions to trap mouse input.</span></span> <span data-ttu-id="31547-125"> "" Ist ein Timer, der alle 10 Sekunden eine Zeit Geber Meldung vom [**WM \_**](wm-timer.md) sendet.</span><span class="sxs-lookup"><span data-stu-id="31547-125">**SetTimer** creates a timer that sends a [**WM\_TIMER**](wm-timer.md) message every 10 seconds.</span></span> <span data-ttu-id="31547-126">Jedes Mal, wenn die Anwendung **eine \_ WM** -Zeit Geber Nachricht empfängt, wird die Position des Mauszeigers aufgezeichnet.</span><span class="sxs-lookup"><span data-stu-id="31547-126">Each time the application receives a **WM\_TIMER** message, it records the mouse pointer location.</span></span> <span data-ttu-id="31547-127">Wenn der aktuelle Speicherort mit dem vorherigen Speicherort identisch ist und das Hauptfenster der Anwendung minimiert ist, verschiebt die Anwendung den Mauszeiger auf das Symbol.</span><span class="sxs-lookup"><span data-stu-id="31547-127">If the current location is the same as the previous location and the application's main window is minimized, the application moves the mouse pointer to the icon.</span></span> <span data-ttu-id="31547-128">Wenn die Anwendung geschlossen wird, beendet **killtimer** den Timer.</span><span class="sxs-lookup"><span data-stu-id="31547-128">When the application closes, **KillTimer** stops the timer.</span></span>


```
HICON hIcon1;               // icon handle 
POINT ptOld;                // previous cursor location 
UINT uResult;               // SetTimer's return value 
HINSTANCE hinstance;        // handle to current instance 
 
//
// Perform application initialization here. 
//
 
wc.hIcon = LoadIcon(hinstance, MAKEINTRESOURCE(400)); 
wc.hCursor = LoadCursor(hinstance, MAKEINTRESOURCE(200)); 
 
// Record the initial cursor position. 
 
GetCursorPos(&ptOld); 
 
// Set the timer for the mousetrap. 
 
uResult = SetTimer(hwnd,             // handle to main window 
    IDT_MOUSETRAP,                   // timer identifier 
    10000,                           // 10-second interval 
    (TIMERPROC) NULL);               // no timer callback 
 
if (uResult == 0) 
{ 
    ErrorHandler("No timer is available."); 
} 
 
LONG APIENTRY MainWndProc( 
    HWND hwnd,          // handle to main window 
    UINT message,       // type of message 
    WPARAM  wParam,     // additional information 
    LPARAM  lParam)     // additional information 
{ 
 
    HDC hdc;        // handle to device context 
    POINT pt;       // current cursor location 
    RECT rc;        // location of minimized window 
 
    switch (message) 
    { 
        //
        // Process other messages. 
        // 
 
        case WM_TIMER: 
        // If the window is minimized, compare the current 
        // cursor position with the one from 10 seconds 
        // earlier. If the cursor position has not changed, 
        // move the cursor to the icon. 
 
            if (IsIconic(hwnd)) 
            { 
                GetCursorPos(&pt); 
 
                if ((pt.x == ptOld.x) && (pt.y == ptOld.y)) 
                { 
                    GetWindowRect(hwnd, &rc); 
                    SetCursorPos(rc.left, rc.top); 
                } 
                else 
                { 
                    ptOld.x = pt.x; 
                    ptOld.y = pt.y; 
                } 
            } 
 
            return 0; 
 
        case WM_DESTROY: 
 
        // Destroy the timer. 
 
            KillTimer(hwnd, IDT_MOUSETRAP); 
            PostQuitMessage(0); 
            break; 
 
        //
        // Process other messages. 
        // 
 
} 
```



<span data-ttu-id="31547-129">Obwohl das folgende Beispiel zeigt, wie Maus Eingaben abgefangen werden, wird die WM- [**Zeit \_**](wm-timer.md) Geber Nachricht durch die Anwendungs definierte Rückruffunktion **mytimerproc** und nicht durch die Meldungs Warteschlange der Anwendung verarbeitet.</span><span class="sxs-lookup"><span data-stu-id="31547-129">Although the following example also shows you how to trap mouse input, it processes the [**WM\_TIMER**](wm-timer.md) message through the application-defined callback function **MyTimerProc**, rather than through the application's message queue.</span></span>


```
UINT uResult;               // SetTimer's return value 
HICON hIcon1;               // icon handle 
POINT ptOld;                // previous cursor location 
HINSTANCE hinstance;        // handle to current instance 
 
//
// Perform application initialization here. 
//
 
wc.hIcon = LoadIcon(hinstance, MAKEINTRESOURCE(400)); 
wc.hCursor = LoadCursor(hinstance, MAKEINTRESOURCE(200)); 
 
// Record the current cursor position. 
 
GetCursorPos(&ptOld); 
 
// Set the timer for the mousetrap. 
 
uResult = SetTimer(hwnd,      // handle to main window 
    IDT_MOUSETRAP,            // timer identifier 
    10000,                    // 10-second interval 
    (TIMERPROC) MyTimerProc); // timer callback 
 
if (uResult == 0) 
{ 
    ErrorHandler("No timer is available."); 
} 
 
LONG APIENTRY MainWndProc( 
    HWND hwnd,          // handle to main window 
    UINT message,       // type of message 
    WPARAM  wParam,     // additional information 
    LPARAM   lParam)    // additional information 
{ 
 
    HDC hdc;            // handle to device context 
 
    switch (message) 
    { 
    // 
    // Process other messages. 
    // 
 
        case WM_DESTROY: 
        // Destroy the timer. 
 
            KillTimer(hwnd, IDT_MOUSETRAP); 
            PostQuitMessage(0); 
            break; 
 
        //
        // Process other messages. 
        // 
 
} 
 
// MyTimerProc is an application-defined callback function that 
// processes WM_TIMER messages. 
 
VOID CALLBACK MyTimerProc( 
    HWND hwnd,        // handle to window for timer messages 
    UINT message,     // WM_TIMER message 
    UINT idTimer,     // timer identifier 
    DWORD dwTime)     // current system time 
{ 
 
    RECT rc; 
    POINT pt; 
 
    // If the window is minimized, compare the current 
    // cursor position with the one from 10 seconds earlier. 
    // If the cursor position has not changed, move the 
    // cursor to the icon. 
 
    if (IsIconic(hwnd)) 
    { 
        GetCursorPos(&pt); 
 
        if ((pt.x == ptOld.x) && (pt.y == ptOld.y)) 
        { 
            GetWindowRect(hwnd, &rc); 
            SetCursorPos(rc.left, rc.top); 
        } 
        else 
        { 
            ptOld.x = pt.x; 
            ptOld.y = pt.y; 
        } 
    } 
} 
```



## <a name="related-topics"></a><span data-ttu-id="31547-130">Zugehörige Themen</span><span class="sxs-lookup"><span data-stu-id="31547-130">Related topics</span></span>

<dl> <dt>

[<span data-ttu-id="31547-131">Informationen zu Timern</span><span class="sxs-lookup"><span data-stu-id="31547-131">About Timers</span></span>](about-timers.md)
</dt> </dl>

 

 
