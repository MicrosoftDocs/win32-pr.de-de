---
description: Im folgenden Verfahren wird beschrieben, wie ein MSP mithilfe von ATL-Version 2,1 oder ATL-Version 3,0 und den MSP-Basisklassen implementiert wird.
ms.assetid: 7485c34a-3c8a-412f-9cb9-8eb895084292
title: Verwenden der TAPI 3-MSP-Basisklassen
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: eb8ad4fd160cf0fc4c7dd682a44f3a4ff0bcec25
ms.sourcegitcommit: 831e8f3db78ab820e1710cede244553c70e50500
ms.translationtype: MT
ms.contentlocale: de-DE
ms.lasthandoff: 01/08/2021
ms.locfileid: "106352744"
---
# <a name="using-the-tapi-3-msp-base-classes"></a>Verwenden der TAPI 3-MSP-Basisklassen

Im folgenden Verfahren wird beschrieben, wie ein MSP mithilfe von ATL-Version 2,1 oder ATL-Version 3,0 und den MSP-Basisklassen implementiert wird. Weitere Informationen und eine Liste von Bibliotheken und Headern finden Sie unter [TAPI 3 MSP-Basisklassen](tapi-3-msp-base-classes.md). Der in diesem Thema enthaltene Inhalt setzt voraus, dass der Entwickler über ein funktionierendes Verständnis von ATL und com verfügt und über Erfahrung mit der Implementierung von COM-DLLs mithilfe von ATL verfügt.

**So implementieren Sie und MSP mithilfe von ATL 2,1 oder ATL 3,0**

1.  Erstellen Sie eine IDL-Datei für Ihren MSP. Diese Datei definiert eine CLSID für Ihren MSP. Deklarieren Sie Ihre msp-"Co-Klasse" als Implementierung der [**itmspaddress**](/windows/desktop/api/msp/nn-msp-itmspaddress) -Schnittstelle, und deklarieren Sie diese Schnittstelle als Standardschnittstelle für Ihr Klassenobjekt. Importieren Sie die Datei "MSP. idl" für die Definition von **itmspaddress**. Fügen Sie Ihre msp-"Co-Klasse" in eine Typbibliothek für Ihr MSP ein. Wenn Ihr MSP private (benutzerdefinierte) Schnittstellen unterstützt, definieren Sie Sie hier, und fügen Sie Sie in die Typbibliothek ein. Das folgende Codebeispiel ist eine IDL-Datei, wie oben beschrieben, ohne benutzerdefinierte Schnittstellen.

    ``` syntax
    import "msp.idl";
    [
          uuid(4DDB6D35-3BC1-11d2-86F2-006008B0E5D2),
          version(2.0),
          helpstring("Wave MSP 2.0 Type Library")
    ]
    library WAVEMSPLib
    {
    importlib("stdole32.tlb");
    importlib("stdole2.tlb");

    [
    uuid(4DDB6D36-3BC1-11d2-86F2-006008B0E5D2),
    helpstring("Wave MSP Class")
    ]
    coclass WaveMSP
    {
    [default] interface ITMSPAddress;
    };
    };
    ```

2.  Ändern Sie den TSP so, dass die CLSID Ihres MSP angekündigt wird, wenn Tapi3.dll ihn anfordert. Stellen Sie sicher, dass (1) Ihr TSP TAPI \_ VERSION3 \_ 0 oder höher in der TSPI-Funktion [**TSPI \_ linenegotiatetspiversion**](/windows/win32/api/tspi/nf-tspi-tspi_linenegotiatetspiversion)aushandeln kann, (2) für die TSP- [**linedevcaps**](/windows/win32/api/tapi/ns-tapi-linedevcaps) -Struktur ist das linedevcapflags- \_ MSP-Flag im **dwdevcapflags** -Member festgelegt, und (3) Ihr TSP gibt Ihre MSP-CLSID in der TSPI-Funktion [**TSPI \_ linemspidentify**](/windows/win32/api/tspi/nf-tspi-tspi_linemspidentify)zurück. Dies sollte die gleiche CLSID sein, die in ihrer IDL-Datei angegeben ist. beispielsweise die zweite Zeile "uuid" in der Beispiel-IDL-Datei im vorherigen Schritt.
3.  Kompilieren Sie die mspbase-Beispielanwendung, die sich im Platform Software Development Kit (SDK) befindet, um die mspbasesample. lib-Bibliothek zu erstellen.
4.  Verknüpfen Sie Ihre MSP-dll mit der mspbasesample. lib-Bibliothek.
5.  Fügen Sie mspbase. h aus dem SDK für MSP-Basisklassen Definitionen ein.
6.  Implementieren Sie Ihre DLL-Exporte (z. b. DllMain). Microsoft Visual C++ werden diese für Sie generieren. Verwenden Sie in DllMain unter \_ dll \_ -Prozess anfügen und dll- \_ Prozess \_ trennen die Makros **msplogregister** und **msplogderegister** , um die Protokollierungsfunktionen für die dll zu aktivieren. Geben Sie den Namen der dll im **msplogderegiester** -Befehl an.
7.  Verwenden Sie das in msplog. h definierte Log-Makro, um Ablauf Verfolgungs Meldungen auf die gleiche Weise wie die Basisklassen auszugeben. Definieren Sie das msplog-Präprozessorsymbol, um die Protokollierung in die dll einzubeziehen. lassen Sie es nicht definiert, um eine DLL zu erstellen, die keine Protokollierung enthält.
8.  Leiten Sie eine Klasse von cmspaddress ab, die Adressen für Ihr MSP implementiert. Deklarieren Sie eine globale ATL-Objekt Zuordnung, die ATL anweist, eine Instanz Ihrer Address-Klasse zu erstellen, wenn Sie zu **CoCreate** für die CLSID aufgefordert werden, die Sie in ihrer IDL-Datei angegeben haben. Leiten Sie außerdem Ihre Address-Klasse aus der ATL- **CComCoClass** -Vorlage ab, und fügen Sie \_ \_ in ihrer Address-Klasse eine Deklaration der ResourceId-Deklaration ein. Erstellen Sie ein entsprechendes Ressourcen Skript und eine Header Datei, wie für jede andere ATL-COM-DLL.
9.  Implementieren Sie die erforderlichen cmspaddress-über Schreibungen für Ihre Address-Klasse. Für [**mspaddressaddressf**](/windows/desktop/api/Mspaddr/nf-mspaddr-cmspaddress-mspaddressaddref) und [**mspaddressrelease**](/windows/desktop/api/Mspaddr/nf-mspaddr-cmspaddress-mspaddressrelease)müssen Sie die bereitgestellten hilfsfunktions Vorlagen aufzurufen. Geben Sie für " [**getcallmediatypes**](/windows/desktop/api/Mspaddr/nf-mspaddr-cmspaddress-getcallmediatypes)" einfach eine **DWORD** -Bitmap mit allen MSP-unterstützten tapimediamodes "ORed" zurück. Geben Sie für " [**comatemspcallcenter**](/windows/desktop/api/msp/nf-msp-itmspaddress-createmspcall) " und " [**shutdownmspcallcenter**](/windows/desktop/api/msp/nf-msp-itmspaddress-shutdownmspcall)" \_ den Wert E notimpl ein, und kompilieren und verknüpfen Sie den MSP zu diesem Zeitpunkt. Stellen Sie jetzt sicher, dass Sie Ihr MSP von TAPI 3-Anwendungen registrieren und instanziieren, aber keine Aufrufe erfolgreich erstellen können.
10. Leiten Sie eine Klasse von cmspcallmultigraph ab, um Ihre MSP-Aufruf Objekte zu implementieren. Möglicherweise möchten Sie von [**cmspcallbase**](/windows/desktop/api/Mspcall/nl-mspcall-cmspcallbase) anstelle von [**cmspcallmultigraph**](/windows/desktop/api/Mspcall/nl-mspcall-cmspcallmultigraph) ableiten, wenn das Filter-Graph-pro-Stream-Modell nicht Ihren Anforderungen entspricht. Dadurch wird die Komplexität der Aufgabe erhöht (zum Zeitpunkt der Erstellung dieses Artikels leiten alle MSPs Aufruf Objekte direkt von **cmspcallmultigraph** ab). Implementieren Sie in Ihrem Adress Objekt " [**anatemspcall"**](/windows/desktop/api/msp/nf-msp-itmspaddress-createmspcall) und " [**shutdownmspcall"**](/windows/desktop/api/msp/nf-msp-itmspaddress-shutdownmspcall) , um Ihren spezifischen Typ von "callobject" mithilfe der bereitgestellten hilfsfunktions Vorlagen zu erstellen und zu beenden. Überschreiben Sie in Ihrem "Callcenter"-Objekt " [**", um**](/windows/desktop/api/Mspcall/nf-mspcall-cmspcallbase-createstreamobject) "E \_ notimpl" zurückzugeben. Überschreiben Sie [**mspcalladressf**](/windows/desktop/api/Mspcall/nf-mspcall-cmspcallbase-mspcalladdref) und [**mspcallrelease**](/windows/desktop/api/Mspcall/nf-mspcall-cmspcallbase-mspcallrelease) auf eine Weise, die mit den entsprechenden Adress Methoden identisch ist. Auch hier sollten Sie in der Lage sein, ihren MSP zu kompilieren und zu verknüpfen. Er sollte nun in der Lage sein, Aufrufe zu erstellen und herunterzufahren, aber die Aufrufe führen kein nützliches Streaming aus.
11. Leiten Sie eine Klasse von cmspstream ab, um Ihre MSP-Streamobjekte zu implementieren. Implementieren Sie in Ihrem Call-Objekt [**createstreamobject**](/windows/desktop/api/Mspcall/nf-mspcall-cmspcallbase-createstreamobject) , um das Streamobjekt zu erstellen und zu initialisieren (in der Regel durch Aufrufen der ATL **CreateInstance** , gefolgt von der ATL **\_ InternalQueryInterface** für [**itstream**](/windows/win32/api/tapi3if/nn-tapi3if-itstream) , gefolgt vom Aufruf von **Init** für das Stream-Objekt). Um eine festgelegte Anzahl von Streams zu unterstützen (Dies ist bei MSPs üblich, die keine Änderungen der streamkonfigurationen durch andere Endpunkte im-Befehl unterstützen), überschreiben Sie **Init**, " [**kreatestream**](/windows/win32/api/tapi3if/nf-tapi3if-itstreamcontrol-createstream)" und " [**removestream**](/windows/win32/api/tapi3if/nf-tapi3if-itstreamcontrol-removestream) " in Ihrem calltobjekt. (Der Befehl " **Init** " erstellt zunächst alle ihre Streams, und " **anatestream** " und " **removestream** " geben die entsprechenden TAPI-Fehlercodes zurück, um zu verhindern, dass die Anwendung Streams erstellt oder entfernt). Überschreiben Sie andernfalls die **Init** -Methode des Aufrufes, um eine anfängliche Standardkonfiguration von Streams mithilfe der für den-Befehl angeforderten Medientypen zu erstellen. Wenn Sie in der **Init** -Methode Ihres Aufrufes die standardmäßigen Streamobjekte erstellen, verwenden Sie die Hilfsmethode [**internalkreatestream**](/windows/desktop/api/Mspcall/nf-mspcall-cmspcallbase-internalcreatestream) .
12. Implementieren Sie das Stream-Objekt. Die einzige erforderliche außer Kraft Setzung ist die [**get \_ Name**](/windows/win32/api/tapi3if/nf-tapi3if-itstream-get_name) -Methode, die einen anzeigen Amen für den Datenstrom zurückgibt. Außerdem müssen Sie mehrere andere Methoden außer Kraft setzen. Welche Methoden außer Kraft gesetzt werden müssen, hängt von ihrer Implementierung und von der Ausführung der verschiedenen Aufgaben ab, die beim Erstellen und dekonstruieren des Filter Diagramms beteiligt sind. Zu diesen Aufgaben gehören das Erstellen der entsprechenden Transport Filter, Codecs usw. und das Einfügen und Entfernen der Filter Diagramme zu den entsprechenden Zeitpunkten. Sie müssen auch die [**itterminalcontrol**](/windows/desktop/api/Termmgr/nn-termmgr-itterminalcontrol) -Schnittstelle für Terminal Objekte verwenden, um die ausgewählten Terminals mit ihren Streams zu verbinden. Möglicherweise möchten Sie [**selectterminal**](/windows/win32/api/tapi3if/nf-tapi3if-itstream-selectterminal) und [**unselectterminal**](/windows/win32/api/tapi3if/nf-tapi3if-itstream-unselectterminal) für das Datenstrom Objekt überschreiben, um die Terminal Konfigurationen einzuschränken, die ihre Streams akzeptieren werden. Wenn Sie die einzelnen Datenströme auf ein einzelnes Terminal beschränken, wird die Erstellung Ihrer Filter Diagramme besonders vereinfacht, aber die Anwendungs Funktionalität wird durch die Video Vorschau geopfert. Abhängig von ihrer Implementierung platzieren Sie den diagrammkonstruktions-, Dekonstruktions-und Terminal Verbindungs Code in den Methoden [**startstream**](/windows/win32/api/tapi3if/nf-tapi3if-itstream-startstream), [**stopstream**](/windows/win32/api/tapi3if/nf-tapi3if-itstream-stopstream), [**pausestream**](/windows/win32/api/tapi3if/nf-tapi3if-itstream-pausestream), [**Initialize**](/windows/desktop/api/msp/nf-msp-itmspaddress-initialize), [**Shutdown**](/windows/desktop/api/msp/nf-msp-itmspaddress-shutdown), [**selectterminal**](/windows/win32/api/tapi3if/nf-tapi3if-itstream-selectterminal)und [**unselectterminal**](/windows/win32/api/tapi3if/nf-tapi3if-itstream-unselectterminal) oder in ihren eigenen Methoden auf der Grundlage privater TSP-Kommunikation. Beachten Sie, dass ein Datenstrom ohne ausgewählte Terminals den gewünschten Diagramm Zustand nachverfolgen muss. ein **startstream** -Befehl, gefolgt von einem **selectterminal** -Befehl für einen solchen Stream, muss einen Datenstream ergeben. Überschreiben Sie die meisten dieser Methoden, um sicherzustellen, dass die korrekte Erstellung, Dekonstruktion, Verbindung und Trennung in jedem Fall abhängig vom Status des Streams erfolgt.
13. Implementieren Sie die TSP-Kommunikation. Überschreiben Sie [**cmspaddress:: receivetspaddressdata**](/windows/desktop/api/Mspaddr/nf-mspaddr-cmspaddress-receivetspaddressdata) und/oder [**cmspcallbase:: receivetspcalldata**](/windows/desktop/api/Mspcall/nf-mspcall-cmspcallbase-receivetspcalldata), und/oder indem Sie " [**postEvent**](/windows/desktop/api/Mspaddr/nf-mspaddr-cmspaddress-postevent) " für Ihr Adress Objekt aufrufen, oder " [**handstreamevent**](/windows/desktop/api/Mspcall/nf-mspcall-cmspcallbase-handlestreamevent) " für das Call-Objekt (entweder aus den Call-oder Streamobjekten).
14. Verwenden Sie "postEvent" für Ihr Adress Objekt oder "handstreamevent" für Ihr calltobjekt (aus den aufrufen-oder Streamobjekten), um über Tapi3.dll Ereignisse für das Aufrufen von Medien an die Anwendung zu senden. Dies erfolgt in der Regel für das Datenstrom Objekt in überschriebenen Methoden, einschließlich der Methoden [**processgraphevent**](/windows/desktop/api/Mspstrm/nf-mspstrm-cmspstream-processgraphevent), [**stopstream**](/windows/win32/api/tapi3if/nf-tapi3if-itstream-stopstream), [**startstream**](/windows/win32/api/tapi3if/nf-tapi3if-itstream-startstream), [**pausestream**](/windows/win32/api/tapi3if/nf-tapi3if-itstream-pausestream), [**selectterminal**](/windows/win32/api/tapi3if/nf-tapi3if-itstream-selectterminal)und [**unselectterminal**](/windows/win32/api/tapi3if/nf-tapi3if-itstream-unselectterminal) , je nachdem, wie Sie Ihre Streams implementieren.
15. Implementieren Sie alle gewünschten privaten Schnittstellen oder untergeordneten Datenströme für die vorhandenen Objekte (Address, Callund Stream). Normalerweise gibt es keine. Beachten Sie, dass Sie bei der Implementierung Ihrer privaten Schnittstellen die LIBID der Typbibliothek aus der IDL-Datei angeben. Das heißt, dass Anwendungsprogrammierer ihre MSP-Typbibliothek verwenden müssen, wenn Sie benutzerdefinierte Schnittstellen verwenden. Die standardmäßigen MSP-Schnittstellen, die in den MSP-Basisklassen implementiert werden, verwenden den Tapi3.dll LIBID und sind daher für alle TAPI 3-Anwendungen zugänglich.
16. Bei der Implementierung von MSP-spezifischen statischen oder dynamischen Terminal Objekten oder Ersetzungen für die statischen Standard Terminals (nicht typisch) können Sie die bereitgestellten Terminal Basisklassen verwenden. Sie müssen verschiedene Methoden für das Adress Objekt überschreiben, um alternative oder zusätzliche Methoden zum Erstellen von Terminal Objekten bereitzustellen.
17. Implementieren Sie die IObjectSafety-Schnittstelle für Adress-, Call-, Stream-und Terminal Objekte. Wenn Sie die [Dispatchzuordnung](dispatch-mapper.md) verwenden möchten, um Schnittstellen für Ihre MSP-Objekte abzufragen, markieren Sie die Objekte für die Skripterstellung für diese Schnittstellen als sicher Zu diesem Zweck implementieren Sie die **iobjectorafety** -Schnittstelle für Ihr Objekt. Die Ableitung von **cmspobjectafetyimpl** (eine Hilfsklasse, die in "msputils. h" bereitgestellt wird) und Hinzufügen von **iobjectafety** zur ATL-COM-Zuordnung Ihrer Klasse \_ macht die Objekte für die Skripterstellung für alle Schnittstellen, die Sie verfügbar machen, sicher Beachten Sie, dass die Verwendung von Dispatch-Mapper für MSP-Objekte implizit sein könnte. MSP-Adresse und MSP-Aufrufe werden durch TAPI-address-und TAPI-calltobjekte aggregiert. Wenn Dispatch-Mapper für die TAPI-Objekte verwendet wird, um die Schnittstellen abzufragen, die von den aggregierten MSP-Objekten verfügbar gemacht werden, werden die aggregierten MSP-Objekte auf Sicherheit der angeforderten Schnittstellen abgefragt.

 

 
