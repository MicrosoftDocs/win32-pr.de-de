---
title: Rasterisierungsregeln
description: Rasterisierungsregeln definieren, wie Vektordaten in Rasterdaten zugeordnet werden.
ms.assetid: 2b3894eb-dff3-401f-8b14-4af98db86e39
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: e256c6fc171c1cce9b63b79fac6a480e507a306e
ms.sourcegitcommit: 592c9bbd22ba69802dc353bcb5eb30699f9e9403
ms.translationtype: MT
ms.contentlocale: de-DE
ms.lasthandoff: 08/20/2020
ms.locfileid: "104390352"
---
# <a name="rasterization-rules"></a><span data-ttu-id="517a3-103">Rasterisierungsregeln</span><span class="sxs-lookup"><span data-stu-id="517a3-103">Rasterization Rules</span></span>

<span data-ttu-id="517a3-104">Rasterisierungsregeln definieren, wie Vektordaten in Rasterdaten zugeordnet werden.</span><span class="sxs-lookup"><span data-stu-id="517a3-104">Rasterization rules define how vector data is mapped into raster data.</span></span> <span data-ttu-id="517a3-105">Die Rasterdaten werden an ganzzahlige Speicherorte angedockt, die dann durch ein-und abgeschnitten werden (um die Mindestanzahl von Pixeln zu zeichnen), und pro Pixel-Attribute werden interpoliert (von pro-Vertex-Attributen), bevor Sie an einen PixelShader übergeben werden.</span><span class="sxs-lookup"><span data-stu-id="517a3-105">The raster data is snapped to integer locations that are then culled and clipped (to draw the minimum number of pixels), and per-pixel attributes are interpolated (from per-vertex attributes) before being passed to a pixel shader.</span></span>

<span data-ttu-id="517a3-106">Es gibt mehrere Typen von Regeln, die vom Typ des primitiven abhängig sind, das zugeordnet wird, und unabhängig davon, ob die Daten multisamplinggrad verwenden, um Aliasing zu verringern.</span><span class="sxs-lookup"><span data-stu-id="517a3-106">There are several types of rules, which depend on the type of primitive that is being mapped, as well as whether or not the data uses multisampling to reduce aliasing.</span></span> <span data-ttu-id="517a3-107">Die folgenden Abbildungen veranschaulichen, wie die eckfälle behandelt werden.</span><span class="sxs-lookup"><span data-stu-id="517a3-107">The following illustrations demonstrate how the corner cases are handled.</span></span>

-   [<span data-ttu-id="517a3-108">Dreiecks rasterisierungsregeln (ohne Multisampling)</span><span class="sxs-lookup"><span data-stu-id="517a3-108">Triangle Rasterization Rules (Without Multisampling)</span></span>](#triangle-rasterization-rules-without-multisampling)
-   [<span data-ttu-id="517a3-109">Linienrasterisierungsregeln (Alias, ohne Multisampling)</span><span class="sxs-lookup"><span data-stu-id="517a3-109">Line Rasterization Rules (Aliased, Without Multisampling)</span></span>](#line-rasterization-rules-aliased-without-multisampling)
-   [<span data-ttu-id="517a3-110">Linienrasterisierungsregeln (Antialiasing, ohne Multisampling)</span><span class="sxs-lookup"><span data-stu-id="517a3-110">Line Rasterization Rules (Antialiased, Without Multisampling)</span></span>](#line-rasterization-rules-antialiased-without-multisampling)
-   [<span data-ttu-id="517a3-111">Punktrasterisierungsregeln (ohne Multisampling)</span><span class="sxs-lookup"><span data-stu-id="517a3-111">Point Rasterization Rules (Without Multisampling)</span></span>](#point-rasterization-rules-without-multisampling)
-   [<span data-ttu-id="517a3-112">Multisample Anti-Aliasing-rasterisierungsregeln</span><span class="sxs-lookup"><span data-stu-id="517a3-112">Multisample Anti-Aliasing Rasterization Rules</span></span>](#multisample-anti-aliasing-rasterization-rules)
    -   [<span data-ttu-id="517a3-113">Hardware Unterstützung</span><span class="sxs-lookup"><span data-stu-id="517a3-113">Hardware Support</span></span>](#hardware-support)
    -   [<span data-ttu-id="517a3-114">Centroid-Stichprobenentnahme von Attributen bei Multisample-Antialiasing</span><span class="sxs-lookup"><span data-stu-id="517a3-114">Centroid Sampling of Attributes when Multisample Antialiasing</span></span>](#centroid-sampling-of-attributes-when-multisample-antialiasing)
    -   [<span data-ttu-id="517a3-115">Abgeleitete Berechnungen bei Multisampling</span><span class="sxs-lookup"><span data-stu-id="517a3-115">Derivative Calculations When Multisampling</span></span>](#derivative-calculations-when-multisampling)
-   [<span data-ttu-id="517a3-116">Zugehörige Themen</span><span class="sxs-lookup"><span data-stu-id="517a3-116">Related topics</span></span>](#related-topics)

## <a name="triangle-rasterization-rules-without-multisampling"></a><span data-ttu-id="517a3-117">Dreiecks rasterisierungsregeln (ohne Multisampling)</span><span class="sxs-lookup"><span data-stu-id="517a3-117">Triangle Rasterization Rules (Without Multisampling)</span></span>

<span data-ttu-id="517a3-118">Jedes Pixel Center, das in einem Dreieck liegt, wird gezeichnet. Es wird davon ausgegangen, dass sich ein Pixel in der oberen linken Regel befindet.</span><span class="sxs-lookup"><span data-stu-id="517a3-118">Any pixel center which falls inside a triangle is drawn; a pixel is assumed to be inside if it passes the top-left rule.</span></span> <span data-ttu-id="517a3-119">Die linke obere Regel besteht darin, dass ein Pixel Center so definiert ist, dass es in einem Dreieck liegt, wenn es am oberen Rand oder am linken Rand eines Dreiecks liegt.</span><span class="sxs-lookup"><span data-stu-id="517a3-119">The top-left rule is that a pixel center is defined to lie inside of a triangle if it lies on the top edge or the left edge of a triangle.</span></span>

<span data-ttu-id="517a3-120">Hierbei gilt:</span><span class="sxs-lookup"><span data-stu-id="517a3-120">Where:</span></span>

-   <span data-ttu-id="517a3-121">Ein oberer Rand ist eine Kante, die exakt horizontal ist und über den anderen Rändern liegt.</span><span class="sxs-lookup"><span data-stu-id="517a3-121">A top edge, is an edge that is exactly horizontal and is above the other edges.</span></span>
-   <span data-ttu-id="517a3-122">Ein linker Rand ist ein Rand, der nicht exakt horizontal ist und sich auf der linken Seite des Dreiecks befindet.</span><span class="sxs-lookup"><span data-stu-id="517a3-122">A left edge, is an edge that is not exactly horizontal and is on the left side of the triangle.</span></span> <span data-ttu-id="517a3-123">Ein Dreieck kann über einen oder zwei Linke Kanten verfügen.</span><span class="sxs-lookup"><span data-stu-id="517a3-123">A triangle can have one or two left edges.</span></span>

<span data-ttu-id="517a3-124">Mit der oberen linken Regel wird sichergestellt, dass angrenzende Dreiecke einmal gezeichnet werden.</span><span class="sxs-lookup"><span data-stu-id="517a3-124">The top-left rule ensures that adjacent triangles are drawn once.</span></span>

<span data-ttu-id="517a3-125">Diese Abbildung zeigt Beispiele für Pixel, die gezeichnet werden, da Sie entweder innerhalb eines Dreiecks liegen oder der oberen linken Regel folgen.</span><span class="sxs-lookup"><span data-stu-id="517a3-125">This illustration shows examples of pixels that are drawn because they either lie inside a triangle or follow the top-left rule.</span></span>

![Abbildung der Beispiele für die Dreiecks rasterisierung oben links](images/d3d10-rasterrulestriangle.png)

<span data-ttu-id="517a3-127">In der hellen und dunklen grauen Abdeckung der Pixel werden Sie als Gruppen von Pixeln angezeigt, um anzugeben, in welchem Dreieck Sie sich befinden.</span><span class="sxs-lookup"><span data-stu-id="517a3-127">The light and dark gray covering of the pixels show them as groups of the pixels to indicate which triangle they are inside.</span></span>

## <a name="line-rasterization-rules-aliased-without-multisampling"></a><span data-ttu-id="517a3-128">Linienrasterisierungsregeln (Alias, ohne Multisampling)</span><span class="sxs-lookup"><span data-stu-id="517a3-128">Line Rasterization Rules (Aliased, Without Multisampling)</span></span>

<span data-ttu-id="517a3-129">Zeilenrasterisierungsregeln verwenden einen rautentestbereich, um zu bestimmen, ob eine Linie ein Pixel abdeckt.</span><span class="sxs-lookup"><span data-stu-id="517a3-129">Line rasterization rules use a diamond test area to determine if a line covers a pixel.</span></span> <span data-ttu-id="517a3-130">Bei x-Hauptlinien (Zeilen mit-1 <= Slope <= + 1) umfasst der rautentestbereich den unteren linken Rand, den unteren rechten Rand und die untere Ecke. der Diamant schließt den oberen linken Rand, den oberen rechten Rand, den oberen Rand, die linke Ecke und die Rechte Ecke (dargestellt) aus.</span><span class="sxs-lookup"><span data-stu-id="517a3-130">For x-major lines (lines with -1 <= slope <= +1), the diamond test area includes (shown solid) the lower-left edge, lower-right edge, and bottom corner; the diamond excludes (shown dotted) the upper-left edge, upper-right edge, the top corder, the left corner, and the right corner.</span></span> <span data-ttu-id="517a3-131">Eine y-Hauptlinie ist eine beliebige Zeile, die keine x-Hauptzeile ist. der rautenrautenbereich ist mit der Beschreibung für die x-Hauptlinie identisch, außer die Rechte Ecke ist ebenfalls enthalten.</span><span class="sxs-lookup"><span data-stu-id="517a3-131">A y-major line is any line that is not an x-major line; the test diamond area is the same as described for the x-major line except the right corner is also included.</span></span>

<span data-ttu-id="517a3-132">Wenn der rautenbereich angezeigt wird, deckt eine Linie ein Pixel ab, wenn die Linie den rautentestbereich des Pixels verlässt, wenn Sie entlang der Linie von Anfang bis zum Ende unterwegs ist.</span><span class="sxs-lookup"><span data-stu-id="517a3-132">Given the diamond area, a line covers a pixel if the line exits the pixel's diamond test area when traveling along the line from the start towards the end.</span></span> <span data-ttu-id="517a3-133">Ein Zeilen Streifen verhält sich genauso, wie er als Sequenz von Zeilen gezeichnet wird.</span><span class="sxs-lookup"><span data-stu-id="517a3-133">A line strip behaves the same, as it is drawn as a sequence of lines.</span></span>

<span data-ttu-id="517a3-134">In der folgenden Abbildung sind einige Beispiele dargestellt.</span><span class="sxs-lookup"><span data-stu-id="517a3-134">The following illustration shows some examples.</span></span>

![Abbildung von Beispielen für die Zeilen-rasterisierung mit Alias](images/d3d10-rasterrulesline.png)

## <a name="line-rasterization-rules-antialiased-without-multisampling"></a><span data-ttu-id="517a3-136">Linienrasterisierungsregeln (Antialiasing, ohne Multisampling)</span><span class="sxs-lookup"><span data-stu-id="517a3-136">Line Rasterization Rules (Antialiased, Without Multisampling)</span></span>

<span data-ttu-id="517a3-137">Eine Antialiasing-Linie wird so gerendert, als ob es sich um ein Rechteck (mit Breite = 1) handelt.</span><span class="sxs-lookup"><span data-stu-id="517a3-137">An antialiased line is rasterized as if it were a rectangle (with width = 1).</span></span> <span data-ttu-id="517a3-138">Das Rechteck überschneidet sich mit einem Renderziel, das pro Pixel Abdeckungs Werte erzeugt, die in Pixel-Shader-Ausgabe-Alpha Komponenten multipliziert werden.</span><span class="sxs-lookup"><span data-stu-id="517a3-138">The rectangle intersects with a render target producing per-pixel coverage values, which are multiplied into pixel shader output alpha components.</span></span> <span data-ttu-id="517a3-139">Beim Zeichnen von Linien auf einem Multisampling-Renderziel gibt es keine präaliasing.</span><span class="sxs-lookup"><span data-stu-id="517a3-139">There is no antialiasing preformed when drawing lines on a multisampled render target.</span></span>

<span data-ttu-id="517a3-140">Es wird davon ausgegangen, dass es keine einzige "beste" Methode zum Ausführen von Zeilen Rendering mit Antialiasing gibt.</span><span class="sxs-lookup"><span data-stu-id="517a3-140">It is deemed that there is no single "best" way to perform antialiased line rendering.</span></span> <span data-ttu-id="517a3-141">Direct3D 10 übernimmt die in der folgenden Abbildung gezeigte Methode als Richtlinie.</span><span class="sxs-lookup"><span data-stu-id="517a3-141">Direct3D 10 adopts as a guideline the method shown in the following illustration.</span></span> <span data-ttu-id="517a3-142">Diese Methode wurde empirisch abgeleitet und stellt eine Reihe von visuellen Eigenschaften dar, die als wünschenswert erachtet werden.</span><span class="sxs-lookup"><span data-stu-id="517a3-142">This method was derived empirically, exhibiting a number of visual properties deemed desirable.</span></span> <span data-ttu-id="517a3-143">Hardware muss mit diesem Algorithmus nicht exakt übereinstimmen. Tests für diesen Verweis sollten über "sinnvolle" Toleranzen verfügen, die durch einige der unten aufgeführten Prinzipien gesteuert werden, die verschiedene Hardware Implementierungen und Filter-Kernel Größen ermöglichen.</span><span class="sxs-lookup"><span data-stu-id="517a3-143">Hardware need not exactly match this algorithm; tests against this reference shall have "reasonable" tolerances, guided by some of the principles listed further below, permitting various hardware implementations and filter kernel sizes.</span></span> <span data-ttu-id="517a3-144">Keine dieser flexiblen Flexibilität bei der Hardware Implementierung kann jedoch über Direct3D 10 an Anwendungen kommuniziert werden, und zwar über das einfache Zeichnen von Linien und das beobachten/Messen der Art und Weise.</span><span class="sxs-lookup"><span data-stu-id="517a3-144">None of this flexibility permitted in hardware implementation, however, can be communicated up through Direct3D 10 to applications, beyond simply drawing lines and observing/measuring how they look.</span></span>

![Abbildung von Beispielen für die Zeilen-rasterisierung mit Antialiasing](images/d3d10-rasterruleslineaa.png)

<span data-ttu-id="517a3-146">Dieser Algorithmus generiert relativ glatte Linien mit einheitlicher Intensität und minimalen verzweigten Kanten oder dem Geflecht.</span><span class="sxs-lookup"><span data-stu-id="517a3-146">This algorithm generates relatively smooth lines, with uniform intensity, with minimal jagged edges or braiding.</span></span> <span data-ttu-id="517a3-147">Das mugistermuster für schließende Zeilen ist minimiert.</span><span class="sxs-lookup"><span data-stu-id="517a3-147">Moire patterning for close lines is minimized.</span></span> <span data-ttu-id="517a3-148">Es gibt eine gute Abdeckung für Verbindungen zwischen Zeilen Segmenten, die End-to-End platziert werden.</span><span class="sxs-lookup"><span data-stu-id="517a3-148">There is good coverage for junctions between line segments placed end-to-end.</span></span> <span data-ttu-id="517a3-149">Der Filter-Kernel ist ein angemessener Kompromiss zwischen dem Umfang des edgeblurrings und den durch gammakorrekturen verursachten Änderungen der Intensität.</span><span class="sxs-lookup"><span data-stu-id="517a3-149">The filter kernel is a reasonable tradeoff between the amount of edge blurring and the changes in intensity caused by gamma corrections.</span></span> <span data-ttu-id="517a3-150">Der Coverage-Wert wird mit Pixel Shader o0. a (srcalpha) gemäß der folgenden Formel von der Output-Merger-Phase multipliziert: srccolor \* srcalpha + destcolor \* (1-srcalpha).</span><span class="sxs-lookup"><span data-stu-id="517a3-150">The coverage value is multiplied into pixel shader o0.a (srcAlpha) per the following formula by the output-merger stage: srcColor \* srcAlpha + destColor \* (1-srcAlpha).</span></span>

## <a name="point-rasterization-rules-without-multisampling"></a><span data-ttu-id="517a3-151">Punktrasterisierungsregeln (ohne Multisampling)</span><span class="sxs-lookup"><span data-stu-id="517a3-151">Point Rasterization Rules (Without Multisampling)</span></span>

<span data-ttu-id="517a3-152">Ein Punkt wird so interpretiert, als wäre er aus zwei Dreiecken in einem Z-Muster zusammengesetzt, die Dreiecks rasterisierungsregeln verwenden.</span><span class="sxs-lookup"><span data-stu-id="517a3-152">A point is interpreted as though it were composed of two triangles in a Z pattern, which use triangle rasterization rules.</span></span> <span data-ttu-id="517a3-153">Die Koordinate identifiziert den Mittelpunkt eines einzelnen Pixel weiten Quadrats.</span><span class="sxs-lookup"><span data-stu-id="517a3-153">The coordinate identifies the center of a one pixel wide square.</span></span> <span data-ttu-id="517a3-154">Es gibt keine Berechnungen für Punkte.</span><span class="sxs-lookup"><span data-stu-id="517a3-154">There is no culling for points.</span></span>

<span data-ttu-id="517a3-155">In der folgenden Abbildung sind einige Beispiele dargestellt.</span><span class="sxs-lookup"><span data-stu-id="517a3-155">The following illustration shows some examples.</span></span>

![Darstellung von Beispielen für die Punkt-rasterisierung](images/d3d10-rasterrulespoint.png)

## <a name="multisample-anti-aliasing-rasterization-rules"></a><span data-ttu-id="517a3-157">Multisample Anti-Aliasing-rasterisierungsregeln</span><span class="sxs-lookup"><span data-stu-id="517a3-157">Multisample Anti-Aliasing Rasterization Rules</span></span>

<span data-ttu-id="517a3-158">Multisample Antialiasing (MSAA) reduziert die Geometrie Aliasing mithilfe von Pixel Abdeckung und tiefen Schablone an mehreren unter Stichproben Positionen.</span><span class="sxs-lookup"><span data-stu-id="517a3-158">Multisample antialiasing (MSAA) reduces geometry aliasing using pixel coverage and depth-stencil tests at multiple sub-sample locations.</span></span> <span data-ttu-id="517a3-159">Um die Leistung zu verbessern, werden pro Pixel-Berechnungen einmal für jedes abgedeckte Pixel durchgeführt, indem shaderausgaben in abgedeckten unter Pixeln gemeinsam genutzt werden.</span><span class="sxs-lookup"><span data-stu-id="517a3-159">To improve performance, per-pixel calculations are performed once for each covered pixel, by sharing shader outputs across covered sub-pixels.</span></span> <span data-ttu-id="517a3-160">Multisample-Antialiasing reduziert das Oberflächen Aliasing nicht.</span><span class="sxs-lookup"><span data-stu-id="517a3-160">Multisample antialiasing does not reduce surface aliasing.</span></span> <span data-ttu-id="517a3-161">Beispiel Speicherorte und-Funktionen sind von der Hardware Implementierung abhängig.</span><span class="sxs-lookup"><span data-stu-id="517a3-161">Sample locations and reconstruction functions are dependent on the hardware implementation.</span></span>

<span data-ttu-id="517a3-162">In der folgenden Abbildung sind einige Beispiele dargestellt.</span><span class="sxs-lookup"><span data-stu-id="517a3-162">The following illustration shows some examples.</span></span>

![Abbildung von Beispielen für die AntiAlias-rasterisierung mit mehreren Stichproben](images/d3d10-rasterrulesmsaa.png)

<span data-ttu-id="517a3-164">Die Anzahl der Beispiel Speicherorte hängt vom Multisampling-Modus ab.</span><span class="sxs-lookup"><span data-stu-id="517a3-164">The number of sample locations is dependent on the multisample mode.</span></span> <span data-ttu-id="517a3-165">Vertex-Attribute werden in Pixel Centern interpoliert, da hier der Pixelshader aufgerufen wird (Dies wird zur extrapolierungen, wenn der Mittelpunkt nicht abgedeckt ist).</span><span class="sxs-lookup"><span data-stu-id="517a3-165">Vertex attributes are interpolated at pixel centers, since this is where the pixel shader is invoked (this becomes extrapolation if the center is not covered).</span></span> <span data-ttu-id="517a3-166">Attribute können im Pixelshader gekennzeichnet werden, um einen Schwerpunkt zu erreichen. Dies bewirkt, dass nicht abgedeckte Pixel das Attribut bei Schnittstellen des Pixel Bereichs und des primitiven interpolieren.</span><span class="sxs-lookup"><span data-stu-id="517a3-166">Attributes can be flagged in the pixel shader to be centroid sampled, which causes non-covered pixels to interpolate the attribute at intersection of the pixel's area and the primitive.</span></span> <span data-ttu-id="517a3-167">Ein Pixelshader wird für jeden 2 x 2-Pixel Bereich ausgeführt, um abgeleitete Berechnungen (die x-und y-Delta verwenden) zu unterstützen.</span><span class="sxs-lookup"><span data-stu-id="517a3-167">A pixel shader runs for each 2x2 pixel area to support derivative calculations (which use x and y deltas).</span></span> <span data-ttu-id="517a3-168">Dies bedeutet, dass Shader-Aufrufe mehr vorkommen, als angezeigt wird, um den minimalen 2 x 2-Quanten-Wert (der unabhängig von Multisampling ist) auszufüllen.</span><span class="sxs-lookup"><span data-stu-id="517a3-168">This means that shader invocations occur more than is shown to fill out the minimum 2x2 quanta (which is independent of multisampling).</span></span> <span data-ttu-id="517a3-169">Das Shader-Ergebnis wird für jedes abgedeckte Beispiel geschrieben, das den Test der tiefen Schablone pro Stichprobe übergibt.</span><span class="sxs-lookup"><span data-stu-id="517a3-169">The shader result is written out for each covered sample that passes the per-sample depth-stencil test.</span></span>

<span data-ttu-id="517a3-170">Rasterisierungsregeln für primitive sind im Allgemeinen durch Multisampling-Antialiasing unverändert, ausgenommen:</span><span class="sxs-lookup"><span data-stu-id="517a3-170">Rasterization rules for primitives are, in general, unchanged by multisample antialiasing, except:</span></span>

-   <span data-ttu-id="517a3-171">Bei einem Dreieck wird für jeden Beispiel Speicherort ein Abdeckungs Test ausgeführt (nicht für ein Pixel Center).</span><span class="sxs-lookup"><span data-stu-id="517a3-171">For a triangle, a coverage test is performed for each sample location (not for a pixel center).</span></span> <span data-ttu-id="517a3-172">Wenn mehr als ein Beispiel Speicherort abgedeckt ist, wird ein Pixelshader einmal mit Attributen ausgeführt, die im Pixel Center interpoliert werden.</span><span class="sxs-lookup"><span data-stu-id="517a3-172">If more than one sample location is covered, a pixel shader runs once with attributes interpolated at the pixel center.</span></span> <span data-ttu-id="517a3-173">Das Ergebnis wird für jeden abgedeckten Beispiel Speicherort im Pixel gespeichert (repliziert), das den tiefen-/Stencil-Test übergibt.</span><span class="sxs-lookup"><span data-stu-id="517a3-173">The result is stored (replicated) for each covered sample location in the pixel that passes the depth/stencil test.</span></span>

    <span data-ttu-id="517a3-174">Eine Linie wird als Rechteck behandelt, das aus zwei Dreiecken besteht und einer Linienbreite von 1,4 entspricht.</span><span class="sxs-lookup"><span data-stu-id="517a3-174">A line is treated as a rectangle made up of two triangles, with a line width of 1.4.</span></span>

-   <span data-ttu-id="517a3-175">Für einen Punkt wird ein Abdeckungs Test für jeden Beispiel Speicherort ausgeführt (nicht für ein Pixel Center).</span><span class="sxs-lookup"><span data-stu-id="517a3-175">For a point, a coverage test is performed for each sample location (not for a pixel center).</span></span>

<span data-ttu-id="517a3-176">Viele Formate unterstützen multisamplinggrad (siehe [Hardware Unterstützung für Direct3D 10-Formate](/previous-versions//cc627090(v=vs.85))), einige Formate können aufgelöst werden ([**resolvesubresource**](/windows/desktop/api/d3d10/nf-d3d10-id3d10device-resolvesubresource)), die ein Downsampling für ein multisamplinggrad-Format auf eine Stichprobengröße von 1 durchgeführt haben.</span><span class="sxs-lookup"><span data-stu-id="517a3-176">Many formats support multisampling (see [Hardware Support for Direct3D 10 Formats](/previous-versions//cc627090(v=vs.85))), some formats can be resolved ([**ResolveSubresource**](/windows/desktop/api/d3d10/nf-d3d10-id3d10device-resolvesubresource); which downsamples a multisampled format to a sample size of 1).</span></span> <span data-ttu-id="517a3-177">Multisampling-Formate können in Renderingzielen verwendet werden, die mithilfe von " [Load](/windows/desktop/direct3dhlsl/dx-graphics-hlsl-to-load)" in Shader eingelesen werden können, da für einzelne Beispiele, auf die der Shader zugreift, keine Auflösung erforderlich ist.</span><span class="sxs-lookup"><span data-stu-id="517a3-177">Multisampling formats can be used in render targets which can be read back into shaders using [load](/windows/desktop/direct3dhlsl/dx-graphics-hlsl-to-load), since no resolve is required for individual samples accessed by the shader.</span></span> <span data-ttu-id="517a3-178">Tiefen Formate werden für Multisampling-Ressourcen nicht unterstützt. Daher sind die tiefen Formate nur auf Renderziele beschränkt.</span><span class="sxs-lookup"><span data-stu-id="517a3-178">Depth formats are not supported for multisample resource, therefore, depth formats are restricted to render targets only.</span></span>

<span data-ttu-id="517a3-179">Typlose Formate ( \_ z. R8G8B8A8. typlose) unterstützen multisamplinggrad, damit eine Ressourcen Ansicht Daten auf unterschiedliche Weise interpretieren kann.</span><span class="sxs-lookup"><span data-stu-id="517a3-179">Typeless formats (R8G8B8A8\_TYPELESS for instance) support multisampling to allow a resource view to interpret data in different ways.</span></span> <span data-ttu-id="517a3-180">Beispielsweise können Sie eine Multisampling-Ressource mit R8G8B8A8 \_ typless erstellen, Sie mit einer "Rendering-Target-View"-Ressource mit einem R8G8B8A8 \_ uint-Format reneln und dann den Inhalt in eine andere Ressource mit einem R8G8B8A8 \_ unorm-Datenformat auflösen.</span><span class="sxs-lookup"><span data-stu-id="517a3-180">For instance, you could create a multisample resource using R8G8B8A8\_TYPELESS, render to it using a render-target-view resource with a R8G8B8A8\_UINT format, then resolve the contents to another resource with a R8G8B8A8\_UNORM data format.</span></span>

### <a name="hardware-support"></a><span data-ttu-id="517a3-181">Hardwareunterstützung</span><span class="sxs-lookup"><span data-stu-id="517a3-181">Hardware Support</span></span>

<span data-ttu-id="517a3-182">Die API meldet die Hardwareunterstützung für multisamplinggrad über die Anzahl der Qualitätsstufen.</span><span class="sxs-lookup"><span data-stu-id="517a3-182">The API reports hardware support for multisampling through the number of quality levels.</span></span> <span data-ttu-id="517a3-183">Beispielsweise bedeutet der Wert 0 (null), dass die Hardware keine multisamplinggrad-Unterstützung (in einem bestimmten Format und einer Qualitätsstufe) unterstützt.</span><span class="sxs-lookup"><span data-stu-id="517a3-183">For example, a 0 quality level means the hardware does not support multisampling (at a particular format and quality level).</span></span> <span data-ttu-id="517a3-184">Ein 3 für Qualitätsstufen bedeutet, dass die Hardware drei verschiedene Beispiel Layouts und/oder Auflösungs Algorithmen unterstützt.</span><span class="sxs-lookup"><span data-stu-id="517a3-184">A 3 for quality levels means that the hardware supports three different sample layouts and/or resolve algorithms.</span></span> <span data-ttu-id="517a3-185">Sie können auch Folgendes annehmen:</span><span class="sxs-lookup"><span data-stu-id="517a3-185">You can also assume the following:</span></span>

-   <span data-ttu-id="517a3-186">Jedes Format, das Multisampling unterstützt, unterstützt die gleiche Anzahl von Qualitäts Ebenen für jedes Format in dieser Familie.</span><span class="sxs-lookup"><span data-stu-id="517a3-186">Any format that supports multisampling, supports the same number of quality levels for every format in that family.</span></span>
-   <span data-ttu-id="517a3-187">Jedes Format, das Multisampling unterstützt und die \_ unorm-, \_ sRGB-, \_ snorm-oder \_ float-Formate unterstützt, unterstützt auch das Auflösen von.</span><span class="sxs-lookup"><span data-stu-id="517a3-187">Every format that supports multisampling, and has the \_UNORM, \_SRGB, \_SNORM or \_FLOAT formats, also supports resolving.</span></span>

### <a name="centroid-sampling-of-attributes-when-multisample-antialiasing"></a><span data-ttu-id="517a3-188">Centroid-Stichprobenentnahme von Attributen bei Multisample-Antialiasing</span><span class="sxs-lookup"><span data-stu-id="517a3-188">Centroid Sampling of Attributes when Multisample Antialiasing</span></span>

<span data-ttu-id="517a3-189">Standardmäßig werden Vertex-Attribute bei Multisampling-Antialiasing in ein Pixel Center interpoliert. Wenn das Pixel Center nicht abgedeckt wird, werden Attribute zu einem Pixel Center extrapoliert.</span><span class="sxs-lookup"><span data-stu-id="517a3-189">By default, vertex attributes are interpolated to a pixel center during multisample antialiasing; if the pixel center is not covered, attributes are extrapolated to a pixel center.</span></span> <span data-ttu-id="517a3-190">Wenn eine Pixel-Shadereingabe, die die Schwerpunkt-Semantik enthält (vorausgesetzt, das Pixel ist nicht vollständig abgedeckt ist), wird eine beliebige Stelle im abgedeckten Bereich des Pixels entnommen, möglicherweise an einem der abgedeckten Beispiel Speicherorte.</span><span class="sxs-lookup"><span data-stu-id="517a3-190">If a pixel shader input that contains the centroid semantic (assuming the pixel is not fully covered) will be sampled somewhere within the covered area of the pixel, possibly at one of the covered sample locations.</span></span> <span data-ttu-id="517a3-191">Eine Beispiel Maske (angegeben durch den Raster-Zustand) wird vor der Schwerpunkt-Berechnung angewendet.</span><span class="sxs-lookup"><span data-stu-id="517a3-191">A sample mask (specified by the rasterizer state) is applied prior to centroid computation.</span></span> <span data-ttu-id="517a3-192">Daher wird ein Beispiel, das maskiert wird, nicht als Schwerpunkt Speicherort verwendet.</span><span class="sxs-lookup"><span data-stu-id="517a3-192">Therefore, a sample that is masked out will not be used as a centroid location.</span></span>

<span data-ttu-id="517a3-193">Der Verweis-Raster wählt einen Beispiel Speicherort für die Schwerpunkt-Stichprobenentnahme ähnlich dem folgenden aus:</span><span class="sxs-lookup"><span data-stu-id="517a3-193">The reference rasterizer chooses a sample location for centroid sampling similar to this:</span></span>

-   <span data-ttu-id="517a3-194">Die Beispiel Maske lässt alle Beispiele zu.</span><span class="sxs-lookup"><span data-stu-id="517a3-194">The sample mask allows all samples.</span></span> <span data-ttu-id="517a3-195">Verwenden Sie ein Pixel Center, wenn das Pixel abgedeckt ist, oder wenn keines der Beispiele abgedeckt wird.</span><span class="sxs-lookup"><span data-stu-id="517a3-195">Use a pixel center if the pixel is covered or if none of the samples are covered.</span></span> <span data-ttu-id="517a3-196">Andernfalls wird das erste abgedeckte Beispiel ausgewählt, beginnend mit dem Pixel Center und nach außen.</span><span class="sxs-lookup"><span data-stu-id="517a3-196">Otherwise, the first covered sample is chosen, starting from the pixel center and moving outward.</span></span>
-   <span data-ttu-id="517a3-197">Die Beispiel Maske deaktiviert alle Beispiele, aber einen (ein gängiges Szenario).</span><span class="sxs-lookup"><span data-stu-id="517a3-197">The sample mask turns off all samples but one (a common scenario).</span></span> <span data-ttu-id="517a3-198">Eine Anwendung kann Multipass-Supersampling implementieren, indem Sie Einzelbit-Stichproben Masken Werte durchlaufen und die Szene für jede Stichprobe mithilfe der Schwerpunkt-Stichproben Erstellung erneut rendern.</span><span class="sxs-lookup"><span data-stu-id="517a3-198">An application can implement multipass supersampling by cycling through single-bit sample-mask values and re-rendering the scene for each sample using centroid sampling.</span></span> <span data-ttu-id="517a3-199">Dies erfordert, dass eine Anwendung Ableitungen anpasst, um für die höhere Textur Stichproben Dichte entsprechend ausführlichere Textur MIPS auszuwählen.</span><span class="sxs-lookup"><span data-stu-id="517a3-199">This would require that an application adjust derivatives to select appropriately more detailed texture mips for the higher texture sampling density.</span></span>

### <a name="derivative-calculations-when-multisampling"></a><span data-ttu-id="517a3-200">Abgeleitete Berechnungen bei Multisampling</span><span class="sxs-lookup"><span data-stu-id="517a3-200">Derivative Calculations When Multisampling</span></span>

<span data-ttu-id="517a3-201">Pixel-Shader werden immer mit einem minimalen 2 x 2-Pixel Bereich ausgeführt, um abgeleitete Berechnungen zu unterstützen. Diese werden berechnet, indem Delta Einheiten zwischen den Daten aus angrenzenden Pixeln verwendet werden (vorausgesetzt, dass die Daten in jedem Pixel horizontal oder vertikal mit dem Einheiten Abstand abgetastet wurden).</span><span class="sxs-lookup"><span data-stu-id="517a3-201">Pixel shaders always run using a minimum 2x2 pixel area to support derivative calculations, which are calculated by taking deltas between data from adjacent pixels (making the assumption that the data in each pixel has been sampled with unit spacing horizontally or vertically).</span></span> <span data-ttu-id="517a3-202">Dies ist von Multisampling nicht betroffen.</span><span class="sxs-lookup"><span data-stu-id="517a3-202">This is unaffected by multisampling.</span></span>

<span data-ttu-id="517a3-203">Wenn für ein Attribut, für das ein Schwerpunkt erstellt wurde, Ableitungen angefordert werden, wird die Hardware Berechnung nicht angepasst, was zu ungenauen Ableitungen führen kann.</span><span class="sxs-lookup"><span data-stu-id="517a3-203">If derivatives are requested on an attribute that has been centroid sampled, the hardware calculation is not adjusted, which can cause inaccurate derivatives.</span></span> <span data-ttu-id="517a3-204">Ein Shader erwartet einen Einheiten Vektor im renderzielbereich, kann jedoch einen nicht-Einheits Vektor in Bezug auf einen anderen Vektorraum erhalten.</span><span class="sxs-lookup"><span data-stu-id="517a3-204">A shader will expect a unit vector in render-target space but may get a non-unit vector with respect to some other vector space.</span></span> <span data-ttu-id="517a3-205">Daher ist es für eine Anwendung wichtig, bei der Anforderung von Ableitungen von Attributen, bei denen es sich um eine Stichprobe handelt, eine Vorsicht zu</span><span class="sxs-lookup"><span data-stu-id="517a3-205">Therefore, it is an application's responsibility to exhibit caution when requesting derivatives from attributes that are centroid sampled.</span></span> <span data-ttu-id="517a3-206">Es wird empfohlen, dass Sie keine Ableitungen und Schwerpunkt-Stichproben kombinieren.</span><span class="sxs-lookup"><span data-stu-id="517a3-206">In fact, it is recommended that you do not combine derivatives and centroid sampling.</span></span> <span data-ttu-id="517a3-207">Die Centroid-Stichprobenentnahme kann in Situationen nützlich sein, in denen es wichtig ist, dass die interpolierten Attribute eines primitiven nicht extrapoliert werden. Dies ist jedoch mit vor-und Nachteile, wie z. b. Attributen zu tun, bei denen ein primitiver Rand ein Pixel überschreitet (anstatt sich ständig zu ändern) oder Ableitungen, die nicht von Textur-Samplings verwendet werden</span><span class="sxs-lookup"><span data-stu-id="517a3-207">Centroid sampling can be useful for situations where it is critical that a primitive's interpolated attributes are not extrapolated, but this comes with tradeoffs such as attributes that appear to jump where a primitive edge crosses a pixel (rather than change continuously) or derivatives that cannot be used by texture sampling operations that derive LOD.</span></span>

## <a name="related-topics"></a><span data-ttu-id="517a3-208">Zugehörige Themen</span><span class="sxs-lookup"><span data-stu-id="517a3-208">Related topics</span></span>

<dl> <dt>

[<span data-ttu-id="517a3-209">Stufe des Rasterizers</span><span class="sxs-lookup"><span data-stu-id="517a3-209">Rasterizer Stage</span></span>](d3d10-graphics-programming-guide-rasterizer-stage.md)
</dt> </dl>

 

 