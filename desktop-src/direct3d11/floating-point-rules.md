---
title: Gleit Komma Regeln (Direct3D 11)
description: Direct3D 11 unterstützt mehrere Gleit Komma Darstellungen. Alle Gleit Komma Berechnungen arbeiten unter einer definierten Teilmenge der IEEE 754 32-Bit-Gleit Komma Regeln mit einfacher Genauigkeit.
ms.assetid: 33F21BD0-FDF8-4D35-95C0-0A3920814CB6
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: d83c87db0daa69c0393d0399ece5bdb6cf01d519
ms.sourcegitcommit: 592c9bbd22ba69802dc353bcb5eb30699f9e9403
ms.translationtype: MT
ms.contentlocale: de-DE
ms.lasthandoff: 08/20/2020
ms.locfileid: "104390430"
---
# <a name="floating-point-rules-direct3d-11"></a><span data-ttu-id="146b9-104">Gleit Komma Regeln (Direct3D 11)</span><span class="sxs-lookup"><span data-stu-id="146b9-104">Floating-point rules (Direct3D 11)</span></span>

<span data-ttu-id="146b9-105">Direct3D 11 unterstützt mehrere Gleit Komma Darstellungen.</span><span class="sxs-lookup"><span data-stu-id="146b9-105">Direct3D 11 supports several floating-point representations.</span></span> <span data-ttu-id="146b9-106">Alle Gleit Komma Berechnungen arbeiten unter einer definierten Teilmenge der IEEE 754 32-Bit-Gleit Komma Regeln mit einfacher Genauigkeit.</span><span class="sxs-lookup"><span data-stu-id="146b9-106">All floating-point computations operate under a defined subset of the IEEE 754 32-bit single precision floating-point rules.</span></span>

-   [<span data-ttu-id="146b9-107">32-Bit-Gleit Komma Regeln</span><span class="sxs-lookup"><span data-stu-id="146b9-107">32-bit floating-point rules</span></span>](#32-bit-floating-point-rules)
    -   [<span data-ttu-id="146b9-108">IEEE-754-Regeln wurden berücksichtigt.</span><span class="sxs-lookup"><span data-stu-id="146b9-108">Honored IEEE-754 rules</span></span>](#honored-ieee-754-rules)
    -   [<span data-ttu-id="146b9-109">Abweichungen oder zusätzliche Anforderungen von IEEE-754-Regeln</span><span class="sxs-lookup"><span data-stu-id="146b9-109">Deviations or additional requirements from IEEE-754 rules</span></span>](#deviations-or-additional-requirements-from-ieee-754-rules)
-   [<span data-ttu-id="146b9-110">64-Bit-Gleit Komma Regeln (doppelte Genauigkeit)</span><span class="sxs-lookup"><span data-stu-id="146b9-110">64-bit (double precision) floating point rules</span></span>](#64-bit-double-precision-floating-point-rules)
-   [<span data-ttu-id="146b9-111">16-Bit-Gleit Komma Regeln</span><span class="sxs-lookup"><span data-stu-id="146b9-111">16-bit floating-point rules</span></span>](#16-bit-floating-point-rules)
-   [<span data-ttu-id="146b9-112">11-Bit-und 10-Bit-Gleit Komma Regeln</span><span class="sxs-lookup"><span data-stu-id="146b9-112">11-bit and 10-bit floating-point rules</span></span>](#11-bit-and-10-bit-floating-point-rules)
-   [<span data-ttu-id="146b9-113">Zugehörige Themen</span><span class="sxs-lookup"><span data-stu-id="146b9-113">Related topics</span></span>](#related-topics)

## <a name="32-bit-floating-point-rules"></a><span data-ttu-id="146b9-114">32-Bit-Gleit Komma Regeln</span><span class="sxs-lookup"><span data-stu-id="146b9-114">32-bit floating-point rules</span></span>

<span data-ttu-id="146b9-115">Es gibt zwei Sätze von Regeln: die, die IEEE-754 entsprechen, und die Regeln, die vom Standard abweichen.</span><span class="sxs-lookup"><span data-stu-id="146b9-115">There are two sets of rules: those that conform to IEEE-754, and those that deviate from the standard.</span></span>

### <a name="honored-ieee-754-rules"></a><span data-ttu-id="146b9-116">IEEE-754-Regeln wurden berücksichtigt.</span><span class="sxs-lookup"><span data-stu-id="146b9-116">Honored IEEE-754 rules</span></span>

<span data-ttu-id="146b9-117">Einige dieser Regeln stellen eine einzelne Option dar, bei der IEEE-754 Optionen bietet.</span><span class="sxs-lookup"><span data-stu-id="146b9-117">Some of these rules are a single option where IEEE-754 offers choices.</span></span>

-   <span data-ttu-id="146b9-118">Division durch 0 erzeugt +/-inf, mit Ausnahme von 0/0, was zu Nan führt.</span><span class="sxs-lookup"><span data-stu-id="146b9-118">Divide by 0 produces +/- INF, except 0/0 which results in NaN.</span></span>
-   <span data-ttu-id="146b9-119">das Protokoll von (+/-) 0 erzeugt-inf.</span><span class="sxs-lookup"><span data-stu-id="146b9-119">log of (+/-) 0 produces -INF.</span></span> <span data-ttu-id="146b9-120">das Protokoll eines negativen Werts (mit Ausnahme von-0) erzeugt Nan.</span><span class="sxs-lookup"><span data-stu-id="146b9-120">log of a negative value (other than -0) produces NaN.</span></span>
-   <span data-ttu-id="146b9-121">Die gegenseitige Quadratwurzel (RSQ) oder die Quadratwurzel (sqrt) einer negativen Zahl erzeugt Nan.</span><span class="sxs-lookup"><span data-stu-id="146b9-121">Reciprocal square root (rsq) or square root (sqrt) of a negative number produces NaN.</span></span> <span data-ttu-id="146b9-122">Die Ausnahme ist-0; SQRT (-0) erzeugt-0, und RSQ (-0) erzeugt-inf.</span><span class="sxs-lookup"><span data-stu-id="146b9-122">The exception is -0; sqrt(-0) produces -0, and rsq(-0) produces -INF.</span></span>
-   <span data-ttu-id="146b9-123">INF-INF = Nan</span><span class="sxs-lookup"><span data-stu-id="146b9-123">INF - INF = NaN</span></span>
-   <span data-ttu-id="146b9-124">(+/-) Inf/(+/-) INF = Nan</span><span class="sxs-lookup"><span data-stu-id="146b9-124">(+/-)INF / (+/-)INF = NaN</span></span>
-   <span data-ttu-id="146b9-125">(+/-) INF \* 0 = Nan</span><span class="sxs-lookup"><span data-stu-id="146b9-125">(+/-)INF \* 0 = NaN</span></span>
-   <span data-ttu-id="146b9-126">Nan (beliebiger OP) beliebiger Wert = NaN</span><span class="sxs-lookup"><span data-stu-id="146b9-126">NaN (any OP) any-value = NaN</span></span>
-   <span data-ttu-id="146b9-127">Die Vergleiche EQ, gt, ge, lt und Le, wenn einer oder beide Operanden NaN ist, wird **false** zurückgegeben.</span><span class="sxs-lookup"><span data-stu-id="146b9-127">The comparisons EQ, GT, GE, LT, and LE, when either or both operands is NaN returns **FALSE**.</span></span>
-   <span data-ttu-id="146b9-128">Vergleiche ignorieren das Vorzeichen von 0 (also + 0 ist 0).</span><span class="sxs-lookup"><span data-stu-id="146b9-128">Comparisons ignore the sign of 0 (so +0 equals -0).</span></span>
-   <span data-ttu-id="146b9-129">Der Vergleichs-ne, wenn einer oder beide Operanden NaN ist, wird **true** zurückgegeben.</span><span class="sxs-lookup"><span data-stu-id="146b9-129">The comparison NE, when either or both operands is NaN returns **TRUE**.</span></span>
-   <span data-ttu-id="146b9-130">Vergleiche eines beliebigen nicht-NaN-Werts mit +/-INF geben das korrekte Ergebnis zurück.</span><span class="sxs-lookup"><span data-stu-id="146b9-130">Comparisons of any non-NaN value against +/- INF return the correct result.</span></span>

### <a name="deviations-or-additional-requirements-from-ieee-754-rules"></a><span data-ttu-id="146b9-131">Abweichungen oder zusätzliche Anforderungen von IEEE-754-Regeln</span><span class="sxs-lookup"><span data-stu-id="146b9-131">Deviations or additional requirements from IEEE-754 rules</span></span>

-   <span data-ttu-id="146b9-132">IEEE-754 erfordert Gleit Komma Vorgänge, um ein Ergebnis zu erhalten, das den nächstgelegenen darstellbaren Wert zu einem unendlich präzisen Ergebnis ist, das auch als "Round-to-Next-even" bezeichnet wird.</span><span class="sxs-lookup"><span data-stu-id="146b9-132">IEEE-754 requires floating-point operations to produce a result that is the nearest representable value to an infinitely-precise result, known as round-to-nearest-even.</span></span> <span data-ttu-id="146b9-133">Direct3D 11 definiert dieselbe Anforderung: 32-Bit-Gleit Komma Operationen führen zu einem Ergebnis, das sich innerhalb von 0,5 Unit-Last-Place (ULP) des unendlich präzisen Ergebnisses befindet.</span><span class="sxs-lookup"><span data-stu-id="146b9-133">Direct3D 11 defines the same requirement: 32-bit floating-point operations produce a result that is within 0.5 unit-last-place (ULP) of the infinitely-precise result.</span></span> <span data-ttu-id="146b9-134">Dies bedeutet, dass Hardware z. b. die Ergebnisse in 32-Bit Abschneiden darf, anstatt Sie auf die nächstgelegene Weise zu durchführen, da dies zu einem Fehler von höchstens 0,5 ULP führen würde. Diese Regel gilt nur für Addition, Subtraktion und Multiplikation.</span><span class="sxs-lookup"><span data-stu-id="146b9-134">This means that, for example, hardware is allowed to truncate results to 32-bit rather than perform round-to-nearest-even, as that would result in error of at most 0.5 ULP.This rule applies only to addition, subtraction, and multiplication.</span></span>
-   <span data-ttu-id="146b9-135">Es gibt keine Unterstützung für Gleit Komma Ausnahmen, Status Bits oder Traps.</span><span class="sxs-lookup"><span data-stu-id="146b9-135">There is no support for floating-point exceptions, status bits or traps.</span></span>
-   <span data-ttu-id="146b9-136">Denorms werden bei einem Eingabe-und Ausgabewert einer mathematischen Gleit Komma Operation in die Signierung NULL geleert.</span><span class="sxs-lookup"><span data-stu-id="146b9-136">Denorms are flushed to sign-preserved zero on input and output of any floating-point mathematical operation.</span></span> <span data-ttu-id="146b9-137">Ausnahmen werden für alle e/a-oder Daten Verschiebungs Vorgänge ausgelöst, die die Daten nicht verändern.</span><span class="sxs-lookup"><span data-stu-id="146b9-137">Exceptions are made for any I/O or data movement operation that doesn't manipulate the data.</span></span>
-   <span data-ttu-id="146b9-138">Zustände, die Gleit Komma Werte enthalten, wie z. b. Viewport mintiefe/maxtiefe, BorderColor-Werte, können als denorm-Werte angegeben werden und werden möglicherweise nicht geleert, bevor Sie von der Hardware verwendet werden.</span><span class="sxs-lookup"><span data-stu-id="146b9-138">States that contain floating-point values, such as Viewport MinDepth/MaxDepth, BorderColor values, may be provided as denorm values and may or may not be flushed before the hardware uses them.</span></span>
-   <span data-ttu-id="146b9-139">Bei minimalen oder maximalen Vorgängen werden denorms zum Vergleichen geleert, das Ergebnis kann jedoch nicht mit denorm geleert werden.</span><span class="sxs-lookup"><span data-stu-id="146b9-139">Min or max operations flush denorms for comparison, but the result may or may not be denorm flushed.</span></span>
-   <span data-ttu-id="146b9-140">Die Nan-Eingabe für einen Vorgang erzeugt immer Nan in der Ausgabe.</span><span class="sxs-lookup"><span data-stu-id="146b9-140">NaN input to an operation always produces NaN on output.</span></span> <span data-ttu-id="146b9-141">Es ist jedoch nicht erforderlich, das genaue Bitmuster des Nan unverändert zu bleiben (es sei denn, der Vorgang ist eine unformatierte Move-Anweisung, die keine Daten ändert).</span><span class="sxs-lookup"><span data-stu-id="146b9-141">But the exact bit pattern of the NaN is not required to stay the same (unless the operation is a raw move instruction - which doesn't alter data.)</span></span>
-   <span data-ttu-id="146b9-142">Bei minimalen oder maximalen Vorgängen, bei denen nur ein Operand NaN ist, wird der andere Operand als Ergebnis zurückgegeben (im Gegensatz zu den zuvor übersuchten Vergleichs Regeln).</span><span class="sxs-lookup"><span data-stu-id="146b9-142">Min or max operations for which only one operand is NaN return the other operand as the result (contrary to comparison rules we looked at earlier).</span></span> <span data-ttu-id="146b9-143">Dies ist eine IEEE 754r-Regel.</span><span class="sxs-lookup"><span data-stu-id="146b9-143">This is a IEEE 754R rule.</span></span>

    <span data-ttu-id="146b9-144">Die IEEE-754r-Spezifikation für Gleit Komma-und Max-Vorgänge gibt an, dass das Ergebnis der Operation der andere Parameter ist, wenn eine der Eingaben für "min" oder "Max" ein stiller QNAN-Wert ist.</span><span class="sxs-lookup"><span data-stu-id="146b9-144">The IEEE-754R specification for floating point min and max operations states that if one of the inputs to min or max is a quiet QNaN value, the result of the operation is the other parameter.</span></span> <span data-ttu-id="146b9-145">Beispiel:</span><span class="sxs-lookup"><span data-stu-id="146b9-145">For example:</span></span>

    ```C++
    min(x,QNaN) == min(QNaN,x) == x (same for max)
    ```

    

    <span data-ttu-id="146b9-146">Eine Revision der IEEE-754r-Spezifikation hat ein anderes Verhalten für "min" und "Max" übernommen, wenn eine Eingabe ein "Signalisierender"-Wert im Vergleich zu einem QNAN-Wert ist:</span><span class="sxs-lookup"><span data-stu-id="146b9-146">A revision of the IEEE-754R specification adopted a different behavior for min and max when one input is a "signaling" SNaN value versus a QNaN value:</span></span>

    ```C++
    min(x,SNaN) == min(SNaN,x) == QNaN (same for max)
     
    ```

    

    <span data-ttu-id="146b9-147">Im allgemeinen befolgt Direct3D die Standards für Arithmetik: IEEE-754 und IEEE-754r.</span><span class="sxs-lookup"><span data-stu-id="146b9-147">Generally, Direct3D follows the standards for arithmetic: IEEE-754 and IEEE-754R.</span></span> <span data-ttu-id="146b9-148">In diesem Fall haben wir jedoch eine Abweichung.</span><span class="sxs-lookup"><span data-stu-id="146b9-148">But in this case, we have a deviation.</span></span>

    <span data-ttu-id="146b9-149">Die arithmetischen Regeln in Direct3D 10 und höher machen keine Unterschiede zwischen Stillen und signalisierenden Nan-Werten (QNAN und SNaN).</span><span class="sxs-lookup"><span data-stu-id="146b9-149">The arithmetic rules in Direct3D 10 and later don't make any distinctions between quiet and signaling NaN values (QNaN versus SNaN).</span></span> <span data-ttu-id="146b9-150">Alle NaN-Werte werden auf dieselbe Weise behandelt.</span><span class="sxs-lookup"><span data-stu-id="146b9-150">All NaN values are handled the same way.</span></span> <span data-ttu-id="146b9-151">Im Fall von min und Max entspricht das Direct3D-Verhalten für jeden NaN-Wert der Art und Weise, wie QNAN in der IEEE-754r-Definition behandelt wird.</span><span class="sxs-lookup"><span data-stu-id="146b9-151">In the case of min and max, the Direct3D behavior for any NaN value is like how QNaN is handled in the IEEE-754R definition.</span></span> <span data-ttu-id="146b9-152">(Aus Gründen der Vollständigkeit: Wenn beide Eingaben Nan sind, wird ein beliebiger NaN-Wert zurückgegeben.)</span><span class="sxs-lookup"><span data-stu-id="146b9-152">(For completeness - if both inputs are NaN, any NaN value is returned.)</span></span>

-   <span data-ttu-id="146b9-153">Eine weitere IEEE 754r-Regel ist, dass min (-0, + 0) = = min (+ 0,-0) = =-0 und Max (-0, + 0) = = Max (+ 0,-0) = = + 0, das das Vorzeichen berücksichtigt, im Gegensatz zu den Vergleichs Regeln für den Wert signed Zero (wie zuvor gesehen).</span><span class="sxs-lookup"><span data-stu-id="146b9-153">Another IEEE 754R rule is that min(-0,+0) == min(+0,-0) == -0, and max(-0,+0) == max(+0,-0) == +0, which honors the sign, in contrast to the comparison rules for signed zero (as we saw earlier).</span></span> <span data-ttu-id="146b9-154">Direct3D empfiehlt das IEEE 754r-Verhalten hier, erzwingt es jedoch nicht. Es ist zulässig, dass das Ergebnis des Vergleichs von Nullen von der Reihenfolge der Parameter abhängig ist. dabei wird ein Vergleich verwendet, bei dem die Vorzeichen ignoriert werden.</span><span class="sxs-lookup"><span data-stu-id="146b9-154">Direct3D recommends the IEEE 754R behavior here, but doesn't enforce it; it is permissible for the result of comparing zeros to be dependent on the order of parameters, using a comparison that ignores the signs.</span></span>
-   <span data-ttu-id="146b9-155">x \* 1.0 f ergibt immer x (außer denorm geleert).</span><span class="sxs-lookup"><span data-stu-id="146b9-155">x\*1.0f always results in x (except denorm flushed).</span></span>
-   <span data-ttu-id="146b9-156">x/1.0 f ergibt immer x (außer denorm geleert).</span><span class="sxs-lookup"><span data-stu-id="146b9-156">x/1.0f always results in x (except denorm flushed).</span></span>
-   <span data-ttu-id="146b9-157">x +/-0,0 f ergibt immer x (außer denorm geleert).</span><span class="sxs-lookup"><span data-stu-id="146b9-157">x +/- 0.0f always results in x (except denorm flushed).</span></span> <span data-ttu-id="146b9-158">Aber-0 + 0 = + 0.</span><span class="sxs-lookup"><span data-stu-id="146b9-158">But -0 + 0 = +0.</span></span>
-   <span data-ttu-id="146b9-159">Beim Durchlaufen von Vorgängen (z. b. Mad, DP3) werden Ergebnisse erzeugt, die nicht weniger genau sind als die schlechtesten mögliche serielle Reihenfolge der Auswertung der nicht geschmolzenen Erweiterung des Vorgangs.</span><span class="sxs-lookup"><span data-stu-id="146b9-159">Fused operations (such as mad, dp3) produce results that are no less accurate than the worst possible serial ordering of evaluation of the unfused expansion of the operation.</span></span> <span data-ttu-id="146b9-160">Die Definition der schlechtesten Reihenfolge ist für die Toleranz keine festgelegte Definition für einen angegebenen Fused-Vorgang. Dies hängt von den jeweiligen Werten der Eingaben ab.</span><span class="sxs-lookup"><span data-stu-id="146b9-160">The definition of the worst possible ordering, for the purpose of tolerance, is not a fixed definition for a given fused operation; it depends on the particular values of the inputs.</span></span> <span data-ttu-id="146b9-161">Die einzelnen Schritte in der nicht zugezierten Erweiterung sind jeweils als 1 ULP-Toleranz zulässig (oder für Anweisungen Direct3D Aufrufe mit einer weniger Lax-Toleranz als 1 ULP, je weniger Lax-Toleranz zulässig ist).</span><span class="sxs-lookup"><span data-stu-id="146b9-161">The individual steps in the unfused expansion are each allowed 1 ULP tolerance (or for any instructions Direct3D calls out with a more lax tolerance than 1 ULP, the more lax tolerance is allowed).</span></span>
-   <span data-ttu-id="146b9-162">Bei der durchgeführten Ausführung werden die gleichen Nan-Regeln wie nicht-Fused-Vorgänge befolgt.</span><span class="sxs-lookup"><span data-stu-id="146b9-162">Fused operations adhere to the same NaN rules as non-fused operations.</span></span>
-   <span data-ttu-id="146b9-163">Sqrt und RCP haben eine ULP-Toleranz.</span><span class="sxs-lookup"><span data-stu-id="146b9-163">sqrt and rcp have 1 ULP tolerance.</span></span> <span data-ttu-id="146b9-164">Die wechselseitigen und gegenseitigen Square-root-Anweisungen, [**RCP**](/previous-versions/windows/desktop/legacy/hh447205(v=vs.85)) und [**RSQ**](/windows/desktop/direct3dhlsl/rsq--sm4---asm-), weisen eine eigene separate, gelockerte Genauigkeits Anforderung auf.</span><span class="sxs-lookup"><span data-stu-id="146b9-164">The shader reciprocal and reciprocal square-root instructions, [**rcp**](/previous-versions/windows/desktop/legacy/hh447205(v=vs.85)) and [**rsq**](/windows/desktop/direct3dhlsl/rsq--sm4---asm-), have their own separate relaxed precision requirement.</span></span>
-   <span data-ttu-id="146b9-165">Multiplizieren und Dividieren der einzelnen Vorgänge auf der 32-Bit-Ebene für Gleit Komma Genauigkeit (Genauigkeit zu 0,5 ULP für Multiplikation, 1,0 ULP für die gegenseitige Verwendung).</span><span class="sxs-lookup"><span data-stu-id="146b9-165">Multiply and divide each operate at the 32-bit floating-point precision level (accuracy to 0.5 ULP for multiply, 1.0 ULP for reciprocal).</span></span> <span data-ttu-id="146b9-166">Wenn x/y direkt implementiert wird, müssen die Ergebnisse größer oder gleich der Genauigkeit als eine zweistufige Methode sein.</span><span class="sxs-lookup"><span data-stu-id="146b9-166">If x/y is implemented directly, results must be of greater or equal accuracy than a two-step method.</span></span>

## <a name="64-bit-double-precision-floating-point-rules"></a><span data-ttu-id="146b9-167">64-Bit-Gleit Komma Regeln (doppelte Genauigkeit)</span><span class="sxs-lookup"><span data-stu-id="146b9-167">64-bit (double precision) floating point rules</span></span>

<span data-ttu-id="146b9-168">Hardware-und Anzeigetreiber unterstützen optional Gleit Komma Zahlen mit doppelter Genauigkeit.</span><span class="sxs-lookup"><span data-stu-id="146b9-168">Hardware and display drivers optionally support double-precision floating-point.</span></span> <span data-ttu-id="146b9-169">Um Unterstützung anzugeben, legt der Treiber beim Anrufen von [**ID3D11Device:: checkfeaturesupport**](/windows/desktop/api/D3D11/nf-d3d11-id3d11device-checkfeaturesupport) mit [**D3D11 \_ Feature \_**](/windows/desktop/api/D3D11/ne-d3d11-d3d11_feature)Double den Wert **Double precisionfloatshaderops** von [**D3D11 \_ Feature \_ Data \_ Doubles**](/windows/desktop/api/D3D11/ns-d3d11-d3d11_feature_data_doubles) auf true fest.</span><span class="sxs-lookup"><span data-stu-id="146b9-169">To indicate support, when you call [**ID3D11Device::CheckFeatureSupport**](/windows/desktop/api/D3D11/nf-d3d11-id3d11device-checkfeaturesupport) with [**D3D11\_FEATURE\_DOUBLES**](/windows/desktop/api/D3D11/ne-d3d11-d3d11_feature), the driver sets **DoublePrecisionFloatShaderOps** of [**D3D11\_FEATURE\_DATA\_DOUBLES**](/windows/desktop/api/D3D11/ns-d3d11-d3d11_feature_data_doubles) to TRUE.</span></span> <span data-ttu-id="146b9-170">Der Treiber und die Hardware müssen dann alle Gleit Komma Anweisungen mit doppelter Genauigkeit unterstützen.</span><span class="sxs-lookup"><span data-stu-id="146b9-170">The driver and hardware must then support all double-precision floating-point instructions.</span></span>

<span data-ttu-id="146b9-171">Anweisungen mit doppelter Genauigkeit folgen den Anforderungen an das IEEE 754r-Verhalten.</span><span class="sxs-lookup"><span data-stu-id="146b9-171">Double-precision instructions follow IEEE 754R behavior requirements.</span></span>

<span data-ttu-id="146b9-172">Die Unterstützung für die Generierung von denormalisierten Werten ist für Daten mit doppelter Genauigkeit erforderlich (kein Verhalten beim leeren zu null).</span><span class="sxs-lookup"><span data-stu-id="146b9-172">Support for generation of denormalized values is required for double-precision data (no flush-to-zero behavior).</span></span> <span data-ttu-id="146b9-173">Ebenso werden von den Anweisungen keine denormalisierten Daten als signierte NULL-Werte gelesen, Sie berücksichtigen den denorm-Wert.</span><span class="sxs-lookup"><span data-stu-id="146b9-173">Likewise, instructions don't read denormalized data as a signed zero, they honor the denorm value.</span></span>

## <a name="16-bit-floating-point-rules"></a><span data-ttu-id="146b9-174">16-Bit-Gleit Komma Regeln</span><span class="sxs-lookup"><span data-stu-id="146b9-174">16-bit floating-point rules</span></span>

<span data-ttu-id="146b9-175">Direct3D 11 unterstützt auch 16-Bit-Darstellungen von Gleit Komma Zahlen.</span><span class="sxs-lookup"><span data-stu-id="146b9-175">Direct3D 11 also supports 16-bit representations of floating-point numbers.</span></span>

<span data-ttu-id="146b9-176">Format:</span><span class="sxs-lookup"><span data-stu-id="146b9-176">Format:</span></span>

-   <span data-ttu-id="146b9-177">1 Signier Bit (e) an der MSB-Bitposition</span><span class="sxs-lookup"><span data-stu-id="146b9-177">1 sign bit (s)in the MSB bit position</span></span>
-   <span data-ttu-id="146b9-178">5 Bits von unparteiischen Exponent (e)</span><span class="sxs-lookup"><span data-stu-id="146b9-178">5 bits of biased exponent (e)</span></span>
-   <span data-ttu-id="146b9-179">10 Bits des Bruchteils (f) mit einem zusätzlichen ausgeblendeten Bit</span><span class="sxs-lookup"><span data-stu-id="146b9-179">10 bits of fraction (f), with an additional hidden bit</span></span>

<span data-ttu-id="146b9-180">Ein float16-Wert (v) folgt diesen Regeln:</span><span class="sxs-lookup"><span data-stu-id="146b9-180">A float16 value (v) follows these rules:</span></span>

-   <span data-ttu-id="146b9-181">Wenn e = = 31 und f! = 0 ist, dann ist v unabhängig von s</span><span class="sxs-lookup"><span data-stu-id="146b9-181">if e == 31 and f != 0, then v is NaN regardless of s</span></span>
-   <span data-ttu-id="146b9-182">Wenn e = = 31 und f = = 0, dann v = (-1) s \* unendlich (Vorzeichen unendlich)</span><span class="sxs-lookup"><span data-stu-id="146b9-182">if e == 31 and f == 0, then v = (-1)s\*infinity (signed infinity)</span></span>
-   <span data-ttu-id="146b9-183">Wenn e zwischen 0 und 31 liegt, dann v = (-1) s \* 2 (e-15) \* (1. f)</span><span class="sxs-lookup"><span data-stu-id="146b9-183">if e is between 0 and 31, then v = (-1)s\*2(e-15)\*(1.f)</span></span>
-   <span data-ttu-id="146b9-184">Wenn e = = 0 und f! = 0, dann v = (-1) s \* 2 (e-14) \* (0. f) (Denormalisierte Zahlen)</span><span class="sxs-lookup"><span data-stu-id="146b9-184">if e == 0 and f != 0, then v = (-1)s\*2(e-14)\*(0.f) (denormalized numbers)</span></span>
-   <span data-ttu-id="146b9-185">Wenn e = = 0 und f = = 0, dann v = (-1) s \* 0 (signierte null)</span><span class="sxs-lookup"><span data-stu-id="146b9-185">if e == 0 and f == 0, then v = (-1)s\*0 (signed zero)</span></span>

<span data-ttu-id="146b9-186">32-Bit-Gleit Komma Regeln enthalten auch für 16-Bit-Gleit Komma Zahlen, die für das zuvor beschriebene bitlayout angepasst wurden.</span><span class="sxs-lookup"><span data-stu-id="146b9-186">32-bit floating-point rules also hold for 16-bit floating-point numbers, adjusted for the bit layout described earlier.</span></span> <span data-ttu-id="146b9-187">Ausnahmen bilden die folgenden Fälle:</span><span class="sxs-lookup"><span data-stu-id="146b9-187">Exceptions to this include:</span></span>

-   <span data-ttu-id="146b9-188">Genauigkeit: bei unfused-Vorgängen für 16-Bit-Gleit Komma Zahlen wird ein Ergebnis erzeugt, bei dem es sich um den nächstgelegenen darstellbaren Wert eines unendlich präzisen Ergebnisses handelt (abgerundet auf den nächstgelegenen Wert, auch pro IEEE-754, auf 16-Bit-Werte angewendet).</span><span class="sxs-lookup"><span data-stu-id="146b9-188">Precision: Unfused operations on 16-bit floating-point numbers produce a result that is the nearest representable value to an infinitely-precise result (round to nearest even, per IEEE-754, applied to 16-bit values).</span></span> <span data-ttu-id="146b9-189">32-Bit-Gleit Komma Regeln entsprechen 1 ULP-Toleranz, 16-Bit-Gleit Komma Regeln entsprechen 0,5 ULP für unfused-Vorgänge und 0,6 ULP für Fused-Vorgänge.</span><span class="sxs-lookup"><span data-stu-id="146b9-189">32-bit floating-point rules adhere to 1 ULP tolerance, 16-bit floating-point rules adhere to 0.5 ULP for unfused operations, and 0.6 ULP for fused operations.</span></span>
-   <span data-ttu-id="146b9-190">16-Bit-Gleit Komma Zahlen behalten denorms bei.</span><span class="sxs-lookup"><span data-stu-id="146b9-190">16-bit floating-point numbers preserve denorms.</span></span>

## <a name="11-bit-and-10-bit-floating-point-rules"></a><span data-ttu-id="146b9-191">11-Bit-und 10-Bit-Gleit Komma Regeln</span><span class="sxs-lookup"><span data-stu-id="146b9-191">11-bit and 10-bit floating-point rules</span></span>

<span data-ttu-id="146b9-192">Direct3D 11 unterstützt auch 11-Bit-und 10-Bit-Gleit Komma Formate.</span><span class="sxs-lookup"><span data-stu-id="146b9-192">Direct3D 11 also supports 11-bit and 10-bit floating-point formats.</span></span>

<span data-ttu-id="146b9-193">Format:</span><span class="sxs-lookup"><span data-stu-id="146b9-193">Format:</span></span>

-   <span data-ttu-id="146b9-194">Kein Signier Bit</span><span class="sxs-lookup"><span data-stu-id="146b9-194">No sign bit</span></span>
-   <span data-ttu-id="146b9-195">5 Bits von unparteiischen Exponent (e)</span><span class="sxs-lookup"><span data-stu-id="146b9-195">5 bits of biased exponent (e)</span></span>
-   <span data-ttu-id="146b9-196">6 Bits des Bruchteils (f) für ein 11-Bit-Format, 5 Bits von Bruchteil (f) für ein 10-Bit-Format, mit einem zusätzlichen ausgeblendeten Bit in beiden Fällen.</span><span class="sxs-lookup"><span data-stu-id="146b9-196">6 bits of fraction (f) for an 11-bit format, 5 bits of fraction (f) for a 10-bit format, with an additional hidden bit in either case.</span></span>

<span data-ttu-id="146b9-197">Ein float11/float10-Wert (v) folgt den folgenden Regeln:</span><span class="sxs-lookup"><span data-stu-id="146b9-197">A float11/float10 value (v) follows the following rules:</span></span>

-   <span data-ttu-id="146b9-198">Wenn e = = 31 und f! = 0 ist, dann ist v Nan.</span><span class="sxs-lookup"><span data-stu-id="146b9-198">if e == 31 and f != 0, then v is NaN</span></span>
-   <span data-ttu-id="146b9-199">Wenn e = = 31 und f = = 0, dann v = + unendlich</span><span class="sxs-lookup"><span data-stu-id="146b9-199">if e == 31 and f == 0, then v = +infinity</span></span>
-   <span data-ttu-id="146b9-200">Wenn e zwischen 0 und 31 liegt, dann v = 2 (e-15) \* (1. f)</span><span class="sxs-lookup"><span data-stu-id="146b9-200">if e is between 0 and 31, then v = 2(e-15)\*(1.f)</span></span>
-   <span data-ttu-id="146b9-201">Wenn e = = 0 und f! = 0, dann v = \* 2 (e-14) \* (0. f) (Denormalisierte Zahlen)</span><span class="sxs-lookup"><span data-stu-id="146b9-201">if e == 0 and f != 0, then v = \*2(e-14)\*(0.f) (denormalized numbers)</span></span>
-   <span data-ttu-id="146b9-202">Wenn e = = 0 und f = = 0, dann v = 0 (null)</span><span class="sxs-lookup"><span data-stu-id="146b9-202">if e == 0 and f == 0, then v = 0 (zero)</span></span>

<span data-ttu-id="146b9-203">32-Bit-Gleit Komma Regeln enthalten auch für 11-Bit-und 10-Bit-Gleit Komma Zahlen, die für das zuvor beschriebene bitlayout angepasst wurden.</span><span class="sxs-lookup"><span data-stu-id="146b9-203">32-bit floating-point rules also hold for 11-bit and 10-bit floating-point numbers, adjusted for the bit layout described earlier.</span></span> <span data-ttu-id="146b9-204">Zu den Ausnahmen zählen:</span><span class="sxs-lookup"><span data-stu-id="146b9-204">Exceptions include:</span></span>

-   <span data-ttu-id="146b9-205">Genauigkeit: 32-Bit-Gleit Komma Regeln entsprechen 0,5 ULP.</span><span class="sxs-lookup"><span data-stu-id="146b9-205">Precision: 32-bit floating-point rules adhere to 0.5 ULP.</span></span>
-   <span data-ttu-id="146b9-206">10/11-Bit-Gleit Komma Zahlen behalten denorms bei.</span><span class="sxs-lookup"><span data-stu-id="146b9-206">10/11-bit floating-point numbers preserve denorms.</span></span>
-   <span data-ttu-id="146b9-207">Jeder Vorgang, der zu einer Zahl kleiner als 0 (null) führt, wird an NULL gebunden.</span><span class="sxs-lookup"><span data-stu-id="146b9-207">Any operation that would result in a number less than zero is clamped to zero.</span></span>

## <a name="related-topics"></a><span data-ttu-id="146b9-208">Zugehörige Themen</span><span class="sxs-lookup"><span data-stu-id="146b9-208">Related topics</span></span>

<dl> <dt>

[<span data-ttu-id="146b9-209">Ressourcen</span><span class="sxs-lookup"><span data-stu-id="146b9-209">Resources</span></span>](overviews-direct3d-11-resources.md)
</dt> <dt>

[<span data-ttu-id="146b9-210">Texturen</span><span class="sxs-lookup"><span data-stu-id="146b9-210">Textures</span></span>](overviews-direct3d-11-resources-textures.md)
</dt> </dl>

 

 