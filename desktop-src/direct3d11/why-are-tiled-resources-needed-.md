---
title: Warum werden Kachel Ressourcen benötigt?
description: Gekachelte Ressourcen werden benötigt, sodass weniger GPU-Speicher (Graphics Processing Unit) verschwendet wird, um Bereiche von Oberflächen zu speichern, auf die die Anwendung keinen Zugriff hat, und die Hardware weiß, wie Sie über angrenzende Kacheln filtern kann.
ms.assetid: E2179D65-56D3-481F-A5F3-B9C45A11A179
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: d42ccccf66a73d224d8bab9a9d10c87cc330be43
ms.sourcegitcommit: 592c9bbd22ba69802dc353bcb5eb30699f9e9403
ms.translationtype: MT
ms.contentlocale: de-DE
ms.lasthandoff: 08/20/2020
ms.locfileid: "104976656"
---
# <a name="why-are-tiled-resources-needed"></a><span data-ttu-id="261ae-103">Warum werden Kachel Ressourcen benötigt?</span><span class="sxs-lookup"><span data-stu-id="261ae-103">Why are tiled resources needed?</span></span>

<span data-ttu-id="261ae-104">Gekachelte Ressourcen werden benötigt, sodass weniger GPU-Speicher (Graphics Processing Unit) verschwendet wird, um Bereiche von Oberflächen zu speichern, auf die die Anwendung keinen Zugriff hat, und die Hardware weiß, wie Sie über angrenzende Kacheln filtern kann.</span><span class="sxs-lookup"><span data-stu-id="261ae-104">Tiled resources are needed so less graphics processing unit (GPU) memory is wasted storing regions of surfaces that the application knows will not be accessed, and the hardware can understand how to filter across adjacent tiles.</span></span>

<span data-ttu-id="261ae-105">In einem Grafiksystem (d. h. Betriebssystem, Anzeigetreiber und Grafikhardware) ohne Unterstützung für gekachelte Ressourcen verwaltet das Grafiksystem alle Direct3D-Speicher Belegungen in der untergeordneten Quell Granularität.</span><span class="sxs-lookup"><span data-stu-id="261ae-105">In a graphics system (that is, the operating system, display driver, and graphics hardware) without tiled resource support, the graphics system manages all Direct3D memory allocations at subresource granularity.</span></span> <span data-ttu-id="261ae-106">Bei einem [Puffer](overviews-direct3d-11-resources-buffers.md)ist der gesamte Puffer die untergeordnete Quelle.</span><span class="sxs-lookup"><span data-stu-id="261ae-106">For a [Buffer](overviews-direct3d-11-resources-buffers.md), the entire Buffer is the subresource.</span></span> <span data-ttu-id="261ae-107">Für eine [Textur](overviews-direct3d-11-resources-textures.md) (z. b. [**Texture2D**](/windows/desktop/direct3dhlsl/sm5-object-texture2d)) ist jede MIP-Ebene eine untergeordnete Quelle. bei einem Textur Array (z. b. [**Texture2DArray**](/windows/desktop/direct3dhlsl/sm5-object-texture2darray)) ist jede MIP-Ebene in einem angegebenen Array Slice eine untergeordnete Quelle.</span><span class="sxs-lookup"><span data-stu-id="261ae-107">For a [Texture](overviews-direct3d-11-resources-textures.md) (for example, [**Texture2D**](/windows/desktop/direct3dhlsl/sm5-object-texture2d)), each mip level is a subresource; for a texture array (for example, [**Texture2DArray**](/windows/desktop/direct3dhlsl/sm5-object-texture2darray)), each mip level at a given array slice is a subresource.</span></span> <span data-ttu-id="261ae-108">Das Grafiksystem macht nur die Möglichkeit zur Verwaltung der Zuordnung von Zuordnungen in dieser unter Quell Granularität verfügbar.</span><span class="sxs-lookup"><span data-stu-id="261ae-108">The graphics system only exposes the ability to manage the mapping of allocations at this subresource granularity.</span></span> <span data-ttu-id="261ae-109">Im Zusammenhang mit den gekachelten Ressourcen bezieht sich "Mapping" darauf, dass Daten für die GPU sichtbar sind.</span><span class="sxs-lookup"><span data-stu-id="261ae-109">In the context of tiled resources, "mapping" refers to making data visible to the GPU.</span></span>

<span data-ttu-id="261ae-110">Angenommen, eine Anwendung weiß, dass ein bestimmter Renderingvorgang nur auf einen kleinen Teil der MipMap-Kette des Bilds zugreifen muss (möglicherweise nicht auf den vollständigen Bereich einer bestimmten MipMap).</span><span class="sxs-lookup"><span data-stu-id="261ae-110">Suppose an application knows that a particular rendering operation only needs to access a small portion of an image mipmap chain (perhaps not even the full area of a given mipmap).</span></span> <span data-ttu-id="261ae-111">Im Idealfall könnte die APP das Grafiksystem über diesen Bedarf informieren.</span><span class="sxs-lookup"><span data-stu-id="261ae-111">Ideally, the app could inform the graphics system about this need.</span></span> <span data-ttu-id="261ae-112">Das Grafiksystem würde dann nur dann sicherstellen, dass der benötigte Arbeitsspeicher auf der GPU ohne Paging in zu viel Arbeitsspeicher zugeordnet wird.</span><span class="sxs-lookup"><span data-stu-id="261ae-112">The graphics system would then only bother to ensure that the needed memory is mapped on the GPU without paging in too much memory.</span></span> <span data-ttu-id="261ae-113">In der Realität kann das Grafiksystem nur über den Arbeitsspeicher informiert werden, der auf der GPU bei der unter Ressourcen-Granularität zugeordnet werden muss (z. b. ein Bereich von vollständigen MipMap-Ebenen, auf die zugegriffen werden kann).</span><span class="sxs-lookup"><span data-stu-id="261ae-113">In reality, without tiled resource support, the graphics system can only be informed about the memory that needs to be mapped on the GPU at subresource granularity (for example, a range of full mipmap levels that could be accessed).</span></span> <span data-ttu-id="261ae-114">Es gibt auch keinen Anforderungs Fehler im Grafiksystem. Daher muss möglicherweise viel überschüssiger GPU-Speicher verwendet werden, um vollständige unter Ressourcen vor einem Rendering-Befehl, der auf einen beliebigen Teil des Arbeitsspeichers verweist, zugeordnet zu werden.</span><span class="sxs-lookup"><span data-stu-id="261ae-114">There is no demand faulting in the graphics system either, so potentially a lot of excess GPU memory must be used to make full subresources mapped before a rendering command that references any part of the memory is executed.</span></span> <span data-ttu-id="261ae-115">Dies ist nur ein Problem, das die Verwendung großer Speicher Belegungen in Direct3D ohne Unterstützung von unterstützten Ressourcen erschwert.</span><span class="sxs-lookup"><span data-stu-id="261ae-115">This is just one issue that makes the use of large memory allocations difficult in Direct3D without tiled resource support.</span></span>

<span data-ttu-id="261ae-116">Direct3D 11 unterstützt [**Texture2D**](/windows/desktop/direct3dhlsl/sm5-object-texture2d) -Oberflächen mit bis zu 16384 Pixeln auf einer angegebenen Seite.</span><span class="sxs-lookup"><span data-stu-id="261ae-116">Direct3D 11 supports [**Texture2D**](/windows/desktop/direct3dhlsl/sm5-object-texture2d) surfaces with up to 16384 pixels on a given side.</span></span> <span data-ttu-id="261ae-117">Ein Bild, das 16384 breit und 4 Bytes pro Pixel ist, würde 1 GB Videospeicher beanspruchen (und das Hinzufügen 16384 von Mipmaps würde diesen Betrag verdoppeln).</span><span class="sxs-lookup"><span data-stu-id="261ae-117">An image that is 16384 wide by 16384 tall and 4 bytes per pixel would consume 1GB of video memory (and adding mipmaps would double that amount).</span></span> <span data-ttu-id="261ae-118">In der Praxis müssen in einem einzelnen Renderingvorgang nur selten auf alle 1 GB verwiesen werden.</span><span class="sxs-lookup"><span data-stu-id="261ae-118">In practice, all 1GB would rarely need to be referenced in a single rendering operation.</span></span>

<span data-ttu-id="261ae-119">Einige Spielentwickler modellieren die Gelände Flächen so groß wie 128 KB und 128 KB.</span><span class="sxs-lookup"><span data-stu-id="261ae-119">Some game developers model terrain surfaces as large as 128K by 128K.</span></span> <span data-ttu-id="261ae-120">Die Vorgehensweise zum Arbeiten mit vorhandenen GPUs besteht darin, die Oberfläche in Kacheln zu unterbrechen, die klein genug für die Verarbeitung sind.</span><span class="sxs-lookup"><span data-stu-id="261ae-120">The way they get this to work on existing GPUs is to break the surface into tiles that are small enough for hardware to handle.</span></span> <span data-ttu-id="261ae-121">Die Anwendung muss herausfinden, welche Kacheln benötigt werden, und Sie in einen Zwischenspeicher zwischen den Texturen auf der GPU laden, einem Software-Paging-System.</span><span class="sxs-lookup"><span data-stu-id="261ae-121">The application must figure out which tiles might be needed and load them into a cache of textures on the GPU - a software paging system.</span></span> <span data-ttu-id="261ae-122">Ein wesentlicher Nachteil dieses Ansatzes ist, dass die Hardware nicht weiß, was das Paging betrifft: Wenn ein Teil eines Abbilds auf dem Bildschirm angezeigt werden muss, der Kacheln durchläuft, weiß die Hardware nicht, wie eine fixierte Funktion (d. h. effizient) gefiltert werden kann.</span><span class="sxs-lookup"><span data-stu-id="261ae-122">A significant downside to this approach comes from the hardware not knowing anything about the paging that is going on: When a part of an image needs to be shown on screen that straddles tiles, the hardware does not know how to perform fixed function (that is, efficient) filtering across tiles.</span></span> <span data-ttu-id="261ae-123">Dies bedeutet, dass die Anwendung, die ihre eigene Software-tiult verwaltet, auf die manuelle Textur Filterung im Shader-Code (der sehr teuer wird, wenn ein guter qualitätsfilterter Filter erwünscht ist) und/oder das vergeuden von Speicher Erstellungs vorspielen bei Kacheln, die Daten aus benachbarten Kacheln enthalten, eine gewisse Unterstützung bieten kann.</span><span class="sxs-lookup"><span data-stu-id="261ae-123">This means the application managing its own software tiling must resort to manual texture filtering in shader code (which becomes very expensive if a good quality anisotropic filter is desired) and/or waste memory authoring gutters around tiles that contain data from neighboring tiles so that fixed function hardware filtering can continue to provide some assistance.</span></span>

<span data-ttu-id="261ae-124">Wenn eine gekachelte Darstellung von Oberflächen Zuordnungen eine erste Klasse im Grafiksystem darstellen könnte, könnte die Anwendung der Hardware mitteilen, welche Kacheln verfügbar gemacht werden sollen.</span><span class="sxs-lookup"><span data-stu-id="261ae-124">If a tiled representation of surface allocations could be a first class feature in the graphics system, the application could tell the hardware which tiles to make available.</span></span> <span data-ttu-id="261ae-125">Auf diese Weise verschwendet weniger GPU-Speicher die Speicherung von Oberflächen Bereichen, auf die die Anwendung keinen Zugriff hat, und die Hardware kann verstehen, wie Sie auf angrenzenden Kacheln filtern, um einige der Probleme zu beseitigen, die Entwickler haben, die Software-tichen selbst durchführen.</span><span class="sxs-lookup"><span data-stu-id="261ae-125">In this way, less GPU memory is wasted storing regions of surfaces that the application knows will not be accessed, and the hardware can understand how to filter across adjacent tiles, alleviating some of the pain experienced by developers who perform software tiling on their own.</span></span>

<span data-ttu-id="261ae-126">Um jedoch eine komplette Lösung bereitzustellen, müssen Sie sich mit der Tatsache befassen, dass unabhängig davon, ob die tik innerhalb einer Oberfläche unterstützt wird, die Oberfläche für die Oberfläche derzeit 16384 ist.</span><span class="sxs-lookup"><span data-stu-id="261ae-126">But to provide a complete solution, something must be done to deal with the fact that, independent of whether tiling within a surface is supported, the maximum surface dimension is currently 16384 - nowhere near the 128K+ that applications already want.</span></span> <span data-ttu-id="261ae-127">Es ist ein Ansatz, nur die Hardware zu benötigen, um größere Textur Größen zu unterstützen. es gibt jedoch beträchtliche Kosten und/oder Kompromisse bei dieser Route.</span><span class="sxs-lookup"><span data-stu-id="261ae-127">Just requiring the hardware to support larger texture sizes is one approach, however there are significant costs and/or tradeoffs to going this route.</span></span> <span data-ttu-id="261ae-128">Der Textur Filter Pfad von Direct3D 11 und der Renderingpfad sind bereits in Bezug auf die Genauigkeit bei der Unterstützung von 16K-Texturen mit den anderen Anforderungen erschöpft, wie z. b. das unterstützen von Viewport-Blöcken, die während des Renderings von der Oberfläche entfernt werden, oder das</span><span class="sxs-lookup"><span data-stu-id="261ae-128">Direct3D 11's texture filter path and rendering path are already saturated in terms of precision in supporting 16K textures with the other requirements, such as supporting viewport extents falling off the surface during rendering, or supporting texture wrapping off the surface edge during filtering.</span></span> <span data-ttu-id="261ae-129">Eine Möglichkeit besteht darin, einen Kompromiss so zu definieren, dass die Textur-und Genauigkeits Größe in gewisser Weise erhöht wird, wenn die Textur Größe über 16K steigt.</span><span class="sxs-lookup"><span data-stu-id="261ae-129">A possibility is to define a tradeoff such that as the texture size increases beyond 16K, functionality/precision is given up in some manner.</span></span> <span data-ttu-id="261ae-130">Auch bei dieser Gewährung sind möglicherweise zusätzliche Hardwarekosten in Bezug auf die Adressierungs Fähigkeit im gesamten Hardwaresystem erforderlich, um zu größeren Textur Größen zu wechseln.</span><span class="sxs-lookup"><span data-stu-id="261ae-130">Even with this concession however, additional hardware costs might be required in terms of addressing capability throughout the hardware system to go to larger texture sizes.</span></span>

<span data-ttu-id="261ae-131">Ein Problem, das im Zusammenhang mit Texturen auftritt, liegt darin, dass die Texturkoordinaten mit einer Gleit Komma Zahl mit einfacher Genauigkeit (und die zugehörigen Interpolatoren zur Unterstützung der rasterisierung) nicht mehr präzise sind, um Orte auf der Oberfläche genau anzugeben.</span><span class="sxs-lookup"><span data-stu-id="261ae-131">One issue that comes into play as textures get very large is that single precision floating point texture coordinates (and the associated interpolators to support rasterization) run out of precision to specify locations on the surface accurately.</span></span> <span data-ttu-id="261ae-132">Die Textur Filterung von Jittery würde folgen.</span><span class="sxs-lookup"><span data-stu-id="261ae-132">Jittery texture filtering would ensue.</span></span> <span data-ttu-id="261ae-133">Eine teure Option wäre die Unterstützung von Interpolatoren mit doppelter Genauigkeit, die jedoch aufgrund einer angemessenen Alternative überschrieben werden könnte.</span><span class="sxs-lookup"><span data-stu-id="261ae-133">One expensive option would be to require double precision interpolator support, though that could be overkill given a reasonable alternative.</span></span>

<span data-ttu-id="261ae-134">Ein alternativer Name für Kachel Ressourcen ist "Sparse Texture".</span><span class="sxs-lookup"><span data-stu-id="261ae-134">An alternate name for tiled resources is "sparse texture."</span></span> <span data-ttu-id="261ae-135">"Sparse" vermittelt sowohl die gekachelte Natur der Ressourcen als auch den Hauptgrund dafür, dass Sie nicht alle gleichzeitig zugeordnet werden sollen.</span><span class="sxs-lookup"><span data-stu-id="261ae-135">"Sparse" conveys both the tiled nature of the resources as well as perhaps the primary reason for tiling them - that not all of them are expected to be mapped at once.</span></span> <span data-ttu-id="261ae-136">Tatsächlich könnte eine Anwendung eine Kachel Ressource erstellen, in der keine Daten für alle Regionen und MIPS der Ressource absichtlich erstellt werden.</span><span class="sxs-lookup"><span data-stu-id="261ae-136">In fact, an application could conceivably author a tiled resource in which no data is authored for all regions+mips of the resource, intentionally.</span></span> <span data-ttu-id="261ae-137">Der Inhalt selbst könnte geringer sein, und die Zuordnung des Inhalts im GPU-Speicher zu einem bestimmten Zeitpunkt wäre eine Teilmenge dieser (noch stärker geringer).</span><span class="sxs-lookup"><span data-stu-id="261ae-137">So, the content itself could be sparse, and the mapping of the content in GPU memory at a given time would be a subset of that (even more sparse).</span></span>

<span data-ttu-id="261ae-138">Ein weiteres Szenario, das von gekachelten Ressourcen bedient werden könnte, besteht darin, dass mehrere Ressourcen mit unterschiedlichen Dimensionen/Formaten denselben Arbeitsspeicher gemeinsam verwenden.</span><span class="sxs-lookup"><span data-stu-id="261ae-138">Another scenario that could be served by tiled resources is enabling multiple resources of different dimensions/formats to share the same memory.</span></span> <span data-ttu-id="261ae-139">Manchmal haben Anwendungen exklusive Ressourcen Sätze, die bekanntermaßen nicht gleichzeitig verwendet werden sollen, oder Ressourcen, die nur für eine sehr kurze Verwendung erstellt und dann zerstört wurden, gefolgt von der Erstellung anderer Ressourcen.</span><span class="sxs-lookup"><span data-stu-id="261ae-139">Sometimes applications have exclusive sets of resources that are known not to be used at the same time, or resources that are created only for very brief use and then destroyed, followed by creation of other resources.</span></span> <span data-ttu-id="261ae-140">Eine Form der Generalität, die von "gekachelten Ressourcen" abweichen kann, besteht darin, dass es möglich ist, dem Benutzer zu ermöglichen, mehrere verschiedene Ressourcen im gleichen (überlappenden) Arbeitsspeicher zu verweisen.</span><span class="sxs-lookup"><span data-stu-id="261ae-140">A form of generality that can fall out of "tiled resources" is that it is possible to allow the user to point multiple different resources at the same (overlapping) memory.</span></span> <span data-ttu-id="261ae-141">Anders ausgedrückt: die Erstellung und Zerstörung von "Resources" (die eine Dimension/ein Format definieren usw.) kann von der Verwaltung des Arbeitsspeichers, der den Ressourcen zugrunde liegt, von der Sicht der Anwendung entkoppelt werden.</span><span class="sxs-lookup"><span data-stu-id="261ae-141">In other words, the creation and destruction of "resources" (which define a dimension/format and so on) can be decoupled from the management of the memory underlying the resources from the application's point of view.</span></span>

## <a name="related-topics"></a><span data-ttu-id="261ae-142">Zugehörige Themen</span><span class="sxs-lookup"><span data-stu-id="261ae-142">Related topics</span></span>

<dl> <dt>

[<span data-ttu-id="261ae-143">Gekachelte Ressourcen</span><span class="sxs-lookup"><span data-stu-id="261ae-143">Tiled resources</span></span>](tiled-resources.md)
</dt> </dl>

 

 