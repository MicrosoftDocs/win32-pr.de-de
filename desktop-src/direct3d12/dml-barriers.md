---
title: UAV-Barrieren und Ressourcen Zustands Barrieren in directml
description: Beschreibt die Richtigkeit der Vorteile von Barrieren und wie Sie in directml mit Ihnen arbeiten können.
ms.custom: Windows 10 May 2019 Update
ms.localizationpriority: high
ms.topic: article
ms.date: 04/19/2019
ms.openlocfilehash: 9bfc93d4fb28cff5d7d196287c6573e3e494d1d5
ms.sourcegitcommit: cba7f424a292fd7f3a8518947b9466439b455419
ms.translationtype: MT
ms.contentlocale: de-DE
ms.lasthandoff: 11/23/2019
ms.locfileid: "104548687"
---
# <a name="uav-barriers-and-resource-state-barriers-in-directml"></a><span data-ttu-id="512b5-103">UAV-Barrieren und Ressourcen Zustands Barrieren in directml</span><span class="sxs-lookup"><span data-stu-id="512b5-103">UAV barriers and resource state barriers in DirectML</span></span>

## <a name="unordered-access-view-uav-barrier-requirements"></a><span data-ttu-id="512b5-104">Anforderungen für die ungeordnete Zugriffs Ansicht (UAV)</span><span class="sxs-lookup"><span data-stu-id="512b5-104">Unordered Access View (UAV) barrier requirements</span></span>

### <a name="uav-barriers-in-direct3d-12"></a><span data-ttu-id="512b5-105">UAV-Barrieren in Direct3D 12</span><span class="sxs-lookup"><span data-stu-id="512b5-105">UAV barriers in Direct3D 12</span></span>

<span data-ttu-id="512b5-106">In Direct3D 12 können angrenzende Compute-Shader innerhalb derselben Befehlsliste parallel auf der GPU ausgeführt werden, es sei denn, Sie sind mit einer dazwischen liegenden UAV-Barriere (unsortierter Zugriffs Ansicht) synchronisiert.</span><span class="sxs-lookup"><span data-stu-id="512b5-106">In Direct3D 12, adjacent compute shader dispatches within the same command list are permitted to execute in parallel on the GPU unless they're synchronized with an intervening unordered access view (UAV) barrier.</span></span> <span data-ttu-id="512b5-107">Dies kann die Leistung verbessern, indem GPU-Hardware erhöht wird.</span><span class="sxs-lookup"><span data-stu-id="512b5-107">This can improve performance by increasing utilization of GPU hardware.</span></span> <span data-ttu-id="512b5-108">Ohne eine UAV-Barriere kann die parallele Ausführung von zwei benachbarten Verteilungen jedoch standardmäßig eine Racebedingung verursachen, wenn eine Daten Abhängigkeit zwischen den beiden Verteilungen vorhanden ist. oder wenn beide sendet UAV-Schreibvorgänge in die gleichen Speicherbereiche durchführen.</span><span class="sxs-lookup"><span data-stu-id="512b5-108">However, by default, without the use of a UAV barrier, the parallel execution of two adjacent dispatches can cause a race condition if there exists a data dependency between the two dispatches; or if both dispatches perform UAV writes to the same regions of memory.</span></span>

<span data-ttu-id="512b5-109">Eine UAV-Barriere zwingt, dass alle zuvor gesendeten sendet den exktions Vorgang auf der GPU vollständig ausführen, bevor nachfolgende sendet beginnen können.</span><span class="sxs-lookup"><span data-stu-id="512b5-109">A UAV barrier forces all previously-submitted dispatches to complete exection on the GPU before subsequent dispatches may begin.</span></span> <span data-ttu-id="512b5-110">UAV-Barrieren werden verwendet, um eine Synchronisierung zwischen den Verteilungen in derselben Befehlsliste durchführen, um Daten Rassen zu vermeiden.</span><span class="sxs-lookup"><span data-stu-id="512b5-110">UAV barriers are used to synchronize between dispatches on the same command list to avoid data races.</span></span> <span data-ttu-id="512b5-111">Sie können eine UAV-Barriere mithilfe der [ **ID3D12GraphicsCommandList:: resourcebarrier** -Methode](/windows/desktop/api/d3d12/nf-d3d12-id3d12graphicscommandlist-resourcebarrier)ausstellen.</span><span class="sxs-lookup"><span data-stu-id="512b5-111">You can issue a UAV barrier by using the [**ID3D12GraphicsCommandList::ResourceBarrier** method](/windows/desktop/api/d3d12/nf-d3d12-id3d12graphicscommandlist-resourcebarrier).</span></span>

### <a name="uav-barriers-in-directml"></a><span data-ttu-id="512b5-112">UAV-Barrieren in der directml</span><span class="sxs-lookup"><span data-stu-id="512b5-112">UAV barriers in DirectML</span></span>

<span data-ttu-id="512b5-113">In directml werden Operatoren auf eine Weise verteilt, die der Art und Weise ähnelt, wie Compute-Shader in Direct3D 12 gesendet werden.</span><span class="sxs-lookup"><span data-stu-id="512b5-113">In DirectML, operators are dispatched in a way that's similar to the way compute shaders are dispatched in Direct3D 12.</span></span> <span data-ttu-id="512b5-114">Das heißt, dass angrenzende Verteiler von Operatoren parallel auf der GPU ausgeführt werden dürfen, es sei denn, zwischen Ihnen besteht eine dazwischen liegende UAV-Barriere.</span><span class="sxs-lookup"><span data-stu-id="512b5-114">That is, adjacent dispatches of operators are permitted to execute in parallel on the GPU unless there exists an intervening UAV barrier between them.</span></span> <span data-ttu-id="512b5-115">Ein typisches Machine Learning-Modell enthält Daten Abhängigkeiten zwischen seinen Operatoren. Beispielsweise wird die Ausgabe eines Operators in die Eingabe eines anderen Operators einfließen.</span><span class="sxs-lookup"><span data-stu-id="512b5-115">A typical machine learning model contains data dependencies between its operators; for instance, the output of one operator feeds into the input of another.</span></span> <span data-ttu-id="512b5-116">Daher ist es wichtig, dass Sie für die ordnungsgemäße Synchronisierung von Verteilungen UAV-Barrieren verwenden.</span><span class="sxs-lookup"><span data-stu-id="512b5-116">It's therefore important to use UAV barriers to correctly synchronize dispatches.</span></span>

<span data-ttu-id="512b5-117">Directml garantiert, dass Sie nur die Eingabe-Tensoren liest (und nie in diese schreiben).</span><span class="sxs-lookup"><span data-stu-id="512b5-117">DirectML guarantees that it will only ever read from (and never write to) input tensors.</span></span> <span data-ttu-id="512b5-118">Außerdem wird sichergestellt, dass keine Schreibvorgänge in einen Ausgabe Mandanten außerhalb des Bereichs des Members [**DML_BUFFER_TENSOR_DESC:: totaltensorsizeinbytes**](/windows/desktop/api/directml/ns-directml-dml_buffer_tensor_desc) des Tensors erstellt werden.</span><span class="sxs-lookup"><span data-stu-id="512b5-118">It also guarantees that it will never manufacture writes to an output tensor outside the range of the tensor's [**DML_BUFFER_TENSOR_DESC::TotalTensorSizeInBytes**](/windows/desktop/api/directml/ns-directml-dml_buffer_tensor_desc) member.</span></span> <span data-ttu-id="512b5-119">Dies bedeutet, dass die Daten Abhängigkeiten zwischen Operatoren in der directml durch die Betrachtung der Eingabe-und Ausgabe Bindungen eines Operators übermittelt werden können.</span><span class="sxs-lookup"><span data-stu-id="512b5-119">This means that data dependencies between operators in DirectML can be reasoned about by looking only at an operator's input and output bindings.</span></span>

<span data-ttu-id="512b5-120">Diese Garantien ermöglichen es Ihnen beispielsweise, zwei Operatoren zu verteilen, die denselben Bereich einer Ressource als Eingabe binden, ohne eine dazwischen liegende UAV-Barriere ausgeben zu müssen.</span><span class="sxs-lookup"><span data-stu-id="512b5-120">For example, these guarantees allow you to dispatch two operators that bind the same region of a resource as an input, without having to issue an intervening UAV barrier.</span></span> <span data-ttu-id="512b5-121">Dies ist immer sicher, weil directml nie in Eingabe-Tensoren schreibt.</span><span class="sxs-lookup"><span data-stu-id="512b5-121">This is always safe because DirectML never writes to input tensors.</span></span> <span data-ttu-id="512b5-122">Ein weiteres Beispiel ist die Bindung der Ausgabe Tensoren von zwei gleichzeitigen Operator Verteilungen an dieselbe Direct3D 12-Ressource (solange sich Ihre Mandanten nicht überlappen), da directml niemals außerhalb der Grenzen eines Mandanten schreibt (wie durch den **DML_BUFFER_TENSOR_DESC:: totaltensorsizeinbytes** von tensorflow definiert).</span><span class="sxs-lookup"><span data-stu-id="512b5-122">As another example, it's always safe to bind the output tensors of two concurrent operator dispatches to the same Direct3D 12 resource (so long as their tensors don't overlap), because DirectML never writes outside the bounds of a tensor (as defined by the tensor's **DML_BUFFER_TENSOR_DESC::TotalTensorSizeInBytes**).</span></span>

<span data-ttu-id="512b5-123">Da UAV-Barrieren eine Art der Synchronisierung sind, kann die unnötige Verwendung von UAV-Barrieren die Leistung beeinträchtigen.</span><span class="sxs-lookup"><span data-stu-id="512b5-123">As UAV barriers are a form of synchronization, unnecessary use of UAV barriers might negatively impact performance.</span></span> <span data-ttu-id="512b5-124">Daher ist es am besten, die Mindestanzahl von UAV-Barrieren zu verwenden, die für die ordnungsgemäße Synchronisierung der Verteiler in einer Befehlsliste erforderlich sind.</span><span class="sxs-lookup"><span data-stu-id="512b5-124">Therefore, it's best for you to use the minimum number of UAV barriers necessary to correctly synchronize the dispatches within a command list.</span></span>

### <a name="example-1"></a><span data-ttu-id="512b5-125">Beispiel 1</span><span class="sxs-lookup"><span data-stu-id="512b5-125">Example 1</span></span>

<span data-ttu-id="512b5-126">Im folgenden Beispiel wird die Ausgabe eines Operator Operators in eine relu-Aktivierung eingefügt, gefolgt von einer Batch Normalisierung.</span><span class="sxs-lookup"><span data-stu-id="512b5-126">In the following example, a convolution operator's output is fed into a ReLU activation, followed by a batch normalization.</span></span>

```console
    CONVOLUTION (conv1)
         |
  ACTIVATION_RELU (relu1)
         |
BATCH_NORMALIZATION (batch1)
```

<span data-ttu-id="512b5-127">Da zwischen allen drei Operatoren eine Daten Abhängigkeit vorhanden ist, benötigen Sie eine UAV-Barriere zwischen den einzelnen aufeinander folgenden Dispatch-Informationen (siehe [**idmlcommandrecorder:: recorddispatch**](/windows/desktop/api/directml/nf-directml-idmlcommandrecorder-recorddispatch)).</span><span class="sxs-lookup"><span data-stu-id="512b5-127">Since a data dependency exists between all three operators, you'll need a UAV barrier between each successive dispatch (see [**IDMLCommandRecorder::RecordDispatch**](/windows/desktop/api/directml/nf-directml-idmlcommandrecorder-recorddispatch)).</span></span>

1. <span data-ttu-id="512b5-128">`dmlCommandRecorder->RecordDispatch(d3d12CommandList, `**conv1**`)`</span><span class="sxs-lookup"><span data-stu-id="512b5-128">`dmlCommandRecorder->RecordDispatch(d3d12CommandList, `**conv1**`)`</span></span>
2. <span data-ttu-id="512b5-129">`d3d12CommandList->ResourceBarrier(`**UAV-Barriere**`)`</span><span class="sxs-lookup"><span data-stu-id="512b5-129">`d3d12CommandList->ResourceBarrier(`**UAV barrier**`)`</span></span>
3. <span data-ttu-id="512b5-130">`dmlCommandRecorder->RecordDispatch(d3d12CommandList, `**relu1**`)`</span><span class="sxs-lookup"><span data-stu-id="512b5-130">`dmlCommandRecorder->RecordDispatch(d3d12CommandList, `**relu1**`)`</span></span>
4. <span data-ttu-id="512b5-131">`d3d12CommandList->ResourceBarrier(`**UAV-Barriere**`)`</span><span class="sxs-lookup"><span data-stu-id="512b5-131">`d3d12CommandList->ResourceBarrier(`**UAV barrier**`)`</span></span>
5. <span data-ttu-id="512b5-132">`dmlCommandRecorder->RecordDispatch(d3d12CommandList, `**batch1**`)`</span><span class="sxs-lookup"><span data-stu-id="512b5-132">`dmlCommandRecorder->RecordDispatch(d3d12CommandList, `**batch1**`)`</span></span>

### <a name="example-2"></a><span data-ttu-id="512b5-133">Beispiel 2</span><span class="sxs-lookup"><span data-stu-id="512b5-133">Example 2</span></span>

```console
     MAX_POOLING (pool1)
        /    \
CONVOLUTION  CONVOLUTION
  (conv1)      (conv2)
        \    /
         JOIN (join1)
```

<span data-ttu-id="512b5-134">Hier wird die Ausgabe von Pooling in zwei konvolutionen eingefügt, deren Ausgaben dann mithilfe des Join-Operators miteinander verkettet werden.</span><span class="sxs-lookup"><span data-stu-id="512b5-134">Here the output of pooling is fed into two convolutions, whose outputs are then concatenated together using the JOIN operator.</span></span> <span data-ttu-id="512b5-135">Zwischen und sowie zwischen und sowie zwischen und und sind eine Daten Abhängigkeit vorhanden `pool1` `conv1` `conv2` `conv1` `conv2` `join1` .</span><span class="sxs-lookup"><span data-stu-id="512b5-135">A data dependency exists between `pool1` and both `conv1` and `conv2`; as well as between both `conv1` and `conv2` and `join1`.</span></span> <span data-ttu-id="512b5-136">Im folgenden finden Sie eine gültige Methode zum Ausführen dieses Diagramms.</span><span class="sxs-lookup"><span data-stu-id="512b5-136">Here's one valid way to execute this graph.</span></span>

1. <span data-ttu-id="512b5-137">`dmlCommandRecorder->RecordDispatch(d3d12CommandList, `**pool1**`)`</span><span class="sxs-lookup"><span data-stu-id="512b5-137">`dmlCommandRecorder->RecordDispatch(d3d12CommandList, `**pool1**`)`</span></span>
2. <span data-ttu-id="512b5-138">`d3d12CommandList->ResourceBarrier(`**UAV-Barriere**`)`</span><span class="sxs-lookup"><span data-stu-id="512b5-138">`d3d12CommandList->ResourceBarrier(`**UAV barrier**`)`</span></span>
3. <span data-ttu-id="512b5-139">`dmlCommandRecorder->RecordDispatch(d3d12CommandList, `**conv1**`)`</span><span class="sxs-lookup"><span data-stu-id="512b5-139">`dmlCommandRecorder->RecordDispatch(d3d12CommandList, `**conv1**`)`</span></span>
4. <span data-ttu-id="512b5-140">`dmlCommandRecorder->RecordDispatch(d3d12CommandList, `**conv2**`)`</span><span class="sxs-lookup"><span data-stu-id="512b5-140">`dmlCommandRecorder->RecordDispatch(d3d12CommandList, `**conv2**`)`</span></span>
5. <span data-ttu-id="512b5-141">`d3d12CommandList->ResourceBarrier(`**UAV-Barriere**`)`</span><span class="sxs-lookup"><span data-stu-id="512b5-141">`d3d12CommandList->ResourceBarrier(`**UAV barrier**`)`</span></span>
6. <span data-ttu-id="512b5-142">`dmlCommandRecorder->RecordDispatch(d3d12CommandList, `**join1**`)`</span><span class="sxs-lookup"><span data-stu-id="512b5-142">`dmlCommandRecorder->RecordDispatch(d3d12CommandList, `**join1**`)`</span></span>

<span data-ttu-id="512b5-143">In diesem Fall `conv1` können und `conv2` gleichzeitig auf der GPU ausgeführt werden, wodurch die Leistung verbessert werden kann.</span><span class="sxs-lookup"><span data-stu-id="512b5-143">In this case, `conv1` and `conv2` are able to execute concurrently on the GPU, which may improve performance.</span></span>

## <a name="resource-barrier-state-requirements"></a><span data-ttu-id="512b5-144">Anforderungen an den Ressourcen Sperr Status</span><span class="sxs-lookup"><span data-stu-id="512b5-144">Resource barrier state requirements</span></span>

<span data-ttu-id="512b5-145">Als Aufrufer müssen Sie sicherstellen, dass sich alle Direct3D 12-Ressourcen im richtigen ressourcensperrungs-Zustand befinden, bevor directml-Verteiler auf der GPU ausgeführt werden.</span><span class="sxs-lookup"><span data-stu-id="512b5-145">As the caller, it's your responsibility to ensure that all Direct3D 12 resources are in the correct resource barrier state prior to executing DirectML dispatches on the GPU.</span></span> <span data-ttu-id="512b5-146">Directml führt keine Übergangs Barrieren in Ihrem Namen aus.</span><span class="sxs-lookup"><span data-stu-id="512b5-146">DirectML doesn't perform any transition barriers on your behalf.</span></span>

<span data-ttu-id="512b5-147">Vor der Ausführung von [**idmlcommandrecorder:: recorddispatch**](/windows/desktop/api/directml/nf-directml-idmlcommandrecorder-recorddispatch) auf der GPU müssen Sie alle gebundenen Ressourcen in den **D3D12_RESOURCE_STATE_UNORDERED_ACCESS** -Zustand oder einen Status, der implizit zu **D3D12_RESOURCE_STATE_UNORDERED_ACCESS** herauf gestuft werden kann, z. b. **D3D12_RESOURCE_STATE_COMMON**, übertragen.</span><span class="sxs-lookup"><span data-stu-id="512b5-147">Prior to execution of [**IDMLCommandRecorder::RecordDispatch**](/windows/desktop/api/directml/nf-directml-idmlcommandrecorder-recorddispatch) on the GPU, you must transition all bound resources to the **D3D12_RESOURCE_STATE_UNORDERED_ACCESS** state, or to a state implicitly promotable to **D3D12_RESOURCE_STATE_UNORDERED_ACCESS**, such as **D3D12_RESOURCE_STATE_COMMON**.</span></span> <span data-ttu-id="512b5-148">Nachdem dieser Vorgang abgeschlossen ist, verbleiben die Ressourcen im **D3D12_RESOURCE_STATE_UNORDERED_ACCESS** Status.</span><span class="sxs-lookup"><span data-stu-id="512b5-148">After this call completes, the resources remain in the **D3D12_RESOURCE_STATE_UNORDERED_ACCESS** state.</span></span> <span data-ttu-id="512b5-149">Weitere Informationen finden Sie unter [binden in directml](dml-binding.md).</span><span class="sxs-lookup"><span data-stu-id="512b5-149">For more details, see [Binding in DirectML](dml-binding.md).</span></span>

## <a name="see-also"></a><span data-ttu-id="512b5-150">Siehe auch</span><span class="sxs-lookup"><span data-stu-id="512b5-150">See also</span></span>

* [<span data-ttu-id="512b5-151">Verwenden von Ressourcen Barrieren zum Synchronisieren von Ressourcen Zuständen in Direct3D 12</span><span class="sxs-lookup"><span data-stu-id="512b5-151">Using resource barriers to synchronize resource states in Direct3D 12</span></span>](/windows/desktop/direct3d12/using-resource-barriers-to-synchronize-resource-states-in-direct3d-12)
* [<span data-ttu-id="512b5-152">Bindung in DirectML</span><span class="sxs-lookup"><span data-stu-id="512b5-152">Binding in DirectML</span></span>](dml-binding.md)
