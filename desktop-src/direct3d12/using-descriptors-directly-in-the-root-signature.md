---
title: Direktes Verwenden von Deskriptoren in der Stammsignatur
description: Um zu vermeiden, dass ein Deskriptorhap durchgehen muss, können Sie einen Deskriptor direkt in die Stammsignatur einordnen.
ms.assetid: 033E3D8F-3003-42F7-BF77-68A7D62802E5
ms.localizationpriority: high
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: ff9d459f3195a4cf722ea210edbe63e5c1bf3cc8
ms.sourcegitcommit: 170bc12e9724d00cecbb96d57c7226c51e135dee
ms.translationtype: MT
ms.contentlocale: de-DE
ms.lasthandoff: 07/07/2021
ms.locfileid: "113489169"
---
# <a name="using-descriptors-directly-in-the-root-signature"></a><span data-ttu-id="e0c89-103">Direktes Verwenden von Deskriptoren in der Stammsignatur</span><span class="sxs-lookup"><span data-stu-id="e0c89-103">Using descriptors directly in the root signature</span></span>

<span data-ttu-id="e0c89-104">Um zu vermeiden, dass ein Deskriptorhap durchgehen muss, können Sie einen Deskriptor direkt in die Stammsignatur einordnen.</span><span class="sxs-lookup"><span data-stu-id="e0c89-104">To avoid the need to go through a descriptor heap, you can put a descriptor directly into the root signature.</span></span> <span data-ttu-id="e0c89-105">Diese Deskriptoren nehmen viel Speicherplatz in der Stammsignatur ein (siehe [Grenzwerte](/windows/win32/direct3d12/root-signature-limits)für Stammsignaturen). Daher wird empfohlen, sie nur wenig zu verwenden.</span><span class="sxs-lookup"><span data-stu-id="e0c89-105">These descriptors take up a lot of space in the root signature (see [Root signature limits](/windows/win32/direct3d12/root-signature-limits)), so we recommend that you use them sparingly.</span></span>

<span data-ttu-id="e0c89-106">Eine Beispielverwendung wäre, im Stammlayout eine konstante Pufferansicht (CONSTANT Buffer View, CBV) zu platzieren, die sich pro Zeichnen ändert.</span><span class="sxs-lookup"><span data-stu-id="e0c89-106">An example usage would be to place in the root layout a constant buffer view (CBV) that is changing per draw.</span></span> <span data-ttu-id="e0c89-107">Dies bedeutet, dass der Deskriptor-Heapspeicher nicht von der Anwendung pro Zeichnen zugeordnet werden muss (und speichert das Verweisen auf eine Deskriptortabelle an der neuen Position im Deskriptor-Heap).</span><span class="sxs-lookup"><span data-stu-id="e0c89-107">That's so that descriptor heap space doesn't have to be allocated by the application per draw (and saves pointing a descriptor table at the new location in the descriptor heap).</span></span> <span data-ttu-id="e0c89-108">Indem sie etwas in die Stammsignatur setzt, überliegt die Anwendung lediglich die Verantwortung für die Versionserstellung dem Treiber. aber dies ist die Infrastruktur, über die Treiber bereits verfügen.</span><span class="sxs-lookup"><span data-stu-id="e0c89-108">By putting something in the root signature, the application is merely handing the versioning responsibility to the driver; but that's infrastructure that drivers already have.</span></span>

<span data-ttu-id="e0c89-109">Für Rendering, das nur sehr wenige Ressourcen verwendet, ist die Verwendung von Deskriptortabellen/Heaps möglicherweise überhaupt nicht erforderlich, wenn alle erforderlichen Deskriptoren direkt in der Stammsignatur platziert werden können.</span><span class="sxs-lookup"><span data-stu-id="e0c89-109">For rendering that uses extremely few resources, descriptor table/heap use may not be needed at all if all of the needed descriptors can be placed directly in the root signature.</span></span>

<span data-ttu-id="e0c89-110">Dies sind die einzigen Typen von Deskriptoren, die in der Stammsignatur unterstützt werden.</span><span class="sxs-lookup"><span data-stu-id="e0c89-110">These are the only types of descriptors supported in the root signature.</span></span>

- <span data-ttu-id="e0c89-111">Konstantenpufferansicht (CBVs).</span><span class="sxs-lookup"><span data-stu-id="e0c89-111">Constant buffer view (CBVs).</span></span>
- <span data-ttu-id="e0c89-112">Shaderressourcenansichten (SRVs) bzw. ungeordnete Zugriffsansichten (UNOrdered Access Views, UAVs) von Pufferressourcen, bei denen keine Formatkonvertierung erforderlich ist (nicht typisierte Puffer).</span><span class="sxs-lookup"><span data-stu-id="e0c89-112">Shader resource views (SRVs) / unordered access views (UAVs) of buffer resources where format conversion is not required (untyped buffers).</span></span> <span data-ttu-id="e0c89-113">Beispiele für nicht typisierte Puffer, die mit Stammdeskriptoren gebunden werden können, sind `StructuredBuffer<type>` `RWStructuredBuffer<type>` , und `ByteAddressBuffer` `RWByteAddressBuffer` .</span><span class="sxs-lookup"><span data-stu-id="e0c89-113">Some examples of untyped buffers that can be bound with root descriptors include `StructuredBuffer<type>`, `RWStructuredBuffer<type>`, `ByteAddressBuffer` and `RWByteAddressBuffer`.</span></span> <span data-ttu-id="e0c89-114">Typierte Puffer wie `Buffer<uint>` und `Buffer<float2>` können nicht.</span><span class="sxs-lookup"><span data-stu-id="e0c89-114">Typed buffers such as `Buffer<uint>` and `Buffer<float2>` can't.</span></span>
- <span data-ttu-id="e0c89-115">SRVs von Raytracingbeschleunigungsstrukturen in lokalen oder globalen Stammsignaturen.</span><span class="sxs-lookup"><span data-stu-id="e0c89-115">SRVs of raytracing acceleration structures, in local or global root signatures.</span></span> 

<span data-ttu-id="e0c89-116">Einem UAV im Stammverzeichnis können keine Leistungsindikatoren zugeordnet sein.</span><span class="sxs-lookup"><span data-stu-id="e0c89-116">A UAV in the root cannot have counters associated with it.</span></span> <span data-ttu-id="e0c89-117">Deskriptoren in der Stammsignatur werden jeweils als einzelne separate Deskriptoren angezeigt, &mdash; die nicht dynamisch indiziert werden können.</span><span class="sxs-lookup"><span data-stu-id="e0c89-117">Descriptors in the root signature appear each as individual separate descriptors&mdash;they cannot be dynamically indexed.</span></span>

``` syntax
struct SceneData
{
   uint foo;
   float bar[2];
   int moo;
};
ConstantBuffer<SceneData> mySceneData : register(b6);
```

<span data-ttu-id="e0c89-118">Im obigen Beispiel kann nicht als Array deklariert werden, wie in , wenn es einem `mySceneData` Deskriptor in der Stammsignatur zugeordnet werden `cbuffer mySceneData[2]` soll.</span><span class="sxs-lookup"><span data-stu-id="e0c89-118">In the above example, `mySceneData` can't be declared as an array, as in `cbuffer mySceneData[2]` if it is going to be mapped onto a descriptor in the root signature.</span></span> <span data-ttu-id="e0c89-119">Das liegt daran, dass die Deskriptorübergreifende Indizierung in der Stammsignatur nicht unterstützt wird.</span><span class="sxs-lookup"><span data-stu-id="e0c89-119">That's because indexing across descriptors isn't supported in the root signature.</span></span> <span data-ttu-id="e0c89-120">Bei Wunsch können Sie separate einzelne konstante Puffer definieren und diese jeweils als separaten Eintrag in der Stammsignatur definieren.</span><span class="sxs-lookup"><span data-stu-id="e0c89-120">If desired, you can define separate individual constant buffers, and define them each as a separate entry in the root signature.</span></span> <span data-ttu-id="e0c89-121">Beachten `mySceneData` Sie, dass sich in der obigen Ansicht ein Array `bar[2]` befindet.</span><span class="sxs-lookup"><span data-stu-id="e0c89-121">Note that within `mySceneData` above, there is an array `bar[2]`.</span></span> <span data-ttu-id="e0c89-122">Die dynamische Indizierung innerhalb des Konstantenpuffers ist gültig. Ein Deskriptor in der Stammsignatur verhält sich genauso wie derselbe Deskriptor, wenn über einen &mdash; Deskriptor-Heap darauf zugegriffen wird.</span><span class="sxs-lookup"><span data-stu-id="e0c89-122">Dynamic indexing within the constant buffer is valid&mdash;a descriptor in the root signature behaves just like the same descriptor would behave if it were accessed through a descriptor heap.</span></span> <span data-ttu-id="e0c89-123">Dies steht im Gegensatz zu Inliningkonst konstanten direkt in der Stammsignatur, die auch wie ein konstanter Puffer erscheinen, mit Ausnahme der Einschränkung, dass die dynamische Indizierung innerhalb der Inlinekonst constants nicht zulässig ist und daher dort nicht zulässig `bar[2]` wäre.</span><span class="sxs-lookup"><span data-stu-id="e0c89-123">This is in contrast with inlining constants directly in the root signature, which also appears like a constant buffer, except with the constraint that dynamic indexing within the inlined constants is not permitted, so `bar[2]` wouldn't be allowed there.</span></span>

<span data-ttu-id="e0c89-124">Diese APIs (von der [**ID3D12GraphicsCommandList-Schnittstelle)**](/windows/win32/api/d3d12/nn-d3d12-id3d12graphicscommandlist) sind zum Festlegen von Deskriptoren direkt in der Stammsignatur.</span><span class="sxs-lookup"><span data-stu-id="e0c89-124">These APIs (from the [**ID3D12GraphicsCommandList**](/windows/win32/api/d3d12/nn-d3d12-id3d12graphicscommandlist) interface) are for setting descriptors directly on the root signature.</span></span>

-   [<span data-ttu-id="e0c89-125">**SetComputeRootConstantBufferView**</span><span class="sxs-lookup"><span data-stu-id="e0c89-125">**SetComputeRootConstantBufferView**</span></span>](/windows/win32/api/d3d12/nf-d3d12-id3d12graphicscommandlist-setcomputerootconstantbufferview)
-   [<span data-ttu-id="e0c89-126">**SetGraphicsRootConstantBufferView**</span><span class="sxs-lookup"><span data-stu-id="e0c89-126">**SetGraphicsRootConstantBufferView**</span></span>](/windows/win32/api/d3d12/nf-d3d12-id3d12graphicscommandlist-setgraphicsrootconstantbufferview)
-   [<span data-ttu-id="e0c89-127">**SetComputeRootShaderResourceView**</span><span class="sxs-lookup"><span data-stu-id="e0c89-127">**SetComputeRootShaderResourceView**</span></span>](/windows/win32/api/d3d12/nf-d3d12-id3d12graphicscommandlist-setcomputerootshaderresourceview)
-   [<span data-ttu-id="e0c89-128">**SetGraphicsRootShaderResourceView**</span><span class="sxs-lookup"><span data-stu-id="e0c89-128">**SetGraphicsRootShaderResourceView**</span></span>](/windows/win32/api/d3d12/nf-d3d12-id3d12graphicscommandlist-setgraphicsrootshaderresourceview)
-   [<span data-ttu-id="e0c89-129">**SetComputeRootUnorderedAccessView**</span><span class="sxs-lookup"><span data-stu-id="e0c89-129">**SetComputeRootUnorderedAccessView**</span></span>](/windows/win32/api/d3d12/nf-d3d12-id3d12graphicscommandlist-setcomputerootunorderedaccessview)
-   [<span data-ttu-id="e0c89-130">**SetGraphicsRootUnorderedAccessView**</span><span class="sxs-lookup"><span data-stu-id="e0c89-130">**SetGraphicsRootUnorderedAccessView**</span></span>](/windows/win32/api/d3d12/nf-d3d12-id3d12graphicscommandlist-setgraphicsrootunorderedaccessview)

> [!NOTE]  
> <span data-ttu-id="e0c89-131">Es gibt kein Konzept eines *Stammdeskriptorarrays* in Direct3D 12.</span><span class="sxs-lookup"><span data-stu-id="e0c89-131">There's no concept of a *root descriptor array* in Direct3D 12.</span></span> <span data-ttu-id="e0c89-132">Deskriptorarrays werden nur in Deskriptorhaps unterstützt.</span><span class="sxs-lookup"><span data-stu-id="e0c89-132">Descriptor arrays are supported only in descriptor heaps.</span></span>

## <a name="related-topics"></a><span data-ttu-id="e0c89-133">Zugehörige Themen</span><span class="sxs-lookup"><span data-stu-id="e0c89-133">Related topics</span></span>

* [<span data-ttu-id="e0c89-134">Stammsignaturen</span><span class="sxs-lookup"><span data-stu-id="e0c89-134">Root signatures</span></span>](root-signatures.md)
