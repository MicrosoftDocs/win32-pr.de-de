---
title: Wichtige Änderungen von Direct3D 11 zu Direct3D 12
description: Direct3D 12 stellt eine bedeutende Abweichung vom Programmiermodell Direct3D 11 dar. Mit Direct3D 12 können apps näher an der Hardware heran liegen als je zuvor.
ms.assetid: CE5066C9-7EA6-437D-9EB0-AACFB6CFAD9E
ms.localizationpriority: high
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: 5be891d71d6c1f3a12d8d5aac3ec46785207ed31
ms.sourcegitcommit: 592c9bbd22ba69802dc353bcb5eb30699f9e9403
ms.translationtype: MT
ms.contentlocale: de-DE
ms.lasthandoff: 08/20/2020
ms.locfileid: "104548650"
---
# <a name="important-changes-from-direct3d-11-to-direct3d-12"></a><span data-ttu-id="d79ac-104">Wichtige Änderungen von Direct3D 11 zu Direct3D 12</span><span class="sxs-lookup"><span data-stu-id="d79ac-104">Important Changes from Direct3D 11 to Direct3D 12</span></span>

<span data-ttu-id="d79ac-105">Direct3D 12 stellt eine bedeutende Abweichung vom Programmiermodell Direct3D 11 dar.</span><span class="sxs-lookup"><span data-stu-id="d79ac-105">Direct3D 12 represents a significant departure from the Direct3D 11 programming model.</span></span> <span data-ttu-id="d79ac-106">Mit Direct3D 12 können apps näher an der Hardware heran liegen als je zuvor.</span><span class="sxs-lookup"><span data-stu-id="d79ac-106">Direct3D 12 lets apps get closer to hardware than ever before.</span></span> <span data-ttu-id="d79ac-107">Wenn Sie sich näher an der Hardware befinden, ist Direct3D 12 schneller und effizienter.</span><span class="sxs-lookup"><span data-stu-id="d79ac-107">By being closer to hardware, Direct3D 12 is faster and more efficient.</span></span> <span data-ttu-id="d79ac-108">Der Kompromiss der APP mit einer höheren Geschwindigkeit und Effizienz mit Direct3D 12 besteht jedoch darin, dass Sie für mehr Aufgaben verantwortlich sind als bei Direct3D 11.</span><span class="sxs-lookup"><span data-stu-id="d79ac-108">But, the trade-off of your app having increased speed and efficiency with Direct3D 12 is that you are responsible for more tasks than you were with Direct3D 11.</span></span>

-   [<span data-ttu-id="d79ac-109">Explizite Synchronisierung</span><span class="sxs-lookup"><span data-stu-id="d79ac-109">Explicit Synchronization</span></span>](#explicit-synchronization)
-   [<span data-ttu-id="d79ac-110">Verwaltung physischer Speicher Residenz</span><span class="sxs-lookup"><span data-stu-id="d79ac-110">Physical Memory Residency Management</span></span>](#physical-memory-residency-management)
-   [<span data-ttu-id="d79ac-111">Pipeline Zustands Objekte</span><span class="sxs-lookup"><span data-stu-id="d79ac-111">Pipeline state objects</span></span>](#pipeline-state-objects)
-   [<span data-ttu-id="d79ac-112">Befehlslisten und Bündel</span><span class="sxs-lookup"><span data-stu-id="d79ac-112">Command lists and bundles</span></span>](#command-lists-and-bundles)
-   [<span data-ttu-id="d79ac-113">Deskriptorheaps und Tabellen</span><span class="sxs-lookup"><span data-stu-id="d79ac-113">Descriptor heaps and tables</span></span>](#descriptor-heaps-and-tables)
-   [<span data-ttu-id="d79ac-114">Portieren von Direct3D 11</span><span class="sxs-lookup"><span data-stu-id="d79ac-114">Porting from Direct3D 11</span></span>](#porting-from-direct3d-11)
-   [<span data-ttu-id="d79ac-115">Verwandte Themen</span><span class="sxs-lookup"><span data-stu-id="d79ac-115">Related topics</span></span>](#related-topics)

<span data-ttu-id="d79ac-116">Direct3D 12 ist eine Rückgabe auf Low-Level-Programmierung. Dadurch erhalten Sie mehr Kontrolle über die grafischen Elemente Ihrer Spiele und apps, indem Sie diese neuen Features einführen: Objekte zur Darstellung des Gesamtstatus der Pipeline, Befehlslisten und Bündel für die Arbeits Übermittlung sowie deskriptorheaps und Tabellen für den Ressourcen Zugriff.</span><span class="sxs-lookup"><span data-stu-id="d79ac-116">Direct3D 12 is a return to low-level programming; it gives you more control over the graphical elements of your games and apps by introducing these new features: objects to represent the overall state of the pipeline, command lists and bundles for work submission, and descriptor heaps and tables for resource access.</span></span>

<span data-ttu-id="d79ac-117">Ihre APP ist mit Direct3D 12 schneller und effizienter geworden, aber Sie sind für mehr Aufgaben verantwortlich als bei Direct3D 11.</span><span class="sxs-lookup"><span data-stu-id="d79ac-117">Your app has increased speed and efficiency with Direct3D 12, but you are responsible for more tasks than you were with Direct3D 11.</span></span>

## <a name="explicit-synchronization"></a><span data-ttu-id="d79ac-118">Explizite Synchronisierung</span><span class="sxs-lookup"><span data-stu-id="d79ac-118">Explicit Synchronization</span></span>

-   <span data-ttu-id="d79ac-119">In Direct3D 12 ist die CPU-GPU-Synchronisierung nun der expliziten Zuständigkeitsbereich der APP und wird nicht mehr implizit von der Laufzeit ausgeführt, wie es in Direct3D 11 der Fall ist.</span><span class="sxs-lookup"><span data-stu-id="d79ac-119">In Direct3D 12, CPU-GPU synchronization is now the explicit responsibility of the app and is no longer implicitly performed by the runtime, as it is in Direct3D 11.</span></span> <span data-ttu-id="d79ac-120">Dies bedeutet auch, dass Direct3D 12 keine automatische Prüfung auf Pipeline Risiken durchführt. Dies ist also die Verantwortung für die apps.</span><span class="sxs-lookup"><span data-stu-id="d79ac-120">This fact also means that no automatic checking for pipeline hazards is performed by Direct3D 12, so again this is the apps responsibility.</span></span>
-   <span data-ttu-id="d79ac-121">In Direct3D 12 sind Apps für das Pipelining von Datenaktualisierungen verantwortlich.</span><span class="sxs-lookup"><span data-stu-id="d79ac-121">In Direct3D 12, apps are responsible for pipelining data updates.</span></span> <span data-ttu-id="d79ac-122">Dies heißt, dass das Muster "Map/Lock-DISCARD" in Direct3D 11 in Direct3D 12 manuell ausgeführt werden muss.</span><span class="sxs-lookup"><span data-stu-id="d79ac-122">That is, the "Map/Lock-DISCARD" pattern in Direct3D 11 must be performed manually in Direct3D 12.</span></span> <span data-ttu-id="d79ac-123">In Direct3D 11 gibt die Laufzeit einen Zeiger auf einen neuen Bereich des Arbeitsspeichers anstelle der alten Puffer Daten zurück, wenn die GPU den Puffer weiterhin verwendet, wenn Sie [**Verknüpfung id3d11devicecontext aus:: Map**](/windows/desktop/api/d3d11/nf-d3d11-id3d11devicecontext-map) mit [**D3D11 \_ map \_ Write \_ DISCARD**](/windows/desktop/api/d3d11/ne-d3d11-d3d11_map)aufgerufen haben.</span><span class="sxs-lookup"><span data-stu-id="d79ac-123">In Direct3D 11, if the GPU is still using the buffer when you call [**ID3D11DeviceContext::Map**](/windows/desktop/api/d3d11/nf-d3d11-id3d11devicecontext-map) with [**D3D11\_MAP\_WRITE\_DISCARD**](/windows/desktop/api/d3d11/ne-d3d11-d3d11_map), the runtime returns a pointer to a new region of memory instead of the old buffer data.</span></span> <span data-ttu-id="d79ac-124">Dadurch kann die GPU die alten Daten weiterhin verwenden, während die APP Daten in den neuen Puffer platziert.</span><span class="sxs-lookup"><span data-stu-id="d79ac-124">This allows the GPU to continue using the old data while the app places data in the new buffer.</span></span> <span data-ttu-id="d79ac-125">In der APP ist keine zusätzliche Speicherverwaltung erforderlich. der alte Puffer wird wieder verwendet oder automatisch zerstört, wenn die GPU damit fertig ist.</span><span class="sxs-lookup"><span data-stu-id="d79ac-125">No additional memory management is required in the app; the old buffer is reused or destroyed automatically when the GPU is finished with it.</span></span>
-   <span data-ttu-id="d79ac-126">In Direct3D 12 werden alle dynamischen Updates (einschließlich konstanter Puffer, dynamischer Scheitelpunkt Puffer, dynamischer Texturen usw.) explizit von der APP gesteuert.</span><span class="sxs-lookup"><span data-stu-id="d79ac-126">In Direct3D 12, all dynamic updates (including constant buffers, dynamic vertex buffers, dynamic textures, and so on) are explicitly controlled by the app.</span></span> <span data-ttu-id="d79ac-127">Diese dynamischen Updates enthalten alle erforderlichen GPU-Zäune oder Pufferung.</span><span class="sxs-lookup"><span data-stu-id="d79ac-127">These dynamic updates include any required GPU fences or buffering.</span></span> <span data-ttu-id="d79ac-128">Die APP ist dafür verantwortlich, den Speicher verfügbar zu halten, bis Sie nicht mehr benötigt wird.</span><span class="sxs-lookup"><span data-stu-id="d79ac-128">The app is responsible for keeping the memory available until it is no longer needed.</span></span>
-   <span data-ttu-id="d79ac-129">Direct3D 12 verwendet die Verweis Zählung im com-Stil nur für die Lebensdauer von Schnittstellen (mit dem schwachen Verweis Modell von Direct3D, das mit der Lebensdauer des Geräts verknüpft ist).</span><span class="sxs-lookup"><span data-stu-id="d79ac-129">Direct3D 12 uses COM-style reference counting only for the lifetimes of interfaces (by using the weak reference model of Direct3D tied to the lifetime of the device).</span></span> <span data-ttu-id="d79ac-130">Alle Arbeitsspeicher Lebensdauer für Ressourcen und Beschreibungen sind die einzige verantwortungsvolle Dauer der APP, die für die richtige Dauer gewährleistet ist, und keine Verweis Zählung.</span><span class="sxs-lookup"><span data-stu-id="d79ac-130">All resource and description memory lifetimes are the sole responsibly of the app to maintain for the proper duration, and are not reference counted.</span></span> <span data-ttu-id="d79ac-131">Direct3D 11 verwendet die Verweis Zählung, um auch die Lebensdauer von Schnittstellen Abhängigkeiten zu verwalten.</span><span class="sxs-lookup"><span data-stu-id="d79ac-131">Direct3D 11 uses reference counting to manage the lifetimes of interface dependencies as well.</span></span>

## <a name="physical-memory-residency-management"></a><span data-ttu-id="d79ac-132">Verwaltung physischer Speicher Residenz</span><span class="sxs-lookup"><span data-stu-id="d79ac-132">Physical Memory Residency Management</span></span>

<span data-ttu-id="d79ac-133">Eine Direct3D 12-Anwendung muss Racebedingungen zwischen mehreren Warteschlangen, mehreren Adaptern und den CPU-Threads vermeiden.</span><span class="sxs-lookup"><span data-stu-id="d79ac-133">A Direct3D 12 application must prevent race-conditions between multiple queues, multiple adapters, and the CPU threads.</span></span> <span data-ttu-id="d79ac-134">D3D12 synchronisiert die CPU und GPU nicht mehr und unterstützt keine praktischen Mechanismen für das Umbenennen von Ressourcen oder die mehrfach Pufferung.</span><span class="sxs-lookup"><span data-stu-id="d79ac-134">D3D12 no longer synchronizes the CPU and GPU, nor supports convenient mechanisms for resource renaming or multi-buffering.</span></span> <span data-ttu-id="d79ac-135">Die Zäune müssen verwendet werden, um zu verhindern, dass mehrere Verarbeitungseinheiten den Arbeitsspeicher überschreiben, bevor die Verarbeitung durch eine andere Verarbeitung abgeschlossen ist.</span><span class="sxs-lookup"><span data-stu-id="d79ac-135">Fences must be used to avoid multiple processing units from over-writing memory before another processing unit finishes using it.</span></span>

<span data-ttu-id="d79ac-136">Die Anwendung Direct3D 12 muss sicherstellen, dass sich die Daten im Arbeitsspeicher befinden, während die GPU Sie liest.</span><span class="sxs-lookup"><span data-stu-id="d79ac-136">The Direct3D 12 application must ensure data is resident in memory while the GPU reads it.</span></span> <span data-ttu-id="d79ac-137">Der von den einzelnen Objekten verwendete Arbeitsspeicher wird während der Erstellung des Objekts als Residenter Speicher festgestellt.</span><span class="sxs-lookup"><span data-stu-id="d79ac-137">Memory used by each object is made resident during the creation of the object.</span></span> <span data-ttu-id="d79ac-138">Anwendungen, die diese Methoden aufrufen, müssen mithilfe von Zäunen sicherstellen, dass die GPU nicht auf Objekte zugreift, die entfernt wurden.</span><span class="sxs-lookup"><span data-stu-id="d79ac-138">Applications which call these methods must use fences to ensure the GPU doesn't access objects which have been evicted.</span></span>

<span data-ttu-id="d79ac-139">Ressourcen Barrieren sind eine andere Art von Synchronisierung, die zum Synchronisieren von Ressourcen-und unter Quell Übergängen auf sehr granularer Ebene verwendet wird.</span><span class="sxs-lookup"><span data-stu-id="d79ac-139">Resource barriers are another type of synchronization needed, used to synchronize resource and subresource transitions at a very granular level.</span></span>

<span data-ttu-id="d79ac-140">Weitere Informationen finden Sie unter [Speicherverwaltung in Direct3D 12](memory-management.md).</span><span class="sxs-lookup"><span data-stu-id="d79ac-140">Refer to [Memory Management in Direct3D 12](memory-management.md).</span></span>

## <a name="pipeline-state-objects"></a><span data-ttu-id="d79ac-141">Pipeline Zustands Objekte</span><span class="sxs-lookup"><span data-stu-id="d79ac-141">Pipeline state objects</span></span>

<span data-ttu-id="d79ac-142">Direct3D 11 ermöglicht die Manipulation von Pipeline Zuständen durch einen großen Satz unabhängiger Objekte.</span><span class="sxs-lookup"><span data-stu-id="d79ac-142">Direct3D 11 allows pipeline state manipulation through a large set of independent objects.</span></span> <span data-ttu-id="d79ac-143">So können z. b. der Status des eingabeassemblers, der Status eines Pixelshaders, der Status des Rasterizers und der Status der Ausgabe Zusammenführung unabhängig geändert</span><span class="sxs-lookup"><span data-stu-id="d79ac-143">For example, input assembler state, pixel shader state, rasterizer state, and output merger state can all be independently modified.</span></span> <span data-ttu-id="d79ac-144">Dieser Entwurf bietet eine bequeme und relativ allgemeine Darstellung der Grafik Pipeline, aber Sie nutzt nicht die Funktionen moderner Hardware, hauptsächlich, weil die verschiedenen Zustände häufig voneinander abhängig sind.</span><span class="sxs-lookup"><span data-stu-id="d79ac-144">This design provides a convenient and relatively high-level representation of the graphics pipeline, but it doesn’t utilize the capabilities of modern hardware, primarily because the various states are often interdependent.</span></span> <span data-ttu-id="d79ac-145">Beispielsweise kombinieren viele GPUs den Pixelshader und den Ausgabe Zusammenführungs Zustand in eine einzelne Hardware Darstellung.</span><span class="sxs-lookup"><span data-stu-id="d79ac-145">For example, many GPUs combine pixel shader and output merger state into a single hardware representation.</span></span> <span data-ttu-id="d79ac-146">Da diese Pipeline Stufen jedoch durch die API Direct3D 11 separat festgelegt werden können, kann der Anzeigetreiber keine Probleme des Pipeline Zustands auflösen, bis der Zustand abgeschlossen ist. Dies gilt nicht für die Draw-Zeit.</span><span class="sxs-lookup"><span data-stu-id="d79ac-146">But because the Direct3D 11 API allows these pipeline stages to be set separately, the display driver can't resolve issues of pipeline state until the state is finalized, which isn’t until draw time.</span></span> <span data-ttu-id="d79ac-147">Mit diesem Schema wird die Hardware Zustands Einrichtung verzögert. Dies bedeutet einen zusätzlichen Verwaltungsaufwand und weniger maximale zeichnen-Aufrufe pro Frame.</span><span class="sxs-lookup"><span data-stu-id="d79ac-147">This scheme delays hardware state setup, which means extra overhead and fewer maximum draw calls per frame.</span></span>

<span data-ttu-id="d79ac-148">Direct3D 12 adressiert dieses Schema, indem ein Großteil des Pipeline Zustands in unveränderliche Pipeline Zustands Objekte (PSOs) vereinheitlicht wird, die bei der Erstellung endgültig erstellt werden.</span><span class="sxs-lookup"><span data-stu-id="d79ac-148">Direct3D 12 addresses this scheme by unifying much of the pipeline state into immutable pipeline state objects (PSOs), which are finalized upon creation.</span></span> <span data-ttu-id="d79ac-149">Hardware und Treiber können dann die PSO sofort in alle systemeigenen Hardware Anweisungen und Zustände konvertieren, die für die Ausführung von GPU-Arbeit erforderlich sind.</span><span class="sxs-lookup"><span data-stu-id="d79ac-149">Hardware and drivers can then immediately convert the PSO into whatever hardware native instructions and state are required to execute GPU work.</span></span> <span data-ttu-id="d79ac-150">Sie können weiterhin dynamisch ändern, welche PSO verwendet wird, aber zu diesem Zweck muss die Hardware nur die minimale Menge vorberechneter Zustände direkt in die Hardware Register kopieren, anstatt den Hardware Status im Handumdrehen zu berechnen.</span><span class="sxs-lookup"><span data-stu-id="d79ac-150">You can still dynamically change which PSO is in use, but to do so, the hardware only needs to copy the minimal amount of pre-computed state directly to the hardware registers, rather than computing the hardware state on the fly.</span></span> <span data-ttu-id="d79ac-151">Durch die Verwendung von PSOs wird der Aufwand für zeichnen-Aufrufe erheblich reduziert, und es können viele weitere Draw-Aufrufe pro Frame erfolgen.</span><span class="sxs-lookup"><span data-stu-id="d79ac-151">By using PSOs, draw call overhead is reduced significantly, and many more draw calls can occur per frame.</span></span> <span data-ttu-id="d79ac-152">Weitere Informationen zu PSOs finden Sie unter [Verwalten des Grafik Pipeline Zustands in Direct3D 12](managing-graphics-pipeline-state-in-direct3d-12.md).</span><span class="sxs-lookup"><span data-stu-id="d79ac-152">For more information about PSOs, see [Managing graphics pipeline state in Direct3D 12](managing-graphics-pipeline-state-in-direct3d-12.md).</span></span>

## <a name="command-lists-and-bundles"></a><span data-ttu-id="d79ac-153">Befehlslisten und Bündel</span><span class="sxs-lookup"><span data-stu-id="d79ac-153">Command lists and bundles</span></span>

<span data-ttu-id="d79ac-154">In Direct3D 11 erfolgt die gesamte Arbeits Übermittlung über den [unmittelbaren Kontext](/windows/desktop/direct3d11/overviews-direct3d-11-render-multi-thread-render), der einen einzelnen Stream von Befehlen darstellt, die an die GPU gesendet werden.</span><span class="sxs-lookup"><span data-stu-id="d79ac-154">In Direct3D 11, all work submission is done via the [immediate context](/windows/desktop/direct3d11/overviews-direct3d-11-render-multi-thread-render), which represents a single stream of commands that go to the GPU.</span></span> <span data-ttu-id="d79ac-155">Um die Multithread-Skalierung zu erreichen, haben Spiele auch [verzögerte Kontexte](/windows/desktop/direct3d11/overviews-direct3d-11-render-multi-thread-render) für Sie zur Verfügung.</span><span class="sxs-lookup"><span data-stu-id="d79ac-155">To achieve multithreaded scaling, games also have [deferred contexts](/windows/desktop/direct3d11/overviews-direct3d-11-render-multi-thread-render) available to them.</span></span> <span data-ttu-id="d79ac-156">Verzögerte Kontexte in Direct3D 11 sind nicht perfekt auf Hardware Zuordnungen, sodass relativ wenig Arbeit durchgeführt werden kann.</span><span class="sxs-lookup"><span data-stu-id="d79ac-156">Deferred contexts in Direct3D 11 don't map perfectly to hardware, so relatively little work can be done in them.</span></span>

<span data-ttu-id="d79ac-157">Direct3D 12 führt ein neues Modell für die Arbeits Übermittlung auf der Grundlage von Befehlslisten ein, die alle Informationen enthalten, die zum Ausführen einer bestimmten Arbeitsauslastung auf der GPU benötigt werden.</span><span class="sxs-lookup"><span data-stu-id="d79ac-157">Direct3D 12 introduces a new model for work submission based on command lists that contain the entirety of information needed to execute a particular workload on the GPU.</span></span> <span data-ttu-id="d79ac-158">Jede neue Befehlsliste enthält Informationen wie die zu verwendende PSO, welche Textur-und Puffer Ressourcen benötigt werden, und die Argumente für alle Draw-Aufrufe.</span><span class="sxs-lookup"><span data-stu-id="d79ac-158">Each new command list contains information such as which PSO to use, what texture and buffer resources are needed, and the arguments to all draw calls.</span></span> <span data-ttu-id="d79ac-159">Da jede Befehlsliste eigenständig ist und keinen Zustand erbt, kann der Treiber alle notwendigen GPU-Befehle vorab und auf kostenlose Thread Weise vorab berechnen.</span><span class="sxs-lookup"><span data-stu-id="d79ac-159">Because each command list is self-contained and inherits no state, the driver can pre-compute all necessary GPU commands up-front and in a free-threaded manner.</span></span> <span data-ttu-id="d79ac-160">Der einzige erforderliche serielle Prozess ist die abschließende Übermittlung von Befehlslisten an die GPU über die Befehls Warteschlange.</span><span class="sxs-lookup"><span data-stu-id="d79ac-160">The only serial process necessary is the final submission of command lists to the GPU via the command queue.</span></span>

<span data-ttu-id="d79ac-161">Zusätzlich zu den Befehlslisten führt Direct3D 12 auch eine zweite Arbeitsebene vor der Berechnung ein: *Bundles*.</span><span class="sxs-lookup"><span data-stu-id="d79ac-161">In addition to command lists, Direct3D 12 also introduces a second level of work pre-computation: *bundles*.</span></span> <span data-ttu-id="d79ac-162">Im Gegensatz zu Befehlslisten, die vollständig eigenständig sind und in der Regel erstellt, einmal gesendet und verworfen werden, stellen Pakete eine Form der Zustands Vererbung dar, die die Wiederverwendung zulässt.</span><span class="sxs-lookup"><span data-stu-id="d79ac-162">Unlike command lists, which are completely self-contained and are typically constructed, submitted once, and discarded, bundles provide a form of state inheritance that permits reuse.</span></span> <span data-ttu-id="d79ac-163">Wenn ein Spiel z. b. zwei Zeichen Modelle mit unterschiedlichen Texturen zeichnen möchte, besteht ein Ansatz darin, eine Befehlsliste mit zwei Sätzen identischer zeichnen-Aufrufe aufzuzeichnen.</span><span class="sxs-lookup"><span data-stu-id="d79ac-163">For example, if a game wants to draw two character models with different textures, one approach is to record a command list with two sets of identical draw calls.</span></span> <span data-ttu-id="d79ac-164">Ein anderer Ansatz besteht jedoch darin, ein Bündel zu erfassen, das ein einzelnes Zeichen Modell zeichnet, und das Paket dann zweimal in der Befehlsliste mit unterschiedlichen Ressourcen wiederzugeben.</span><span class="sxs-lookup"><span data-stu-id="d79ac-164">But another approach is to "record" one bundle that draws a single character model, then "play back" the bundle twice on the command list using different resources.</span></span> <span data-ttu-id="d79ac-165">Im letzteren Fall muss der Anzeigetreiber nur einmal die entsprechenden Anweisungen berechnen, und das Erstellen der Befehlsliste bedeutet im Wesentlichen zwei kostengünstige Funktionsaufrufe.</span><span class="sxs-lookup"><span data-stu-id="d79ac-165">In the latter case, the display driver only has to compute the appropriate instructions once, and creating the command list essentially amounts to two low-cost function calls.</span></span>

<span data-ttu-id="d79ac-166">Weitere Informationen zu Befehlslisten und Paketen finden Sie unter [work Submission in Direct3D 12](command-queues-and-command-lists.md).</span><span class="sxs-lookup"><span data-stu-id="d79ac-166">For more information about command lists and bundles, see [Work Submission in Direct3D 12](command-queues-and-command-lists.md).</span></span>

## <a name="descriptor-heaps-and-tables"></a><span data-ttu-id="d79ac-167">Deskriptorheaps und Tabellen</span><span class="sxs-lookup"><span data-stu-id="d79ac-167">Descriptor heaps and tables</span></span>

<span data-ttu-id="d79ac-168">Die Ressourcen Bindung in Direct3D 11 ist hochgradig abstrahiert und komfortabel, lässt jedoch viele moderne Hardwarefunktionen unterausgelastet.</span><span class="sxs-lookup"><span data-stu-id="d79ac-168">Resource binding in Direct3D 11 is highly abstracted and convenient, but leaves many modern hardware capabilities underutilized.</span></span> <span data-ttu-id="d79ac-169">In Direct3D 11 erstellen Spiele *Ansichts* Objekte von Ressourcen und binden diese Ansichten dann an mehrere *Slots* in verschiedenen Shader-Stufen in der Pipeline.</span><span class="sxs-lookup"><span data-stu-id="d79ac-169">In Direct3D 11, games create *view* objects of resources, then bind those views to several *slots* at various shader stages in the pipeline.</span></span> <span data-ttu-id="d79ac-170">Shader lesen wiederum Daten aus diesen expliziten Bindungs Slots, die zur zeichnungszeit korrigiert werden.</span><span class="sxs-lookup"><span data-stu-id="d79ac-170">Shaders, in turn, read data from those explicit bind slots, which are fixed at draw time.</span></span> <span data-ttu-id="d79ac-171">Dieses Modell bedeutet, dass immer dann, wenn ein Spiel verschiedene Ressourcen verwendet, eine neue Ansicht an unterschiedliche Slots gebunden werden muss, und zeichnen erneut aufrufen.</span><span class="sxs-lookup"><span data-stu-id="d79ac-171">This model means that whenever a game will draw using different resources, it must re-bind different views to different slots, and call draw again.</span></span> <span data-ttu-id="d79ac-172">Dieser Fall steht auch für mehr Aufwand, der durch die vollständige Nutzung moderner Hardwarefunktionen vermieden werden kann.</span><span class="sxs-lookup"><span data-stu-id="d79ac-172">This case also represents overhead that can be eliminated by fully utilizing modern hardware capabilities.</span></span>

<span data-ttu-id="d79ac-173">Direct3D 12 ändert das Bindungs Modell, sodass es mit moderner Hardware identisch ist, und verbessert die Leistung erheblich.</span><span class="sxs-lookup"><span data-stu-id="d79ac-173">Direct3D 12 changes the binding model to match modern hardware and significantly improves performance.</span></span> <span data-ttu-id="d79ac-174">Anstatt eigenständige Ressourcen Sichten und explizite Zuordnung zu Slots zu benötigen, bietet Direct3D 12 einen deskriptorheap, in den Spiele ihre verschiedenen Ressourcen Ansichten erstellen.</span><span class="sxs-lookup"><span data-stu-id="d79ac-174">Instead of requiring standalone resource views and explicit mapping to slots, Direct3D 12 provides a descriptor heap into which games create their various resource views.</span></span> <span data-ttu-id="d79ac-175">Dieses Schema bietet einen Mechanismus, mit dem die GPU die Hardware Native Ressourcen Beschreibung (Deskriptor) direkt in den Arbeitsspeicher schreiben muss.</span><span class="sxs-lookup"><span data-stu-id="d79ac-175">This scheme provides a mechanism for the GPU to directly write the hardware-native resource description (descriptor) to memory up-front.</span></span> <span data-ttu-id="d79ac-176">Um zu deklarieren, welche Ressourcen von der Pipeline für einen bestimmten zeichnen-Befehl verwendet werden sollen, geben Spiele eine oder mehrere deskriptortabellen an, die Unterbereiche des vollständigen deskriptorheaps darstellen.</span><span class="sxs-lookup"><span data-stu-id="d79ac-176">To declare which resources are to be used by the pipeline for a particular draw call, games specify one or more descriptor tables that represent sub-ranges of the full descriptor heap.</span></span> <span data-ttu-id="d79ac-177">Da der deskriptorheap bereits mit den entsprechenden Hardware spezifischen deskriptordaten aufgefüllt wurde, ist das Ändern der deskriptortabellen ein extremkosten günstiger Vorgang.</span><span class="sxs-lookup"><span data-stu-id="d79ac-177">As the descriptor heap has already been populated with the appropriate hardware-specific descriptor data, changing descriptor tables is an extremely low-cost operation.</span></span>

<span data-ttu-id="d79ac-178">Zusätzlich zu der verbesserten Leistung von deskriptorheaps und-Tabellen ermöglicht Direct3D 12 auch die dynamische Indizierung von Ressourcen in Shader, was eine nie dagewesene Flexibilität bietet und neue Renderingverfahren entsperrt.</span><span class="sxs-lookup"><span data-stu-id="d79ac-178">In addition to the improved performance offered by descriptor heaps and tables, Direct3D 12 also allows resources to be dynamically indexed in shaders, which provides unprecedented flexibility and unlocks new rendering techniques.</span></span> <span data-ttu-id="d79ac-179">Beispielsweise codieren moderne verzögerte renderingmodule in der Regel einen Material-oder Objekt Bezeichner einer Art in den zwischen-g-Puffer.</span><span class="sxs-lookup"><span data-stu-id="d79ac-179">As an example, modern deferred rendering engines typically encode a material or object identifier of some kind to the intermediate g-buffer.</span></span> <span data-ttu-id="d79ac-180">In Direct3D 11 müssen diese Module sorgfältig sein, um zu vermeiden, dass zu viele Materialien verwendet werden, da das Einschließen einer zu großen Anzahl in einem g-Puffer das abschließende renderdurchlauf erheblich verlangsamen kann.</span><span class="sxs-lookup"><span data-stu-id="d79ac-180">In Direct3D 11, these engines must be careful to avoid using too many materials, as including too many in one g-buffer can significantly slow down the final render pass.</span></span> <span data-ttu-id="d79ac-181">Mit dynamisch indizierbaren Ressourcen kann eine Szene mit tausend Materialien genau so schnell wie eine mit zehn Materialien fertiggestellt werden.</span><span class="sxs-lookup"><span data-stu-id="d79ac-181">With dynamically indexable resources, a scene with a thousand materials can be finalized just as quickly as one with only ten.</span></span>

<span data-ttu-id="d79ac-182">Weitere Informationen zu deskriptorheaps und Tabellen finden Sie unter [Ressourcen Bindung](resource-binding.md)und [Unterschiede im Bindungs Modell von Direct3D 11](binding-model.md).</span><span class="sxs-lookup"><span data-stu-id="d79ac-182">For more information about descriptor heaps and tables, see [Resource Binding](resource-binding.md), and [Differences in the Binding Model from Direct3D 11](binding-model.md).</span></span>

## <a name="porting-from-direct3d-11"></a><span data-ttu-id="d79ac-183">Portieren von Direct3D 11</span><span class="sxs-lookup"><span data-stu-id="d79ac-183">Porting from Direct3D 11</span></span>

<span data-ttu-id="d79ac-184">Das Portieren von Direct3D 11 ist ein beteiligter Prozess, der unter [Portieren von Direct3D 11 auf Direct3D 12](porting-from-direct3d-11-to-direct3d-12.md)beschrieben wird.</span><span class="sxs-lookup"><span data-stu-id="d79ac-184">Porting from Direct3D 11 is an involved process, described in [Porting from Direct3D 11 to Direct3D 12](porting-from-direct3d-11-to-direct3d-12.md).</span></span> <span data-ttu-id="d79ac-185">Weitere Informationen finden Sie auch unter dem Bereich der Optionen bei der [Arbeit mit Direct3D 11, Direct3D 10 und Direct2D](direct3d-12-interop.md).</span><span class="sxs-lookup"><span data-stu-id="d79ac-185">Also refer to the range of options in [Working with Direct3D 11, Direct3D 10 and Direct2D](direct3d-12-interop.md).</span></span>

## <a name="related-topics"></a><span data-ttu-id="d79ac-186">Verwandte Themen</span><span class="sxs-lookup"><span data-stu-id="d79ac-186">Related topics</span></span>

<dl> <dt>

[<span data-ttu-id="d79ac-187">Grundlegendes zu Direct3D 12</span><span class="sxs-lookup"><span data-stu-id="d79ac-187">Understanding Direct3D 12</span></span>](directx-12-getting-started.md)
</dt> </dl>

 

 