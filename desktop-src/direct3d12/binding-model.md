---
title: Unterschiede im Bindungs Modell von Direct3D 11
description: Eine der wichtigsten Entwurfsentscheidungen hinter der DirectX12-Bindung besteht darin, Sie von anderen Verwaltungsaufgaben zu trennen. Dadurch sind einige Anforderungen an die APP erforderlich, um bestimmte potenzielle Gefahren zu verwalten.
ms.assetid: 3EE7E9AE-203D-40D4-9F12-4313ED179035
ms.localizationpriority: high
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: 43b2785da6497fd4e775d9f88847928e7c4c08e8
ms.sourcegitcommit: 2d531328b6ed82d4ad971a45a5131b430c5866f7
ms.translationtype: MT
ms.contentlocale: de-DE
ms.lasthandoff: 09/16/2019
ms.locfileid: "74104724"
---
# <a name="differences-in-the-binding-model-from-direct3d-11"></a><span data-ttu-id="6475a-104">Unterschiede im Bindungs Modell von Direct3D 11</span><span class="sxs-lookup"><span data-stu-id="6475a-104">Differences in the Binding Model from Direct3D 11</span></span>

<span data-ttu-id="6475a-105">Eine der wichtigsten Entwurfsentscheidungen hinter der DirectX12-Bindung besteht darin, Sie von anderen Verwaltungsaufgaben zu trennen.</span><span class="sxs-lookup"><span data-stu-id="6475a-105">One of the main design decisions behind DirectX12 binding is to separate it from other management tasks.</span></span> <span data-ttu-id="6475a-106">Dadurch sind einige Anforderungen an die APP erforderlich, um bestimmte potenzielle Gefahren zu verwalten.</span><span class="sxs-lookup"><span data-stu-id="6475a-106">This places some requirements on the app to manage certain potential hazards.</span></span>

<span data-ttu-id="6475a-107">Der Hauptvorteil des D3D12-Bindungs Modells besteht darin, dass apps häufig Textur Bindungen ändern können, ohne dass die CPU-Leistung beeinträchtigt wird.</span><span class="sxs-lookup"><span data-stu-id="6475a-107">The main advantage of the D3D12 Binding Model is that it enables apps to change texture bindings frequently, without a huge CPU performance cost.</span></span> <span data-ttu-id="6475a-108">Andere Vorteile sind, dass Shader auf eine sehr große Anzahl von Ressourcen zugreifen können, dass Shader nicht im Voraus wissen müssen, wie viele Ressourcen gebunden werden, und dass ein einheitliches Ressourcen Bindungs Modell unabhängig von der Hardware oder dem App-Inhalts Fluss verwendet werden kann.</span><span class="sxs-lookup"><span data-stu-id="6475a-108">Other benefits are that shaders have access to a very large number of resources, shaders need not know in advance how many resources will be bound, and that a unified resource binding model can be used regardless of hardware or the apps content flow.</span></span>

<span data-ttu-id="6475a-109">Um die Leistung zu verbessern, erfordert das Bindungs Modell nicht, dass das System nachverfolgt, welche Bindungen die GPU von der APP angefordert hat, und es gibt eine saubere Integration zwischen Bindungen und Multithread-Befehlslisten.</span><span class="sxs-lookup"><span data-stu-id="6475a-109">To improve performance, the binding model does not require the system to keep track of what bindings an app has requested the GPU to use, and there is a clean integration between binding and multi-threaded command lists.</span></span>

<span data-ttu-id="6475a-110">In den folgenden Abschnitten werden einige der Änderungen am Ressourcen Bindungs Modell seit D3D11 aufgelistet.</span><span class="sxs-lookup"><span data-stu-id="6475a-110">The following sections list some of the changes to the resource binding model since D3D11.</span></span>

-   [<span data-ttu-id="6475a-111">Verwaltung der Speicher Residenz durch Bindung getrennt</span><span class="sxs-lookup"><span data-stu-id="6475a-111">Memory Residency Management Separated From Binding</span></span>](#memory-residency-management-separated-from-binding)
-   [<span data-ttu-id="6475a-112">Verwaltung der Objekt Lebensdauer getrennt von Bindung</span><span class="sxs-lookup"><span data-stu-id="6475a-112">Object Lifetime Management Separated From Binding</span></span>](#object-lifetime-management-separated-from-binding)
-   [<span data-ttu-id="6475a-113">Treiber Ressourcen-Statusüberwachung getrennt von Bindung</span><span class="sxs-lookup"><span data-stu-id="6475a-113">Driver Resource State Tracking Separated From Binding</span></span>](#driver-resource-state-tracking-separated-from-binding)
-   [<span data-ttu-id="6475a-114">CPU-GPU-zugeordnete Speicher Synchronisierung getrennt von Bindung</span><span class="sxs-lookup"><span data-stu-id="6475a-114">CPU GPU Mapped Memory Synchronization Separated From Binding</span></span>](#cpu-gpu-mapped-memory-synchronization-separated-from-binding)
-   [<span data-ttu-id="6475a-115">Verwandte Themen</span><span class="sxs-lookup"><span data-stu-id="6475a-115">Related topics</span></span>](#related-topics)

## <a name="memory-residency-management-separated-from-binding"></a><span data-ttu-id="6475a-116">Verwaltung der Speicher Residenz durch Bindung getrennt</span><span class="sxs-lookup"><span data-stu-id="6475a-116">Memory Residency Management Separated From Binding</span></span>

<span data-ttu-id="6475a-117">Anwendungen können explizit steuern, welche Oberflächen verfügbar sein müssen, damit die GPU direkt verwendet werden muss (als "residente" bezeichnet).</span><span class="sxs-lookup"><span data-stu-id="6475a-117">Applications have explicit control over which surfaces they need to be available for the GPU to use directly (called being "resident").</span></span> <span data-ttu-id="6475a-118">Im Gegensatz dazu können Sie andere Zustände auf Ressourcen anwenden, z. b. explizites Anfügen von Dateien oder das Betriebssystem für bestimmte Anwendungs Klassen, die einen minimalen Speicherbedarf erfordern.</span><span class="sxs-lookup"><span data-stu-id="6475a-118">Conversely, they can apply other states on resources such as explicitly making them not resident, or letting the OS choose for certain classes of applications that require a minimal memory footprint.</span></span> <span data-ttu-id="6475a-119">Der wichtigste Punkt hierbei ist, dass die Verwaltung des Residenten der Anwendung vollständig von der Verwaltung des Zugriffs auf Ressourcen für Shader entkoppelt ist.</span><span class="sxs-lookup"><span data-stu-id="6475a-119">The important point here is that the application's management of what is resident is completely decoupled from how it gives access to resources to shaders.</span></span>

<span data-ttu-id="6475a-120">Durch die Entkopplung der Residenz Verwaltung von dem Mechanismus zum Gewähren von Shadern auf Ressourcen werden die System-/Hardwarekosten für das Rendering reduziert, da das Betriebssystem den Zustand der lokalen Bindung nicht ständig überprüfen muss, um zu wissen, was der residente</span><span class="sxs-lookup"><span data-stu-id="6475a-120">The decoupling of residency management from the mechanism for giving shaders access to resources reduces the system/hardware cost for rendering since the OS doesn't have to constantly inspect the local binding state to know what to make resident.</span></span> <span data-ttu-id="6475a-121">Außerdem müssen Shader nicht mehr wissen, auf welche exakten Oberflächen Sie möglicherweise verweisen müssen, solange der gesamte Satz von Ressourcen, auf die möglicherweise zugegriffen werden kann, bereits im Voraus verfügbar gemacht wurde.</span><span class="sxs-lookup"><span data-stu-id="6475a-121">Furthermore, shaders no longer have to know which exact surfaces they may need to reference, as long as the entire set of possibly accessible resources has been made resident ahead of time.</span></span>

## <a name="object-lifetime-management-separated-from-binding"></a><span data-ttu-id="6475a-122">Verwaltung der Objekt Lebensdauer getrennt von Bindung</span><span class="sxs-lookup"><span data-stu-id="6475a-122">Object Lifetime Management Separated From Binding</span></span>

<span data-ttu-id="6475a-123">Im Gegensatz zu vorherigen APIs verfolgt das System keine Bindungen von Ressourcen mehr an die Pipeline.</span><span class="sxs-lookup"><span data-stu-id="6475a-123">Unlike previous APIs, the system no longer tracks bindings of resources to the pipeline.</span></span> <span data-ttu-id="6475a-124">Dies wurde verwendet, um dem System zu ermöglichen, von der Anwendung freigegebene Ressourcen beizubehalten, da noch immer eine ausstehende GPU-Arbeit referenziert ist.</span><span class="sxs-lookup"><span data-stu-id="6475a-124">This used to enable the system to keep alive resources that the application has released because they are still referenced by outstanding GPU work.</span></span>

<span data-ttu-id="6475a-125">Vor dem Freigeben von Ressourcen, wie z. b. einer Textur, müssen Anwendungen nun sicherstellen, dass die GPU den Verweis abgeschlossen hat.</span><span class="sxs-lookup"><span data-stu-id="6475a-125">Before freeing any resource, such as a texture, applications now must make sure the GPU has completed referencing it.</span></span> <span data-ttu-id="6475a-126">Dies bedeutet, dass eine Anwendung, die eine Ressource sicher freigeben kann, die Ausführung der Befehlsliste, die auf die Ressource verweist, abgeschlossen haben muss.</span><span class="sxs-lookup"><span data-stu-id="6475a-126">This means before an application can safely free a resource the GPU must have completed execution of the command list referencing the resource.</span></span>

## <a name="driver-resource-state-tracking-separated-from-binding"></a><span data-ttu-id="6475a-127">Treiber Ressourcen-Statusüberwachung getrennt von Bindung</span><span class="sxs-lookup"><span data-stu-id="6475a-127">Driver Resource State Tracking Separated From Binding</span></span>

<span data-ttu-id="6475a-128">Das System überprüft Ressourcen Bindungen nicht mehr, um zu verstehen, wann Ressourcen Übergänge aufgetreten sind, die zusätzliche Treiber-oder GPU-Arbeiten erfordern.</span><span class="sxs-lookup"><span data-stu-id="6475a-128">The system no longer inspects resource bindings to understand when resource transitions have occurred which require additional driver or GPU work.</span></span> <span data-ttu-id="6475a-129">Ein gängiges Beispiel für viele GPUs und Treiber ist zu wissen, wenn eine Oberfläche von der Verwendung als renderzielansicht (RTV) zu Shader Ressourcenansicht (SRV) übergeht.</span><span class="sxs-lookup"><span data-stu-id="6475a-129">A common example for many GPUs and drivers is having to know when a surface transitions from being used as a Render Target View (RTV) to Shader Resource View (SRV).</span></span> <span data-ttu-id="6475a-130">Anwendungen selbst müssen jetzt ermitteln, wann Ressourcen Übergänge, die das System möglicherweise benötigt, über dedizierte APIs erfolgen.</span><span class="sxs-lookup"><span data-stu-id="6475a-130">Applications themselves must now identify when any resource transitions that the system might care about are happening via dedicated APIs.</span></span>

## <a name="cpu-gpu-mapped-memory-synchronization-separated-from-binding"></a><span data-ttu-id="6475a-131">CPU-GPU-zugeordnete Speicher Synchronisierung getrennt von Bindung</span><span class="sxs-lookup"><span data-stu-id="6475a-131">CPU GPU Mapped Memory Synchronization Separated From Binding</span></span>

<span data-ttu-id="6475a-132">Das System überprüft Ressourcen Bindungen nicht mehr, um zu verstehen, ob das Rendering verzögert werden muss, da es von einer Ressource abhängt, die für den CPU-Zugriff zugeordnet wurde, aber noch nicht zugeordnet wurde.</span><span class="sxs-lookup"><span data-stu-id="6475a-132">The system no longer inspects resource bindings to understand if rendering needs to be delayed because it depends on a resource that has been mapped for CPU access but has not been unmapped yet.</span></span> <span data-ttu-id="6475a-133">Anwendungen sind jetzt in der Verantwortung, CPU-und GPU-Speicherzugriffe zu synchronisieren.</span><span class="sxs-lookup"><span data-stu-id="6475a-133">Applications now have the responsibility to synchronize CPU and GPU memory accesses.</span></span> <span data-ttu-id="6475a-134">Um dies zu unterstützen, stellt das System Mechanismen bereit, mit denen die Anwendung den Ruhezustand eines CPU-Threads anfordern kann, bis die Arbeit abgeschlossen ist.</span><span class="sxs-lookup"><span data-stu-id="6475a-134">To help with this, the system provides mechanisms for the application to request the sleeping of a CPU thread until work completes.</span></span> <span data-ttu-id="6475a-135">Der Abruf kann auch durchgeführt werden, kann jedoch weniger effizient sein.</span><span class="sxs-lookup"><span data-stu-id="6475a-135">Polling could also be done, but can be less efficient.</span></span>

## <a name="related-topics"></a><span data-ttu-id="6475a-136">Verwandte Themen</span><span class="sxs-lookup"><span data-stu-id="6475a-136">Related topics</span></span>

<dl> <dt>

[<span data-ttu-id="6475a-137">Ressourcen Bindung</span><span class="sxs-lookup"><span data-stu-id="6475a-137">Resource Binding</span></span>](resource-binding.md)
</dt> </dl>

 

 




