---
title: Direct3D 12 konservative rasterisierung
description: Die konservative rasterisierung sorgt für ein gewisses Maß an Sicherheit für das Pixel Rendering. Dies ist insbesondere bei Algorithmen zum Erkennen von Kollisionen hilfreich.
ms.assetid: 081199AD-1702-4EC8-95AD-B1148C676199
ms.localizationpriority: high
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: 4e4fae3489d54ab7b6b7abfda56f54dd8d970962
ms.sourcegitcommit: cba7f424a292fd7f3a8518947b9466439b455419
ms.translationtype: MT
ms.contentlocale: de-DE
ms.lasthandoff: 11/23/2019
ms.locfileid: "104548755"
---
# <a name="direct3d-12-conservative-rasterization"></a><span data-ttu-id="b608f-103">Direct3D 12 konservative rasterisierung</span><span class="sxs-lookup"><span data-stu-id="b608f-103">Direct3D 12 Conservative Rasterization</span></span>

<span data-ttu-id="b608f-104">Die konservative rasterisierung sorgt für ein gewisses Maß an Sicherheit für das Pixel Rendering. Dies ist insbesondere bei Algorithmen zum Erkennen von Kollisionen hilfreich.</span><span class="sxs-lookup"><span data-stu-id="b608f-104">Conservative Rasterization adds some certainty to pixel rendering, which is helpful in particular to collision detection algorithms.</span></span>

-   [<span data-ttu-id="b608f-105">Übersicht</span><span class="sxs-lookup"><span data-stu-id="b608f-105">Overview</span></span>](#overview)
-   [<span data-ttu-id="b608f-106">Interaktionen mit der Pipeline</span><span class="sxs-lookup"><span data-stu-id="b608f-106">Interactions with the pipeline</span></span>](#interactions-with-the-pipeline)
    -   [<span data-ttu-id="b608f-107">Interaktion von rasterisierungsregeln</span><span class="sxs-lookup"><span data-stu-id="b608f-107">Rasterization Rules interaction</span></span>](#rasterization-rules-interaction)
    -   [<span data-ttu-id="b608f-108">Multisampling-Interaktion</span><span class="sxs-lookup"><span data-stu-id="b608f-108">Multisampling interaction</span></span>](#multisampling-interaction)
    -   [<span data-ttu-id="b608f-109">Samplemask-Interaktion</span><span class="sxs-lookup"><span data-stu-id="b608f-109">SampleMask interaction</span></span>](#samplemask-interaction)
    -   [<span data-ttu-id="b608f-110">Interaktion mit tiefen/Schablone testen</span><span class="sxs-lookup"><span data-stu-id="b608f-110">Depth/Stencil Test interaction</span></span>](#depthstencil-test-interaction)
    -   [<span data-ttu-id="b608f-111">Hilfspixel Interaktion</span><span class="sxs-lookup"><span data-stu-id="b608f-111">Helper Pixel interaction</span></span>](#helper-pixel-interaction)
    -   [<span data-ttu-id="b608f-112">Interaktion bei der Ausgabe Abdeckung</span><span class="sxs-lookup"><span data-stu-id="b608f-112">Output Coverage interaction</span></span>](#output-coverage-interaction)
    -   [<span data-ttu-id="b608f-113">Inputcoverage-Interaktion</span><span class="sxs-lookup"><span data-stu-id="b608f-113">InputCoverage interaction</span></span>](#inputcoverage-interaction)
    -   [<span data-ttu-id="b608f-114">Innercoverage-Interaktion</span><span class="sxs-lookup"><span data-stu-id="b608f-114">InnerCoverage interaction</span></span>](#innercoverage-interaction)
    -   [<span data-ttu-id="b608f-115">Interaktion mit Attribut Interpolations</span><span class="sxs-lookup"><span data-stu-id="b608f-115">Attribute Interpolation interaction</span></span>](#attribute-interpolation-interaction)
    -   [<span data-ttu-id="b608f-116">Clipping-Interaktion</span><span class="sxs-lookup"><span data-stu-id="b608f-116">Clipping interaction</span></span>](#clipping-interaction)
    -   [<span data-ttu-id="b608f-117">Interaktion bei Clip Distanz</span><span class="sxs-lookup"><span data-stu-id="b608f-117">Clip Distance interaction</span></span>](#clip-distance-interaction)
    -   [<span data-ttu-id="b608f-118">Ziel unabhängige rasterisierungsinteraktion</span><span class="sxs-lookup"><span data-stu-id="b608f-118">Target Independent Rasterization interaction</span></span>](#target-independent-rasterization-interaction)
    -   [<span data-ttu-id="b608f-119">Interaktion mit primitiver Topologie</span><span class="sxs-lookup"><span data-stu-id="b608f-119">IA Primitive Topology interaction</span></span>](#ia-primitive-topology-interaction)
    -   [<span data-ttu-id="b608f-120">Abfrage Interaktion</span><span class="sxs-lookup"><span data-stu-id="b608f-120">Query interaction</span></span>](#query-interaction)
    -   [<span data-ttu-id="b608f-121">Interaktionsinteraktion</span><span class="sxs-lookup"><span data-stu-id="b608f-121">Cull State interaction</span></span>](#cull-state-interaction)
    -   [<span data-ttu-id="b608f-122">Isfrontface-Interaktion</span><span class="sxs-lookup"><span data-stu-id="b608f-122">IsFrontFace interaction</span></span>](#isfrontface-interaction)
    -   [<span data-ttu-id="b608f-123">Interaktion mit Füll Modi</span><span class="sxs-lookup"><span data-stu-id="b608f-123">Fill Modes interaction</span></span>](#fill-modes-interaction)
-   [<span data-ttu-id="b608f-124">Implementierungsdetails</span><span class="sxs-lookup"><span data-stu-id="b608f-124">Implementation details</span></span>](#implementation-details)
-   [<span data-ttu-id="b608f-125">API-Zusammenfassung</span><span class="sxs-lookup"><span data-stu-id="b608f-125">API summary</span></span>](#api-summary)
-   [<span data-ttu-id="b608f-126">Verwandte Themen</span><span class="sxs-lookup"><span data-stu-id="b608f-126">Related topics</span></span>](#related-topics)

## <a name="overview"></a><span data-ttu-id="b608f-127">Überblick</span><span class="sxs-lookup"><span data-stu-id="b608f-127">Overview</span></span>

<span data-ttu-id="b608f-128">Die konservative rasterisierung bedeutet, dass alle Pixel, die zumindest teilweise von einem gerenderten primitiven abgedeckt werden, rasterisiert sind. Dies bedeutet, dass der Pixelshader aufgerufen wird.</span><span class="sxs-lookup"><span data-stu-id="b608f-128">Conservative Rasterization means that all pixels that are at least partially covered by a rendered primitive are rasterized, which means that the pixel shader is invoked.</span></span> <span data-ttu-id="b608f-129">Normales Verhalten ist die Stichprobenentnahme, die nicht verwendet wird, wenn die konservative rasterisierung aktiviert ist.</span><span class="sxs-lookup"><span data-stu-id="b608f-129">Normal behavior is sampling, which is not used if Conservative Rasterization is enabled.</span></span>

<span data-ttu-id="b608f-130">Die konservative rasterisierung ist in einer Reihe von Situationen nützlich, einschließlich der Sicherheit bei der Konflikterkennung, der Okklusions Erkennung und des gekachelten Rendering.</span><span class="sxs-lookup"><span data-stu-id="b608f-130">Conservative Rasterization is useful in a number of situations, including for certainty in collision detection, occlusion culling, and tiled rendering.</span></span>

<span data-ttu-id="b608f-131">Die folgende Abbildung zeigt z. b. ein grünes Dreieck, das mit konservativer rasterisierung gerendert wird, wie es im Raster (mit 16,8-Scheitelpunkt Koordinaten mit festem Punkt) angezeigt würde.</span><span class="sxs-lookup"><span data-stu-id="b608f-131">For example, the following figure shows a green triangle rendered using Conservative Rasterization, as it would appear in the rasterizer (that is, using 16.8 fixed point vertex coordinates).</span></span> <span data-ttu-id="b608f-132">Der braune Bereich wird als "Ungewissheit-Region" bezeichnet. Dies ist ein konzeptioneller Bereich, der die erweiterten Begrenzungen des Dreiecks darstellt. Dies ist erforderlich, um sicherzustellen, dass der primitive im Raster in Bezug auf die ursprünglichen Gleit Komma Koordinaten des Vertex konservativ ist.</span><span class="sxs-lookup"><span data-stu-id="b608f-132">The brown area is known as an "uncertainty region" - a conceptual region that represents the extended bounds of the triangle, required to ensure the primitive in the rasterizer is conservative with respect to the original floating point vertex coordinates.</span></span> <span data-ttu-id="b608f-133">Die roten Quadrate in den einzelnen Scheitel Punkten zeigen, wie der unsicher-Bereich berechnet wird: als ein gesweep Quadrat.</span><span class="sxs-lookup"><span data-stu-id="b608f-133">The red squares at each vertex shows how the uncertainty region is calculated: as a swept square.</span></span>

<span data-ttu-id="b608f-134">Die großen grauen Quadrate zeigen die Pixel an, die gerendert werden.</span><span class="sxs-lookup"><span data-stu-id="b608f-134">The large gray squares show the pixels that will be rendered.</span></span> <span data-ttu-id="b608f-135">In den rosa Quadraten werden Pixel angezeigt, die mit der "Top-Left"-Regel gerendert werden. diese wird wiedergegeben, wenn der Rand des Dreiecks den Rand der Pixel überschreitet.</span><span class="sxs-lookup"><span data-stu-id="b608f-135">The pink squares show pixels rendered using the "Top-Left Rule", which comes into play as the edge of the triangle crosses the edge of the pixels.</span></span> <span data-ttu-id="b608f-136">Es können falsch positive Ergebnisse (Pixel festgelegt werden, die nicht vorhanden sein sollten) sein, die das System normalerweise aber nicht immer umschlägt.</span><span class="sxs-lookup"><span data-stu-id="b608f-136">There can be false positives (pixels set that should not have been) which the system will normally but not always cull.</span></span>

![die linke obere Regel](images/conservative-rasterization-0.png)

## <a name="interactions-with-the-pipeline"></a><span data-ttu-id="b608f-138">Interaktionen mit der Pipeline</span><span class="sxs-lookup"><span data-stu-id="b608f-138">Interactions with the pipeline</span></span>

### <a name="rasterization-rules-interaction"></a><span data-ttu-id="b608f-139">Interaktion von rasterisierungsregeln</span><span class="sxs-lookup"><span data-stu-id="b608f-139">Rasterization Rules interaction</span></span>

<span data-ttu-id="b608f-140">Im konservativen rasterisierungsmodus gelten rasterisierungsregeln genauso wie, wenn der konservative rasterisierungsmodus nicht mit Ausnahmen für die Top-Left Regel, wie oben beschrieben, und Pixel Abdeckung aktiviert ist.</span><span class="sxs-lookup"><span data-stu-id="b608f-140">In Conservative Rasterization mode, Rasterization Rules apply the same way as when Conservative Rasterization mode is not enabled with exceptions for the Top-Left Rule, described above, and Pixel Coverage.</span></span> <span data-ttu-id="b608f-141">16,8 Fixed-Point Genauigkeit für den Rasterizer muss verwendet werden.</span><span class="sxs-lookup"><span data-stu-id="b608f-141">16.8 Fixed-Point Rasterizer precision must be used.</span></span>

<span data-ttu-id="b608f-142">Pixel, die nicht abgedeckt werden, wenn die Hardware vollständige Gleit Komma Koordinaten verwendet, kann nur eingeschlossen werden, wenn Sie sich innerhalb eines unsicheren Bereichs befinden, der nicht größer als ein Pixel in der fest Komma Domäne ist.</span><span class="sxs-lookup"><span data-stu-id="b608f-142">Pixels that would not be covered if hardware was using full floating point vertex coordinates may only be included if they are within an uncertainty region no larger half a pixel in the fixed point domain.</span></span> <span data-ttu-id="b608f-143">Zukünftige Hardware geht davon aus, dass die in Ebene 2 angegebene verschärfte Unsicherheit erreicht werden soll.</span><span class="sxs-lookup"><span data-stu-id="b608f-143">Future hardware is expected to reach the tightened uncertainty region specified in Tier 2.</span></span> <span data-ttu-id="b608f-144">Beachten Sie, dass diese Anforderung verhindert, dass Farbname Dreiecke weiter als erforderlich erweitert werden.</span><span class="sxs-lookup"><span data-stu-id="b608f-144">Note that this requirement prevents sliver triangles from extending further than necessary.</span></span>

<span data-ttu-id="b608f-145">Ein ähnlicher gültiger Bereich für Ungewissheit gilt `InnerCoverage` auch für, aber es ist strenger, da keine Implementierungen in diesem Fall einen größeren unsicheren Bereich erfordern.</span><span class="sxs-lookup"><span data-stu-id="b608f-145">A similar valid uncertainty region applies to `InnerCoverage` as well, but it is tighter since no implementations require a larger uncertainty region for this case.</span></span> <span data-ttu-id="b608f-146">Weitere Details finden Sie unter [innercoverage-Interaktion](#innercoverage-interaction) .</span><span class="sxs-lookup"><span data-stu-id="b608f-146">See [InnerCoverage interaction](#innercoverage-interaction) for more detail.</span></span>

<span data-ttu-id="b608f-147">Innere und äußere Ungleichheits Bereiche müssen größer oder gleich der Größe der Hälfte des unter-Pixel-Rasters oder 1/512 eines Pixels in der Fixed-Point-Domäne sein.</span><span class="sxs-lookup"><span data-stu-id="b608f-147">Inner and outer uncertainty regions must be greater than or equal to the size of half the sub-pixel grid, or 1/512 of a pixel, in the fixed point domain.</span></span> <span data-ttu-id="b608f-148">Dies ist der minimale gültige unsicherungsbereich.</span><span class="sxs-lookup"><span data-stu-id="b608f-148">This is the minimum valid uncertainty region.</span></span> <span data-ttu-id="b608f-149">1/512 stammt aus der Koordinaten Darstellung von 16,8 Fixed Point Rasterizer und der roundTo-Next-Regel, die angewendet wird, wenn Gleit Komma-Scheitelpunkt Koordinaten in 16,8 festgelegte Punkt Koordinaten umgeschrieben werden.</span><span class="sxs-lookup"><span data-stu-id="b608f-149">1/512 comes from the 16.8 fixed point Rasterizer coordinate representation and the round-to-nearest rule that applies when converting floating point vertex coordinates to 16.8 fixed point coordinates.</span></span> <span data-ttu-id="b608f-150">1/512 kann sich ändern, wenn die Genauigkeit des Rasterizers geändert wird.</span><span class="sxs-lookup"><span data-stu-id="b608f-150">1/512 can change if the Rasterizer precision changes.</span></span> <span data-ttu-id="b608f-151">Wenn eine Implementierung diesen minimalen unsicheren Bereich implementiert, müssen Sie der Top-Left Regel folgen, wenn ein Rand oder eine Ecke des unsicheren Bereichs an der Kante oder Ecke eines Pixels liegt.</span><span class="sxs-lookup"><span data-stu-id="b608f-151">If an implementation implements this minimum uncertainty region, then they must follow the Top-Left Rule when an edge or corner of the uncertainty region falls along the edge or corner of a pixel.</span></span> <span data-ttu-id="b608f-152">Die ausgeschnittenen Kanten des unsicheren Bereichs sollten als nächster Scheitelpunkt behandelt werden, was bedeutet, dass Sie als zwei Ränder gezählt werden: die beiden, die am zugeordneten Scheitelpunkt beitreten.</span><span class="sxs-lookup"><span data-stu-id="b608f-152">The clipped edges of the uncertainty region should be treated as the closest vertex, meaning that it counts as two edges: the two that join at the associated vertex.</span></span> <span data-ttu-id="b608f-153">Top-Left Regel ist erforderlich, wenn der Bereich für die minimale Ungewissheit verwendet wird. ist dies nicht der Fall, würde eine konservative rasterization-Implementierung die Pixel, die abgedeckt werden können, wenn der konservative rasterisierungsmodus deaktiviert ist, nicht Rasterisieren.</span><span class="sxs-lookup"><span data-stu-id="b608f-153">Top-Left Rule is required when the minimum uncertainty region is used because if it is not, then a Conservative Rasterization implementation would fail to rasterize pixels that could be covered when Conservative Rasterization mode is disabled.</span></span>

<span data-ttu-id="b608f-154">Im folgenden Diagramm wird ein gültiger äußerer unsicher dargestellt, der durch das Durchlaufen eines Quadrats um die Ränder des primitiven in der Fixed-Point-Domäne erzeugt wird (d. h., die Scheitel Punkte wurden mit der 16,8-fest Komma Darstellung quantifisiert).</span><span class="sxs-lookup"><span data-stu-id="b608f-154">The following diagram illustrates a valid outer uncertainty region produced by sweeping a square around the edges of the primitive in the fixed point domain (i.e. the vertices have been quantized by the 16.8 fixed point representation).</span></span> <span data-ttu-id="b608f-155">Die Abmessungen dieses Quadrats basieren auf der gültigen Regions Größe für äußere Ungewissheit: für 1/2 eines Pixels beträgt das Quadrat 1 Pixel in Breite und Höhe, bei 1/512 eines Pixels ist das Quadrat 1/256 eines Pixels in Breite und Höhe.</span><span class="sxs-lookup"><span data-stu-id="b608f-155">The dimensions of this square are based on the valid outer uncertainty region size: for the 1/2 of a pixel, the square is 1 pixel in width and height, for 1/512 of a pixel, the square is 1/256 of a pixel in width and height.</span></span> <span data-ttu-id="b608f-156">Das grüne Dreieck stellt ein bestimmtes primitiv dar, die rote gepunktete Linie stellt die Grenze für die überschätzte konservative rasterisierung dar, die schwarzen Quadrate stellen das Quadrat dar, das entlang der primitiven Ränder gezogen wird, und der blaue aktivierte Bereich ist der äußere unsicher-Bereich:</span><span class="sxs-lookup"><span data-stu-id="b608f-156">The green triangle represents a given primitive, the red dotted line represents the bound on Overestimated Conservative Rasterization, the solid black squares represent the square that is swept along the primitive edges, and the blue checkered area is the outer uncertainty region:</span></span>

![äußerer unsicheren Bereich.](images/outercoverage.jpg)

### <a name="multisampling-interaction"></a><span data-ttu-id="b608f-158">Multisampling-Interaktion</span><span class="sxs-lookup"><span data-stu-id="b608f-158">Multisampling interaction</span></span>

<span data-ttu-id="b608f-159">Unabhängig von der Anzahl von Beispielen in **renderTarget** / **depthstencil** -Oberflächen (bzw. unabhängig davon, ob *forcedsamplecount* verwendet wird oder nicht) werden alle Beispiele für Pixel behandelt, die durch die konservative rasterisierung gerengt werden.</span><span class="sxs-lookup"><span data-stu-id="b608f-159">Regardless of the number of samples in **RenderTarget**/**DepthStencil** surfaces (or whether *ForcedSampleCount* is being used or not), all samples are covered for pixels rasterized by Conservative Rasterization.</span></span> <span data-ttu-id="b608f-160">Einzelne Beispiel Speicherorte werden nicht darauf getestet, ob Sie in den primitiven oder nicht.</span><span class="sxs-lookup"><span data-stu-id="b608f-160">Individual sample locations are not tested for whether they fall in the primitive or not.</span></span>

### <a name="samplemask-interaction"></a><span data-ttu-id="b608f-161">Samplemask-Interaktion</span><span class="sxs-lookup"><span data-stu-id="b608f-161">SampleMask interaction</span></span>

<span data-ttu-id="b608f-162">Der Zustand des *samplemask* -Rasterizers wird auf dieselbe Weise angewendet, als wenn die konservative rasterisierung nicht aktiviert ist `InputCoverage` , aber keine Auswirkung hat `InnerCoverage` (d. h. er wird nicht in eine mit deklarierte Eingabe umgewandelt `InnerCoverage` ).</span><span class="sxs-lookup"><span data-stu-id="b608f-162">The *SampleMask* Rasterizer State applies the same way as when Conservative Rasterization is not enabled for `InputCoverage`, but does not affect `InnerCoverage` (i.e. it is not AND’ed into an input declared with `InnerCoverage`).</span></span> <span data-ttu-id="b608f-163">Dies liegt daran, `InnerCoverage` dass nicht mit der Maskierung von MSAA-Beispielen in Beziehung steht: "0" `InnerCoverage` bedeutet nur, dass das Pixel nicht vollständig abgedeckt ist und keine Beispiele aktualisiert werden.</span><span class="sxs-lookup"><span data-stu-id="b608f-163">This is because `InnerCoverage` is unrelated to whether MSAA samples are masked out: 0 `InnerCoverage` only means that the pixel is not guaranteed to be fully covered, not that no samples will be updated.</span></span>

### <a name="depthstencil-test-interaction"></a><span data-ttu-id="b608f-164">Interaktion mit tiefen/Schablone testen</span><span class="sxs-lookup"><span data-stu-id="b608f-164">Depth/Stencil Test interaction</span></span>

<span data-ttu-id="b608f-165">Das Testen der Tiefe/Schablone verläuft für ein konservatives rasterisiertes Pixel auf dieselbe Weise, als wenn alle Stichproben behandelt werden, wenn die konservative rasterisierung nicht aktiviert ist.</span><span class="sxs-lookup"><span data-stu-id="b608f-165">Depth/Stencil Testing proceeds for a conservatively rasterized pixel the same way as if all samples are covered when Conservative Rasterization is not enabled.</span></span>

<span data-ttu-id="b608f-166">Wenn Sie mit allen behandelten Beispielen fortfahren, kann dies zu einer tiefen Extrapolierung führen, die gültig ist und wie angegeben an den Viewport gebunden werden muss, wenn die konservative rasterisierung nicht aktiviert ist.</span><span class="sxs-lookup"><span data-stu-id="b608f-166">Proceeding with all samples covered can cause Depth Extrapolation, which is valid and must be clamped to the viewport as specified when Conservative Rasterization is not enabled.</span></span> <span data-ttu-id="b608f-167">Dies ist vergleichbar mit der Verwendung von Pixelfrequenz-Interpolations Modi für ein **renderTarget** mit einer Stichproben Anzahl von mehr als 1. im Fall von konservativer rasterisierung ist es jedoch der tiefen Wert, der in den tiefen Test für die festgelegte Funktion geht, der extrapoliert werden kann.</span><span class="sxs-lookup"><span data-stu-id="b608f-167">This is similar to when pixel-frequency interpolation modes are used on a **RenderTarget** with sample count greater than 1, although in the case of Conservative Rasterization, it is the depth value going into the fixed function depth test that can be extrapolated.</span></span>

<span data-ttu-id="b608f-168">Das frühe tiefen kulationsverhalten bei tiefen extrapolierungsverhalten ist nicht definiert.</span><span class="sxs-lookup"><span data-stu-id="b608f-168">Early Depth culling behavior with Depth Extrapolation is undefined.</span></span> <span data-ttu-id="b608f-169">Dies ist darauf zurückzuführen, dass einige frühesnapskationshardware die extrapolierten tiefen Werte nicht unterstützen kann</span><span class="sxs-lookup"><span data-stu-id="b608f-169">This is because some Early Depth culling hardware cannot properly support extrapolated depth values.</span></span> <span data-ttu-id="b608f-170">Allerdings ist das frühe Verhalten bei der Tiefe der tiefen extrapolierungsverhalten auch bei Hardware, die extrapolierte tiefen Werte unterstützen kann, problematisch.</span><span class="sxs-lookup"><span data-stu-id="b608f-170">However, Early Depth culling behavior in the presence of Depth Extrapolation is problematic even with hardware that can support extrapolated depth values.</span></span> <span data-ttu-id="b608f-171">Dieses Problem kann umgangen werden, indem die Pixel-Shader-Eingabe Tiefe auf die minimalen und maximalen tiefen Werte des primitiven, das gerachtelert wird, und das Schreiben dieses Werts in `oDepth` (das Pixel-Shader-Ausgabe tiefen Register) geklammert wird.</span><span class="sxs-lookup"><span data-stu-id="b608f-171">This issue can be worked around by clamping the Pixel Shader input depth to the min and max depth values of the primitive being rasterized and writing that value to `oDepth` (the pixel shader output depth register).</span></span> <span data-ttu-id="b608f-172">Zum Deaktivieren der frühen tiefen Erstellung in diesem Fall sind Implementierungen aufgrund des Schreibzugriffs erforderlich `oDepth` .</span><span class="sxs-lookup"><span data-stu-id="b608f-172">Implementations are required to disable Early Depth culling in this case, due to the `oDepth` write.</span></span>

### <a name="helper-pixel-interaction"></a><span data-ttu-id="b608f-173">Hilfspixel Interaktion</span><span class="sxs-lookup"><span data-stu-id="b608f-173">Helper Pixel interaction</span></span>

<span data-ttu-id="b608f-174">Hilfspixel Regeln gelten genauso wie bei nicht aktivierter konservativer rasterisierung.</span><span class="sxs-lookup"><span data-stu-id="b608f-174">Helper Pixel rules apply the same way as when Conservative Rasterization is not enabled.</span></span> <span data-ttu-id="b608f-175">Im Rahmen dieser Angabe müssen alle Pixel, einschließlich `InputCoverage` der Hilfsskripts, genau wie im `InputCoverage` Interaktions Abschnitt angegeben Berichten.</span><span class="sxs-lookup"><span data-stu-id="b608f-175">As part of this, all pixels including Helper Pixels must report `InputCoverage` accurately as specified in the `InputCoverage` interaction section.</span></span> <span data-ttu-id="b608f-176">Die Abdeckung für vollständig nicht abgedeckte Pixel Report 0.</span><span class="sxs-lookup"><span data-stu-id="b608f-176">So fully non-covered pixels report 0 coverage.</span></span>

### <a name="output-coverage-interaction"></a><span data-ttu-id="b608f-177">Interaktion bei der Ausgabe Abdeckung</span><span class="sxs-lookup"><span data-stu-id="b608f-177">Output Coverage interaction</span></span>

<span data-ttu-id="b608f-178">Die Ausgabe Abdeckung ( `oMask` ) verhält sich für ein konrechtes geändertes Pixel, wie dies geschieht, wenn die konservative rasterisierung nicht mit allen behandelten Beispielen aktiviert ist.</span><span class="sxs-lookup"><span data-stu-id="b608f-178">Output Coverage (`oMask`) behaves for a conservatively rasterized pixel as it does when Conservative Rasterization is not enabled with all samples covered.</span></span>

### <a name="inputcoverage-interaction"></a><span data-ttu-id="b608f-179">Inputcoverage-Interaktion</span><span class="sxs-lookup"><span data-stu-id="b608f-179">InputCoverage interaction</span></span>

<span data-ttu-id="b608f-180">Im Modus für die konservative rasterisierung wird dieses Eingabe Register aufgefüllt, als ob alle Stichproben abgedeckt werden, wenn die konservative rasterisierung nicht für ein bestimmtes, Geheimnis geändertes Pixel aktiviert ist.</span><span class="sxs-lookup"><span data-stu-id="b608f-180">In Conservative Rasterization mode, this input register is populated as if all samples are covered when Conservative Rasterization is not enabled for a given conservatively rasterized pixel.</span></span> <span data-ttu-id="b608f-181">Das heißt, dass alle vorhandenen Interaktionen zutreffen (z. b. *samplemask* ), und die ersten n-Bits in `InputCoverage` aus dem lsb werden für ein Modell mit einer geheimnisvollen Schleife auf 1 festgelegt. dabei wird ein n-Beispiel pro Pixel **renderTarget** und/oder **depthstencil** -Puffer, das bei der **Ausgabe** Zusammenführung gebunden ist, bzw</span><span class="sxs-lookup"><span data-stu-id="b608f-181">That is to say, all existing interactions apply (e.g. *SampleMask* is applied), and the first n bits in `InputCoverage` from the LSB are set to 1 for a conservatively rasterized pixel, given an n sample per pixel **RenderTarget** and/or **DepthStencil** buffer bound at the **Output Merger**, or an n sample *ForcedSampleCount*.</span></span> <span data-ttu-id="b608f-182">Der Rest der Bits ist 0 (null).</span><span class="sxs-lookup"><span data-stu-id="b608f-182">The rest of the bits are 0.</span></span>

<span data-ttu-id="b608f-183">Diese Eingabe ist unabhängig von der Verwendung der konservativen rasterisierung in einem Shader verfügbar, obwohl die konservative rasterisierung das Verhalten ändert, sodass nur alle Abtastungen angezeigt werden (oder keine für hilfspixel).</span><span class="sxs-lookup"><span data-stu-id="b608f-183">This input is available in a shader regardless of the use of Conservative Rasterization, though Conservative Rasterization changes its behavior to only show all samples covered (or none for Helper Pixels).</span></span>

### <a name="innercoverage-interaction"></a><span data-ttu-id="b608f-184">Innercoverage-Interaktion</span><span class="sxs-lookup"><span data-stu-id="b608f-184">InnerCoverage interaction</span></span>

<span data-ttu-id="b608f-185">Diese Funktion ist für und nur in, Ebene 3, erforderlich.</span><span class="sxs-lookup"><span data-stu-id="b608f-185">This feature is required by, and only available in, Tier 3.</span></span> <span data-ttu-id="b608f-186">Die Laufzeit schlägt die Shader-Erstellung für Shader fehl, die diesen Modus verwenden, wenn eine Implementierung eine Ebene unterstützt, die kleiner als Ebene 3 ist.</span><span class="sxs-lookup"><span data-stu-id="b608f-186">The runtime will fail shader creation for shaders that use this mode when an implementation supports a Tier less than Tier 3.</span></span>

<span data-ttu-id="b608f-187">Der Pixelshader verfügt über einen 32-Bit-Skalarwert für einen Skalarwert mit skalarem System `InnerCoverage` .</span><span class="sxs-lookup"><span data-stu-id="b608f-187">The Pixel Shader has a 32-bit scalar integer System Generate Value available: `InnerCoverage`.</span></span> <span data-ttu-id="b608f-188">Dabei handelt es sich um ein Bitfeld, das Bit 0 vom lsb auf 1 festgelegt ist, und zwar nur dann, wenn das Pixel sicher vollständig innerhalb des aktuellen primitiven liegt.</span><span class="sxs-lookup"><span data-stu-id="b608f-188">This is a bit-field that has bit 0 from the LSB set to 1 for a given conservatively rasterized pixel, only when that pixel is guaranteed to be entirely inside the current primitive.</span></span> <span data-ttu-id="b608f-189">Alle anderen Eingabe Register Bits müssen auf 0 festgelegt werden, wenn Bit 0 nicht festgelegt ist. Sie sind jedoch nicht definiert, wenn Bit 0 auf 1 festgelegt ist (im Grunde stellt dieses Bitfeld einen booleschen Wert dar, bei dem false genau 0 sein muss. true kann jedoch ein beliebiger Wert (d. h. Bit 0 Set) sein, der ungleich NULL ist.</span><span class="sxs-lookup"><span data-stu-id="b608f-189">All other input register bits must be set to 0 when bit 0 is not set, but are undefined when bit 0 is set to 1 (essentially, this bit-field represents a Boolean value where false must be exactly 0, but true can be any odd (i.e. bit 0 set) non-zero value).</span></span> <span data-ttu-id="b608f-190">Diese Eingabe wird für unterschätzte konservative rasterisierungsinformationen verwendet.</span><span class="sxs-lookup"><span data-stu-id="b608f-190">This input is used for underestimated Conservative Rasterization information.</span></span> <span data-ttu-id="b608f-191">Er informiert den Pixelshader darüber, ob das aktuelle Pixel vollständig innerhalb der Geometrie liegt.</span><span class="sxs-lookup"><span data-stu-id="b608f-191">It informs the Pixel Shader whether the current pixel lies completely inside the geometry.</span></span>

<span data-ttu-id="b608f-192">Dabei muss ein Ausrichtungsfehler bei Auflösungen auftreten, der größer oder gleich der Auflösung ist, in der die aktuelle Zeichnung ausgeführt wird.</span><span class="sxs-lookup"><span data-stu-id="b608f-192">This must account for snapping error at resolutions greater than or equal to the resolution at which the current Draw is operating.</span></span> <span data-ttu-id="b608f-193">Es dürfen keine falsch positiven Ergebnisse auftreten (legen Sie `InnerCoverage` Bits fest, wenn das Pixel nicht vollständig für einen Ausrichtungsfehler bei Auflösungen, die größer oder gleich der Auflösung sind, bei der der aktuelle Zeichnen ausgeführt wird, nicht vollständig abgedeckt ist), aber es sind falsche Negative Werte zulässig.</span><span class="sxs-lookup"><span data-stu-id="b608f-193">There must not be false positives (setting `InnerCoverage` bits when the pixel is not fully covered for any snapping error at resolutions greater than or equal to the resolution at which the current Draw is operating), but false negatives are allowed.</span></span> <span data-ttu-id="b608f-194">Zusammenfassend lässt sich sagen, dass die-Implementierung Pixel nicht fälschlicherweise als vollständig abgedeckte kennzeichnen muss, die nicht mit vollständigen Gleit Komma Koordinaten im Rasterizer zu tun haben.</span><span class="sxs-lookup"><span data-stu-id="b608f-194">In summary, the implementation must not incorrectly identify pixels as fully covered that would not be with full floating point vertex coordinates in the Rasterizer.</span></span>

<span data-ttu-id="b608f-195">Pixel, die vollständig abgedeckt werden, wenn die Hardware vollständige Gleit Komma Koordinaten verwendet, darf nur ausgelassen werden, wenn Sie den inneren unsicheren Bereich überschneiden, der nicht größer als die Größe des unter-Pixel-Rasters oder 1/256 eines Pixels in der Fixed-Point-Domäne sein muss.</span><span class="sxs-lookup"><span data-stu-id="b608f-195">Pixels that would be fully covered if hardware was using full floating point vertex coordinates may only be omitted if they intersect the inner uncertainty region, which must be no larger than the size of the sub-pixel grid, or 1/256 of a pixel, in the fixed point domain.</span></span> <span data-ttu-id="b608f-196">Anders gesagt: Pixel, die sich vollständig innerhalb der inneren Grenze des inneren unsicheren Bereichs befinden, müssen als vollständig abgedeckt gekennzeichnet werden.</span><span class="sxs-lookup"><span data-stu-id="b608f-196">Said another way, pixels entirely within the inner boundary of the inner uncertainty region must be marked as fully covered.</span></span> <span data-ttu-id="b608f-197">Die innere Begrenzung des unsicheren Bereichs wird in der Abbildung unten durch die rote gepunktete Linie dargestellt.</span><span class="sxs-lookup"><span data-stu-id="b608f-197">The inner boundary of the uncertainty region is illustrated in the diagram below by the bold black dotted line.</span></span> <span data-ttu-id="b608f-198">1/256 stammt aus der Koordinaten Darstellung von 16,8 Fixed Point Rasterizer, die sich ändern kann, wenn die Genauigkeit des Rasterizers geändert wird.</span><span class="sxs-lookup"><span data-stu-id="b608f-198">1/256 comes from the 16.8 fixed point Rasterizer coordinate representation, which can change if the Rasterizer precision changes.</span></span> <span data-ttu-id="b608f-199">Diese unsicheren Region ist ausreichend, um den Ausrichtungsfehler zu berücksichtigen, der durch die Konvertierung von Vertex-Gleit Komma Koordinaten in die Scheitelpunkt Koordinaten des Rasterizers verursacht wurde.</span><span class="sxs-lookup"><span data-stu-id="b608f-199">This uncertainty region is enough to account for snapping error caused by the conversion of floating point vertex coordinates to fixed point vertex coordinates in the Rasterizer.</span></span>

<span data-ttu-id="b608f-200">Die gleichen 1/512-Mindestanforderungen hinsichtlich der Ungewissheit, die bei der Interaktion mit der rasterisierungsregeln definiert sind, gelten auch hier.</span><span class="sxs-lookup"><span data-stu-id="b608f-200">The same 1/512 minimum uncertainty region requirements defined in Rasterization Rules interaction apply here as well.</span></span>

<span data-ttu-id="b608f-201">Das folgende Diagramm veranschaulicht einen gültigen inneren unsicheren Bereich, der durch das Durchlaufen eines Quadrats um die Ränder des primitiven in der Fixed-Point-Domäne erzeugt wird (d. h., die Scheitel Punkte wurden mit der 16,8-fest Komma Darstellung quantifisiert).</span><span class="sxs-lookup"><span data-stu-id="b608f-201">The following diagram illustrates a valid inner uncertainty region produced by sweeping a square around the edges of the primitive in the fixed point domain (i.e. the vertices have been quantized by the 16.8 fixed point representation).</span></span> <span data-ttu-id="b608f-202">Die Abmessungen dieses Quadrats basieren auf der gültigen Regions Größe für die innere Ungewissheit: für 1/256 eines Pixels ist das Quadrat 1/128 eines Pixels in Breite und Höhe.</span><span class="sxs-lookup"><span data-stu-id="b608f-202">The dimensions of this square are based on the valid inner uncertainty region size: for 1/256 of a pixel, the square is 1/128 of a pixel in width and height.</span></span> <span data-ttu-id="b608f-203">Das grüne Dreieck stellt ein bestimmtes primitiv dar, die fettrote gepunktete Linie stellt die Grenze des inneren unsicheren Bereichs dar, die schwarzen Quadrate stellen das Quadrat dar, das entlang der primitiven Ränder gezogen wird, und der Orange aktivierte Bereich ist der innere unsicher-Bereich:</span><span class="sxs-lookup"><span data-stu-id="b608f-203">The green triangle represents a given primitive, the bold black dotted line represents the boundary of the inner uncertainty region, the solid black squares represent the square that is swept along the primitive edges, and the orange checkered area is the inner uncertainty region:</span></span>

![reqion der inneren Ungewissheit.](images/innercoverage.jpg)

<span data-ttu-id="b608f-205">Die Verwendung von wirkt sich nicht darauf aus `InnerCoverage` , ob ein Pixel konservativ rasteriert ist, d. h., die Verwendung eines dieser Modi wirkt sich nicht darauf aus, `InputCoverage` welche Pixel gerengt werden, wenn der konservative rasterisierungsmodus aktiviert ist.</span><span class="sxs-lookup"><span data-stu-id="b608f-205">The use of `InnerCoverage` does not affect whether a pixel is conservatively rasterized, i.e. using one of these `InputCoverage` modes does not affect which pixels are rasterized when Conservative Rasterization mode is enabled.</span></span> <span data-ttu-id="b608f-206">Wenn `InnerCoverage` verwendet wird und der Pixelshader ein Pixel verarbeitet, das von der Geometrie nicht vollständig abgedeckt ist, ist der Wert 0, aber für den Pixelshader-Aufruf werden Beispiele aktualisiert.</span><span class="sxs-lookup"><span data-stu-id="b608f-206">Therefore, when `InnerCoverage` is used and the Pixel Shader is processing a pixel that is not completely covered by the geometry its value will be 0, but the Pixel Shader invocation will have samples updated.</span></span> <span data-ttu-id="b608f-207">Dies unterscheidet sich von, wenn 0 (null) `InputCoverage` ist, was bedeutet, dass keine Beispiele aktualisiert werden.</span><span class="sxs-lookup"><span data-stu-id="b608f-207">This is different from when `InputCoverage` is 0, meaning that no samples will be updated.</span></span>

<span data-ttu-id="b608f-208">Diese Eingabe schließt sich gegenseitig aus `InputCoverage` : beide können nicht verwendet werden.</span><span class="sxs-lookup"><span data-stu-id="b608f-208">This input is mutually exclusive with `InputCoverage` : both cannot be used.</span></span>

<span data-ttu-id="b608f-209">Für den Zugriff auf `InnerCoverage` muss Sie als einzelne Komponente aus einem der Pixel-Shader-Eingabe Register deklariert werden.</span><span class="sxs-lookup"><span data-stu-id="b608f-209">To access `InnerCoverage`, it must be declared as a single component out of one of the Pixel Shader input registers.</span></span> <span data-ttu-id="b608f-210">Der Interpolations Modus für die Deklaration muss konstant sein (Interpolation ist nicht anwendbar).</span><span class="sxs-lookup"><span data-stu-id="b608f-210">The interpolation mode on the declaration must be constant (interpolation does not apply).</span></span>

<span data-ttu-id="b608f-211">Das `InnerCoverage` Bitfeld wirkt sich nicht auf tiefen-und Schablonen Tests aus, und es ist nicht mit dem *samplemask* -Rasterizer-Zustand verknüpft.</span><span class="sxs-lookup"><span data-stu-id="b608f-211">The `InnerCoverage` bit-field is not affected by depth/stencil tests, nor is it ANDed with the *SampleMask* Rasterizer state.</span></span>

<span data-ttu-id="b608f-212">Diese Eingabe ist nur im konservativen rasterisierungsmodus gültig.</span><span class="sxs-lookup"><span data-stu-id="b608f-212">This input is only valid in Conservative Rasterization mode.</span></span> <span data-ttu-id="b608f-213">Wenn die konservative rasterisierung nicht aktiviert ist, `InnerCoverage` erzeugt einen nicht definierten Wert.</span><span class="sxs-lookup"><span data-stu-id="b608f-213">When Conservative Rasterization is not enabled, `InnerCoverage` produces an undefined value.</span></span>

<span data-ttu-id="b608f-214">Bei Pixeln-Shader-aufrufen, die durch die Notwendigkeit von Hilfsskripts verursacht werden, aber andernfalls nicht durch die primitive abgedeckt werden, muss das `InnerCoverage` Register auf 0 festgelegt sein.</span><span class="sxs-lookup"><span data-stu-id="b608f-214">Pixel Shader invocations caused by the need for Helper Pixels, but otherwise not covered by the primitive, must have the `InnerCoverage` register set to 0.</span></span>

### <a name="attribute-interpolation-interaction"></a><span data-ttu-id="b608f-215">Interaktion mit Attribut Interpolations</span><span class="sxs-lookup"><span data-stu-id="b608f-215">Attribute Interpolation interaction</span></span>

<span data-ttu-id="b608f-216">Die Attribut Interpolations Modi sind unverändert und werden auf dieselbe Weise fortgesetzt, wenn die konservative rasterisierung nicht aktiviert ist, in der die mit Viewports skalierten und mit einem Punkt konvertierten Vertices verwendet werden.</span><span class="sxs-lookup"><span data-stu-id="b608f-216">Attribute interpolation modes are unchanged and proceed the same way as when Conservative Rasterization is not enabled, where the viewport-scaled and fixed-point-converted vertices are used.</span></span> <span data-ttu-id="b608f-217">Da alle Beispiele in einem konservativ erfassten Pixel als abgedeckt angesehen werden, ist es für Werte gültig, die extrapoliert werden, ähnlich wie bei Verwendung von Pixel-Frequency-Interpolations Modi für ein **renderTarget** mit einer Stichproben Anzahl von mehr als 1.</span><span class="sxs-lookup"><span data-stu-id="b608f-217">Because all samples in a conservatively rasterized pixel are considered covered, it is valid for values to be extrapolated, similar to when pixel-frequency interpolation modes are used on a **RenderTarget** with sample count greater than 1.</span></span> <span data-ttu-id="b608f-218">Centroid-Interpolations Modi liefern Ergebnisse, die mit dem entsprechenden nicht-Centroid-Interpolations Modus identisch sind. Das Konzept von "Schwerpunkt" ist in diesem Szenario bedeutungslos – wobei die Stichproben Abdeckung nur "Full" oder "0" ist.</span><span class="sxs-lookup"><span data-stu-id="b608f-218">Centroid interpolation modes produce results identical to the corresponding non-centroid interpolation mode; the notion of centroid is meaningless in this scenario – where sample coverage is only either full or 0.</span></span>

<span data-ttu-id="b608f-219">Durch die konservative rasterisierung können degenerierte Dreiecke zum Generieren von PixelShader-Aufrufen verwendet werden. Daher müssen degenerierte Dreiecke die Werte, die Vertex 0 zugewiesen sind, für alle interinterpolierten Werte verwenden.</span><span class="sxs-lookup"><span data-stu-id="b608f-219">Conservative Rasterization allows for degenerate triangles to produce Pixel Shader invocations, therefore, degenerate triangles must use the values assigned to Vertex 0 for all interpolated values.</span></span>

### <a name="clipping-interaction"></a><span data-ttu-id="b608f-220">Clipping-Interaktion</span><span class="sxs-lookup"><span data-stu-id="b608f-220">Clipping interaction</span></span>

<span data-ttu-id="b608f-221">Wenn der konservative rasterisierungsmodus aktiviert und der tiefen Clip deaktiviert ist (wenn der Status des *depthcliutable* -Rasterizers auf false festgelegt ist), es gibt möglicherweise Abweichungen in der Attribut Interpolation für Segmente eines primitiven, die außerhalb des Bereichs 0 <= z <= w liegen, abhängig von der Implementierung: entweder werden Konstante Werte von einem Punkt verwendet, an dem die primitive die relevante Ebene (fast oder weit) überschneidet, oder die Attribut Interpolation verhält sich so, als wäre der konservative rasterisierungsmodus deaktiviert.</span><span class="sxs-lookup"><span data-stu-id="b608f-221">When Conservative Rasterization mode is enabled and depth clip is disabled (when the *DepthClipEnable* Rasterizer State is set to FALSE), there may be variances in attribute interpolation for segments of a primitive that fall outside the 0 <= z <= w range, depending on implementation: either constant values are used from a point where the primitive intersects the relevant plane (near or far), or attribute interpolation behaves as when Conservative Rasterization mode is disabled.</span></span> <span data-ttu-id="b608f-222">Allerdings ist das Verhalten des tiefen Werts unabhängig vom Modus für die konservative rasterisierung identisch, d. h., dass primitive, die außerhalb des tiefen Bereichs liegen, immer noch den Wert des nächsten Limits für den Bereich der viewporttiefe erhalten müssen.</span><span class="sxs-lookup"><span data-stu-id="b608f-222">However, the depth value behavior is the same regardless of Conservative Rasterization mode, i.e. primitives that fall outside of the depth range must still be given the value of the nearest limit of the viewport depth range.</span></span> <span data-ttu-id="b608f-223">Das Attribut Interpolations Verhalten im Bereich 0 <= z <= w muss unverändert bleiben.</span><span class="sxs-lookup"><span data-stu-id="b608f-223">Attribute interpolation behavior inside the 0 <= z <= w range must remain unchanged.</span></span>

### <a name="clip-distance-interaction"></a><span data-ttu-id="b608f-224">Interaktion bei Clip Distanz</span><span class="sxs-lookup"><span data-stu-id="b608f-224">Clip Distance interaction</span></span>

<span data-ttu-id="b608f-225">Die Clip-Distanz ist gültig, wenn der konservative rasterisierungsmodus aktiviert ist, und sich für ein konkales rasterisiertes Pixel verhält, wie es der Fall ist, wenn die konservative rasterisierung nicht mit allen behandelten Beispielen aktiviert ist.</span><span class="sxs-lookup"><span data-stu-id="b608f-225">Clip Distance is valid when Conservative Rasterization mode is enabled, and behaves for a conservatively rasterized pixel as it does when Conservative Rasterization is not enabled with all samples covered.</span></span>

<span data-ttu-id="b608f-226">Beachten Sie, dass die konservative rasterisierung eine Extrapolierung der w-Scheitelpunkt Koordinate verursachen kann, was zu einer w <= 0 führen kann.</span><span class="sxs-lookup"><span data-stu-id="b608f-226">Note that Conservative Rasterization can cause extrapolation of the W vertex coordinate, which may cause W <= 0.</span></span> <span data-ttu-id="b608f-227">Dies könnte dazu führen, dass pro-Pixel-Clip Entfernungs Implementierungen auf eine Clip Distanz angewendet werden, die durch einen ungültigen W-Wert geteilt wurde.</span><span class="sxs-lookup"><span data-stu-id="b608f-227">This could cause per-pixel Clip Distance implementations to operate on a Clip Distance that has been Perspective Divided by an invalid W value.</span></span> <span data-ttu-id="b608f-228">Clip Entfernungs Implementierungen müssen vor dem Aufruf von Rasterung für Pixel stehen, bei denen die Vertex-Koordinate <= 0 (z. b. aufgrund der Extrapolierung im Modus für die konservative rasterisierung).</span><span class="sxs-lookup"><span data-stu-id="b608f-228">Clip Distance implementations must guard against invoking rasterization for pixels where vertex coordinate W <= 0 (e.g. due to extrapolation when in Conservative Rasterization mode).</span></span>

### <a name="target-independent-rasterization-interaction"></a><span data-ttu-id="b608f-229">Ziel unabhängige rasterisierungsinteraktion</span><span class="sxs-lookup"><span data-stu-id="b608f-229">Target Independent Rasterization interaction</span></span>

<span data-ttu-id="b608f-230">Der konservative rasterisierungsmodus ist mit der Ziel unabhängigen rasterization (TIR) kompatibel.</span><span class="sxs-lookup"><span data-stu-id="b608f-230">Conservative Rasterization mode is compatible with Target Independent Rasterization (TIR).</span></span> <span data-ttu-id="b608f-231">Es gelten die TIR-Regeln und-Einschränkungen, die sich für ein konservatives rasterisiertes Pixel Verhalten, als ob alle Stichproben abgedeckt werden.</span><span class="sxs-lookup"><span data-stu-id="b608f-231">TIR rules and restrictions apply, behaving for a conservatively rasterized pixel as if all samples are covered.</span></span>

### <a name="ia-primitive-topology-interaction"></a><span data-ttu-id="b608f-232">Interaktion mit primitiver Topologie</span><span class="sxs-lookup"><span data-stu-id="b608f-232">IA Primitive Topology interaction</span></span>

<span data-ttu-id="b608f-233">Die konservative rasterisierung ist für Zeilen-oder Punkt primitiven nicht definiert.</span><span class="sxs-lookup"><span data-stu-id="b608f-233">Conservative Rasterization is not defined for line or point primitives.</span></span> <span data-ttu-id="b608f-234">Daher wird durch primitive Topologien, die Punkte oder Zeilen angeben, ein nicht definiertes Verhalten erzeugt, wenn Sie in die Raster-Einheit eingespeist werden, wenn die konservative rasterisierung aktiviert ist.</span><span class="sxs-lookup"><span data-stu-id="b608f-234">Therefore, Primitive Topologies that specify points or lines produce undefined behavior if they are fed to the rasterizer unit when Conservative Rasterization is enabled.</span></span>

<span data-ttu-id="b608f-235">Die debugebenenvalidierung überprüft, ob Anwendungen diese primitiven Topologien nicht verwenden.</span><span class="sxs-lookup"><span data-stu-id="b608f-235">The debug layer validation verifies applications do not use these Primitive Topologies.</span></span>

### <a name="query-interaction"></a><span data-ttu-id="b608f-236">Abfrage Interaktion</span><span class="sxs-lookup"><span data-stu-id="b608f-236">Query interaction</span></span>

<span data-ttu-id="b608f-237">Für ein konformisch Erfassungs Endes Pixel Verhalten sich die Abfragen so, wie Sie es tun, wenn die konservative rasterisierung nicht aktiviert ist, wenn alle Stichproben abgedeckt werden.</span><span class="sxs-lookup"><span data-stu-id="b608f-237">For a conservatively rasterized pixel, queries behave as they do when Conservative Rasterization is not enabled when all samples are covered.</span></span> <span data-ttu-id="b608f-238">Beispielsweise müssen Sie für ein konformes rasterisiertes Pixel das D3D12 \_ \_ \_ -Abfragetyp-oksion und den D3D12- \_ \_ \_ Abfragetyp Pipeline \_ Statistiken (aus [**D3D12- \_ Abfragetyp \_**](/windows/desktop/api/d3d12/ne-d3d12-d3d12_query_type)) so Verhalten, als würden die konservative rasterisierung nicht aktiviert, wenn alle Stichproben abgedeckt werden.</span><span class="sxs-lookup"><span data-stu-id="b608f-238">For example, for a conservatively rasterized pixel, D3D12\_QUERY\_TYPE\_OCCLUSION and D3D12\_QUERY\_TYPE\_PIPELINE\_STATISTICS (from [**D3D12\_QUERY\_TYPE**](/windows/desktop/api/d3d12/ne-d3d12-d3d12_query_type)) must behave as they would when Conservative Rasterization is not enabled when all samples are covered.</span></span>

<span data-ttu-id="b608f-239">Pixel-Shader-Aufrufe sollten für jedes im konservativ aufgeblenierte Pixel im konservativen rasterisierungsmodus erhöht werden.</span><span class="sxs-lookup"><span data-stu-id="b608f-239">Pixel Shader invocations should increment for every conservatively rasterized pixel in Conservative Rasterization mode.</span></span>

### <a name="cull-state-interaction"></a><span data-ttu-id="b608f-240">Interaktionsinteraktion</span><span class="sxs-lookup"><span data-stu-id="b608f-240">Cull State interaction</span></span>

<span data-ttu-id="b608f-241">Alle Statusangaben sind im Modus für die konservative rasterisierung gültig und befolgen dieselben Regeln wie bei aktivierter konservativer rasterisierung.</span><span class="sxs-lookup"><span data-stu-id="b608f-241">All Cull States are valid in Conservative Rasterization mode and follow the same rules as when Conservative Rasterization is not enabled.</span></span>

<span data-ttu-id="b608f-242">Wenn Sie die konservative rasterisierung über Auflösungen mit sich selbst oder ohne die konservative rasterisierung hinweg vergleichen, besteht die Möglichkeit, dass einige primitive eine nicht übereinstimmende faktigkeit aufweisen (d. h. ein Back-End, die andere Vorderseite).</span><span class="sxs-lookup"><span data-stu-id="b608f-242">When comparing Conservative Rasterization across resolutions to itself or without Conservative Rasterization enabled, there is the possibility that some primitives may have mismatched facedness (i.e. one back facing, the other front facing).</span></span> <span data-ttu-id="b608f-243">Anwendungen können diese Ungewissheit vermeiden, indem Sie D3D12 \_ cull \_ Mode \_ None (aus dem [**D3D12 \_ cull- \_ Modus**](/windows/desktop/api/d3d12/ne-d3d12-d3d12_cull_mode)) verwenden und nicht den vom `IsFrontFace` System generierten Wert verwenden.</span><span class="sxs-lookup"><span data-stu-id="b608f-243">Applications can avoid this uncertainty by using D3D12\_CULL\_MODE\_NONE (from [**D3D12\_CULL\_MODE**](/windows/desktop/api/d3d12/ne-d3d12-d3d12_cull_mode)) and not using the `IsFrontFace` System Generated Value.</span></span>

### <a name="isfrontface-interaction"></a><span data-ttu-id="b608f-244">Isfrontface-Interaktion</span><span class="sxs-lookup"><span data-stu-id="b608f-244">IsFrontFace interaction</span></span>

<span data-ttu-id="b608f-245">Der vom `IsFrontFace` System generierte Wert ist für die Verwendung im konservativen rasterisierungsmodus gültig und folgt dem Verhalten, das definiert ist, wenn die konservative rasterisierung nicht aktiviert ist.</span><span class="sxs-lookup"><span data-stu-id="b608f-245">The `IsFrontFace` System Generated Value is valid to use in Conservative Rasterization mode, and follows the behavior defined when Conservative Rasterization is not enabled.</span></span>

### <a name="fill-modes-interaction"></a><span data-ttu-id="b608f-246">Interaktion mit Füll Modi</span><span class="sxs-lookup"><span data-stu-id="b608f-246">Fill Modes interaction</span></span>

<span data-ttu-id="b608f-247">Der einzige gültige [**D3D12 \_ - \_ Füllmodus**](/windows/desktop/api/d3d12/ne-d3d12-d3d12_fill_mode) für die konservative rasterisierung ist D3D12 \_ Fill \_ Solid, jeder andere Füll Modus ist ein ungültiger Parameter für den Status des Rasterizers.</span><span class="sxs-lookup"><span data-stu-id="b608f-247">The only valid [**D3D12\_FILL\_MODE**](/windows/desktop/api/d3d12/ne-d3d12-d3d12_fill_mode) for Conservative Rasterization is D3D12\_FILL\_SOLID, any other fill mode is an invalid parameter for the Rasterizer State.</span></span>

<span data-ttu-id="b608f-248">Dies liegt daran, dass die D3D12-Funktionsspezifikation angibt, dass der Draht Modell-Füllmodus Dreiecks Ränder in Linien konvertieren und die zeilenrasterisierungsregeln und das Verhalten der konservativen Zeilen rasterisierung nicht definiert wurde.</span><span class="sxs-lookup"><span data-stu-id="b608f-248">This is because D3D12 functional specification specifies that wireframe fill mode should convert triangle edges to lines and follow the line rasterization rules and conservative line rasterization behavior has not been defined.</span></span>

## <a name="implementation-details"></a><span data-ttu-id="b608f-249">Details zur Implementierung</span><span class="sxs-lookup"><span data-stu-id="b608f-249">Implementation details</span></span>

<span data-ttu-id="b608f-250">Der Typ der in Direct3D 12 unterstützten rasterisierung wird manchmal als "überschätzte konservative rasterisierung" bezeichnet.</span><span class="sxs-lookup"><span data-stu-id="b608f-250">The type of rasterization supported in Direct3D 12 is sometimes referred to as "Overestimated Conservative Rasterization".</span></span> <span data-ttu-id="b608f-251">Es gibt auch das Konzept der "unterschätzten konservative rasterisierung", was bedeutet, dass nur Pixel, die vollständig von einem gerenderten primitiven abgedeckt werden, rasterisiert werden.</span><span class="sxs-lookup"><span data-stu-id="b608f-251">There is also the concept of "Underestimated Conservative Rasterization", which means that only pixels that are fully covered by a rendered primitive are rasterized.</span></span> <span data-ttu-id="b608f-252">Unterschätzte konservative rasterisierungsinformationen sind über den Pixelshader durch die Verwendung von Eingabe Abdeckungs Daten verfügbar, und nur die überschätzte konservative rasterisierung ist als rasterisierungsmodus verfügbar.</span><span class="sxs-lookup"><span data-stu-id="b608f-252">Underestimated Conservative Rasterization information is available through the pixel shader through the use of input coverage data, and only overestimated Conservative Rasterization is available as a rasterizing mode.</span></span>

<span data-ttu-id="b608f-253">Wenn ein beliebiger Teil eines primitiven ein Pixel überlappt, wird dieses Pixel als abgedeckt betrachtet und dann rasteriert.</span><span class="sxs-lookup"><span data-stu-id="b608f-253">If any part of a primitive overlaps a pixel, then that pixel is considered covered and is then rasterized.</span></span> <span data-ttu-id="b608f-254">Wenn ein Rand oder eine Ecke eines primitiven entlang der Kante oder Ecke eines Pixels fällt, ist die Anwendung der "Top-Left-Regel" Implementierungs spezifisch.</span><span class="sxs-lookup"><span data-stu-id="b608f-254">When an edge or corner of a primitive falls along the edge or corner of a pixel, the application of the "top-left rule" is implementation-specific.</span></span> <span data-ttu-id="b608f-255">Bei Implementierungen, die degenerierte Dreiecke unterstützen, muss ein degeneriertes Dreieck an einer Kante oder Ecke jedoch mindestens ein Pixel abdecken.</span><span class="sxs-lookup"><span data-stu-id="b608f-255">However, for implementations that support degenerate triangles, a degenerate triangle along an edge or corner must cover at least one pixel.</span></span>

<span data-ttu-id="b608f-256">Konservative rasterization-Implementierungen können sich auf unterschiedlichen Hardware unterscheiden, und es werden falsche positiv Ergebnisse erzeugt. Dies bedeutet, dass Sie fälschlicherweise festlegen können, dass Pixel abgedeckt werden.</span><span class="sxs-lookup"><span data-stu-id="b608f-256">Conservative Rasterization implementations can vary on different hardware, and do produce false positives, meaning that they can incorrectly decide that pixels are covered.</span></span> <span data-ttu-id="b608f-257">Dies kann aufgrund von Implementierungs spezifischen Details auftreten, wie z. b. primitive ansteigende oder Ausrichtungsfehler, die in den in der rasterisierung verwendeten festen Punkt Vertex-Koordinaten enthalten sind.</span><span class="sxs-lookup"><span data-stu-id="b608f-257">This can occur because of implementation-specific details like primitive growing or snapping errors inherent in the fixed-point vertex coordinates used in rasterization.</span></span> <span data-ttu-id="b608f-258">Der Grund, warum falsch positive Ergebnisse (in Bezug auf Scheitelpunkt Koordinaten mit festem Punkt) gültig sind, liegt darin, dass einige falsch positive Ergebnisse erforderlich sind, damit eine Implementierung die Abdeckungs Auswertung für nach gestellte Scheitel Punkte (d. h. vertexkoordinaten, die von Gleit Komma Zahlen in den in der Rasterizer verwendeten Fixed-Punkt 16,8 konvertiert wurden, berücksichtigen jedoch die Abdeckung, die von den ursprünglichen Gleit Komma Koordinaten des Vertex erzeugt wurde.</span><span class="sxs-lookup"><span data-stu-id="b608f-258">The reason false positives (with respect to fixed point vertex coordinates) are valid is because some amount of false positives are needed to allow an implementation to do coverage evaluation against post-snapped vertices (i.e. vertex coordinates that have been converted from floating point to the 16.8 fixed-point used in the rasterizer), but honor the coverage produced by the original floating point vertex coordinates.</span></span>

<span data-ttu-id="b608f-259">Konservative rasterization-Implementierungen generieren keine falschen negativen in Bezug auf die Vertex-Gleit Komma Koordinaten für nicht degenerierte Post-Snap-primitive: Wenn ein beliebiger Teil eines primitiven einen Teil eines Pixels überlappt, wird dieses Pixel rasteriert.</span><span class="sxs-lookup"><span data-stu-id="b608f-259">Conservative Rasterization implementations do not produce false negatives with respect to the floating-point vertex coordinates for non-degenerate post-snap primitives: if any part of a primitive overlaps any part of a pixel, then that pixel is rasterized.</span></span>

<span data-ttu-id="b608f-260">Dreiecke, die deseriell sind (doppelte Indizes in einem Index Puffer oder kollinear in 3D) oder nach der fest Komma Konvertierung (kollinear Vertices in the Rasterizer) deseriell werden. Beide sind ein gültiges Verhalten.</span><span class="sxs-lookup"><span data-stu-id="b608f-260">Triangles that are degenerate (duplicate indices in an index buffer or collinear in 3D), or become degenerate after fixed-point conversion (collinear vertices in the rasterizer), may or may not be culled; both are valid behaviors.</span></span> <span data-ttu-id="b608f-261">Degenerierte Dreiecke müssen als "zurück" betrachtet werden. Wenn also ein bestimmtes Verhalten für eine Anwendung erforderlich ist, kann es die Hintergrund Erkennung oder den Test für die Vorderseite verwenden.</span><span class="sxs-lookup"><span data-stu-id="b608f-261">Degenerate triangles must be considered back facing, so if a specific behavior is required by an application, it can use back-face culling or test for front facing.</span></span> <span data-ttu-id="b608f-262">Degenerierte Dreiecke verwenden die den Scheitel Punkten 0 zugewiesenen Werte für alle interpoliert-Werte.</span><span class="sxs-lookup"><span data-stu-id="b608f-262">Degenerate triangles use the values assigned to Vertex 0 for all interpolated values.</span></span>

<span data-ttu-id="b608f-263">Es gibt drei Ebenen von Hardwareunterstützung, zusätzlich zur Möglichkeit, dass die Hardware dieses Feature nicht unterstützt.</span><span class="sxs-lookup"><span data-stu-id="b608f-263">There are three tiers of hardware support, in addition to the possibility that the hardware does not support this feature.</span></span>

-   <span data-ttu-id="b608f-264">Ebene 1 erzwingt einen maximalen Bereich von 1/2 Pixel Unsicherheit und unterstützt nicht die Post-Snap-Degenerierung.</span><span class="sxs-lookup"><span data-stu-id="b608f-264">Tier 1 enforces a maximum 1/2 pixel uncertainty region and does not support post-snap degenerates.</span></span> <span data-ttu-id="b608f-265">Dies eignet sich gut für das gekachelte Rendering, einen Textur Atlas, eine Licht Zuordnungs Generierung und unter Pixel Schatten Zuordnungen.</span><span class="sxs-lookup"><span data-stu-id="b608f-265">This is good for tiled rendering, a texture atlas, light map generation and sub-pixel shadow maps.</span></span>
-   <span data-ttu-id="b608f-266">Ebene 2 reduziert den Bereich für die maximale Anzahl von Unsicherheiten auf 1/256 und erfordert, dass Post-Snap-Ins nicht durchgeführt werden.</span><span class="sxs-lookup"><span data-stu-id="b608f-266">Tier 2 reduces the maximum uncertainty region to 1/256 and requires post-snap degenerates not be culled.</span></span> <span data-ttu-id="b608f-267">Diese Ebene ist für die CPU-basierte Beschleunigung der Algorithmen (z. b. voxelization) hilfreich.</span><span class="sxs-lookup"><span data-stu-id="b608f-267">This tier is helpful for CPU-based algorithm acceleration (such as voxelization).</span></span>
-   <span data-ttu-id="b608f-268">Ebene 3 behält einen maximalen Bereich von 1/256-Unsicherheiten bei und bietet Unterstützung für die innere Eingabe Abdeckung.</span><span class="sxs-lookup"><span data-stu-id="b608f-268">Tier 3 maintains a maximum 1/256 uncertainty region and adds support for inner input coverage.</span></span> <span data-ttu-id="b608f-269">Die innere Eingabe Abdeckung fügt den neuen Wert der `SV_InnerCoverage` High Level Shading Language (HLSL) hinzu.</span><span class="sxs-lookup"><span data-stu-id="b608f-269">Inner input coverage adds the new value `SV_InnerCoverage` to High Level Shading Language (HLSL).</span></span> <span data-ttu-id="b608f-270">Dies ist eine ganzzahlige 32-Bit-Ganzzahl, die für die Eingabe an einen PixelShader angegeben werden kann, und stellt die unterschätzten Informationen zur konservativen rasterisierung dar (d. h., ob ein Pixel garantiert vollständig abgedeckt ist).</span><span class="sxs-lookup"><span data-stu-id="b608f-270">This is a 32-bit scalar integer that can be specified on input to a pixel shader, and represents the underestimated Conservative Rasterization information (that is, whether a pixel is guaranteed-to-be-fully covered).</span></span> <span data-ttu-id="b608f-271">Diese Ebene ist für die Verschleierung von Okklusion hilfreich.</span><span class="sxs-lookup"><span data-stu-id="b608f-271">This tier is helpful for occlusion culling.</span></span>

## <a name="api-summary"></a><span data-ttu-id="b608f-272">API-Zusammenfassung</span><span class="sxs-lookup"><span data-stu-id="b608f-272">API summary</span></span>

<span data-ttu-id="b608f-273">Die folgenden Methoden, Strukturen, Enumerationsklassen und Hilfsklassen verweisen auf die konservative rasterisierung:</span><span class="sxs-lookup"><span data-stu-id="b608f-273">The following methods, structures, enums, and helper classes reference Conservative Rasterization:</span></span>

-   <span data-ttu-id="b608f-274">[**D3D12 \_ Raster \_**](/windows/desktop/api/d3d12/ns-d3d12-d3d12_rasterizer_desc) -Debug: Struktur mit der Beschreibung des Rasterizers.</span><span class="sxs-lookup"><span data-stu-id="b608f-274">[**D3D12\_RASTERIZER\_DESC**](/windows/desktop/api/d3d12/ns-d3d12-d3d12_rasterizer_desc) : structure holding the rasterizer description.</span></span>
-   <span data-ttu-id="b608f-275">[**D3D12 \_ Konservativer \_ rasterisierungsmodus \_**](/windows/desktop/api/d3d12/ne-d3d12-d3d12_conservative_rasterization_mode) : Enumeration-Werte für den Modus (ein oder aus).</span><span class="sxs-lookup"><span data-stu-id="b608f-275">[**D3D12\_CONSERVATIVE\_RASTERIZATION\_MODE**](/windows/desktop/api/d3d12/ne-d3d12-d3d12_conservative_rasterization_mode) : enum values for the mode (on or off).</span></span>
-   <span data-ttu-id="b608f-276">[**D3D12 \_ Feature \_ Data \_ D3D12 \_ Optionen**](/windows/desktop/api/d3d12/ns-d3d12-d3d12_feature_data_d3d12_options) : Struktur, die die Ebene der Unterstützung enthält.</span><span class="sxs-lookup"><span data-stu-id="b608f-276">[**D3D12\_FEATURE\_DATA\_D3D12\_OPTIONS**](/windows/desktop/api/d3d12/ns-d3d12-d3d12_feature_data_d3d12_options) : structure holding the tier of support.</span></span>
-   <span data-ttu-id="b608f-277">[**D3D12 \_ Konservative \_ rasterization- \_ Ebene**](/windows/desktop/api/d3d12/ne-d3d12-d3d12_conservative_rasterization_tier) : Enumerationswerte für jede Ebene der Unterstützung durch die Hardware.</span><span class="sxs-lookup"><span data-stu-id="b608f-277">[**D3D12\_CONSERVATIVE\_RASTERIZATION\_TIER**](/windows/desktop/api/d3d12/ne-d3d12-d3d12_conservative_rasterization_tier) : enum values for each tier of support by the hardware.</span></span>
-   <span data-ttu-id="b608f-278">[**Checkfeaturesupport**](/windows/desktop/api/d3d12/nf-d3d12-id3d12device-checkfeaturesupport) : Methode für den Zugriff auf die unterstützten Funktionen.</span><span class="sxs-lookup"><span data-stu-id="b608f-278">[**CheckFeatureSupport**](/windows/desktop/api/d3d12/nf-d3d12-id3d12device-checkfeaturesupport) : method to access the supported features.</span></span>
-   <span data-ttu-id="b608f-279">[**CD3DX12 \_ Raster \_ DESC**](cd3dx12-rasterizer-desc.md) : Hilfsklasse zum Erstellen von Raster-Beschreibungen.</span><span class="sxs-lookup"><span data-stu-id="b608f-279">[**CD3DX12\_RASTERIZER\_DESC**](cd3dx12-rasterizer-desc.md) : helper class for creating rasterizer descriptions.</span></span>

## <a name="related-topics"></a><span data-ttu-id="b608f-280">Verwandte Themen</span><span class="sxs-lookup"><span data-stu-id="b608f-280">Related topics</span></span>

<dl> <dt>

[<span data-ttu-id="b608f-281">Video-Tutorials zu DirectX Advanced Learning: konservative rasterization</span><span class="sxs-lookup"><span data-stu-id="b608f-281">DirectX advanced learning video tutorials : Conservative Rasterization</span></span>](https://www.youtube.com/watch?v=zL0oSY_YmDY)
</dt> <dt>

[<span data-ttu-id="b608f-282">Geordnete Ansichten des Rasterizers</span><span class="sxs-lookup"><span data-stu-id="b608f-282">Rasterizer Ordered Views</span></span>](rasterizer-order-views.md)
</dt> <dt>

[<span data-ttu-id="b608f-283">Darstellung</span><span class="sxs-lookup"><span data-stu-id="b608f-283">Rendering</span></span>](rendering.md)
</dt> </dl>

 

 




