---
description: Programmieren von DirectX mit com.
title: Programmieren von DirectX mit com
ms.topic: article
ms.date: 01/29/2019
ms.openlocfilehash: 67fc7a35f42439e1a9eeef1b2895d88dc0dbf5d4
ms.sourcegitcommit: f712e5fed19d6afe2762a77ffcdf8b5977f85901
ms.translationtype: MT
ms.contentlocale: de-DE
ms.lasthandoff: 01/26/2021
ms.locfileid: "103961037"
---
# <a name="programming-directx-with-com"></a><span data-ttu-id="fb22d-103">Programmieren von DirectX mit com</span><span class="sxs-lookup"><span data-stu-id="fb22d-103">Programming DirectX with COM</span></span>

<span data-ttu-id="fb22d-104">Beim Microsoft-Component Object Model (com) handelt es sich um ein objektorientiertes Programmiermodell, das von verschiedenen Technologien verwendet wird, einschließlich des Massen Vorgangs der DirectX-API-Oberfläche.</span><span class="sxs-lookup"><span data-stu-id="fb22d-104">The Microsoft Component Object Model (COM) is an object-oriented programming model used by several technologies, including the bulk of the DirectX API surface.</span></span> <span data-ttu-id="fb22d-105">Aus diesem Grund verwenden Sie (als DirectX-Entwickler) beim Programmieren von DirectX unweigerlich com.</span><span class="sxs-lookup"><span data-stu-id="fb22d-105">For that reason, you (as a DirectX developer) inevitably use COM when you program DirectX.</span></span>

> [!NOTE]
> <span data-ttu-id="fb22d-106">Das Thema Verwenden von [com-Komponenten mit C++/WinRT](/windows/uwp/cpp-and-winrt-apis/consume-com) zeigt, wie Sie mit [C++/WinRT](/windows/uwp/cpp-and-winrt-apis/)DirectX-APIs (und eine beliebige com-API) verwenden.</span><span class="sxs-lookup"><span data-stu-id="fb22d-106">The topic [Consume COM components with C++/WinRT](/windows/uwp/cpp-and-winrt-apis/consume-com) shows how to consume DirectX APIs (and any COM API, for that matter) by using [C++/WinRT](/windows/uwp/cpp-and-winrt-apis/).</span></span> <span data-ttu-id="fb22d-107">Das ist die einfachste und empfohlene Technologie, die Sie verwenden können.</span><span class="sxs-lookup"><span data-stu-id="fb22d-107">That's by far the most convenient and recommended technology to use.</span></span>

<span data-ttu-id="fb22d-108">Alternativ dazu können Sie auch unformatierte com verwenden, und das ist das, was in diesem Thema erläutert wird.</span><span class="sxs-lookup"><span data-stu-id="fb22d-108">Alternatively, you can use raw COM, and that's what this topic is about.</span></span> <span data-ttu-id="fb22d-109">Sie benötigen grundlegende Kenntnisse über die Prinzipien und Programmiertechniken, die bei der Nutzung von COM-APIs beteiligt sind.</span><span class="sxs-lookup"><span data-stu-id="fb22d-109">You'll need a basic understanding of the principles and programming techniques involved in consuming COM APIs.</span></span> <span data-ttu-id="fb22d-110">Obwohl com den Ruf hat, schwierig und komplex zu sein, ist die für die meisten DirectX-Anwendungen erforderliche com-Programmierung unkompliziert.</span><span class="sxs-lookup"><span data-stu-id="fb22d-110">Although COM has a reputation for being difficult and complex, the COM programming required by most DirectX applications is straightforward.</span></span> <span data-ttu-id="fb22d-111">Dies liegt teilweise daran, dass Sie die von DirectX bereitgestellten com-Objekte verbrauchen.</span><span class="sxs-lookup"><span data-stu-id="fb22d-111">In part, this is because you'll be consuming the COM objects provided by DirectX.</span></span> <span data-ttu-id="fb22d-112">Es ist nicht erforderlich, eigene COM-Objekte zu erstellen, was in der Regel die Komplexität ergibt.</span><span class="sxs-lookup"><span data-stu-id="fb22d-112">There's no need for you to author your own COM objects, which is typically where the complexity arises.</span></span>

## <a name="com-component-overview"></a><span data-ttu-id="fb22d-113">Übersicht über COM-Komponenten</span><span class="sxs-lookup"><span data-stu-id="fb22d-113">COM component overview</span></span>

<span data-ttu-id="fb22d-114">Ein COM-Objekt ist im Wesentlichen eine gekapselte Komponente von Funktionen, die von Anwendungen verwendet werden kann, um eine oder mehrere Tasks auszuführen.</span><span class="sxs-lookup"><span data-stu-id="fb22d-114">A COM object is essentially an encapsulated component of functionality that can be used by applications to perform one or more tasks.</span></span> <span data-ttu-id="fb22d-115">Für die Bereitstellung werden mindestens eine COM-Komponente in eine Binärdatei mit dem Namen com-Server gepackt. häufiger als eine DLL.</span><span class="sxs-lookup"><span data-stu-id="fb22d-115">For deployment, one or more COM components are packaged into a binary called a COM server; more often than not a DLL.</span></span>

<span data-ttu-id="fb22d-116">Eine herkömmliche dll exportiert kostenlose Funktionen.</span><span class="sxs-lookup"><span data-stu-id="fb22d-116">A traditional DLL exports free functions.</span></span> <span data-ttu-id="fb22d-117">Ein com-Server kann dasselbe tun.</span><span class="sxs-lookup"><span data-stu-id="fb22d-117">A COM server can do the same.</span></span> <span data-ttu-id="fb22d-118">Die COM-Komponenten innerhalb des COM-Servers machen jedoch COM-Schnittstellen und Mitglieds Methoden verfügbar, die zu diesen Schnittstellen gehören.</span><span class="sxs-lookup"><span data-stu-id="fb22d-118">But the COM components inside the COM server expose COM interfaces and member methods belonging to those interfaces.</span></span> <span data-ttu-id="fb22d-119">Die Anwendung erstellt Instanzen von COM-Komponenten, ruft Schnittstellen von Ihnen ab und ruft Methoden für diese Schnittstellen auf, um von den in den COM-Komponenten implementierten Funktionen zu profitieren.</span><span class="sxs-lookup"><span data-stu-id="fb22d-119">Your application creates instances of COM components, retrieves interfaces from them, and calls methods on those interfaces in order to benefit from the features implemented in the COM components.</span></span>

<span data-ttu-id="fb22d-120">In der Praxis ist dies vergleichbar mit dem Aufrufen von Methoden für ein reguläres C++-Objekt.</span><span class="sxs-lookup"><span data-stu-id="fb22d-120">In practice, this feels similar to calling methods on a regular C++ object.</span></span> <span data-ttu-id="fb22d-121">Es gibt jedoch einige Unterschiede.</span><span class="sxs-lookup"><span data-stu-id="fb22d-121">But there are some differences.</span></span>

- <span data-ttu-id="fb22d-122">Ein COM-Objekt erzwingt eine strengere Kapselung als ein C++-Objekt.</span><span class="sxs-lookup"><span data-stu-id="fb22d-122">A COM object enforces stricter encapsulation than a C++ object does.</span></span> <span data-ttu-id="fb22d-123">Sie können das Objekt nicht einfach erstellen und dann eine beliebige öffentliche Methode abrufen.</span><span class="sxs-lookup"><span data-stu-id="fb22d-123">You can't just create the object, and then call any public method.</span></span> <span data-ttu-id="fb22d-124">Stattdessen werden die öffentlichen Methoden einer COM-Komponente in eine oder mehrere COM-Schnittstellen gruppiert.</span><span class="sxs-lookup"><span data-stu-id="fb22d-124">Instead, a COM component's public methods are grouped into one or more COM interfaces.</span></span> <span data-ttu-id="fb22d-125">Zum Aufrufen einer Methode erstellen Sie das-Objekt und rufen aus dem-Objekt die-Schnittstelle ab, die die-Methode implementiert.</span><span class="sxs-lookup"><span data-stu-id="fb22d-125">To call a method, you create the object and retrieve from the object the interface that implements the method.</span></span> <span data-ttu-id="fb22d-126">Eine Schnittstelle implementiert in der Regel einen zugehörigen Satz von Methoden, die Zugriff auf eine bestimmte Funktion des Objekts ermöglichen.</span><span class="sxs-lookup"><span data-stu-id="fb22d-126">An interface typically implements a related set of methods that provide access to a particular feature of the object.</span></span> <span data-ttu-id="fb22d-127">Die [**ID3D12Device**](/windows/desktop/api/d3d12/nn-d3d12-id3d12device) -Schnittstelle stellt z. b. einen virtuellen Grafikadapter dar und enthält Methoden, die Ihnen das Erstellen von Ressourcen ermöglichen, z. b. und viele andere Adapter bezogene Aufgaben.</span><span class="sxs-lookup"><span data-stu-id="fb22d-127">For example, the [**ID3D12Device**](/windows/desktop/api/d3d12/nn-d3d12-id3d12device) interface represents a virtual graphics adapter, and it contains methods that enable you create resources, for example, and many other adapter-related tasks.</span></span>
- <span data-ttu-id="fb22d-128">Ein COM-Objekt wird nicht auf die gleiche Weise wie ein C++-Objekt erstellt.</span><span class="sxs-lookup"><span data-stu-id="fb22d-128">A COM object is not created in the same way as a C++ object.</span></span> <span data-ttu-id="fb22d-129">Es gibt mehrere Möglichkeiten, ein COM-Objekt zu erstellen, aber alle umfassen com-spezifische Techniken.</span><span class="sxs-lookup"><span data-stu-id="fb22d-129">There are several ways to create a COM object, but all involve COM-specific techniques.</span></span> <span data-ttu-id="fb22d-130">Die DirectX-API umfasst eine Vielzahl von Hilfsfunktionen und-Methoden, die das Erstellen der meisten DirectX-com-Objekte vereinfachen.</span><span class="sxs-lookup"><span data-stu-id="fb22d-130">The DirectX API includes a variety of helper functions and methods that simplify creating most of the DirectX COM objects.</span></span>
- <span data-ttu-id="fb22d-131">Sie müssen com-spezifische Techniken verwenden, um die Lebensdauer eines COM-Objekts zu steuern.</span><span class="sxs-lookup"><span data-stu-id="fb22d-131">You must use COM-specific techniques to control the lifetime of a COM object.</span></span>
- <span data-ttu-id="fb22d-132">Der com-Server (in der Regel eine DLL) muss nicht explizit geladen werden.</span><span class="sxs-lookup"><span data-stu-id="fb22d-132">The COM server (typically a DLL) doesn't need to be explicitly loaded.</span></span> <span data-ttu-id="fb22d-133">Sie können auch nicht mit einer statischen Bibliothek verknüpfen, um eine COM-Komponente zu verwenden.</span><span class="sxs-lookup"><span data-stu-id="fb22d-133">Nor do you link to a static library in order to use a COM component.</span></span> <span data-ttu-id="fb22d-134">Jede COM-Komponente verfügt über einen eindeutigen registrierten Bezeichner (einen global eindeutigen Bezeichner oder eine GUID), der von Ihrer Anwendung verwendet wird, um das COM-Objekt zu identifizieren.</span><span class="sxs-lookup"><span data-stu-id="fb22d-134">Each COM component has a unique registered identifier (a globally-unique identifier, or GUID), which your application uses to identify the COM object.</span></span> <span data-ttu-id="fb22d-135">Die-Komponente wird von der Anwendung identifiziert, und die com-Laufzeit lädt automatisch die korrekte com-Server-DLL.</span><span class="sxs-lookup"><span data-stu-id="fb22d-135">Your application identifies the component, and the COM runtime automatically loads the correct COM server DLL.</span></span>
- <span data-ttu-id="fb22d-136">COM ist eine binäre Spezifikation.</span><span class="sxs-lookup"><span data-stu-id="fb22d-136">COM is a binary specification.</span></span> <span data-ttu-id="fb22d-137">COM-Objekte können in einer Vielzahl von Sprachen geschrieben und darauf zugegriffen werden.</span><span class="sxs-lookup"><span data-stu-id="fb22d-137">COM objects can be written in and accessed from a variety of languages.</span></span> <span data-ttu-id="fb22d-138">Sie müssen nichts über den Quellcode des Objekts wissen.</span><span class="sxs-lookup"><span data-stu-id="fb22d-138">You don't need to know anything about the object's source code.</span></span> <span data-ttu-id="fb22d-139">Beispielsweise verwenden Visual Basic Anwendungen regelmäßig com-Objekte, die in C++ geschrieben wurden.</span><span class="sxs-lookup"><span data-stu-id="fb22d-139">For example, Visual Basic applications routinely use COM objects that were written in C++.</span></span>

## <a name="component-object-and-interface"></a><span data-ttu-id="fb22d-140">Komponente, Objekt und Schnittstelle</span><span class="sxs-lookup"><span data-stu-id="fb22d-140">Component, object, and interface</span></span>

<span data-ttu-id="fb22d-141">Es ist wichtig, den Unterschied zwischen Komponenten, Objekten und Schnittstellen zu verstehen.</span><span class="sxs-lookup"><span data-stu-id="fb22d-141">It's important to understand the distinction between components, objects, and interfaces.</span></span> <span data-ttu-id="fb22d-142">Bei der zufälligen Verwendung werden Sie möglicherweise eine Komponente oder ein Objekt mit dem Namen der Prinzipal Schnittstelle, auf die verwiesen wird, hören.</span><span class="sxs-lookup"><span data-stu-id="fb22d-142">In casual usage, you may hear a component or object referred to by the name of its principal interface.</span></span> <span data-ttu-id="fb22d-143">Die Begriffe sind jedoch nicht austauschbar.</span><span class="sxs-lookup"><span data-stu-id="fb22d-143">But the terms are not interchangeable.</span></span> <span data-ttu-id="fb22d-144">Eine Komponente kann eine beliebige Anzahl von Schnittstellen implementieren. und ein Objekt ist eine Instanz einer Komponente.</span><span class="sxs-lookup"><span data-stu-id="fb22d-144">A component can implement any number of interfaces; and an object is an instance of a component.</span></span> <span data-ttu-id="fb22d-145">Wenn z. b. alle Komponenten die [**IUnknown-Schnittstelle**](/windows/desktop/api/unknwn/nn-unknwn-iunknown)implementieren müssen, implementieren Sie normalerweise mindestens eine zusätzliche Schnittstelle, und Sie können viele implementieren.</span><span class="sxs-lookup"><span data-stu-id="fb22d-145">For example, while all components must implement the [**IUnknown interface**](/windows/desktop/api/unknwn/nn-unknwn-iunknown), they normally implement at least one additional interface, and they might implement many.</span></span>

<span data-ttu-id="fb22d-146">Wenn Sie eine bestimmte Schnittstellen Methode verwenden möchten, dürfen Sie nicht nur ein Objekt instanziieren, sondern auch die richtige Schnittstelle daraus abrufen.</span><span class="sxs-lookup"><span data-stu-id="fb22d-146">To use a particular interface method, you must not only instantiate an object, you must also obtain the correct interface from it.</span></span>

<span data-ttu-id="fb22d-147">Darüber hinaus können mehr als eine Komponente dieselbe Schnittstelle implementieren.</span><span class="sxs-lookup"><span data-stu-id="fb22d-147">In addition, more than one component might implement the same interface.</span></span> <span data-ttu-id="fb22d-148">Eine Schnittstelle ist eine Gruppe von Methoden, die einen logisch zusammen gehörigen Satz von Vorgängen ausführen.</span><span class="sxs-lookup"><span data-stu-id="fb22d-148">An interface is a group of methods that perform a logically-related set of operations.</span></span> <span data-ttu-id="fb22d-149">Die Schnittstellen Definition gibt nur die Syntax der Methoden und ihrer allgemeinen Funktionalität an.</span><span class="sxs-lookup"><span data-stu-id="fb22d-149">The interface definition specifies only the syntax of the methods and their general functionality.</span></span> <span data-ttu-id="fb22d-150">Jede COM-Komponente, die einen bestimmten Satz von Vorgängen unterstützen muss, kann dies durch Implementieren einer geeigneten Schnittstelle erreichen.</span><span class="sxs-lookup"><span data-stu-id="fb22d-150">Any COM component that needs to support a particular set of operations can do so by implementing a suitable interface.</span></span> <span data-ttu-id="fb22d-151">Einige Schnittstellen sind hochgradig spezialisiert und werden nur von einer einzelnen Komponente implementiert. andere sind in einer Vielzahl von Situationen nützlich und werden von vielen Komponenten implementiert.</span><span class="sxs-lookup"><span data-stu-id="fb22d-151">Some interfaces are highly specialized, and are implemented only by a single component; others are useful in a variety of circumstances, and are implemented by many components.</span></span>

<span data-ttu-id="fb22d-152">Wenn eine Komponente eine Schnittstelle implementiert, muss Sie jede Methode in der Schnittstellen Definition unterstützen.</span><span class="sxs-lookup"><span data-stu-id="fb22d-152">If a component implements an interface, it must support every method in the interface definition.</span></span> <span data-ttu-id="fb22d-153">Anders ausgedrückt: Sie müssen in der Lage sein, jede beliebige Methode aufzurufen und sicher zu sein, dass Sie vorhanden ist.</span><span class="sxs-lookup"><span data-stu-id="fb22d-153">In other words, you must be able to call any method and be confident that it exists.</span></span> <span data-ttu-id="fb22d-154">Die Details der Implementierung einer bestimmten Methode können sich jedoch von einer Komponente zu einer anderen unterscheiden.</span><span class="sxs-lookup"><span data-stu-id="fb22d-154">However, the details of how a particular method is implemented may vary from one component to another.</span></span> <span data-ttu-id="fb22d-155">Beispielsweise können unterschiedliche-Komponenten andere Algorithmen verwenden, um am Endergebnis zu gelangen.</span><span class="sxs-lookup"><span data-stu-id="fb22d-155">For example, different components may use different algorithms to arrive at the final result.</span></span> <span data-ttu-id="fb22d-156">Es gibt auch keine Garantie dafür, dass eine Methode auf nicht triviale Weise unterstützt wird.</span><span class="sxs-lookup"><span data-stu-id="fb22d-156">There is also no guarantee that a method will be supported in a nontrivial way.</span></span> <span data-ttu-id="fb22d-157">Manchmal implementiert eine Komponente eine häufig verwendete Schnittstelle, aber Sie muss nur eine Teilmenge der Methoden unterstützen.</span><span class="sxs-lookup"><span data-stu-id="fb22d-157">Sometimes, a component implements a commonly-used interface, but it needs to support only a subset of the methods.</span></span> <span data-ttu-id="fb22d-158">Sie können die restlichen Methoden weiterhin erfolgreich aufzurufen, aber Sie geben ein [**HRESULT**](#hresult-values) (einen com-Standard Typ, der einen Ergebniscode darstellt) zurück, der den Wert **E_NOTIMPL** enthält.</span><span class="sxs-lookup"><span data-stu-id="fb22d-158">You will still be able to call the remaining methods successfully, but they will return an [**HRESULT**](#hresult-values) (which is a standard COM type representing a result code) containing the value **E_NOTIMPL**.</span></span> <span data-ttu-id="fb22d-159">In der Dokumentation finden Sie Informationen dazu, wie eine Schnittstelle von einer bestimmten Komponente implementiert wird.</span><span class="sxs-lookup"><span data-stu-id="fb22d-159">You should refer to its documentation to see how an interface is implemented by any particular component.</span></span>

<span data-ttu-id="fb22d-160">Der com-Standard erfordert, dass eine Schnittstellen Definition nicht geändert werden darf, sobald Sie veröffentlicht wurde.</span><span class="sxs-lookup"><span data-stu-id="fb22d-160">The COM standard requires that an interface definition must not change once it has been published.</span></span> <span data-ttu-id="fb22d-161">Der Autor kann z. b. eine neue Methode nicht zu einer vorhandenen Schnittstelle hinzufügen.</span><span class="sxs-lookup"><span data-stu-id="fb22d-161">The author cannot, for example, add a new method to an existing interface.</span></span> <span data-ttu-id="fb22d-162">Der Autor muss stattdessen eine neue Schnittstelle erstellen.</span><span class="sxs-lookup"><span data-stu-id="fb22d-162">The author must instead create a new interface.</span></span> <span data-ttu-id="fb22d-163">Es gibt zwar keine Einschränkungen bezüglich der Methoden, die sich in dieser Schnittstelle befinden müssen, eine gängige Vorgehensweise besteht jedoch darin, dass die Schnittstelle der nächsten Generation alle Methoden der alten Schnittstelle sowie alle neuen Methoden enthält.</span><span class="sxs-lookup"><span data-stu-id="fb22d-163">While there are no restrictions on what methods must be in that interface, a common practice is to have the next-generation interface include all the of the old interface's methods, plus any new methods.</span></span>

<span data-ttu-id="fb22d-164">Es ist nicht ungewöhnlich, dass eine Schnittstelle mehrere Generationen hat.</span><span class="sxs-lookup"><span data-stu-id="fb22d-164">It's not unusual for an interface to have several generations.</span></span> <span data-ttu-id="fb22d-165">In der Regel führen alle Generationen im Wesentlichen die gleiche Gesamtaufgabe aus, aber Sie unterscheiden sich in den Besonderheiten.</span><span class="sxs-lookup"><span data-stu-id="fb22d-165">Typically, all generations perform essentially the same overall task, but they're different in specifics.</span></span> <span data-ttu-id="fb22d-166">Häufig implementiert eine COM-Komponente jede aktuelle und vorherige Generierung der Herkunft einer bestimmten Schnittstelle.</span><span class="sxs-lookup"><span data-stu-id="fb22d-166">Often, a COM component implements every current and prior generation of a given interface's lineage.</span></span> <span data-ttu-id="fb22d-167">Auf diese Weise können ältere Anwendungen weiterhin die älteren Schnittstellen des Objekts verwenden, während neuere Anwendungen die Features der neueren Schnittstellen nutzen können.</span><span class="sxs-lookup"><span data-stu-id="fb22d-167">Doing so allows older applications to continue using the object's older interfaces, while newer applications can take advantage of the features of the newer interfaces.</span></span> <span data-ttu-id="fb22d-168">Normalerweise hat eine abstiegsgruppe von Schnittstellen denselben Namen und eine ganze Zahl, die die Generierung angibt.</span><span class="sxs-lookup"><span data-stu-id="fb22d-168">Typically, a descent group of interfaces all have the same name, plus an integer that indicates the generation.</span></span> <span data-ttu-id="fb22d-169">Wenn die ursprüngliche Schnittstelle z. b. den Namen **IMyInterface** hat (was Generation 1 impliziert), werden die nächsten zwei Generationen als " **IMyInterface2** " und " **IMyInterface3**" bezeichnet.</span><span class="sxs-lookup"><span data-stu-id="fb22d-169">For example, if the original interface were named **IMyInterface** (implying generation 1), then the next two generations would be called **IMyInterface2** and **IMyInterface3**.</span></span> <span data-ttu-id="fb22d-170">Bei DirectX-Schnittstellen werden aufeinander folgende Generationen in der Regel für die Versionsnummer von DirectX benannt.</span><span class="sxs-lookup"><span data-stu-id="fb22d-170">In the case of DirectX interfaces, successive generations are typically named for the version number of DirectX.</span></span>

## <a name="guids"></a><span data-ttu-id="fb22d-171">GUIDs</span><span class="sxs-lookup"><span data-stu-id="fb22d-171">GUIDs</span></span>

<span data-ttu-id="fb22d-172">GUIDs sind ein wichtiger Bestandteil des com-Programmiermodells.</span><span class="sxs-lookup"><span data-stu-id="fb22d-172">GUIDs are a key part of the COM programming model.</span></span> <span data-ttu-id="fb22d-173">Bei der grundlegendsten ist eine GUID eine 128-Bit-Struktur.</span><span class="sxs-lookup"><span data-stu-id="fb22d-173">At its most basic, a GUID is a 128-bit structure.</span></span> <span data-ttu-id="fb22d-174">GUIDs werden jedoch auf eine Weise erstellt, um sicherzustellen, dass keine zwei GUIDs identisch sind.</span><span class="sxs-lookup"><span data-stu-id="fb22d-174">However, GUIDs are created in such a way as to guarantee that no two GUIDs are the same.</span></span> <span data-ttu-id="fb22d-175">COM verwendet GUIDs für zwei primäre Zwecke ausgiebig.</span><span class="sxs-lookup"><span data-stu-id="fb22d-175">COM uses GUIDs extensively for two primary purposes.</span></span>

- <span data-ttu-id="fb22d-176">, Um eine bestimmte COM-Komponente eindeutig zu identifizieren.</span><span class="sxs-lookup"><span data-stu-id="fb22d-176">To uniquely identify a particular COM component.</span></span> <span data-ttu-id="fb22d-177">Eine GUID, die zum Identifizieren einer COM-Komponente zugewiesen wird, wird als Klassen Bezeichner (CLSID) bezeichnet, und Sie verwenden eine CLSID, wenn Sie eine Instanz der zugeordneten COM-Komponente erstellen möchten.</span><span class="sxs-lookup"><span data-stu-id="fb22d-177">A GUID that is assigned to identify a COM component is called a class identifier (CLSID), and you use a CLSID when you want to create an instance of the associated COM component.</span></span>
- <span data-ttu-id="fb22d-178">, Um eine bestimmte COM-Schnittstelle eindeutig zu identifizieren.</span><span class="sxs-lookup"><span data-stu-id="fb22d-178">To uniquely identify a particular COM interface.</span></span> <span data-ttu-id="fb22d-179">Eine GUID, die zum Identifizieren einer COM-Schnittstelle zugewiesen ist, wird als Schnittstellen Bezeichner (IID) bezeichnet, und Sie verwenden eine IID, wenn Sie eine bestimmte Schnittstelle von einer Instanz einer Komponente (ein Objekt) anfordern.</span><span class="sxs-lookup"><span data-stu-id="fb22d-179">A GUID that is assigned to identify a COM interface is called an interface identifier (IID), and you use an IID when you request a particular interface from an instance of a component (an object).</span></span> <span data-ttu-id="fb22d-180">Die IID einer Schnittstelle ist identisch, unabhängig davon, welche Komponente die Schnittstelle implementiert.</span><span class="sxs-lookup"><span data-stu-id="fb22d-180">An interface's IID will be the same, regardless of which component implements the interface.</span></span>

<span data-ttu-id="fb22d-181">Die DirectX-Dokumentation bezieht sich in der Regel auf Komponenten und Schnittstellen anhand ihrer beschreibenden Namen (z. b. **ID3D12Device**) und nicht anhand ihrer GUIDs.</span><span class="sxs-lookup"><span data-stu-id="fb22d-181">For convenience, the DirectX documentation normally refers to components and interfaces by their descriptive names (for example, **ID3D12Device**) rather than by their GUIDs.</span></span> <span data-ttu-id="fb22d-182">Innerhalb des Kontexts der DirectX-Dokumentation gibt es keine Mehrdeutigkeit.</span><span class="sxs-lookup"><span data-stu-id="fb22d-182">Within the context of the DirectX documentation, there is no ambiguity.</span></span> <span data-ttu-id="fb22d-183">Es ist technisch möglich, dass ein Drittanbieter eine Schnittstelle mit dem beschreibenden Namen " **ID3D12Device** " erstellt (er muss eine andere IID aufweisen, um gültig zu sein).</span><span class="sxs-lookup"><span data-stu-id="fb22d-183">It's technically possible for a third-party to author an interface with the descriptive name **ID3D12Device** (it would need to have a different IID in order to be valid).</span></span> <span data-ttu-id="fb22d-184">Im Interesse der Übersichtlichkeit wird dies jedoch nicht empfohlen.</span><span class="sxs-lookup"><span data-stu-id="fb22d-184">In the interest of clarity, though, we don't recommend that.</span></span>

<span data-ttu-id="fb22d-185">Der einzige eindeutige Weg, auf ein bestimmtes Objekt oder eine bestimmte Schnittstelle zu verweisen, ist die GUID.</span><span class="sxs-lookup"><span data-stu-id="fb22d-185">So, the only unambiguous way to refer to a particular object or interface is by its GUID.</span></span>

<span data-ttu-id="fb22d-186">Obwohl eine GUID eine Struktur ist, wird eine GUID häufig in einer äquivalenten Zeichen folgen Form ausgedrückt.</span><span class="sxs-lookup"><span data-stu-id="fb22d-186">Although a GUID is a structure, a GUID is often expressed in equivalent string form.</span></span> <span data-ttu-id="fb22d-187">Das allgemeine Format der Zeichen folgen Form einer GUID ist 32 hexadezimal Ziffern im Format 8-4-4-4-12.</span><span class="sxs-lookup"><span data-stu-id="fb22d-187">The general format of the string form of a GUID is 32 hexadecimal digits, in the format 8-4-4-4-12.</span></span> <span data-ttu-id="fb22d-188">Das heißt, {xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx}, wobei jedes x einer hexadezimal Ziffer entspricht.</span><span class="sxs-lookup"><span data-stu-id="fb22d-188">That is, {xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx}, where each x corresponds to a hexadecimal digit.</span></span> <span data-ttu-id="fb22d-189">Die Zeichen folgen Form der IID für die **ID3D12Device** -Schnittstelle lautet z. b. {189819f 1-1db6-4b57-be54-1821339b85b85}.</span><span class="sxs-lookup"><span data-stu-id="fb22d-189">For example, the string form of the IID for the **ID3D12Device** interface is {189819F1-1DB6-4B57-BE54-1821339B85F7}.</span></span>

<span data-ttu-id="fb22d-190">Da die tatsächliche GUID etwas unscharf und leicht zu verwenden ist, wird normalerweise auch ein entsprechender Name bereitgestellt.</span><span class="sxs-lookup"><span data-stu-id="fb22d-190">Because the actual GUID is somewhat clumsy to use and easy to mistype, an equivalent name is usually provided as well.</span></span> <span data-ttu-id="fb22d-191">In Ihrem Code können Sie diesen Namen anstelle der eigentlichen Struktur verwenden, wenn Sie Funktionen aufrufen, z. b. Wenn Sie ein Argument für den `riid` Parameter an [**D3D12CreateDevice**](/windows/desktop/api/d3d12/nf-d3d12-d3d12createdevice)übergeben.</span><span class="sxs-lookup"><span data-stu-id="fb22d-191">In your code, you can use this name instead of the actual structure when you call functions, for example when you pass an argument for the `riid` parameter to [**D3D12CreateDevice**](/windows/desktop/api/d3d12/nf-d3d12-d3d12createdevice).</span></span> <span data-ttu-id="fb22d-192">Die übliche Benennungs Konvention besteht darin, entweder IID_ oder CLSID_ dem beschreibenden Namen der Schnittstelle bzw. des Objekts voranzustellen.</span><span class="sxs-lookup"><span data-stu-id="fb22d-192">The customary naming convention is to prepend either IID_ or CLSID_ to the descriptive name of the interface or object, respectively.</span></span> <span data-ttu-id="fb22d-193">Beispielsweise ist der Name der IID der **ID3D12Device** -Schnittstelle IID_ID3D12Device.</span><span class="sxs-lookup"><span data-stu-id="fb22d-193">For example, the name of the **ID3D12Device** interface's IID is IID_ID3D12Device.</span></span>

> [!NOTE]
> <span data-ttu-id="fb22d-194">DirectX-Anwendungen sollten mit ``dxguid.lib`` und verknüpft werden ``uuid.lib`` , um Definitionen für die verschiedenen Schnittstellen-und Klassen-GUIDs bereitzustellen.</span><span class="sxs-lookup"><span data-stu-id="fb22d-194">DirectX applications should link with ``dxguid.lib`` and ``uuid.lib`` to provide definitions for the various interface and class GUIDs.</span></span> <span data-ttu-id="fb22d-195">Visual C++ und andere Compiler unterstützen die Spracherweiterung **__uuidof** Operators, aber eine explizite Verknüpfung im C-Stil mit diesen Linkbibliotheken wird ebenfalls unterstützt und ist vollständig portabel.</span><span class="sxs-lookup"><span data-stu-id="fb22d-195">Visual C++ and other compilers support the **__uuidof** operator language extension, but explicit C-style linkage with these link libraries is also supported and fully portable.</span></span>

## <a name="hresult-values"></a><span data-ttu-id="fb22d-196">HRESULT-Werte</span><span class="sxs-lookup"><span data-stu-id="fb22d-196">HRESULT values</span></span>

<span data-ttu-id="fb22d-197">Die meisten com-Methoden geben eine 32-Bit-Ganzzahl mit dem Namen **HRESULT** zurück.</span><span class="sxs-lookup"><span data-stu-id="fb22d-197">Most COM methods return a 32-bit integer called an **HRESULT**.</span></span> <span data-ttu-id="fb22d-198">Bei den meisten Methoden ist das HRESULT im Wesentlichen eine Struktur, die zwei primäre Informationsteile enthält.</span><span class="sxs-lookup"><span data-stu-id="fb22d-198">With most methods, the HRESULT is essentially a structure that contains two primary pieces of information.</span></span>
- <span data-ttu-id="fb22d-199">Gibt an, ob die Methode erfolgreich oder fehlerhaft war.</span><span class="sxs-lookup"><span data-stu-id="fb22d-199">Whether the method succeeded or failed.</span></span>
- <span data-ttu-id="fb22d-200">Ausführlichere Informationen zum Ergebnis des Vorgangs, der von der-Methode ausgeführt wird.</span><span class="sxs-lookup"><span data-stu-id="fb22d-200">More detailed information about the outcome of the operation performed by the method.</span></span>

<span data-ttu-id="fb22d-201">Einige Methoden geben einen **HRESULT** -Wert aus dem Standardsatz zurück, der in definiert ist `Winerror.h` .</span><span class="sxs-lookup"><span data-stu-id="fb22d-201">Some methods return a **HRESULT** value from the standard set defined in `Winerror.h`.</span></span> <span data-ttu-id="fb22d-202">Eine Methode kann jedoch einen benutzerdefinierten **HRESULT** -Wert mit spezielleren Informationen zurückgeben.</span><span class="sxs-lookup"><span data-stu-id="fb22d-202">However, a method is free to return a custom **HRESULT** value with more specialized information.</span></span> <span data-ttu-id="fb22d-203">Diese Werte sind in der Regel auf der Referenzseite der Methode dokumentiert.</span><span class="sxs-lookup"><span data-stu-id="fb22d-203">These values are normally documented on the method's reference page.</span></span>

<span data-ttu-id="fb22d-204">Die Liste der **HRESULT** -Werte, die Sie auf der Referenzseite einer Methode finden, ist oft nur eine Teilmenge der möglichen Werte, die zurückgegeben werden können.</span><span class="sxs-lookup"><span data-stu-id="fb22d-204">The list of **HRESULT** values that you find on a method's reference page is often only a subset of the possible values that may be returned.</span></span> <span data-ttu-id="fb22d-205">Die Liste deckt in der Regel nur die Werte ab, die für die-Methode spezifisch sind, sowie die Standardwerte, die eine bestimmte Methoden spezifische Bedeutung haben.</span><span class="sxs-lookup"><span data-stu-id="fb22d-205">The list typically covers only those values that are specific to the method, as well as those standard values that have some method-specific meaning.</span></span> <span data-ttu-id="fb22d-206">Sie sollten davon ausgehen, dass eine Methode möglicherweise eine Vielzahl von **HRESULT** -Standardwerten zurückgibt, auch wenn Sie nicht explizit dokumentiert werden.</span><span class="sxs-lookup"><span data-stu-id="fb22d-206">You should assume that a method may return a variety of standard **HRESULT** values, even if they're not explicitly documented.</span></span>

<span data-ttu-id="fb22d-207">Obwohl **HRESULT** -Werte häufig zum Zurückgeben von Fehlerinformationen verwendet werden, sollten Sie sich nicht als Fehlercodes vorstellen.</span><span class="sxs-lookup"><span data-stu-id="fb22d-207">While **HRESULT** values are often used to return error information, you should not think of them as error codes.</span></span> <span data-ttu-id="fb22d-208">Die Tatsache, dass das Bit, das den Erfolg oder Misserfolg angibt, getrennt von den Bits, die die detaillierten Informationen enthalten, gespeichert wird, ermöglicht **HRESULT** -Werten, eine beliebige Anzahl von Erfolgs-und Fehlercodes zu haben.</span><span class="sxs-lookup"><span data-stu-id="fb22d-208">The fact that the bit that indicates success or failure is stored separately from the bits that contain the detailed information allows **HRESULT** values to have any number of success and failure codes.</span></span> <span data-ttu-id="fb22d-209">Gemäß der Konvention werden den Namen von Erfolgs Codes s_ und Fehlercodes durch E_ vorangestellt.</span><span class="sxs-lookup"><span data-stu-id="fb22d-209">By convention, the names of success codes are prefixed by S_ and failure codes by E_.</span></span> <span data-ttu-id="fb22d-210">Die beiden am häufigsten verwendeten Codes sind z. b. S_OK und E_FAIL, die einen einfachen Erfolg bzw. Fehler angeben.</span><span class="sxs-lookup"><span data-stu-id="fb22d-210">For example, the two most commonly used codes are S_OK and E_FAIL, which indicate simple success or failure, respectively.</span></span>

<span data-ttu-id="fb22d-211">Die Tatsache, dass com-Methoden möglicherweise eine Vielzahl von Erfolgs-oder Fehlercodes zurückgeben, bedeutet, dass Sie sorgfältig darauf achten müssen, wie Sie den **HRESULT** -Wert testen.</span><span class="sxs-lookup"><span data-stu-id="fb22d-211">The fact that COM methods may return a variety of success or failure codes means that you have to be careful how you test the **HRESULT** value.</span></span> <span data-ttu-id="fb22d-212">Stellen Sie sich z. b. eine hypothetische Methode mit dokumentierten Rückgabe Werten S_OK bei erfolgreicher Ausführung vor, und E_FAIL andernfalls.</span><span class="sxs-lookup"><span data-stu-id="fb22d-212">For example, consider a hypothetical method with documented return values of S_OK if successful and E_FAIL if not.</span></span> <span data-ttu-id="fb22d-213">Beachten Sie jedoch, dass die Methode möglicherweise auch andere Fehler-oder Erfolgs Codes zurückgibt.</span><span class="sxs-lookup"><span data-stu-id="fb22d-213">However, remember that the method may also return other failure or success codes.</span></span> <span data-ttu-id="fb22d-214">Das folgende Code Fragment veranschaulicht die Gefahr der Verwendung eines einfachen Tests, wobei `hr` den **HRESULT** -Wert enthält, der von der-Methode zurückgegeben wird.</span><span class="sxs-lookup"><span data-stu-id="fb22d-214">The following code fragment illustrates the danger of using a simple test, where `hr` contains the **HRESULT** value returned by the method.</span></span>

```cpp
if (hr == E_FAIL)
{
    // Handle the failure case.
}
else
{
    // Handle the success case.
}  
```

<span data-ttu-id="fb22d-215">Solange diese Methode im Falle eines Fehlers nur E_FAIL zurückgibt (und nicht in einem anderen Fehlercode), funktioniert dieser Test.</span><span class="sxs-lookup"><span data-stu-id="fb22d-215">As long as, in the failure case, this method only ever return E_FAIL (and not some other failure code), then this test works.</span></span> <span data-ttu-id="fb22d-216">Es ist jedoch realistischer, dass eine bestimmte Methode implementiert wird, um eine Reihe spezifischer Fehlercodes zurückzugeben, vielleicht E_NOTIMPL oder E_INVALIDARG.</span><span class="sxs-lookup"><span data-stu-id="fb22d-216">However, it's more realistic that a given method is implemented to return a set of specific failure codes, perhaps E_NOTIMPL or E_INVALIDARG.</span></span> <span data-ttu-id="fb22d-217">Mit dem obigen Code werden diese Werte fälschlicherweise als erfolgreich interpretiert.</span><span class="sxs-lookup"><span data-stu-id="fb22d-217">With the code above, those values would be incorrectly interpreted as a success.</span></span>

<span data-ttu-id="fb22d-218">Wenn Sie ausführliche Informationen zum Ergebnis des Methoden Aufrufes benötigen, müssen Sie jeden relevanten **HRESULT** -Wert testen.</span><span class="sxs-lookup"><span data-stu-id="fb22d-218">If you need detailed information about the outcome of the method call, you need to test each relevant **HRESULT** value.</span></span> <span data-ttu-id="fb22d-219">Sie sind jedoch möglicherweise nur daran interessiert, ob die Methode erfolgreich war oder fehlgeschlagen ist.</span><span class="sxs-lookup"><span data-stu-id="fb22d-219">However, you may be interested only in whether the method succeeded or failed.</span></span> <span data-ttu-id="fb22d-220">Ein robuster Weg, um zu testen, ob ein **HRESULT** -Wert Erfolg oder Fehler angibt, besteht darin, den Wert an die folgenden Makros zu übergeben, die in WinError. h definiert sind.</span><span class="sxs-lookup"><span data-stu-id="fb22d-220">A robust way to test whether an **HRESULT** value indicates success or failure is to pass the value to the one of the following macros, defined in Winerror.h.</span></span>

- <span data-ttu-id="fb22d-221">Das `SUCCEEDED` Makro gibt true für einen Erfolgs Code und false für einen Fehlercode zurück.</span><span class="sxs-lookup"><span data-stu-id="fb22d-221">The `SUCCEEDED` macro returns TRUE for a success code, and FALSE for a failure code.</span></span>
- <span data-ttu-id="fb22d-222">Das `FAILED` -Makro gibt true für einen Fehlercode und false für einen Erfolgs Code zurück.</span><span class="sxs-lookup"><span data-stu-id="fb22d-222">The `FAILED` macro returns TRUE for a failure code, and FALSE for a success code.</span></span>

<span data-ttu-id="fb22d-223">Daher können Sie das vorangehende Code Fragment mit dem- `FAILED` Makro beheben, wie im folgenden Code gezeigt.</span><span class="sxs-lookup"><span data-stu-id="fb22d-223">So, you can fix the preceding code fragment by using the `FAILED` macro, as shown in the following code.</span></span>

```cpp
if (FAILED(hr))
{
    // Handle the failure case.
}
else
{
    // Handle the success case.
}  
```

<span data-ttu-id="fb22d-224">Dieses korrigierte Code Fragment behandelt E_NOTIMPL und E_INVALIDARG ordnungsgemäß als Fehler.</span><span class="sxs-lookup"><span data-stu-id="fb22d-224">This corrected code fragment properly treats E_NOTIMPL and E_INVALIDARG as failures.</span></span>

<span data-ttu-id="fb22d-225">Obwohl die meisten com-Methoden strukturierte **HRESULT** -Werte zurückgeben, verwendet eine kleine Zahl das **HRESULT** , um eine einfache Ganzzahl zurückzugeben.</span><span class="sxs-lookup"><span data-stu-id="fb22d-225">Although most COM methods return structured **HRESULT** values, a small number use the **HRESULT** to return a simple integer.</span></span> <span data-ttu-id="fb22d-226">Diese Methoden sind implizit immer erfolgreich.</span><span class="sxs-lookup"><span data-stu-id="fb22d-226">Implicitly, these methods are always successful.</span></span> <span data-ttu-id="fb22d-227">Wenn Sie ein **HRESULT** dieser Sortierung an das Makro "erfolgreich" übergeben, gibt das Makro immer "true" zurück.</span><span class="sxs-lookup"><span data-stu-id="fb22d-227">If you pass an **HRESULT** of this sort to the SUCCEEDED macro, then the macro always returns TRUE.</span></span> <span data-ttu-id="fb22d-228">Ein Beispiel für eine häufig aufgerufene Methode, die kein **HRESULT** zurückgibt, ist die **IUnknown:: Release** -Methode, die einen Ulong-Wert zurückgibt.</span><span class="sxs-lookup"><span data-stu-id="fb22d-228">An example of a commonly-called method that doesn't return an **HRESULT** is the **IUnknown::Release** method, which returns a ULONG.</span></span> <span data-ttu-id="fb22d-229">Diese Methode Dekremente den Verweis Zähler eines Objekts um 1 und gibt den aktuellen Verweis Zähler zurück.</span><span class="sxs-lookup"><span data-stu-id="fb22d-229">This method decrements an object's reference count by one and returns the current reference count.</span></span> <span data-ttu-id="fb22d-230">Eine Erörterung der Verweis Zählung finden Sie unter [Verwalten der Lebensdauer eines COM-Objekts](#managing-a-com-objects-lifetime) .</span><span class="sxs-lookup"><span data-stu-id="fb22d-230">See [Managing a COM object's lifetime](#managing-a-com-objects-lifetime) for a discussion of reference counting.</span></span>

## <a name="the-address-of-a-pointer"></a><span data-ttu-id="fb22d-231">Die Adresse eines Zeigers.</span><span class="sxs-lookup"><span data-stu-id="fb22d-231">The address of a pointer</span></span>

<span data-ttu-id="fb22d-232">Wenn Sie einige Referenzseiten der com-Methode anzeigen, werden Sie wahrscheinlich in etwa wie folgt ausgeführt.</span><span class="sxs-lookup"><span data-stu-id="fb22d-232">If you view a few COM method reference pages, you'll probably run across something like the following.</span></span>

```cpp
HRESULT D3D12CreateDevice(
  IUnknown          *pAdapter,
  D3D_FEATURE_LEVEL MinimumFeatureLevel,
  REFIID            riid,
  void              **ppDevice
);
```

<span data-ttu-id="fb22d-233">Obwohl ein normaler Zeiger einem C/C++-Entwickler recht vertraut ist, verwendet com häufig eine zusätzliche Dereferenzierungsebene.</span><span class="sxs-lookup"><span data-stu-id="fb22d-233">While a normal pointer is quite familiar to any C/C++ developer, COM often uses an additional level of indirection.</span></span> <span data-ttu-id="fb22d-234">Diese zweite Dereferenzierungsebene wird durch zwei Sternchen, `**` , nach der Typdeklaration und der Variablenname in der Regel über ein Präfix von angegeben `pp` .</span><span class="sxs-lookup"><span data-stu-id="fb22d-234">This second level of indirection is indicated by two asterisks, `**`, following the type declaration, and the variable name typically has a prefix of `pp`.</span></span> <span data-ttu-id="fb22d-235">Bei der obigen Funktion wird der- `ppDevice` Parameter in der Regel als Adresse eines Zeigers auf eine void-Funktion bezeichnet.</span><span class="sxs-lookup"><span data-stu-id="fb22d-235">For the function above, the `ppDevice` parameter is typically referred to as the address of a pointer to a void.</span></span> <span data-ttu-id="fb22d-236">In der Praxis ist in diesem Beispiel `ppDevice` die Adresse eines Zeigers auf eine **ID3D12Device** -Schnittstelle.</span><span class="sxs-lookup"><span data-stu-id="fb22d-236">In practice, in this example, `ppDevice` is the address of a pointer to an **ID3D12Device** interface.</span></span>

<span data-ttu-id="fb22d-237">Im Gegensatz zu einem C++-Objekt greifen Sie nicht direkt auf die Methoden eines COM-Objekts zu.</span><span class="sxs-lookup"><span data-stu-id="fb22d-237">Unlike a C++ object, you don't access a COM object's methods directly.</span></span> <span data-ttu-id="fb22d-238">Stattdessen müssen Sie einen Zeiger auf eine-Schnittstelle abrufen, die die-Methode verfügbar macht.</span><span class="sxs-lookup"><span data-stu-id="fb22d-238">Instead, you must obtain a pointer to an interface that exposes the method.</span></span> <span data-ttu-id="fb22d-239">Zum Aufrufen der-Methode verwenden Sie im Grunde die gleiche Syntax wie zum Aufrufen eines Zeigers auf eine C++-Methode.</span><span class="sxs-lookup"><span data-stu-id="fb22d-239">To invoke the method, you use essentially the same syntax as you would to invoke a pointer to a C++ method.</span></span> <span data-ttu-id="fb22d-240">Wenn Sie z. b. die **IMyInterface::D osomething** -Methode aufrufen möchten, verwenden Sie die folgende Syntax.</span><span class="sxs-lookup"><span data-stu-id="fb22d-240">For example, to invoke the **IMyInterface::DoSomething** method, you would use the following syntax.</span></span>

```cpp
IMyInterface * pMyIface = nullptr;
...
pMyIface->DoSomething(...);
```

<span data-ttu-id="fb22d-241">Die Notwendigkeit einer zweiten dereferenzierungsstufe ergibt sich aus der Tatsache, dass Sie keine Schnittstellen Zeiger direkt erstellen.</span><span class="sxs-lookup"><span data-stu-id="fb22d-241">The need for a second level of indirection comes from the fact that you don't create interface pointers directly.</span></span> <span data-ttu-id="fb22d-242">Sie müssen eine der verschiedenen Methoden, wie z. b. die oben gezeigte **D3D12CreateDevice** -Methode, aufzurufen.</span><span class="sxs-lookup"><span data-stu-id="fb22d-242">You must call one of a variety of methods, such as the **D3D12CreateDevice** method shown above.</span></span> <span data-ttu-id="fb22d-243">Um eine solche Methode zum Abrufen eines Schnittstellen Zeigers zu verwenden, deklarieren Sie eine Variable als Zeiger auf die gewünschte Schnittstelle, und übergeben Sie dann die Adresse dieser Variablen an die-Methode.</span><span class="sxs-lookup"><span data-stu-id="fb22d-243">To use such a method to obtain an interface pointer, you declare a variable as a pointer to the desired interface, and then you pass the address of that variable to the method.</span></span> <span data-ttu-id="fb22d-244">Das heißt, dass Sie die Adresse eines Zeigers an die-Methode übergeben.</span><span class="sxs-lookup"><span data-stu-id="fb22d-244">In other words, you pass the address of a pointer to the method.</span></span> <span data-ttu-id="fb22d-245">Wenn die-Methode zurückgibt, verweist die Variable auf die angeforderte Schnittstelle, und Sie können diesen Zeiger verwenden, um beliebige Methoden der Schnittstelle aufzurufen.</span><span class="sxs-lookup"><span data-stu-id="fb22d-245">When the method returns, the variable points to the requested interface, and you can use that pointer to call any of the interface's methods.</span></span>

```cpp
IDXGIAdapter * pIDXGIAdapter = nullptr;
...
ID3D12Device * pD3D12Device = nullptr;
HRESULT hr = ::D3D12CreateDevice(
    pIDXGIAdapter,
    D3D_FEATURE_LEVEL_11_0,
    IID_ID3D12Device,
    &pD3D12Device);
if (FAILED(hr)) return E_FAIL;

// Now use pD3D12Device in the form pD3D12Device->MethodName(...);
```

## <a name="creating-a-com-object"></a><span data-ttu-id="fb22d-246">Erstellen eines COM-Objekts</span><span class="sxs-lookup"><span data-stu-id="fb22d-246">Creating a COM object</span></span>

<span data-ttu-id="fb22d-247">Es gibt mehrere Möglichkeiten, ein COM-Objekt zu erstellen.</span><span class="sxs-lookup"><span data-stu-id="fb22d-247">There are several ways to create a COM object.</span></span> <span data-ttu-id="fb22d-248">Dies sind die beiden am häufigsten verwendeten in der DirectX-Programmierung.</span><span class="sxs-lookup"><span data-stu-id="fb22d-248">These are the two most commonly used in DirectX programming.</span></span>

- <span data-ttu-id="fb22d-249">Indirekt durch Aufrufen einer DirectX-Methode oder Funktion, die das-Objekt für Sie erstellt.</span><span class="sxs-lookup"><span data-stu-id="fb22d-249">Indirectly, by calling a DirectX method or function that creates the object for you.</span></span> <span data-ttu-id="fb22d-250">Die-Methode erstellt das-Objekt und gibt eine-Schnittstelle für das-Objekt zurück.</span><span class="sxs-lookup"><span data-stu-id="fb22d-250">The method creates the object, and returns an interface on the object.</span></span> <span data-ttu-id="fb22d-251">Wenn Sie ein Objekt auf diese Weise erstellen, können Sie manchmal angeben, welche Schnittstelle zurückgegeben werden soll, und das andere Mal, wenn die Schnittstelle impliziert ist.</span><span class="sxs-lookup"><span data-stu-id="fb22d-251">When you create an object this way, sometimes you can specify which interface should be returned, other times the interface is implied.</span></span> <span data-ttu-id="fb22d-252">Im obigen Codebeispiel wird gezeigt, wie ein COM-Objekt mit einem Direct3D 12-Gerät indirekt erstellt wird.</span><span class="sxs-lookup"><span data-stu-id="fb22d-252">The code example above shows how to indirectly create a Direct3D 12 device COM object.</span></span>
- <span data-ttu-id="fb22d-253">Direkt, indem die CLSID des Objekts an die [**cokreateinstance-Funktion**](/windows/desktop/api/combaseapi/nf-combaseapi-cocreateinstance)übergeben wird.</span><span class="sxs-lookup"><span data-stu-id="fb22d-253">Directly, by passing the object's CLSID to the [**CoCreateInstance function**](/windows/desktop/api/combaseapi/nf-combaseapi-cocreateinstance).</span></span> <span data-ttu-id="fb22d-254">Die-Funktion erstellt eine Instanz des-Objekts und gibt einen Zeiger auf eine-Schnittstelle zurück, die Sie angeben.</span><span class="sxs-lookup"><span data-stu-id="fb22d-254">The function creates an instance of the object, and it returns a pointer to an interface that you specify.</span></span>

<span data-ttu-id="fb22d-255">Wenn Sie ein COM-Objekt erstellen, müssen Sie ein com-initialisieren, indem Sie die [**CoInitializeEx-Funktion**](/windows/desktop/api/combaseapi/nf-combaseapi-coinitializeex)aufrufen.</span><span class="sxs-lookup"><span data-stu-id="fb22d-255">One time, before you create any COM objects, you must initialize COM by calling the [**CoInitializeEx function**](/windows/desktop/api/combaseapi/nf-combaseapi-coinitializeex).</span></span> <span data-ttu-id="fb22d-256">Wenn Sie Objekte indirekt erstellen, wird diese Aufgabe von der Objekt Erstellungs Methode verarbeitet.</span><span class="sxs-lookup"><span data-stu-id="fb22d-256">If you're creating objects indirectly, then the object creation method handles this task.</span></span> <span data-ttu-id="fb22d-257">Wenn Sie jedoch ein Objekt mit **cokreateinstance** erstellen müssen, müssen Sie **CoInitializeEx** explizit aufrufen.</span><span class="sxs-lookup"><span data-stu-id="fb22d-257">But, if you need to create an object with **CoCreateInstance**, then you must call **CoInitializeEx** explicitly.</span></span> <span data-ttu-id="fb22d-258">Wenn Sie fertig sind, muss com durch Aufrufen von " [**aninitialize**](/windows/desktop/api/combaseapi/nf-combaseapi-couninitialize)" nicht initialisiert werden.</span><span class="sxs-lookup"><span data-stu-id="fb22d-258">When you're finished, COM must be uninitialized by calling [**CoUninitialize**](/windows/desktop/api/combaseapi/nf-combaseapi-couninitialize).</span></span> <span data-ttu-id="fb22d-259">Wenn Sie **CoInitializeEx** aufrufen, müssen Sie es mit einem **CallInitialize**-Befehl vergleichen.</span><span class="sxs-lookup"><span data-stu-id="fb22d-259">If you make a call to **CoInitializeEx** then you must match it with a call to **CoUninitialize**.</span></span> <span data-ttu-id="fb22d-260">Anwendungen, die com explizit initialisieren müssen, führen dies in der Regel in der Start Routine aus, und die Initialisierung von com in der Bereinigungs Routine wird nicht durchzuführen.</span><span class="sxs-lookup"><span data-stu-id="fb22d-260">Typically, applications that need to explicitly initialize COM do so in their startup routine, and they uninitialize COM in their cleanup routine.</span></span>

<span data-ttu-id="fb22d-261">Zum Erstellen einer neuen Instanz eines COM-Objekts mit **cokreateinstance** muss die CLSID des Objekts vorhanden sein.</span><span class="sxs-lookup"><span data-stu-id="fb22d-261">To create a new instance of a COM object with **CoCreateInstance**, you must have the object's CLSID.</span></span> <span data-ttu-id="fb22d-262">Wenn diese CLSID öffentlich verfügbar ist, finden Sie Sie in der Referenz Dokumentation oder in der entsprechenden Header Datei.</span><span class="sxs-lookup"><span data-stu-id="fb22d-262">If this CLSID is publicly available, you will find it in the reference documentation or the appropriate header file.</span></span> <span data-ttu-id="fb22d-263">Wenn die CLSID nicht öffentlich verfügbar ist, können Sie das Objekt nicht direkt erstellen.</span><span class="sxs-lookup"><span data-stu-id="fb22d-263">If the CLSID is not publicly available, then you can't create the object directly.</span></span>

<span data-ttu-id="fb22d-264">Die **cokreateinzustance** -Funktion hat fünf Parameter.</span><span class="sxs-lookup"><span data-stu-id="fb22d-264">The **CoCreateInstance** function has five parameters.</span></span> <span data-ttu-id="fb22d-265">Für die COM-Objekte, die Sie mit DirectX verwenden, können Sie die Parameter normalerweise wie folgt festlegen.</span><span class="sxs-lookup"><span data-stu-id="fb22d-265">For the COM objects you will be using with DirectX, you can normally set the parameters as follows.</span></span>

<span data-ttu-id="fb22d-266">*rclsid* Legen Sie diese Einstellung auf die CLSID des Objekts fest, das Sie erstellen möchten.</span><span class="sxs-lookup"><span data-stu-id="fb22d-266">*rclsid* Set this to the CLSID of the object that you want to create.</span></span>

<span data-ttu-id="fb22d-267">*pUnkOuter* Legen Sie auf fest `nullptr` .</span><span class="sxs-lookup"><span data-stu-id="fb22d-267">*pUnkOuter* Set to `nullptr`.</span></span> <span data-ttu-id="fb22d-268">Dieser Parameter wird nur verwendet, wenn Sie-Objekte aggregierten.</span><span class="sxs-lookup"><span data-stu-id="fb22d-268">This parameter is used only if you are aggregating objects.</span></span> <span data-ttu-id="fb22d-269">Eine Erörterung der com-Aggregation wird in diesem Thema nicht behandelt.</span><span class="sxs-lookup"><span data-stu-id="fb22d-269">A discussion of COM aggregation is outside the scope of this topic.</span></span>

<span data-ttu-id="fb22d-270">*dwClsContext* Legen Sie auf CLSCTX_INPROC_SERVER fest.</span><span class="sxs-lookup"><span data-stu-id="fb22d-270">*dwClsContext* Set to CLSCTX_INPROC_SERVER.</span></span> <span data-ttu-id="fb22d-271">Diese Einstellung gibt an, dass das Objekt als dll implementiert wird und im Rahmen des Anwendungsprozesses ausgeführt wird.</span><span class="sxs-lookup"><span data-stu-id="fb22d-271">This setting indicates that the object is implemented as a DLL and runs as part of your application's process.</span></span>

<span data-ttu-id="fb22d-272">*riid* Legen Sie auf die IID der Schnittstelle fest, die zurückgegeben werden soll.</span><span class="sxs-lookup"><span data-stu-id="fb22d-272">*riid* Set to the IID of the interface that you would like to have returned.</span></span> <span data-ttu-id="fb22d-273">Die Funktion erstellt das Objekt und gibt den angeforderten Schnittstellen Zeiger im PPV-Parameter zurück.</span><span class="sxs-lookup"><span data-stu-id="fb22d-273">The function will create the object and return the requested interface pointer in the ppv parameter.</span></span>

<span data-ttu-id="fb22d-274">*PPV* Legen Sie diese Einstellung auf die Adresse eines Zeigers fest, der auf die durch angegebene Schnittstelle festgelegt wird, `riid` Wenn die Funktion zurückgibt.</span><span class="sxs-lookup"><span data-stu-id="fb22d-274">*ppv* Set this to the address of a pointer that will be set to the interface specified by `riid` when the function returns.</span></span> <span data-ttu-id="fb22d-275">Diese Variable sollte als Zeiger auf die angeforderte Schnittstelle deklariert werden, und der Verweis auf den Zeiger in der Parameterliste sollte in (LPVOID \*) umgewandelt werden.</span><span class="sxs-lookup"><span data-stu-id="fb22d-275">This variable should be declared as a pointer to the requested interface, and the reference to the pointer in the parameter list should be cast as (LPVOID \*).</span></span>

<span data-ttu-id="fb22d-276">Die indirekte Erstellung eines Objekts ist in der Regel viel einfacher, wie im obigen Codebeispiel gezeigt.</span><span class="sxs-lookup"><span data-stu-id="fb22d-276">Creating an object indirectly is usually much simpler, as we saw in the code example above.</span></span> <span data-ttu-id="fb22d-277">Sie übergeben die Objekt Erstellungs Methode als Adresse eines Schnittstellen Zeigers, und die-Methode erstellt dann das-Objekt und gibt einen Schnittstellen Zeiger zurück.</span><span class="sxs-lookup"><span data-stu-id="fb22d-277">You pass the object creation method the address of an interface pointer, and the method then creates the object and returns an interface pointer.</span></span> <span data-ttu-id="fb22d-278">Wenn Sie ein Objekt indirekt erstellen, können Sie auch dann, wenn Sie nicht auswählen, welche Schnittstelle die Methode zurückgibt, häufig eine Vielzahl von Dingen angeben, wie das Objekt erstellt werden soll.</span><span class="sxs-lookup"><span data-stu-id="fb22d-278">When you create an object indirectly, even if you can't choose which interface the method returns, often you can still specify a variety of things about how the object should be created.</span></span>

<span data-ttu-id="fb22d-279">Beispielsweise können Sie an **D3D12CreateDevice** einen Wert übergeben, der die minimale D3D-Funktionsebene angibt, die vom zurückgegebenen Gerät unterstützt werden soll, wie im obigen Codebeispiel gezeigt.</span><span class="sxs-lookup"><span data-stu-id="fb22d-279">For example, you can pass to **D3D12CreateDevice** a value specifying the minimum D3D feature level that the returned device should support, as shown in the code example above.</span></span>

## <a name="using-com-interfaces"></a><span data-ttu-id="fb22d-280">Mit COM-Schnittstellen</span><span class="sxs-lookup"><span data-stu-id="fb22d-280">Using COM interfaces</span></span>

<span data-ttu-id="fb22d-281">Wenn Sie ein COM-Objekt erstellen, gibt die Erstellungs Methode einen Schnittstellen Zeiger zurück.</span><span class="sxs-lookup"><span data-stu-id="fb22d-281">When you create a COM object, the creation method returns an interface pointer.</span></span> <span data-ttu-id="fb22d-282">Sie können dann mit diesem Zeiger auf eine beliebige Methode der Schnittstelle zugreifen.</span><span class="sxs-lookup"><span data-stu-id="fb22d-282">You can then use that pointer to access any of the interface's methods.</span></span> <span data-ttu-id="fb22d-283">Die Syntax ist identisch mit der, die mit einem Zeiger auf eine C++-Methode verwendet wird.</span><span class="sxs-lookup"><span data-stu-id="fb22d-283">The syntax is identical to that used with a pointer to a C++ method.</span></span>

## <a name="requesting-additional-interfaces"></a><span data-ttu-id="fb22d-284">Anfordern zusätzlicher Schnittstellen</span><span class="sxs-lookup"><span data-stu-id="fb22d-284">Requesting Additional Interfaces</span></span>

<span data-ttu-id="fb22d-285">In vielen Fällen kann der Schnittstellen Zeiger, den Sie von der Erstellungs Methode erhalten, der einzige sein, den Sie benötigen.</span><span class="sxs-lookup"><span data-stu-id="fb22d-285">In many cases, the interface pointer that you receive from the creation method may be the only one that you need.</span></span> <span data-ttu-id="fb22d-286">Tatsächlich ist es für ein Objekt relativ üblich, nur eine andere Schnittstelle als **IUnknown** zu exportieren.</span><span class="sxs-lookup"><span data-stu-id="fb22d-286">In fact, it's relatively common for an object to export only one interface other than **IUnknown**.</span></span> <span data-ttu-id="fb22d-287">Viele-Objekte exportieren jedoch mehrere Schnittstellen, und Sie benötigen möglicherweise Zeiger auf einige von Ihnen.</span><span class="sxs-lookup"><span data-stu-id="fb22d-287">However, many objects export multiple interfaces, and you may need pointers to several of them.</span></span> <span data-ttu-id="fb22d-288">Wenn Sie mehr Schnittstellen benötigen, als von der Erstellungs Methode zurückgegeben werden, ist es nicht erforderlich, ein neues Objekt zu erstellen.</span><span class="sxs-lookup"><span data-stu-id="fb22d-288">If you need more interfaces than the one returned by the creation method, there's no need to create a new object.</span></span> <span data-ttu-id="fb22d-289">Fordern Sie stattdessen einen weiteren Schnittstellen Zeiger mit der [**IUnknown:: QueryInterface-Methode**](/windows/desktop/api/unknwn/nf-unknwn-iunknown-queryinterface(refiid_void))des Objekts an.</span><span class="sxs-lookup"><span data-stu-id="fb22d-289">Instead, request another interface pointer by using the object's [**IUnknown::QueryInterface method**](/windows/desktop/api/unknwn/nf-unknwn-iunknown-queryinterface(refiid_void)).</span></span>

<span data-ttu-id="fb22d-290">Wenn Sie Ihr Objekt mit **cokreateinstance** erstellen, können Sie einen **IUnknown** -Schnittstellen Zeiger anfordern und dann **IUnknown:: QueryInterface** aufrufen, um jede benötigte Schnittstelle anzufordern.</span><span class="sxs-lookup"><span data-stu-id="fb22d-290">If you create your object with **CoCreateInstance**, then you can request an **IUnknown** interface pointer and then call **IUnknown::QueryInterface** to request every interface you need.</span></span> <span data-ttu-id="fb22d-291">Diese Vorgehensweise ist jedoch nicht geeignet, wenn Sie nur eine einzige Schnittstelle benötigen, und Sie funktioniert nicht, wenn Sie eine Objekt Erstellungs Methode verwenden, mit der Sie nicht angeben können, welcher Schnittstellen Zeiger zurückgegeben werden soll.</span><span class="sxs-lookup"><span data-stu-id="fb22d-291">However, this approach is inconvenient if you need only a single interface, and it doesn't work at all if you use an object creation method that doesn't allow you to specify which interface pointer should be returned.</span></span> <span data-ttu-id="fb22d-292">In der Praxis müssen Sie in der Regel keinen expliziten **IUnknown** -Zeiger abrufen, da alle COM-Schnittstellen die **IUnknown** -Schnittstelle erweitern.</span><span class="sxs-lookup"><span data-stu-id="fb22d-292">In practice, you usually don't need to obtain an explicit **IUnknown** pointer, because all COM interfaces extend the **IUnknown** interface.</span></span>

<span data-ttu-id="fb22d-293">Das Erweitern einer Schnittstelle ähnelt konzeptionell der Vererbung von einer C++-Klasse.</span><span class="sxs-lookup"><span data-stu-id="fb22d-293">Extending an interface is conceptually similar to inheriting from a C++ class.</span></span> <span data-ttu-id="fb22d-294">Die untergeordnete Schnittstelle macht alle Methoden der übergeordneten Schnittstelle sowie eine oder mehrere eigene verfügbar.</span><span class="sxs-lookup"><span data-stu-id="fb22d-294">The child interface exposes all of the parent interface's methods, plus one or more of its own.</span></span> <span data-ttu-id="fb22d-295">Tatsächlich wird häufig "erbt von" anstelle von "Erweitert" angezeigt.</span><span class="sxs-lookup"><span data-stu-id="fb22d-295">In fact, you will often see "inherits from" used instead of "extends".</span></span> <span data-ttu-id="fb22d-296">Sie müssen daran denken, dass die Vererbung für das Objekt intern ist.</span><span class="sxs-lookup"><span data-stu-id="fb22d-296">What you need to remember is that the inheritance is internal to the object.</span></span> <span data-ttu-id="fb22d-297">Die Anwendung kann die Schnittstelle eines Objekts nicht erben oder erweitern.</span><span class="sxs-lookup"><span data-stu-id="fb22d-297">Your application can't inherit from or extend an object's interface.</span></span> <span data-ttu-id="fb22d-298">Allerdings können Sie die untergeordnete-Schnittstelle verwenden, um eine beliebige Methode des untergeordneten oder übergeordneten Elements aufzurufen.</span><span class="sxs-lookup"><span data-stu-id="fb22d-298">However, you can use the child interface to call any of the methods of the child or parent.</span></span>

<span data-ttu-id="fb22d-299">Da alle Schnittstellen untergeordnete Elemente von **IUnknown** sind, können Sie **QueryInterface** für jeden der Schnittstellen Zeiger, den Sie bereits für das Objekt besitzen, aufgerufen werden.</span><span class="sxs-lookup"><span data-stu-id="fb22d-299">Because all interfaces are children of **IUnknown**, you can call **QueryInterface** on any of the interface pointers that you already have for the object.</span></span> <span data-ttu-id="fb22d-300">Wenn Sie dies tun, müssen Sie die IID der angeforderten Schnittstelle und die Adresse eines Zeigers angeben, der den Schnittstellen Zeiger enthält, wenn die Methode zurückgegeben wird.</span><span class="sxs-lookup"><span data-stu-id="fb22d-300">When you do so, you must provide the IID of the interface that you're requesting and the address of a pointer that will contain the interface pointer when the method returns.</span></span>

<span data-ttu-id="fb22d-301">Das folgende Code Fragment ruft z. b. **IDXGIFactory2:: kreateswapchainforhwnd** auf, um ein primäres Austausch Ketten Objekt zu erstellen.</span><span class="sxs-lookup"><span data-stu-id="fb22d-301">For example, the following code fragment calls **IDXGIFactory2::CreateSwapChainForHwnd** to create a primary swap chain object.</span></span> <span data-ttu-id="fb22d-302">Dieses Objekt stellt mehrere Schnittstellen zur Verfügung.</span><span class="sxs-lookup"><span data-stu-id="fb22d-302">This object exposes several interfaces.</span></span> <span data-ttu-id="fb22d-303">Die Methode " **kreateswapchainforhwnd** " gibt eine **IDXGISwapChain1** -Schnittstelle zurück.</span><span class="sxs-lookup"><span data-stu-id="fb22d-303">The **CreateSwapChainForHwnd** method returns an **IDXGISwapChain1** interface.</span></span> <span data-ttu-id="fb22d-304">Der nachfolgende Code verwendet dann die **IDXGISwapChain1** -Schnittstelle, um **QueryInterface** aufzurufen, um eine **IDXGISwapChain3** -Schnittstelle anzufordern.</span><span class="sxs-lookup"><span data-stu-id="fb22d-304">The subsequent code then uses the **IDXGISwapChain1** interface to call **QueryInterface** to request an **IDXGISwapChain3** interface.</span></span>

```cpp
HRESULT hr = S_OK;

IDXGISwapChain1 * pDXGISwapChain1 = nullptr;
hr = pIDXGIFactory->CreateSwapChainForHwnd(
    pCommandQueue, // For D3D12, this is a pointer to a direct command queue.
    hWnd,
    &swapChainDesc,
    nullptr,
    nullptr,
    &pDXGISwapChain1));
if (FAILED(hr)) return hr;

IDXGISwapChain3 * pDXGISwapChain3 = nullptr;
hr = pDXGISwapChain1->QueryInterface(IID_IDXGISwapChain3, (LPVOID*)&pDXGISwapChain3);
if (FAILED(hr)) return hr;
```

> [!NOTE]
> <span data-ttu-id="fb22d-305">In C++ können Sie das ``IID_PPV_ARGS`` -Makro anstelle des expliziten IID-und Cast-Zeigers verwenden: ``pDXGISwapChain1->QueryInterface(IID_PPV_ARGS(&pDXGISwapChain3));`` .</span><span class="sxs-lookup"><span data-stu-id="fb22d-305">In C++ you can make use of the ``IID_PPV_ARGS`` macro rather than the explicit IID and cast pointer: ``pDXGISwapChain1->QueryInterface(IID_PPV_ARGS(&pDXGISwapChain3));``.</span></span>
> <span data-ttu-id="fb22d-306">Dies wird häufig für Erstellungs Methoden und **QueryInterface** verwendet.</span><span class="sxs-lookup"><span data-stu-id="fb22d-306">This is often used for creation methods as well as **QueryInterface**.</span></span> <span data-ttu-id="fb22d-307">Weitere Informationen finden Sie unter " [combaseapi. h](/windows/win32/api/combaseapi/nf-combaseapi-iid_ppv_args) ".</span><span class="sxs-lookup"><span data-stu-id="fb22d-307">See [combaseapi.h](/windows/win32/api/combaseapi/nf-combaseapi-iid_ppv_args) for more information.</span></span>

## <a name="managing-a-com-objects-lifetime"></a><span data-ttu-id="fb22d-308">Verwalten der Lebensdauer eines COM-Objekts</span><span class="sxs-lookup"><span data-stu-id="fb22d-308">Managing a COM object's lifetime</span></span>

<span data-ttu-id="fb22d-309">Wenn ein Objekt erstellt wird, ordnet das System die erforderlichen Speicherressourcen zu.</span><span class="sxs-lookup"><span data-stu-id="fb22d-309">When an object is created, the system allocates the necessary memory resources.</span></span> <span data-ttu-id="fb22d-310">Wenn ein Objekt nicht mehr benötigt wird, sollte es zerstört werden.</span><span class="sxs-lookup"><span data-stu-id="fb22d-310">When an object is no longer needed, it should be destroyed.</span></span> <span data-ttu-id="fb22d-311">Das System kann diesen Arbeitsspeicher für andere Zwecke verwenden.</span><span class="sxs-lookup"><span data-stu-id="fb22d-311">The system can use that memory for other purposes.</span></span> <span data-ttu-id="fb22d-312">Mit C++-Objekten können Sie die Lebensdauer des Objekts direkt mit den `new` `delete` Operatoren und Steuern, in Fällen, in denen Sie auf dieser Ebene arbeiten oder indem Sie die Stapel-und Bereichs Lebensdauer verwenden.</span><span class="sxs-lookup"><span data-stu-id="fb22d-312">With C++ objects, you can control the object's lifetime directly with the `new` and `delete` operators in cases where you're operating at that level, or just by using the stack and scope lifetime.</span></span> <span data-ttu-id="fb22d-313">COM ermöglicht keine direkte Erstellung oder Zerstörung von Objekten.</span><span class="sxs-lookup"><span data-stu-id="fb22d-313">COM doesn't enable you to directly create or destroy objects.</span></span> <span data-ttu-id="fb22d-314">Der Grund für diesen Entwurf ist, dass das gleiche Objekt von mehr als einem Teil der Anwendung oder in einigen Fällen durch mehr als eine Anwendung verwendet werden kann.</span><span class="sxs-lookup"><span data-stu-id="fb22d-314">The reason for this design is that the same object may be used by more than one part of your application or, in some cases, by more than one application.</span></span> <span data-ttu-id="fb22d-315">Wenn einer dieser Verweise das Objekt zerstören würde, werden die anderen Verweise ungültig.</span><span class="sxs-lookup"><span data-stu-id="fb22d-315">If one of those references were to destroy the object, then the other references would become invalid.</span></span> <span data-ttu-id="fb22d-316">Stattdessen verwendet com ein System der Verweis Zählung, um die Lebensdauer eines Objekts zu steuern.</span><span class="sxs-lookup"><span data-stu-id="fb22d-316">Instead, COM uses a system of reference counting to control an object's lifetime.</span></span>

<span data-ttu-id="fb22d-317">Der Verweis Zähler eines Objekts gibt an, wie oft eine der Schnittstellen angefordert wurde.</span><span class="sxs-lookup"><span data-stu-id="fb22d-317">An object's reference count is the number of times one of its interfaces has been requested.</span></span> <span data-ttu-id="fb22d-318">Jedes Mal, wenn eine Schnittstelle angefordert wird, wird der Verweis Zähler inkrementiert.</span><span class="sxs-lookup"><span data-stu-id="fb22d-318">Each time that an interface is requested, the reference count is incremented.</span></span> <span data-ttu-id="fb22d-319">Eine Anwendung gibt eine Schnittstelle frei, wenn diese Schnittstelle nicht mehr benötigt wird, und verringert den Verweis Zähler.</span><span class="sxs-lookup"><span data-stu-id="fb22d-319">An application releases an interface when that interface is no longer needed, decrementing the reference count.</span></span> <span data-ttu-id="fb22d-320">Solange der Verweis Zähler größer als 0 (null) ist, verbleibt das Objekt im Arbeitsspeicher.</span><span class="sxs-lookup"><span data-stu-id="fb22d-320">As long as the reference count is greater than zero, the object remains in memory.</span></span> <span data-ttu-id="fb22d-321">Wenn der Verweis Zähler Null erreicht, zerstört sich das Objekt selbst.</span><span class="sxs-lookup"><span data-stu-id="fb22d-321">When the reference count reaches zero, the object destroys itself.</span></span> <span data-ttu-id="fb22d-322">Sie müssen nichts über den Verweis Zähler eines Objekts wissen.</span><span class="sxs-lookup"><span data-stu-id="fb22d-322">You don't need to know anything about the reference count of an object.</span></span> <span data-ttu-id="fb22d-323">Solange Sie die Schnittstellen eines Objekts ordnungsgemäß abrufen und freigeben, verfügt das Objekt über die entsprechende Lebensdauer.</span><span class="sxs-lookup"><span data-stu-id="fb22d-323">As long as you obtain and release an object's interfaces properly, the object will have the appropriate lifetime.</span></span>

<span data-ttu-id="fb22d-324">Die ordnungsgemäße Handhabung der Verweis Zählung ist ein wesentlicher Bestandteil der com-Programmierung.</span><span class="sxs-lookup"><span data-stu-id="fb22d-324">Properly handling reference counting is a crucial part of COM programming.</span></span> <span data-ttu-id="fb22d-325">Wenn dies nicht der Fall ist, können Sie problemlos einen Speicherfehler oder einen Absturz erzeugen.</span><span class="sxs-lookup"><span data-stu-id="fb22d-325">Failure to do so can easily create a memory leak or a crash.</span></span> <span data-ttu-id="fb22d-326">Einer der häufigsten Fehler, die com-Programmierer treffen, besteht darin, eine Schnittstelle nicht freizugeben.</span><span class="sxs-lookup"><span data-stu-id="fb22d-326">One of the most common mistakes that COM programmers make is failing to release an interface.</span></span> <span data-ttu-id="fb22d-327">Wenn dies geschieht, erreicht der Verweis Zähler niemals NULL, und das Objekt bleibt unbegrenzt im Speicher.</span><span class="sxs-lookup"><span data-stu-id="fb22d-327">When this happens, the reference count never reaches zero, and the object remains in memory indefinitely.</span></span>

> [!NOTE]
> <span data-ttu-id="fb22d-328">Direct3D 10 oder höher hat leicht geänderte Lebensdauer Regeln für-Objekte.</span><span class="sxs-lookup"><span data-stu-id="fb22d-328">Direct3D 10 or later has slightly modified lifetime rules for objects.</span></span> <span data-ttu-id="fb22d-329">Insbesondere von Objekten, die von **ID3DxxDeviceChild** abgeleitet sind, wird Ihr übergeordnetes Gerät nicht mehr angezeigt (d. h., wenn die besitzende **ID3DxxDevice** auf den Wert 0 Ref count trifft, sind alle untergeordneten Objekte ebenfalls ebenfalls ungültig).</span><span class="sxs-lookup"><span data-stu-id="fb22d-329">In particular, objects that are derived from **ID3DxxDeviceChild** never outlive their parent device (that is, if the owning **ID3DxxDevice** hits a 0 refcount, then all child objects are immediately invalid as well).</span></span> <span data-ttu-id="fb22d-330">Wenn Sie **Set** -Methoden verwenden, um Objekte an die renderpipeline zu binden, erhöhen diese Verweise den Verweis Zähler nicht (d. h., Sie sind schwache Verweise).</span><span class="sxs-lookup"><span data-stu-id="fb22d-330">Also, when you use **Set** methods to bind objects to the render pipeline, these references don't increase the reference count (that is, they are weak references).</span></span> <span data-ttu-id="fb22d-331">In der Praxis ist dies am besten, indem Sie sicherstellen, dass alle untergeordneten Geräte Objekte vollständig freigegeben werden, bevor Sie das Gerät freigeben.</span><span class="sxs-lookup"><span data-stu-id="fb22d-331">In practice, this is best handled by ensuring that you release all device child objects fully before you release the device.</span></span>

## <a name="incrementing-and-decrementing-the-reference-count"></a><span data-ttu-id="fb22d-332">Inkrementieren und Dekrementieren des Verweis zähders</span><span class="sxs-lookup"><span data-stu-id="fb22d-332">Incrementing and decrementing the reference count</span></span>

<span data-ttu-id="fb22d-333">Wenn Sie einen neuen Schnittstellen Zeiger abrufen, muss der Verweis Zähler durch einen Aufruf von [**IUnknown:: adressf**](/windows/desktop/api/unknwn/nf-unknwn-iunknown-addref)erhöht werden.</span><span class="sxs-lookup"><span data-stu-id="fb22d-333">Whenever you obtain a new interface pointer, the reference count must be incremented by a call to [**IUnknown::AddRef**](/windows/desktop/api/unknwn/nf-unknwn-iunknown-addref).</span></span> <span data-ttu-id="fb22d-334">Allerdings muss die Anwendung diese Methode in der Regel nicht aufzurufen.</span><span class="sxs-lookup"><span data-stu-id="fb22d-334">However, your application doesn't usually need to call this method.</span></span> <span data-ttu-id="fb22d-335">Wenn Sie einen Schnittstellen Zeiger abrufen, indem Sie eine Objekt Erstellungs Methode aufrufen, oder indem Sie **IUnknown:: QueryInterface** aufrufen, erhöht das Objekt automatisch den Verweis Zähler.</span><span class="sxs-lookup"><span data-stu-id="fb22d-335">If you obtain an interface pointer by calling an object creation method, or by calling **IUnknown::QueryInterface**, then the object automatically increments the reference count.</span></span> <span data-ttu-id="fb22d-336">Wenn Sie jedoch einen Schnittstellen Zeiger auf andere Weise erstellen, z. b. Kopieren eines vorhandenen Zeigers, müssen Sie **IUnknown:: adressf** explizit aufruft.</span><span class="sxs-lookup"><span data-stu-id="fb22d-336">However, if you create an interface pointer in some other way, such as copying an existing pointer, then you must explicitly call **IUnknown::AddRef**.</span></span> <span data-ttu-id="fb22d-337">Wenn Sie andernfalls den ursprünglichen Schnittstellen Zeiger freigeben, wird das Objekt möglicherweise zerstört, auch wenn Sie möglicherweise noch die Kopie des Zeigers verwenden müssen.</span><span class="sxs-lookup"><span data-stu-id="fb22d-337">Otherwise, when you release the original interface pointer, the object may be destroyed even though you may still need to use the copy of the pointer.</span></span>

<span data-ttu-id="fb22d-338">Sie müssen alle Schnittstellen Zeiger freigeben, unabhängig davon, ob Sie oder das Objekt den Verweis Zähler inkrementiert haben.</span><span class="sxs-lookup"><span data-stu-id="fb22d-338">You must release all interface pointers, regardless of whether you or the object incremented the reference count.</span></span> <span data-ttu-id="fb22d-339">Wenn Sie keinen Schnittstellen Zeiger mehr benötigen, wenden Sie [**IUnknown:: Release**](/windows/desktop/api/unknwn/nf-unknwn-iunknown-release) an, um den Verweis Zähler zu verringern.</span><span class="sxs-lookup"><span data-stu-id="fb22d-339">When you no longer need an interface pointer, call [**IUnknown::Release**](/windows/desktop/api/unknwn/nf-unknwn-iunknown-release) to decrement the reference count.</span></span> <span data-ttu-id="fb22d-340">Eine gängige Vorgehensweise besteht darin, alle Schnittstellen Zeiger auf zu initialisieren `nullptr` und Sie dann wieder auf festzulegen, `nullptr` Wenn Sie freigegeben werden.</span><span class="sxs-lookup"><span data-stu-id="fb22d-340">A common practice is to initialize all interface pointers to `nullptr`, and then to set them back to `nullptr` when they are released.</span></span> <span data-ttu-id="fb22d-341">Mit dieser Konvention können Sie alle Schnittstellen Zeiger im Bereinigungs Code testen.</span><span class="sxs-lookup"><span data-stu-id="fb22d-341">That convention allows you to test all interface pointers in your cleanup code.</span></span> <span data-ttu-id="fb22d-342">Diese sind noch nicht `nullptr` aktiv, und Sie müssen Sie freigeben, bevor Sie die Anwendung beenden.</span><span class="sxs-lookup"><span data-stu-id="fb22d-342">Those that are not `nullptr` are still active, and you need to release them before you terminate the application.</span></span>

<span data-ttu-id="fb22d-343">Das folgende Code Fragment erweitert das oben gezeigte Beispiel, um zu veranschaulichen, wie die Verweis Zählung behandelt werden soll.</span><span class="sxs-lookup"><span data-stu-id="fb22d-343">The following code fragment extends the sample shown earlier to illustrate how to handle reference counting.</span></span>

```cpp
HRESULT hr = S_OK;

IDXGISwapChain1 * pDXGISwapChain1 = nullptr;
hr = pIDXGIFactory->CreateSwapChainForHwnd(
    pCommandQueue, // For D3D12, this is a pointer to a direct command queue.
    hWnd,
    &swapChainDesc,
    nullptr,
    nullptr,
    &pDXGISwapChain1));
if (FAILED(hr)) return hr;

IDXGISwapChain3 * pDXGISwapChain3 = nullptr;
hr = pDXGISwapChain1->QueryInterface(IID_IDXGISwapChain3, (LPVOID*)&pDXGISwapChain3);
if (FAILED(hr)) return hr;

IDXGISwapChain3 * pDXGISwapChain3Copy = nullptr;

// Make a copy of the IDXGISwapChain3 interface pointer.
// Call AddRef to increment the reference count and to ensure that
// the object is not destroyed prematurely.
pDXGISwapChain3Copy = pDXGISwapChain3;
pDXGISwapChain3Copy->AddRef();
...
// Cleanup code. Check to see whether the pointers are still active.
// If they are, then call Release to release the interface.
if (pDXGISwapChain1 != nullptr)
{
    pDXGISwapChain1->Release();
    pDXGISwapChain1 = nullptr;
}
if (pDXGISwapChain3 != nullptr)
{
    pDXGISwapChain3->Release();
    pDXGISwapChain3 = nullptr;
}
if (pDXGISwapChain3Copy != nullptr)
{
    pDXGISwapChain3Copy->Release();
    pDXGISwapChain3Copy = nullptr;
}
```

## <a name="com-smart-pointers"></a><span data-ttu-id="fb22d-344">Intelligente com-Zeiger</span><span class="sxs-lookup"><span data-stu-id="fb22d-344">COM Smart Pointers</span></span>

<span data-ttu-id="fb22d-345">Der bisherige Code hat explizit ``Release`` und zum Verwalten ``AddRef`` der Verweis Zähler mithilfe von **IUnknown** -Methoden aufgerufen.</span><span class="sxs-lookup"><span data-stu-id="fb22d-345">The code so far has explicitly called ``Release`` and ``AddRef`` to maintain the reference counts using **IUnknown** methods.</span></span> <span data-ttu-id="fb22d-346">Dieses Muster erfordert, dass der Programmierer sorgfältig daran interessiert ist, die Anzahl in allen möglichen Codepath beizubehalten.</span><span class="sxs-lookup"><span data-stu-id="fb22d-346">This pattern requires the programmer to be diligent in remembering to properly maintain the count in all possible codepaths.</span></span> <span data-ttu-id="fb22d-347">Dies kann zu einer komplizierten Fehlerbehandlung führen, und mit aktivierter C++-Ausnahmebehandlung kann es besonders schwierig sein, diese zu implementieren.</span><span class="sxs-lookup"><span data-stu-id="fb22d-347">This can result in complicated error-handling, and with C++ exception handling enabled can be particularly difficult to implement.</span></span> <span data-ttu-id="fb22d-348">Eine bessere Lösung mit C++ ist die Verwendung eines [intelligenten Zeigers](/cpp/cpp/smart-pointers-modern-cpp).</span><span class="sxs-lookup"><span data-stu-id="fb22d-348">A better solution with C++ is to make use of a [smart pointer](/cpp/cpp/smart-pointers-modern-cpp).</span></span>

* <span data-ttu-id="fb22d-349">**WinRT:: com_ptr** ist ein intelligenter Zeiger, der durch die [C++/WinRT-sprach Projektionen](/uwp/cpp-ref-for-winrt/com-ptr)bereitgestellt wird.</span><span class="sxs-lookup"><span data-stu-id="fb22d-349">**winrt::com_ptr** is a smart pointer provided by the [C++/WinRT language projections](/uwp/cpp-ref-for-winrt/com-ptr).</span></span> <span data-ttu-id="fb22d-350">Dies ist der empfohlene com-Zeiger, der für UWP-Apps verwendet werden soll.</span><span class="sxs-lookup"><span data-stu-id="fb22d-350">This is the recommended COM smart pointer to use for UWP apps.</span></span> <span data-ttu-id="fb22d-351">Beachten Sie, dass für C++/WinRT C++ 17 erforderlich ist.</span><span class="sxs-lookup"><span data-stu-id="fb22d-351">Note that C++/WinRT requires C++17.</span></span>

* <span data-ttu-id="fb22d-352">**Microsoft:: WRL:: comptr** ist ein intelligenter Zeiger, der von der [Windows-Runtime C++ Template Library (WRL)](/cpp/cppcx/wrl/comptr-class)bereitgestellt wird.</span><span class="sxs-lookup"><span data-stu-id="fb22d-352">**Microsoft::WRL::ComPtr** is a smart pointer provided by the [Windows Runtime C++ Template Library (WRL)](/cpp/cppcx/wrl/comptr-class).</span></span> <span data-ttu-id="fb22d-353">Diese Bibliothek ist "Pure" C++ und kann daher für Windows-Runtime Anwendungen (über C++/CX oder C++/WinRT) sowie für klassische Win32-Desktop Anwendungen verwendet werden.</span><span class="sxs-lookup"><span data-stu-id="fb22d-353">This library is "pure" C++ so it can be utilized for Windows Runtime applications (via C++/CX or C++/WinRT) as well as classic Win32 desktop applications.</span></span> <span data-ttu-id="fb22d-354">Dieser intelligente Zeiger funktioniert auch für ältere Versionen von Windows, die die Windows-Runtime-APIs nicht unterstützen.</span><span class="sxs-lookup"><span data-stu-id="fb22d-354">This smart pointer also works on older versions of Windows that do not support the Windows Runtime APIs.</span></span> <span data-ttu-id="fb22d-355">Für Win32-Desktop Anwendungen können Sie verwenden, ``#include <wrl/client.h>`` um nur diese Klasse einzuschließen und optional auch das Präprozessorsymbol zu definieren ``__WRL_CLASSIC_COM_STRICT__`` .</span><span class="sxs-lookup"><span data-stu-id="fb22d-355">For Win32 desktop applications, you can use ``#include <wrl/client.h>`` to only include this class and optionally define the preprocessor symbol ``__WRL_CLASSIC_COM_STRICT__`` as well.</span></span> <span data-ttu-id="fb22d-356">Weitere Informationen finden Sie unter Überprüfen von [intelligenten com-Zeigern](/archive/msdn-magazine/2015/february/windows-with-c-com-smart-pointers-revisited).</span><span class="sxs-lookup"><span data-stu-id="fb22d-356">For more information, see [COM smart pointers revisited](/archive/msdn-magazine/2015/february/windows-with-c-com-smart-pointers-revisited).</span></span>

* <span data-ttu-id="fb22d-357">**CComPtr** ist ein intelligenter Zeiger, der vom [Active Template Library (ATL)](/cpp/atl/reference/ccomptr-class)bereitgestellt wird.</span><span class="sxs-lookup"><span data-stu-id="fb22d-357">**CComPtr** is a smart pointer provided by the [Active Template Library (ATL)](/cpp/atl/reference/ccomptr-class).</span></span> <span data-ttu-id="fb22d-358">**Microsoft:: WRL:: comptr** ist eine neuere Version dieser Implementierung, die eine Reihe von Problemen mit der geringfügigen Verwendung behandelt. Daher wird die Verwendung dieses intelligenten Zeigers nicht für neue Projekte empfohlen.</span><span class="sxs-lookup"><span data-stu-id="fb22d-358">The **Microsoft::WRL::ComPtr** is a newer version of this implementation that addresses a number of subtle usage issues, so use of this smart pointer is not recommended for new projects.</span></span> <span data-ttu-id="fb22d-359">Weitere Informationen finden Sie unter [Erstellen und Verwenden von CComPtr und CComQIPtr](/cpp/cpp/how-to-create-and-use-ccomptr-and-ccomqiptr-instances).</span><span class="sxs-lookup"><span data-stu-id="fb22d-359">For more information, see [How to create and use CComPtr and CComQIPtr](/cpp/cpp/how-to-create-and-use-ccomptr-and-ccomqiptr-instances).</span></span>


## <a name="using-atl-with-directx-9"></a><span data-ttu-id="fb22d-360">Verwenden von ATL mit DirectX 9</span><span class="sxs-lookup"><span data-stu-id="fb22d-360">Using ATL with DirectX 9</span></span>

<span data-ttu-id="fb22d-361">Wenn Sie die Active Template Library (ATL) mit DirectX 9 verwenden möchten, müssen Sie die Schnittstellen für die ATL-Kompatibilität neu definieren.</span><span class="sxs-lookup"><span data-stu-id="fb22d-361">To use the Active Template Library (ATL) with DirectX 9, you must redefine the interfaces for ATL compatibility.</span></span> <span data-ttu-id="fb22d-362">Dies ermöglicht es Ihnen, die **CComQIPtr** -Klasse ordnungsgemäß zu verwenden, um einen Zeiger auf eine Schnittstelle zu erhalten.</span><span class="sxs-lookup"><span data-stu-id="fb22d-362">This allows you to properly use the **CComQIPtr** class to obtain a pointer to an interface.</span></span>

<span data-ttu-id="fb22d-363">Sie wissen, ob Sie die Schnittstellen für ATL nicht neu definieren, da die folgende Fehlermeldung angezeigt wird.</span><span class="sxs-lookup"><span data-stu-id="fb22d-363">You'll know if you don't redefine the interfaces for ATL, because you'll see the following error message.</span></span>

```
[...]\atlmfc\include\atlbase.h(4704) :   error C2787: 'IDirectXFileData' : no GUID has been associated with this object
```

<span data-ttu-id="fb22d-364">Im folgenden Codebeispiel wird gezeigt, wie die idirectxfiledata-Schnittstelle definiert wird.</span><span class="sxs-lookup"><span data-stu-id="fb22d-364">The following code sample shows how to define the IDirectXFileData interface.</span></span>

```cpp
// Explicit declaration
struct __declspec(uuid("{3D82AB44-62DA-11CF-AB39-0020AF71E433}")) IDirectXFileData;

// Macro method
#define RT_IID(iid_, name_) struct __declspec(uuid(iid_)) name_
RT_IID("{1DD9E8DA-1C77-4D40-B0CF-98FEFDFF9512}", IDirectXFileData);
```

<span data-ttu-id="fb22d-365">Nachdem Sie die Schnittstelle neu definiert haben, müssen Sie die **Attach** -Methode verwenden, um die Schnittstelle an den von zurückgegebenen Schnittstellen Zeiger anzufügen **::D irect3dcreate9**.</span><span class="sxs-lookup"><span data-stu-id="fb22d-365">After redefining the interface, you must use the **Attach** method to attach the interface to the interface pointer returned by **::Direct3DCreate9**.</span></span> <span data-ttu-id="fb22d-366">Wenn Sie dies nicht tun, wird die **IDirect3D9** -Schnittstelle von der intelligenten Zeiger Klasse nicht ordnungsgemäß freigegeben.</span><span class="sxs-lookup"><span data-stu-id="fb22d-366">If you don't, then the **IDirect3D9** interface won't be properly released by the smart pointer class.</span></span>

<span data-ttu-id="fb22d-367">Die **CComPtr** -Klasse ruft intern **IUnknown:: adressf** für den Schnittstellen Zeiger auf, wenn das Objekt erstellt wird und eine Schnittstelle der **CComPtr** -Klasse zugewiesen wird.</span><span class="sxs-lookup"><span data-stu-id="fb22d-367">The **CComPtr** class internally calls **IUnknown::AddRef** on the interface pointer when the object is created and when an interface is assigned to the **CComPtr** class.</span></span> <span data-ttu-id="fb22d-368">Um das Verlust des Schnittstellen Zeigers zu vermeiden, dürfen Sie nicht \* \* IUnknown:: adressf für die von zurückgegebene Schnittstelle aufzurufen **::D irect3dcreate9**.</span><span class="sxs-lookup"><span data-stu-id="fb22d-368">To avoid leaking the interface pointer, don't call \*\*IUnknown::AddRef on the interface returned from **::Direct3DCreate9**.</span></span>

<span data-ttu-id="fb22d-369">Der folgende Code gibt die-Schnittstelle ordnungsgemäß frei, ohne **IUnknown:: adressf** zu aufrufen.</span><span class="sxs-lookup"><span data-stu-id="fb22d-369">The following code properly releases the interface without calling **IUnknown::AddRef**.</span></span>

```cpp
CComPtr<IDirect3D9> d3d;
d3d.Attach(::Direct3DCreate9(D3D_SDK_VERSION));
```

<span data-ttu-id="fb22d-370">Verwenden Sie den vorherigen Code.</span><span class="sxs-lookup"><span data-stu-id="fb22d-370">Use the previous code.</span></span> <span data-ttu-id="fb22d-371">Verwenden Sie den folgenden Code nicht, der " **IUnknown:: adressf** " gefolgt von " **IUnknown:: Release**" aufruft und den von hinzugefügten Verweis nicht freigibt **::D irect3dcreate9**.</span><span class="sxs-lookup"><span data-stu-id="fb22d-371">Don't use the following code, which calls **IUnknown::AddRef** followed by **IUnknown::Release**, and doesn't release the reference added by **::Direct3DCreate9**.</span></span>

```cpp
CComPtr<IDirect3D9> d3d = ::Direct3DCreate9(D3D_SDK_VERSION);
```

<span data-ttu-id="fb22d-372">Beachten Sie, dass dies die einzige Stelle in Direct3D 9 ist, an der Sie die **Attach** -Methode auf diese Weise verwenden müssen.</span><span class="sxs-lookup"><span data-stu-id="fb22d-372">Note that this is the only place in Direct3D 9 where you'll have to use the **Attach** method in this manner.</span></span>

<span data-ttu-id="fb22d-373">Weitere Informationen zu den **CComPtr** -und **CComQIPtr** -Klassen finden Sie in ihren Definitionen in der `Atlbase.h` Header Datei.</span><span class="sxs-lookup"><span data-stu-id="fb22d-373">For more information about the **CComPTR** and **CComQIPtr** classes, see their definitions in the `Atlbase.h` header file.</span></span>
